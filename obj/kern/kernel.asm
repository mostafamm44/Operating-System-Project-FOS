
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 b0 17 00 	lgdtl  0x17b018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 b0 17 f0       	mov    $0xf017b000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 f0 c9 5e f0 01 	movl   $0x1,0xf05ec9f0
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 44 c9 5e f0 01 	movl   $0x1,0xf05ec944
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba f4 f5 60 f0       	mov    $0xf060f5f4,%edx
f010006a:	b8 10 37 5c f0       	mov    $0xf05c3710,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 10 37 5c f0       	push   $0xf05c3710
f010007e:	e8 4a ed 01 00       	call   f011edcd <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 ac 0d 00 00       	call   f0100e37 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 30 02 00 00       	call   f01002c0 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 c0 0e 12 f0       	push   $0xf0120ec0
f0100098:	e8 ee 0e 00 00       	call   f0100f8b <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 07 0f 12 f0       	push   $0xf0120f07
f01000a8:	e8 de 0e 00 00       	call   f0100f8b <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 1b 0f 12 f0       	push   $0xf0120f1b
f01000b8:	e8 ce 0e 00 00       	call   f0100f8b <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 2f 0f 12 f0       	push   $0xf0120f2f
f01000c8:	e8 be 0e 00 00       	call   f0100f8b <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 74 70 00 00       	call   f010714e <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 3b 0f 12 f0       	push   $0xf0120f3b
f01000e5:	e8 a1 0e 00 00       	call   f0100f8b <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 43 0f 12 f0       	push   $0xf0120f43
f01000f5:	e8 91 0e 00 00       	call   f0100f8b <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 c1 79 00 00       	call   f0107ac3 <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 5a 75 00 00       	call   f0107661 <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 0f 7d 00 00       	call   f0107e1b <initialize_paging>
		sharing_init();
f010010c:	e8 03 8a 00 00       	call   f0108b14 <sharing_init>

#if USE_KHEAP
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0100111:	83 ec 04             	sub    $0x4,%esp
f0100114:	68 00 00 00 f8       	push   $0xf8000000
f0100119:	68 00 10 00 00       	push   $0x1000
f010011e:	68 00 00 00 f6       	push   $0xf6000000
f0100123:	e8 1f 8b 00 00       	call   f0108c47 <initialize_kheap_dynamic_allocator>
f0100128:	83 c4 10             	add    $0x10,%esp
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010012b:	e8 e6 e5 00 00       	call   f010e716 <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100130:	e8 1a ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100135:	e8 05 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010013a:	83 ec 0c             	sub    $0xc,%esp
f010013d:	6a 00                	push   $0x0
f010013f:	e8 cf e6 00 00       	call   f010e813 <enableBuffering>
f0100144:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100147:	83 ec 0c             	sub    $0xc,%esp
f010014a:	6a 00                	push   $0x0
f010014c:	e8 aa e6 00 00       	call   f010e7fb <enableModifiedBuffer>
f0100151:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100154:	83 ec 0c             	sub    $0xc,%esp
f0100157:	68 e8 03 00 00       	push   $0x3e8
f010015c:	e8 ca e6 00 00       	call   f010e82b <setModifiedBufferLength>
f0100161:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100164:	e8 bb f1 01 00       	call   f011f324 <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f0100169:	83 ec 0c             	sub    $0xc,%esp
f010016c:	68 51 0f 12 f0       	push   $0xf0120f51
f0100171:	e8 15 0e 00 00       	call   f0100f8b <cprintf>
f0100176:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f0100179:	e8 ca 9e 00 00       	call   f010a048 <env_init>
		ts_init();
f010017e:	e8 63 bf 00 00       	call   f010c0e6 <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100183:	83 ec 0c             	sub    $0xc,%esp
f0100186:	68 3b 0f 12 f0       	push   $0xf0120f3b
f010018b:	e8 fb 0d 00 00       	call   f0100f8b <cprintf>
f0100190:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100193:	83 ec 0c             	sub    $0xc,%esp
f0100196:	68 64 0f 12 f0       	push   $0xf0120f64
f010019b:	e8 eb 0d 00 00       	call   f0100f8b <cprintf>
f01001a0:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f01001a3:	e8 92 6c 00 00       	call   f0106e3a <pic_init>
		cprintf("*	PIC is initialized\n");
f01001a8:	83 ec 0c             	sub    $0xc,%esp
f01001ab:	68 8d 0f 12 f0       	push   $0xf0120f8d
f01001b0:	e8 d6 0d 00 00       	call   f0100f8b <cprintf>
f01001b5:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f01001b8:	83 ec 0c             	sub    $0xc,%esp
f01001bb:	6a 00                	push   $0x0
f01001bd:	e8 6a 6e 00 00       	call   f010702c <irq_clear_mask>
f01001c2:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001c5:	83 ec 0c             	sub    $0xc,%esp
f01001c8:	68 a3 0f 12 f0       	push   $0xf0120fa3
f01001cd:	e8 b9 0d 00 00       	call   f0100f8b <cprintf>
f01001d2:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001d5:	83 ec 0c             	sub    $0xc,%esp
f01001d8:	6a 01                	push   $0x1
f01001da:	e8 4d 6e 00 00       	call   f010702c <irq_clear_mask>
f01001df:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001e2:	83 ec 0c             	sub    $0xc,%esp
f01001e5:	68 c0 0f 12 f0       	push   $0xf0120fc0
f01001ea:	e8 9c 0d 00 00       	call   f0100f8b <cprintf>
f01001ef:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001f2:	83 ec 0c             	sub    $0xc,%esp
f01001f5:	6a 04                	push   $0x4
f01001f7:	e8 30 6e 00 00       	call   f010702c <irq_clear_mask>
f01001fc:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001ff:	83 ec 0c             	sub    $0xc,%esp
f0100202:	68 df 0f 12 f0       	push   $0xf0120fdf
f0100207:	e8 7f 0d 00 00       	call   f0100f8b <cprintf>
f010020c:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f010020f:	83 ec 0c             	sub    $0xc,%esp
f0100212:	68 fc 0f 12 f0       	push   $0xf0120ffc
f0100217:	e8 6f 0d 00 00       	call   f0100f8b <cprintf>
f010021c:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f010021f:	e8 15 4a 00 00       	call   f0104c39 <kclock_init>
		sched_init() ;
f0100224:	e8 45 65 00 00       	call   f010676e <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f0100229:	83 ec 0c             	sub    $0xc,%esp
f010022c:	68 20 10 12 f0       	push   $0xf0121020
f0100231:	e8 55 0d 00 00       	call   f0100f8b <cprintf>
f0100236:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100239:	89 e0                	mov    %esp,%eax
f010023b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010023e:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100241:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100244:	b8 00 b0 17 f0       	mov    $0xf017b000,%eax
f0100249:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010024c:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f010024f:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100254:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100257:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010025a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010025d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100263:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100265:	89 e0                	mov    %esp,%eax
f0100267:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010026a:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010026d:	83 ec 04             	sub    $0x4,%esp
f0100270:	50                   	push   %eax
f0100271:	ff 75 f4             	pushl  -0xc(%ebp)
f0100274:	68 40 10 12 f0       	push   $0xf0121040
f0100279:	e8 0d 0d 00 00       	call   f0100f8b <cprintf>
f010027e:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100281:	83 ec 0c             	sub    $0xc,%esp
f0100284:	68 64 10 12 f0       	push   $0xf0121064
f0100289:	e8 fd 0c 00 00       	call   f0100f8b <cprintf>
f010028e:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100291:	c7 05 1c cc 5e f0 00 	movl   $0x0,0xf05ecc1c
f0100298:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010029b:	83 ec 0c             	sub    $0xc,%esp
f010029e:	68 ac 10 12 f0       	push   $0xf01210ac
f01002a3:	e8 e3 0c 00 00       	call   f0100f8b <cprintf>
f01002a8:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f01002ab:	83 ec 0c             	sub    $0xc,%esp
f01002ae:	68 d8 10 12 f0       	push   $0xf01210d8
f01002b3:	e8 d3 0c 00 00       	call   f0100f8b <cprintf>
f01002b8:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01002bb:	e8 02 1b 00 00       	call   f0101dc2 <get_into_prompt>

f01002c0 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002c0:	55                   	push   %ebp
f01002c1:	89 e5                	mov    %esp,%ebp
f01002c3:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002c6:	83 ec 0c             	sub    $0xc,%esp
f01002c9:	68 fd 10 12 f0       	push   $0xf01210fd
f01002ce:	e8 b8 0c 00 00       	call   f0100f8b <cprintf>
f01002d3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002d6:	83 ec 0c             	sub    $0xc,%esp
f01002d9:	68 04 11 12 f0       	push   $0xf0121104
f01002de:	e8 a8 0c 00 00       	call   f0100f8b <cprintf>
f01002e3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e6:	83 ec 0c             	sub    $0xc,%esp
f01002e9:	68 4c 11 12 f0       	push   $0xf012114c
f01002ee:	e8 98 0c 00 00       	call   f0100f8b <cprintf>
f01002f3:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002f6:	83 ec 0c             	sub    $0xc,%esp
f01002f9:	68 94 11 12 f0       	push   $0xf0121194
f01002fe:	e8 88 0c 00 00       	call   f0100f8b <cprintf>
f0100303:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f0100306:	83 ec 0c             	sub    $0xc,%esp
f0100309:	68 4c 11 12 f0       	push   $0xf012114c
f010030e:	e8 78 0c 00 00       	call   f0100f8b <cprintf>
f0100313:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100316:	83 ec 0c             	sub    $0xc,%esp
f0100319:	68 04 11 12 f0       	push   $0xf0121104
f010031e:	e8 68 0c 00 00       	call   f0100f8b <cprintf>
f0100323:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100326:	83 ec 0c             	sub    $0xc,%esp
f0100329:	68 d9 11 12 f0       	push   $0xf01211d9
f010032e:	e8 58 0c 00 00       	call   f0100f8b <cprintf>
f0100333:	83 c4 10             	add    $0x10,%esp
}
f0100336:	90                   	nop
f0100337:	c9                   	leave  
f0100338:	c3                   	ret    

f0100339 <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100339:	55                   	push   %ebp
f010033a:	89 e5                	mov    %esp,%ebp
f010033c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010033f:	e8 15 a9 00 00       	call   f010ac59 <get_cpu_proc>
f0100344:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100347:	8b 45 10             	mov    0x10(%ebp),%eax
f010034a:	a3 20 37 5c f0       	mov    %eax,0xf05c3720

	va_start(ap, fmt);
f010034f:	8d 45 10             	lea    0x10(%ebp),%eax
f0100352:	83 c0 04             	add    $0x4,%eax
f0100355:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100358:	83 ec 04             	sub    $0x4,%esp
f010035b:	ff 75 0c             	pushl  0xc(%ebp)
f010035e:	ff 75 08             	pushl  0x8(%ebp)
f0100361:	68 e0 11 12 f0       	push   $0xf01211e0
f0100366:	e8 20 0c 00 00       	call   f0100f8b <cprintf>
f010036b:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010036e:	8b 45 10             	mov    0x10(%ebp),%eax
f0100371:	83 ec 08             	sub    $0x8,%esp
f0100374:	ff 75 f0             	pushl  -0x10(%ebp)
f0100377:	50                   	push   %eax
f0100378:	e8 e5 0b 00 00       	call   f0100f62 <vcprintf>
f010037d:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100380:	83 ec 0c             	sub    $0xc,%esp
f0100383:	68 05 12 12 f0       	push   $0xf0121205
f0100388:	e8 fe 0b 00 00       	call   f0100f8b <cprintf>
f010038d:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100390:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100394:	74 10                	je     f01003a6 <_panic+0x6d>
f0100396:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100399:	8b 40 18             	mov    0x18(%eax),%eax
f010039c:	83 f8 02             	cmp    $0x2,%eax
f010039f:	75 05                	jne    f01003a6 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01003a1:	e8 71 a8 00 00       	call   f010ac17 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f01003a6:	89 e0                	mov    %esp,%eax
f01003a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f01003ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f01003ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f01003b1:	83 ec 08             	sub    $0x8,%esp
f01003b4:	ff 75 ec             	pushl  -0x14(%ebp)
f01003b7:	68 07 12 12 f0       	push   $0xf0121207
f01003bc:	e8 ca 0b 00 00       	call   f0100f8b <cprintf>
f01003c1:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003c4:	e8 f9 19 00 00       	call   f0101dc2 <get_into_prompt>

f01003c9 <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003c9:	55                   	push   %ebp
f01003ca:	89 e5                	mov    %esp,%ebp
f01003cc:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01003d2:	a3 20 37 5c f0       	mov    %eax,0xf05c3720

	va_start(ap, fmt);
f01003d7:	8d 45 10             	lea    0x10(%ebp),%eax
f01003da:	83 c0 04             	add    $0x4,%eax
f01003dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003e0:	83 ec 04             	sub    $0x4,%esp
f01003e3:	ff 75 0c             	pushl  0xc(%ebp)
f01003e6:	ff 75 08             	pushl  0x8(%ebp)
f01003e9:	68 11 12 12 f0       	push   $0xf0121211
f01003ee:	e8 98 0b 00 00       	call   f0100f8b <cprintf>
f01003f3:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003f6:	8b 45 10             	mov    0x10(%ebp),%eax
f01003f9:	83 ec 08             	sub    $0x8,%esp
f01003fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01003ff:	50                   	push   %eax
f0100400:	e8 5d 0b 00 00       	call   f0100f62 <vcprintf>
f0100405:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100408:	83 ec 0c             	sub    $0xc,%esp
f010040b:	68 05 12 12 f0       	push   $0xf0121205
f0100410:	e8 76 0b 00 00       	call   f0100f8b <cprintf>
f0100415:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100418:	e8 ea 6d 00 00       	call   f0107207 <pushcli>
	struct cpu *c = mycpu();
f010041d:	e8 22 6d 00 00       	call   f0107144 <mycpu>
f0100422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100425:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100428:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010042e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100431:	e8 23 6e 00 00       	call   f0107259 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100436:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010043a:	74 23                	je     f010045f <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010043c:	e8 d5 60 00 00       	call   f0106516 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100441:	e8 13 a8 00 00       	call   f010ac59 <get_cpu_proc>
f0100446:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100449:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010044d:	74 10                	je     f010045f <_panic_all+0x96>
f010044f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100452:	8b 40 18             	mov    0x18(%eax),%eax
f0100455:	83 f8 02             	cmp    $0x2,%eax
f0100458:	75 05                	jne    f010045f <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010045a:	e8 b8 a7 00 00       	call   f010ac17 <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f010045f:	e8 5e 19 00 00       	call   f0101dc2 <get_into_prompt>

f0100464 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100464:	55                   	push   %ebp
f0100465:	89 e5                	mov    %esp,%ebp
f0100467:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010046a:	8b 45 10             	mov    0x10(%ebp),%eax
f010046d:	a3 20 37 5c f0       	mov    %eax,0xf05c3720

	va_start(ap, fmt);
f0100472:	8d 45 10             	lea    0x10(%ebp),%eax
f0100475:	83 c0 04             	add    $0x4,%eax
f0100478:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010047b:	83 ec 04             	sub    $0x4,%esp
f010047e:	ff 75 0c             	pushl  0xc(%ebp)
f0100481:	ff 75 08             	pushl  0x8(%ebp)
f0100484:	68 11 12 12 f0       	push   $0xf0121211
f0100489:	e8 fd 0a 00 00       	call   f0100f8b <cprintf>
f010048e:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100491:	8b 45 10             	mov    0x10(%ebp),%eax
f0100494:	83 ec 08             	sub    $0x8,%esp
f0100497:	ff 75 f4             	pushl  -0xc(%ebp)
f010049a:	50                   	push   %eax
f010049b:	e8 c2 0a 00 00       	call   f0100f62 <vcprintf>
f01004a0:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004a3:	83 ec 0c             	sub    $0xc,%esp
f01004a6:	68 05 12 12 f0       	push   $0xf0121205
f01004ab:	e8 db 0a 00 00       	call   f0100f8b <cprintf>
f01004b0:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f01004b3:	e8 a1 a7 00 00       	call   f010ac59 <get_cpu_proc>
f01004b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f01004bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004bf:	74 10                	je     f01004d1 <_panic_into_prompt+0x6d>
f01004c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004c4:	8b 40 18             	mov    0x18(%eax),%eax
f01004c7:	83 f8 02             	cmp    $0x2,%eax
f01004ca:	75 05                	jne    f01004d1 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004cc:	e8 46 a7 00 00       	call   f010ac17 <env_exit>
	}

	get_into_prompt();
f01004d1:	e8 ec 18 00 00       	call   f0101dc2 <get_into_prompt>

f01004d6 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004d6:	55                   	push   %ebp
f01004d7:	89 e5                	mov    %esp,%ebp
f01004d9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004dc:	8d 45 10             	lea    0x10(%ebp),%eax
f01004df:	83 c0 04             	add    $0x4,%eax
f01004e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004e5:	83 ec 04             	sub    $0x4,%esp
f01004e8:	ff 75 0c             	pushl  0xc(%ebp)
f01004eb:	ff 75 08             	pushl  0x8(%ebp)
f01004ee:	68 2a 12 12 f0       	push   $0xf012122a
f01004f3:	e8 93 0a 00 00       	call   f0100f8b <cprintf>
f01004f8:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004fb:	8b 45 10             	mov    0x10(%ebp),%eax
f01004fe:	83 ec 08             	sub    $0x8,%esp
f0100501:	ff 75 f4             	pushl  -0xc(%ebp)
f0100504:	50                   	push   %eax
f0100505:	e8 58 0a 00 00       	call   f0100f62 <vcprintf>
f010050a:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010050d:	83 ec 0c             	sub    $0xc,%esp
f0100510:	68 05 12 12 f0       	push   $0xf0121205
f0100515:	e8 71 0a 00 00       	call   f0100f8b <cprintf>
f010051a:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010051d:	90                   	nop
f010051e:	c9                   	leave  
f010051f:	c3                   	ret    

f0100520 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100520:	55                   	push   %ebp
f0100521:	89 e5                	mov    %esp,%ebp
f0100523:	83 ec 10             	sub    $0x10,%esp
f0100526:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010052d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100530:	89 c2                	mov    %eax,%edx
f0100532:	ec                   	in     (%dx),%al
f0100533:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100536:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f0100539:	0f b6 c0             	movzbl %al,%eax
f010053c:	83 e0 01             	and    $0x1,%eax
f010053f:	85 c0                	test   %eax,%eax
f0100541:	75 07                	jne    f010054a <serial_proc_data+0x2a>
		return -1;
f0100543:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100548:	eb 16                	jmp    f0100560 <serial_proc_data+0x40>
f010054a:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100551:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100554:	89 c2                	mov    %eax,%edx
f0100556:	ec                   	in     (%dx),%al
f0100557:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010055a:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010055d:	0f b6 c0             	movzbl %al,%eax
}
f0100560:	c9                   	leave  
f0100561:	c3                   	ret    

f0100562 <serial_intr>:

void
serial_intr(void)
{
f0100562:	55                   	push   %ebp
f0100563:	89 e5                	mov    %esp,%ebp
f0100565:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100568:	a1 44 37 5c f0       	mov    0xf05c3744,%eax
f010056d:	85 c0                	test   %eax,%eax
f010056f:	74 10                	je     f0100581 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100571:	83 ec 0c             	sub    $0xc,%esp
f0100574:	68 20 05 10 f0       	push   $0xf0100520
f0100579:	e8 9d 07 00 00       	call   f0100d1b <cons_intr>
f010057e:	83 c4 10             	add    $0x10,%esp
}
f0100581:	90                   	nop
f0100582:	c9                   	leave  
f0100583:	c3                   	ret    

f0100584 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100584:	55                   	push   %ebp
f0100585:	89 e5                	mov    %esp,%ebp
f0100587:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010058a:	83 ec 0c             	sub    $0xc,%esp
f010058d:	68 48 12 12 f0       	push   $0xf0121248
f0100592:	e8 f4 09 00 00       	call   f0100f8b <cprintf>
f0100597:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010059a:	e8 c3 ff ff ff       	call   f0100562 <serial_intr>
}
f010059f:	90                   	nop
f01005a0:	c9                   	leave  
f01005a1:	c3                   	ret    

f01005a2 <serial_init>:

void
serial_init(void)
{
f01005a2:	55                   	push   %ebp
f01005a3:	89 e5                	mov    %esp,%ebp
f01005a5:	83 ec 48             	sub    $0x48,%esp
f01005a8:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f01005af:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01005b3:	8a 45 c6             	mov    -0x3a(%ebp),%al
f01005b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01005b9:	ee                   	out    %al,(%dx)
f01005ba:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005c1:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005c5:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005cb:	ee                   	out    %al,(%dx)
f01005cc:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005d3:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005d7:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005da:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005dd:	ee                   	out    %al,(%dx)
f01005de:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005e5:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005e9:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005ef:	ee                   	out    %al,(%dx)
f01005f0:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005f7:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005fb:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100601:	ee                   	out    %al,(%dx)
f0100602:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0100609:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010060d:	8a 45 cb             	mov    -0x35(%ebp),%al
f0100610:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100613:	ee                   	out    %al,(%dx)
f0100614:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f010061b:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010061f:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100622:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100625:	ee                   	out    %al,(%dx)
f0100626:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100630:	89 c2                	mov    %eax,%edx
f0100632:	ec                   	in     (%dx),%al
f0100633:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100636:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f0100639:	3c ff                	cmp    $0xff,%al
f010063b:	0f 95 c0             	setne  %al
f010063e:	0f b6 c0             	movzbl %al,%eax
f0100641:	a3 44 37 5c f0       	mov    %eax,0xf05c3744
f0100646:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010064d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100650:	89 c2                	mov    %eax,%edx
f0100652:	ec                   	in     (%dx),%al
f0100653:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100656:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010065d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100660:	89 c2                	mov    %eax,%edx
f0100662:	ec                   	in     (%dx),%al
f0100663:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100666:	83 ec 08             	sub    $0x8,%esp
f0100669:	68 84 05 10 f0       	push   $0xf0100584
f010066e:	6a 04                	push   $0x4
f0100670:	e8 75 cd 00 00       	call   f010d3ea <irq_install_handler>
f0100675:	83 c4 10             	add    $0x10,%esp

}
f0100678:	90                   	nop
f0100679:	c9                   	leave  
f010067a:	c3                   	ret    

f010067b <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010067b:	55                   	push   %ebp
f010067c:	89 e5                	mov    %esp,%ebp
f010067e:	83 ec 20             	sub    $0x20,%esp
f0100681:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100688:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010068b:	89 c2                	mov    %eax,%edx
f010068d:	ec                   	in     (%dx),%al
f010068e:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100691:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100698:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010069b:	89 c2                	mov    %eax,%edx
f010069d:	ec                   	in     (%dx),%al
f010069e:	88 45 ed             	mov    %al,-0x13(%ebp)
f01006a1:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f01006a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01006ab:	89 c2                	mov    %eax,%edx
f01006ad:	ec                   	in     (%dx),%al
f01006ae:	88 45 ee             	mov    %al,-0x12(%ebp)
f01006b1:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f01006b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01006bb:	89 c2                	mov    %eax,%edx
f01006bd:	ec                   	in     (%dx),%al
f01006be:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006c1:	90                   	nop
f01006c2:	c9                   	leave  
f01006c3:	c3                   	ret    

f01006c4 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006c4:	55                   	push   %ebp
f01006c5:	89 e5                	mov    %esp,%ebp
f01006c7:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006d1:	eb 08                	jmp    f01006db <lpt_putc+0x17>
		delay();
f01006d3:	e8 a3 ff ff ff       	call   f010067b <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006d8:	ff 45 fc             	incl   -0x4(%ebp)
f01006db:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006e5:	89 c2                	mov    %eax,%edx
f01006e7:	ec                   	in     (%dx),%al
f01006e8:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006eb:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006ee:	84 c0                	test   %al,%al
f01006f0:	78 09                	js     f01006fb <lpt_putc+0x37>
f01006f2:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006f9:	7e d8                	jle    f01006d3 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01006fe:	0f b6 c0             	movzbl %al,%eax
f0100701:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0100708:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010070b:	8a 45 e8             	mov    -0x18(%ebp),%al
f010070e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100711:	ee                   	out    %al,(%dx)
f0100712:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0100719:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010071d:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100720:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100723:	ee                   	out    %al,(%dx)
f0100724:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010072b:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f010072f:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100732:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100735:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100736:	90                   	nop
f0100737:	c9                   	leave  
f0100738:	c3                   	ret    

f0100739 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f0100739:	55                   	push   %ebp
f010073a:	89 e5                	mov    %esp,%ebp
f010073c:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f010073f:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100746:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100749:	66 8b 00             	mov    (%eax),%ax
f010074c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100750:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100753:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100758:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010075b:	66 8b 00             	mov    (%eax),%ax
f010075e:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100762:	74 13                	je     f0100777 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100764:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010076b:	c7 05 48 37 5c f0 b4 	movl   $0x3b4,0xf05c3748
f0100772:	03 00 00 
f0100775:	eb 14                	jmp    f010078b <cga_init+0x52>
	} else {
		*cp = was;
f0100777:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010077a:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010077e:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100781:	c7 05 48 37 5c f0 d4 	movl   $0x3d4,0xf05c3748
f0100788:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010078b:	a1 48 37 5c f0       	mov    0xf05c3748,%eax
f0100790:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100793:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100797:	8a 45 e0             	mov    -0x20(%ebp),%al
f010079a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010079d:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010079e:	a1 48 37 5c f0       	mov    0xf05c3748,%eax
f01007a3:	40                   	inc    %eax
f01007a4:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01007aa:	89 c2                	mov    %eax,%edx
f01007ac:	ec                   	in     (%dx),%al
f01007ad:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f01007b0:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01007b3:	0f b6 c0             	movzbl %al,%eax
f01007b6:	c1 e0 08             	shl    $0x8,%eax
f01007b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f01007bc:	a1 48 37 5c f0       	mov    0xf05c3748,%eax
f01007c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007c4:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007c8:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007ce:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007cf:	a1 48 37 5c f0       	mov    0xf05c3748,%eax
f01007d4:	40                   	inc    %eax
f01007d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007db:	89 c2                	mov    %eax,%edx
f01007dd:	ec                   	in     (%dx),%al
f01007de:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007e1:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007e4:	0f b6 c0             	movzbl %al,%eax
f01007e7:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ed:	a3 4c 37 5c f0       	mov    %eax,0xf05c374c
	crt_pos = pos;
f01007f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007f5:	66 a3 50 37 5c f0    	mov    %ax,0xf05c3750
}
f01007fb:	90                   	nop
f01007fc:	c9                   	leave  
f01007fd:	c3                   	ret    

f01007fe <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007fe:	55                   	push   %ebp
f01007ff:	89 e5                	mov    %esp,%ebp
f0100801:	53                   	push   %ebx
f0100802:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f0100805:	8b 45 08             	mov    0x8(%ebp),%eax
f0100808:	b0 00                	mov    $0x0,%al
f010080a:	85 c0                	test   %eax,%eax
f010080c:	75 07                	jne    f0100815 <cga_putc+0x17>
		c |= 0x0700;
f010080e:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f0100815:	8b 45 08             	mov    0x8(%ebp),%eax
f0100818:	0f b6 c0             	movzbl %al,%eax
f010081b:	83 f8 0a             	cmp    $0xa,%eax
f010081e:	74 77                	je     f0100897 <cga_putc+0x99>
f0100820:	83 f8 0a             	cmp    $0xa,%eax
f0100823:	7f 13                	jg     f0100838 <cga_putc+0x3a>
f0100825:	83 f8 08             	cmp    $0x8,%eax
f0100828:	74 2e                	je     f0100858 <cga_putc+0x5a>
f010082a:	83 f8 09             	cmp    $0x9,%eax
f010082d:	0f 84 a8 00 00 00    	je     f01008db <cga_putc+0xdd>
f0100833:	e9 22 01 00 00       	jmp    f010095a <cga_putc+0x15c>
f0100838:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010083d:	0f 84 de 00 00 00    	je     f0100921 <cga_putc+0x123>
f0100843:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100848:	0f 84 f1 00 00 00    	je     f010093f <cga_putc+0x141>
f010084e:	83 f8 0d             	cmp    $0xd,%eax
f0100851:	74 5d                	je     f01008b0 <cga_putc+0xb2>
f0100853:	e9 02 01 00 00       	jmp    f010095a <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100858:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f010085e:	66 85 c0             	test   %ax,%ax
f0100861:	0f 84 4f 01 00 00    	je     f01009b6 <cga_putc+0x1b8>
			crt_pos--;
f0100867:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f010086d:	48                   	dec    %eax
f010086e:	66 a3 50 37 5c f0    	mov    %ax,0xf05c3750
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100874:	8b 15 4c 37 5c f0    	mov    0xf05c374c,%edx
f010087a:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f0100880:	0f b7 c0             	movzwl %ax,%eax
f0100883:	01 c0                	add    %eax,%eax
f0100885:	01 c2                	add    %eax,%edx
f0100887:	8b 45 08             	mov    0x8(%ebp),%eax
f010088a:	b0 00                	mov    $0x0,%al
f010088c:	83 c8 20             	or     $0x20,%eax
f010088f:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100892:	e9 1f 01 00 00       	jmp    f01009b6 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100897:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f010089d:	83 c0 50             	add    $0x50,%eax
f01008a0:	66 a3 50 37 5c f0    	mov    %ax,0xf05c3750
		text_length = 0;
f01008a6:	c7 05 40 37 5c f0 00 	movl   $0x0,0xf05c3740
f01008ad:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f01008b0:	66 8b 0d 50 37 5c f0 	mov    0xf05c3750,%cx
f01008b7:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f01008bd:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008c2:	ba 00 00 00 00       	mov    $0x0,%edx
f01008c7:	66 f7 f3             	div    %bx
f01008ca:	89 d0                	mov    %edx,%eax
f01008cc:	29 c1                	sub    %eax,%ecx
f01008ce:	89 c8                	mov    %ecx,%eax
f01008d0:	66 a3 50 37 5c f0    	mov    %ax,0xf05c3750
		break;
f01008d6:	e9 e5 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008db:	83 ec 0c             	sub    $0xc,%esp
f01008de:	6a 20                	push   $0x20
f01008e0:	e8 30 05 00 00       	call   f0100e15 <cons_putc>
f01008e5:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e8:	83 ec 0c             	sub    $0xc,%esp
f01008eb:	6a 20                	push   $0x20
f01008ed:	e8 23 05 00 00       	call   f0100e15 <cons_putc>
f01008f2:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f5:	83 ec 0c             	sub    $0xc,%esp
f01008f8:	6a 20                	push   $0x20
f01008fa:	e8 16 05 00 00       	call   f0100e15 <cons_putc>
f01008ff:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0100902:	83 ec 0c             	sub    $0xc,%esp
f0100905:	6a 20                	push   $0x20
f0100907:	e8 09 05 00 00       	call   f0100e15 <cons_putc>
f010090c:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010090f:	83 ec 0c             	sub    $0xc,%esp
f0100912:	6a 20                	push   $0x20
f0100914:	e8 fc 04 00 00       	call   f0100e15 <cons_putc>
f0100919:	83 c4 10             	add    $0x10,%esp
		break;
f010091c:	e9 9f 00 00 00       	jmp    f01009c0 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100921:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f0100927:	66 85 c0             	test   %ax,%ax
f010092a:	0f 84 89 00 00 00    	je     f01009b9 <cga_putc+0x1bb>
			crt_pos--;
f0100930:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f0100936:	48                   	dec    %eax
f0100937:	66 a3 50 37 5c f0    	mov    %ax,0xf05c3750
		break;
f010093d:	eb 7a                	jmp    f01009b9 <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f010093f:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f0100945:	66 3d cf 07          	cmp    $0x7cf,%ax
f0100949:	77 71                	ja     f01009bc <cga_putc+0x1be>
			crt_pos++;
f010094b:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f0100951:	40                   	inc    %eax
f0100952:	66 a3 50 37 5c f0    	mov    %ax,0xf05c3750
		break;
f0100958:	eb 62                	jmp    f01009bc <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010095a:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100961:	74 5c                	je     f01009bf <cga_putc+0x1c1>
f0100963:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010096a:	74 53                	je     f01009bf <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010096c:	8b 0d 4c 37 5c f0    	mov    0xf05c374c,%ecx
f0100972:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f0100978:	8d 50 01             	lea    0x1(%eax),%edx
f010097b:	66 89 15 50 37 5c f0 	mov    %dx,0xf05c3750
f0100982:	0f b7 c0             	movzwl %ax,%eax
f0100985:	01 c0                	add    %eax,%eax
f0100987:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010098a:	8b 45 08             	mov    0x8(%ebp),%eax
f010098d:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100990:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f0100996:	0f b7 c0             	movzwl %ax,%eax
f0100999:	8b 15 40 37 5c f0    	mov    0xf05c3740,%edx
f010099f:	81 c2 80 07 00 00    	add    $0x780,%edx
f01009a5:	39 d0                	cmp    %edx,%eax
f01009a7:	7e 16                	jle    f01009bf <cga_putc+0x1c1>
				text_length++;
f01009a9:	a1 40 37 5c f0       	mov    0xf05c3740,%eax
f01009ae:	40                   	inc    %eax
f01009af:	a3 40 37 5c f0       	mov    %eax,0xf05c3740
		}
		break;
f01009b4:	eb 09                	jmp    f01009bf <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f01009b6:	90                   	nop
f01009b7:	eb 07                	jmp    f01009c0 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f01009b9:	90                   	nop
f01009ba:	eb 04                	jmp    f01009c0 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f01009bc:	90                   	nop
f01009bd:	eb 01                	jmp    f01009c0 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009bf:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009c0:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f01009c6:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ca:	76 58                	jbe    f0100a24 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009cc:	a1 4c 37 5c f0       	mov    0xf05c374c,%eax
f01009d1:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009d7:	a1 4c 37 5c f0       	mov    0xf05c374c,%eax
f01009dc:	83 ec 04             	sub    $0x4,%esp
f01009df:	68 00 0f 00 00       	push   $0xf00
f01009e4:	52                   	push   %edx
f01009e5:	50                   	push   %eax
f01009e6:	e8 12 e4 01 00       	call   f011edfd <memcpy>
f01009eb:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ee:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009f5:	eb 15                	jmp    f0100a0c <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009f7:	8b 15 4c 37 5c f0    	mov    0xf05c374c,%edx
f01009fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100a00:	01 c0                	add    %eax,%eax
f0100a02:	01 d0                	add    %edx,%eax
f0100a04:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0100a09:	ff 45 f4             	incl   -0xc(%ebp)
f0100a0c:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f0100a13:	7e e2                	jle    f01009f7 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f0100a15:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f0100a1b:	83 e8 50             	sub    $0x50,%eax
f0100a1e:	66 a3 50 37 5c f0    	mov    %ax,0xf05c3750
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a24:	a1 48 37 5c f0       	mov    0xf05c3748,%eax
f0100a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a2c:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a30:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a33:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a36:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a37:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f0100a3d:	66 c1 e8 08          	shr    $0x8,%ax
f0100a41:	0f b6 c0             	movzbl %al,%eax
f0100a44:	8b 15 48 37 5c f0    	mov    0xf05c3748,%edx
f0100a4a:	42                   	inc    %edx
f0100a4b:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a4e:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a51:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a54:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a57:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a58:	a1 48 37 5c f0       	mov    0xf05c3748,%eax
f0100a5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a60:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a64:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a6a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a6b:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f0100a71:	0f b6 c0             	movzbl %al,%eax
f0100a74:	8b 15 48 37 5c f0    	mov    0xf05c3748,%edx
f0100a7a:	42                   	inc    %edx
f0100a7b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a7e:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a81:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a87:	ee                   	out    %al,(%dx)
}
f0100a88:	90                   	nop
f0100a89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a8c:	c9                   	leave  
f0100a8d:	c3                   	ret    

f0100a8e <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a8e:	55                   	push   %ebp
f0100a8f:	89 e5                	mov    %esp,%ebp
f0100a91:	83 ec 28             	sub    $0x28,%esp
f0100a94:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a9e:	89 c2                	mov    %eax,%edx
f0100aa0:	ec                   	in     (%dx),%al
f0100aa1:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100aa4:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100aa7:	0f b6 c0             	movzbl %al,%eax
f0100aaa:	83 e0 01             	and    $0x1,%eax
f0100aad:	85 c0                	test   %eax,%eax
f0100aaf:	75 0a                	jne    f0100abb <kbd_proc_data+0x2d>
		return -1;
f0100ab1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100ab6:	e9 2a 02 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
f0100abb:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100ac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100ac5:	89 c2                	mov    %eax,%edx
f0100ac7:	ec                   	in     (%dx),%al
f0100ac8:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100acb:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100ace:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ad1:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ad5:	75 17                	jne    f0100aee <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ad7:	a1 68 39 5c f0       	mov    0xf05c3968,%eax
f0100adc:	83 c8 40             	or     $0x40,%eax
f0100adf:	a3 68 39 5c f0       	mov    %eax,0xf05c3968
		return 0;
f0100ae4:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ae9:	e9 f7 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100aee:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100af1:	84 c0                	test   %al,%al
f0100af3:	79 44                	jns    f0100b39 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100af5:	a1 68 39 5c f0       	mov    0xf05c3968,%eax
f0100afa:	83 e0 40             	and    $0x40,%eax
f0100afd:	85 c0                	test   %eax,%eax
f0100aff:	75 08                	jne    f0100b09 <kbd_proc_data+0x7b>
f0100b01:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b04:	83 e0 7f             	and    $0x7f,%eax
f0100b07:	eb 03                	jmp    f0100b0c <kbd_proc_data+0x7e>
f0100b09:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100b0c:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100b0f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b13:	8a 80 20 b0 17 f0    	mov    -0xfe84fe0(%eax),%al
f0100b19:	83 c8 40             	or     $0x40,%eax
f0100b1c:	0f b6 c0             	movzbl %al,%eax
f0100b1f:	f7 d0                	not    %eax
f0100b21:	89 c2                	mov    %eax,%edx
f0100b23:	a1 68 39 5c f0       	mov    0xf05c3968,%eax
f0100b28:	21 d0                	and    %edx,%eax
f0100b2a:	a3 68 39 5c f0       	mov    %eax,0xf05c3968
		return 0;
f0100b2f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b34:	e9 ac 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b39:	a1 68 39 5c f0       	mov    0xf05c3968,%eax
f0100b3e:	83 e0 40             	and    $0x40,%eax
f0100b41:	85 c0                	test   %eax,%eax
f0100b43:	74 11                	je     f0100b56 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b45:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b49:	a1 68 39 5c f0       	mov    0xf05c3968,%eax
f0100b4e:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b51:	a3 68 39 5c f0       	mov    %eax,0xf05c3968
	}

	shift |= shiftcode[data];
f0100b56:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b5a:	8a 80 20 b0 17 f0    	mov    -0xfe84fe0(%eax),%al
f0100b60:	0f b6 d0             	movzbl %al,%edx
f0100b63:	a1 68 39 5c f0       	mov    0xf05c3968,%eax
f0100b68:	09 d0                	or     %edx,%eax
f0100b6a:	a3 68 39 5c f0       	mov    %eax,0xf05c3968
	shift ^= togglecode[data];
f0100b6f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b73:	8a 80 20 b1 17 f0    	mov    -0xfe84ee0(%eax),%al
f0100b79:	0f b6 d0             	movzbl %al,%edx
f0100b7c:	a1 68 39 5c f0       	mov    0xf05c3968,%eax
f0100b81:	31 d0                	xor    %edx,%eax
f0100b83:	a3 68 39 5c f0       	mov    %eax,0xf05c3968

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b88:	a1 68 39 5c f0       	mov    0xf05c3968,%eax
f0100b8d:	83 e0 03             	and    $0x3,%eax
f0100b90:	8b 14 85 20 b5 17 f0 	mov    -0xfe84ae0(,%eax,4),%edx
f0100b97:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b9b:	01 d0                	add    %edx,%eax
f0100b9d:	8a 00                	mov    (%eax),%al
f0100b9f:	0f b6 c0             	movzbl %al,%eax
f0100ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100ba5:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100bac:	0f 85 9c 00 00 00    	jne    f0100c4e <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100bb2:	a1 40 37 5c f0       	mov    0xf05c3740,%eax
f0100bb7:	85 c0                	test   %eax,%eax
f0100bb9:	0f 8e 85 00 00 00    	jle    f0100c44 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100bbf:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f0100bc5:	0f b7 c0             	movzwl %ax,%eax
f0100bc8:	8b 15 40 37 5c f0    	mov    0xf05c3740,%edx
f0100bce:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bd4:	39 d0                	cmp    %edx,%eax
f0100bd6:	75 0a                	jne    f0100be2 <kbd_proc_data+0x154>
				return 0;
f0100bd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bdd:	e9 03 01 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100be2:	a1 40 37 5c f0       	mov    0xf05c3740,%eax
f0100be7:	48                   	dec    %eax
f0100be8:	a3 40 37 5c f0       	mov    %eax,0xf05c3740
				int crt_pos_Length = crt_pos - 1925;
f0100bed:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f0100bf3:	0f b7 c0             	movzwl %ax,%eax
f0100bf6:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bfe:	66 a1 50 37 5c f0    	mov    0xf05c3750,%ax
f0100c04:	0f b7 c0             	movzwl %ax,%eax
f0100c07:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100c0a:	eb 26                	jmp    f0100c32 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100c0c:	8b 15 4c 37 5c f0    	mov    0xf05c374c,%edx
f0100c12:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100c15:	01 c0                	add    %eax,%eax
f0100c17:	01 c2                	add    %eax,%edx
f0100c19:	a1 4c 37 5c f0       	mov    0xf05c374c,%eax
f0100c1e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c21:	41                   	inc    %ecx
f0100c22:	01 c9                	add    %ecx,%ecx
f0100c24:	01 c8                	add    %ecx,%eax
f0100c26:	66 8b 00             	mov    (%eax),%ax
f0100c29:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c2c:	ff 45 e8             	incl   -0x18(%ebp)
f0100c2f:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c32:	a1 40 37 5c f0       	mov    0xf05c3740,%eax
f0100c37:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c3a:	7e d0                	jle    f0100c0c <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c3f:	e9 a1 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c44:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c49:	e9 97 00 00 00       	jmp    f0100ce5 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c4e:	a1 68 39 5c f0       	mov    0xf05c3968,%eax
f0100c53:	83 e0 08             	and    $0x8,%eax
f0100c56:	85 c0                	test   %eax,%eax
f0100c58:	74 22                	je     f0100c7c <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c5a:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c5e:	7e 0c                	jle    f0100c6c <kbd_proc_data+0x1de>
f0100c60:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c64:	7f 06                	jg     f0100c6c <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c66:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c6a:	eb 10                	jmp    f0100c7c <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c6c:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c70:	7e 0a                	jle    f0100c7c <kbd_proc_data+0x1ee>
f0100c72:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c76:	7f 04                	jg     f0100c7c <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c78:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c7c:	a1 68 39 5c f0       	mov    0xf05c3968,%eax
f0100c81:	83 f8 10             	cmp    $0x10,%eax
f0100c84:	75 13                	jne    f0100c99 <kbd_proc_data+0x20b>
f0100c86:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c8a:	7e 0d                	jle    f0100c99 <kbd_proc_data+0x20b>
f0100c8c:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c90:	7f 07                	jg     f0100c99 <kbd_proc_data+0x20b>
		return 0;
f0100c92:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c97:	eb 4c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	if (c == 255)
f0100c99:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100ca0:	75 07                	jne    f0100ca9 <kbd_proc_data+0x21b>
		return 0;
f0100ca2:	b8 00 00 00 00       	mov    $0x0,%eax
f0100ca7:	eb 3c                	jmp    f0100ce5 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100ca9:	a1 68 39 5c f0       	mov    0xf05c3968,%eax
f0100cae:	f7 d0                	not    %eax
f0100cb0:	83 e0 06             	and    $0x6,%eax
f0100cb3:	85 c0                	test   %eax,%eax
f0100cb5:	75 2b                	jne    f0100ce2 <kbd_proc_data+0x254>
f0100cb7:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100cbe:	75 22                	jne    f0100ce2 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100cc0:	83 ec 0c             	sub    $0xc,%esp
f0100cc3:	68 5b 12 12 f0       	push   $0xf012125b
f0100cc8:	e8 be 02 00 00       	call   f0100f8b <cprintf>
f0100ccd:	83 c4 10             	add    $0x10,%esp
f0100cd0:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cd7:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cdb:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100ce1:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100ce5:	c9                   	leave  
f0100ce6:	c3                   	ret    

f0100ce7 <kbd_intr>:

void
kbd_intr(void)
{
f0100ce7:	55                   	push   %ebp
f0100ce8:	89 e5                	mov    %esp,%ebp
f0100cea:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100ced:	83 ec 0c             	sub    $0xc,%esp
f0100cf0:	68 8e 0a 10 f0       	push   $0xf0100a8e
f0100cf5:	e8 21 00 00 00       	call   f0100d1b <cons_intr>
f0100cfa:	83 c4 10             	add    $0x10,%esp
}
f0100cfd:	90                   	nop
f0100cfe:	c9                   	leave  
f0100cff:	c3                   	ret    

f0100d00 <kbd_init>:

void
kbd_init(void)
{
f0100d00:	55                   	push   %ebp
f0100d01:	89 e5                	mov    %esp,%ebp
f0100d03:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100d06:	83 ec 08             	sub    $0x8,%esp
f0100d09:	68 a2 0e 10 f0       	push   $0xf0100ea2
f0100d0e:	6a 01                	push   $0x1
f0100d10:	e8 d5 c6 00 00       	call   f010d3ea <irq_install_handler>
f0100d15:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100d18:	90                   	nop
f0100d19:	c9                   	leave  
f0100d1a:	c3                   	ret    

f0100d1b <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100d1b:	55                   	push   %ebp
f0100d1c:	89 e5                	mov    %esp,%ebp
f0100d1e:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d21:	eb 35                	jmp    f0100d58 <cons_intr+0x3d>
		if (c == 0)
f0100d23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d27:	75 02                	jne    f0100d2b <cons_intr+0x10>
			continue;
f0100d29:	eb 2d                	jmp    f0100d58 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d2b:	a1 64 39 5c f0       	mov    0xf05c3964,%eax
f0100d30:	8d 50 01             	lea    0x1(%eax),%edx
f0100d33:	89 15 64 39 5c f0    	mov    %edx,0xf05c3964
f0100d39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d3c:	88 90 60 37 5c f0    	mov    %dl,-0xfa3c8a0(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d42:	a1 64 39 5c f0       	mov    0xf05c3964,%eax
f0100d47:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d4c:	75 0a                	jne    f0100d58 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d4e:	c7 05 64 39 5c f0 00 	movl   $0x0,0xf05c3964
f0100d55:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d58:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d5b:	ff d0                	call   *%eax
f0100d5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d60:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d64:	75 bd                	jne    f0100d23 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d66:	90                   	nop
f0100d67:	c9                   	leave  
f0100d68:	c3                   	ret    

f0100d69 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d69:	55                   	push   %ebp
f0100d6a:	89 e5                	mov    %esp,%ebp
f0100d6c:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d6f:	e8 ee f7 ff ff       	call   f0100562 <serial_intr>
	kbd_intr();
f0100d74:	e8 6e ff ff ff       	call   f0100ce7 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d79:	8b 15 60 39 5c f0    	mov    0xf05c3960,%edx
f0100d7f:	a1 64 39 5c f0       	mov    0xf05c3964,%eax
f0100d84:	39 c2                	cmp    %eax,%edx
f0100d86:	74 35                	je     f0100dbd <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d88:	a1 60 39 5c f0       	mov    0xf05c3960,%eax
f0100d8d:	8d 50 01             	lea    0x1(%eax),%edx
f0100d90:	89 15 60 39 5c f0    	mov    %edx,0xf05c3960
f0100d96:	8a 80 60 37 5c f0    	mov    -0xfa3c8a0(%eax),%al
f0100d9c:	0f b6 c0             	movzbl %al,%eax
f0100d9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100da2:	a1 60 39 5c f0       	mov    0xf05c3960,%eax
f0100da7:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dac:	75 0a                	jne    f0100db8 <cons_getc+0x4f>
			cons.rpos = 0;
f0100dae:	c7 05 60 39 5c f0 00 	movl   $0x0,0xf05c3960
f0100db5:	00 00 00 
		return c;
f0100db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100dbb:	eb 05                	jmp    f0100dc2 <cons_getc+0x59>
	}
	return 0;
f0100dbd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100dc2:	c9                   	leave  
f0100dc3:	c3                   	ret    

f0100dc4 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100dc4:	55                   	push   %ebp
f0100dc5:	89 e5                	mov    %esp,%ebp
f0100dc7:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dca:	8b 15 60 39 5c f0    	mov    0xf05c3960,%edx
f0100dd0:	a1 64 39 5c f0       	mov    0xf05c3964,%eax
f0100dd5:	39 c2                	cmp    %eax,%edx
f0100dd7:	74 35                	je     f0100e0e <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dd9:	a1 60 39 5c f0       	mov    0xf05c3960,%eax
f0100dde:	8d 50 01             	lea    0x1(%eax),%edx
f0100de1:	89 15 60 39 5c f0    	mov    %edx,0xf05c3960
f0100de7:	8a 80 60 37 5c f0    	mov    -0xfa3c8a0(%eax),%al
f0100ded:	0f b6 c0             	movzbl %al,%eax
f0100df0:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100df3:	a1 60 39 5c f0       	mov    0xf05c3960,%eax
f0100df8:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dfd:	75 0a                	jne    f0100e09 <cons_getc2+0x45>
			cons.rpos = 0;
f0100dff:	c7 05 60 39 5c f0 00 	movl   $0x0,0xf05c3960
f0100e06:	00 00 00 
		return c;
f0100e09:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100e0c:	eb 05                	jmp    f0100e13 <cons_getc2+0x4f>
	}
	return 0;
f0100e0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100e13:	c9                   	leave  
f0100e14:	c3                   	ret    

f0100e15 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100e15:	55                   	push   %ebp
f0100e16:	89 e5                	mov    %esp,%ebp
f0100e18:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100e1b:	ff 75 08             	pushl  0x8(%ebp)
f0100e1e:	e8 a1 f8 ff ff       	call   f01006c4 <lpt_putc>
f0100e23:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e26:	83 ec 0c             	sub    $0xc,%esp
f0100e29:	ff 75 08             	pushl  0x8(%ebp)
f0100e2c:	e8 cd f9 ff ff       	call   f01007fe <cga_putc>
f0100e31:	83 c4 10             	add    $0x10,%esp
}
f0100e34:	90                   	nop
f0100e35:	c9                   	leave  
f0100e36:	c3                   	ret    

f0100e37 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e37:	55                   	push   %ebp
f0100e38:	89 e5                	mov    %esp,%ebp
f0100e3a:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e3d:	e8 f7 f8 ff ff       	call   f0100739 <cga_init>
	kbd_init();
f0100e42:	e8 b9 fe ff ff       	call   f0100d00 <kbd_init>
	serial_init();
f0100e47:	e8 56 f7 ff ff       	call   f01005a2 <serial_init>

	if (!serial_exists)
f0100e4c:	a1 44 37 5c f0       	mov    0xf05c3744,%eax
f0100e51:	85 c0                	test   %eax,%eax
f0100e53:	75 10                	jne    f0100e65 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e55:	83 ec 0c             	sub    $0xc,%esp
f0100e58:	68 67 12 12 f0       	push   $0xf0121267
f0100e5d:	e8 29 01 00 00       	call   f0100f8b <cprintf>
f0100e62:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e65:	90                   	nop
f0100e66:	c9                   	leave  
f0100e67:	c3                   	ret    

f0100e68 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e68:	55                   	push   %ebp
f0100e69:	89 e5                	mov    %esp,%ebp
f0100e6b:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e6e:	83 ec 0c             	sub    $0xc,%esp
f0100e71:	ff 75 08             	pushl  0x8(%ebp)
f0100e74:	e8 9c ff ff ff       	call   f0100e15 <cons_putc>
f0100e79:	83 c4 10             	add    $0x10,%esp
}
f0100e7c:	90                   	nop
f0100e7d:	c9                   	leave  
f0100e7e:	c3                   	ret    

f0100e7f <getchar>:

int
getchar(void)
{
f0100e7f:	55                   	push   %ebp
f0100e80:	89 e5                	mov    %esp,%ebp
f0100e82:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e85:	e8 df fe ff ff       	call   f0100d69 <cons_getc>
f0100e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e91:	74 f2                	je     f0100e85 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e93:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e96:	c9                   	leave  
f0100e97:	c3                   	ret    

f0100e98 <iscons>:

int
iscons(int fdnum)
{
f0100e98:	55                   	push   %ebp
f0100e99:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e9b:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100ea0:	5d                   	pop    %ebp
f0100ea1:	c3                   	ret    

f0100ea2 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100ea2:	55                   	push   %ebp
f0100ea3:	89 e5                	mov    %esp,%ebp
f0100ea5:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100ea8:	e8 3a fe ff ff       	call   f0100ce7 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100ead:	90                   	nop
f0100eae:	c9                   	leave  
f0100eaf:	c3                   	ret    

f0100eb0 <cons_lock>:

void cons_lock(void)
{
f0100eb0:	55                   	push   %ebp
f0100eb1:	89 e5                	mov    %esp,%ebp
f0100eb3:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100eb6:	e8 40 3e 00 00       	call   f0104cfb <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100ebb:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ebc:	e8 98 9d 00 00       	call   f010ac59 <get_cpu_proc>
f0100ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ec4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ec8:	75 17                	jne    f0100ee1 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eca:	83 ec 04             	sub    $0x4,%esp
f0100ecd:	68 84 12 12 f0       	push   $0xf0121284
f0100ed2:	68 2d 02 00 00       	push   $0x22d
f0100ed7:	68 ab 12 12 f0       	push   $0xf01212ab
f0100edc:	e8 58 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ee4:	8b 00                	mov    (%eax),%eax
f0100ee6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100ee9:	8b 12                	mov    (%edx),%edx
f0100eeb:	8b 52 38             	mov    0x38(%edx),%edx
f0100eee:	80 e6 fd             	and    $0xfd,%dh
f0100ef1:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ef4:	90                   	nop
f0100ef5:	c9                   	leave  
f0100ef6:	c3                   	ret    

f0100ef7 <cons_unlock>:

void cons_unlock(void)
{
f0100ef7:	55                   	push   %ebp
f0100ef8:	89 e5                	mov    %esp,%ebp
f0100efa:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100efd:	e8 f9 3d 00 00       	call   f0104cfb <kclock_stop>
f0100f02:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100f03:	e8 51 9d 00 00       	call   f010ac59 <get_cpu_proc>
f0100f08:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100f0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f0f:	75 17                	jne    f0100f28 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100f11:	83 ec 04             	sub    $0x4,%esp
f0100f14:	68 c0 12 12 f0       	push   $0xf01212c0
f0100f19:	68 46 02 00 00       	push   $0x246
f0100f1e:	68 ab 12 12 f0       	push   $0xf01212ab
f0100f23:	e8 11 f4 ff ff       	call   f0100339 <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f2b:	8b 00                	mov    (%eax),%eax
f0100f2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f30:	8b 12                	mov    (%edx),%edx
f0100f32:	8b 52 38             	mov    0x38(%edx),%edx
f0100f35:	80 ce 02             	or     $0x2,%dh
f0100f38:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f3b:	90                   	nop
f0100f3c:	c9                   	leave  
f0100f3d:	c3                   	ret    

f0100f3e <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f44:	83 ec 0c             	sub    $0xc,%esp
f0100f47:	ff 75 08             	pushl  0x8(%ebp)
f0100f4a:	e8 19 ff ff ff       	call   f0100e68 <cputchar>
f0100f4f:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f55:	8b 00                	mov    (%eax),%eax
f0100f57:	8d 50 01             	lea    0x1(%eax),%edx
f0100f5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f5d:	89 10                	mov    %edx,(%eax)
}
f0100f5f:	90                   	nop
f0100f60:	c9                   	leave  
f0100f61:	c3                   	ret    

f0100f62 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f62:	55                   	push   %ebp
f0100f63:	89 e5                	mov    %esp,%ebp
f0100f65:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f6f:	ff 75 0c             	pushl  0xc(%ebp)
f0100f72:	ff 75 08             	pushl  0x8(%ebp)
f0100f75:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f78:	50                   	push   %eax
f0100f79:	68 3e 0f 10 f0       	push   $0xf0100f3e
f0100f7e:	e8 9a d5 01 00       	call   f011e51d <vprintfmt>
f0100f83:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f89:	c9                   	leave  
f0100f8a:	c3                   	ret    

f0100f8b <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f8b:	55                   	push   %ebp
f0100f8c:	89 e5                	mov    %esp,%ebp
f0100f8e:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f91:	e8 71 62 00 00       	call   f0107207 <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f96:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f99:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f9f:	83 ec 08             	sub    $0x8,%esp
f0100fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0100fa5:	50                   	push   %eax
f0100fa6:	e8 b7 ff ff ff       	call   f0100f62 <vcprintf>
f0100fab:	83 c4 10             	add    $0x10,%esp
f0100fae:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100fb1:	e8 a3 62 00 00       	call   f0107259 <popcli>

	return cnt;
f0100fb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100fb9:	c9                   	leave  
f0100fba:	c3                   	ret    

f0100fbb <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100fbb:	55                   	push   %ebp
f0100fbc:	89 e5                	mov    %esp,%ebp
f0100fbe:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fc8:	eb 10                	jmp    f0100fda <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fca:	83 ec 0c             	sub    $0xc,%esp
f0100fcd:	6a 08                	push   $0x8
f0100fcf:	e8 94 fe ff ff       	call   f0100e68 <cputchar>
f0100fd4:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fd7:	ff 45 f4             	incl   -0xc(%ebp)
f0100fda:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fdd:	8b 00                	mov    (%eax),%eax
f0100fdf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fe2:	7f e6                	jg     f0100fca <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fe7:	c1 e0 0a             	shl    $0xa,%eax
f0100fea:	05 e0 5c 60 f0       	add    $0xf0605ce0,%eax
f0100fef:	83 ec 0c             	sub    $0xc,%esp
f0100ff2:	50                   	push   %eax
f0100ff3:	e8 e7 db 01 00       	call   f011ebdf <strlen>
f0100ff8:	83 c4 10             	add    $0x10,%esp
f0100ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100ffe:	83 ec 04             	sub    $0x4,%esp
f0101001:	68 00 04 00 00       	push   $0x400
f0101006:	68 00 ad 60 f0       	push   $0xf060ad00
f010100b:	ff 75 10             	pushl  0x10(%ebp)
f010100e:	e8 ea dd 01 00       	call   f011edfd <memcpy>
f0101013:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0101016:	8b 45 08             	mov    0x8(%ebp),%eax
f0101019:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010101f:	eb 52                	jmp    f0101073 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101021:	8b 45 08             	mov    0x8(%ebp),%eax
f0101024:	8b 00                	mov    (%eax),%eax
f0101026:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101029:	c1 e2 0a             	shl    $0xa,%edx
f010102c:	01 d0                	add    %edx,%eax
f010102e:	05 e0 5c 60 f0       	add    $0xf0605ce0,%eax
f0101033:	8a 00                	mov    (%eax),%al
f0101035:	0f be c0             	movsbl %al,%eax
f0101038:	83 ec 0c             	sub    $0xc,%esp
f010103b:	50                   	push   %eax
f010103c:	e8 27 fe ff ff       	call   f0100e68 <cputchar>
f0101041:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101044:	8b 45 08             	mov    0x8(%ebp),%eax
f0101047:	8b 00                	mov    (%eax),%eax
f0101049:	89 c2                	mov    %eax,%edx
f010104b:	8b 45 10             	mov    0x10(%ebp),%eax
f010104e:	01 c2                	add    %eax,%edx
f0101050:	8b 45 08             	mov    0x8(%ebp),%eax
f0101053:	8b 00                	mov    (%eax),%eax
f0101055:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101058:	c1 e1 0a             	shl    $0xa,%ecx
f010105b:	01 c8                	add    %ecx,%eax
f010105d:	05 e0 5c 60 f0       	add    $0xf0605ce0,%eax
f0101062:	8a 00                	mov    (%eax),%al
f0101064:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101066:	8b 45 08             	mov    0x8(%ebp),%eax
f0101069:	8b 00                	mov    (%eax),%eax
f010106b:	8d 50 01             	lea    0x1(%eax),%edx
f010106e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101071:	89 10                	mov    %edx,(%eax)
f0101073:	8b 45 08             	mov    0x8(%ebp),%eax
f0101076:	8b 00                	mov    (%eax),%eax
f0101078:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010107b:	7c a4                	jl     f0101021 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010107d:	8b 45 14             	mov    0x14(%ebp),%eax
f0101080:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101083:	89 10                	mov    %edx,(%eax)
}
f0101085:	90                   	nop
f0101086:	c9                   	leave  
f0101087:	c3                   	ret    

f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101088:	55                   	push   %ebp
f0101089:	89 e5                	mov    %esp,%ebp
f010108b:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010108e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101095:	eb 10                	jmp    f01010a7 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101097:	83 ec 0c             	sub    $0xc,%esp
f010109a:	6a 08                	push   $0x8
f010109c:	e8 c7 fd ff ff       	call   f0100e68 <cputchar>
f01010a1:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f01010a4:	ff 45 f4             	incl   -0xc(%ebp)
f01010a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01010aa:	3b 45 08             	cmp    0x8(%ebp),%eax
f01010ad:	7c e8                	jl     f0101097 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f01010af:	83 ec 0c             	sub    $0xc,%esp
f01010b2:	ff 75 0c             	pushl  0xc(%ebp)
f01010b5:	e8 25 db 01 00       	call   f011ebdf <strlen>
f01010ba:	83 c4 10             	add    $0x10,%esp
f01010bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010c0:	83 ec 04             	sub    $0x4,%esp
f01010c3:	68 00 04 00 00       	push   $0x400
f01010c8:	68 00 ad 60 f0       	push   $0xf060ad00
f01010cd:	ff 75 10             	pushl  0x10(%ebp)
f01010d0:	e8 28 dd 01 00       	call   f011edfd <memcpy>
f01010d5:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010d8:	8b 45 14             	mov    0x14(%ebp),%eax
f01010db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010e1:	eb 46                	jmp    f0101129 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010e3:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e6:	8b 00                	mov    (%eax),%eax
f01010e8:	89 c2                	mov    %eax,%edx
f01010ea:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ed:	01 d0                	add    %edx,%eax
f01010ef:	8a 00                	mov    (%eax),%al
f01010f1:	0f be c0             	movsbl %al,%eax
f01010f4:	83 ec 0c             	sub    $0xc,%esp
f01010f7:	50                   	push   %eax
f01010f8:	e8 6b fd ff ff       	call   f0100e68 <cputchar>
f01010fd:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0101100:	8b 45 14             	mov    0x14(%ebp),%eax
f0101103:	8b 00                	mov    (%eax),%eax
f0101105:	89 c2                	mov    %eax,%edx
f0101107:	8b 45 10             	mov    0x10(%ebp),%eax
f010110a:	01 c2                	add    %eax,%edx
f010110c:	8b 45 14             	mov    0x14(%ebp),%eax
f010110f:	8b 00                	mov    (%eax),%eax
f0101111:	89 c1                	mov    %eax,%ecx
f0101113:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101116:	01 c8                	add    %ecx,%eax
f0101118:	8a 00                	mov    (%eax),%al
f010111a:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f010111c:	8b 45 14             	mov    0x14(%ebp),%eax
f010111f:	8b 00                	mov    (%eax),%eax
f0101121:	8d 50 01             	lea    0x1(%eax),%edx
f0101124:	8b 45 14             	mov    0x14(%ebp),%eax
f0101127:	89 10                	mov    %edx,(%eax)
f0101129:	8b 45 14             	mov    0x14(%ebp),%eax
f010112c:	8b 00                	mov    (%eax),%eax
f010112e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101131:	7c b0                	jl     f01010e3 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101133:	8b 45 18             	mov    0x18(%ebp),%eax
f0101136:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101139:	89 10                	mov    %edx,(%eax)
}
f010113b:	90                   	nop
f010113c:	c9                   	leave  
f010113d:	c3                   	ret    

f010113e <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010113e:	55                   	push   %ebp
f010113f:	89 e5                	mov    %esp,%ebp
f0101141:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101144:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010114b:	eb 21                	jmp    f010116e <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010114d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101150:	c1 e0 0a             	shl    $0xa,%eax
f0101153:	05 e0 cc 5e f0       	add    $0xf05ecce0,%eax
f0101158:	83 ec 04             	sub    $0x4,%esp
f010115b:	68 00 04 00 00       	push   $0x400
f0101160:	6a 00                	push   $0x0
f0101162:	50                   	push   %eax
f0101163:	e8 65 dc 01 00       	call   f011edcd <memset>
f0101168:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010116b:	ff 45 f4             	incl   -0xc(%ebp)
f010116e:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101172:	7e d9                	jle    f010114d <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101174:	90                   	nop
f0101175:	c9                   	leave  
f0101176:	c3                   	ret    

f0101177 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101177:	55                   	push   %ebp
f0101178:	89 e5                	mov    %esp,%ebp
f010117a:	57                   	push   %edi
f010117b:	53                   	push   %ebx
f010117c:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101182:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101186:	74 13                	je     f010119b <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101188:	83 ec 08             	sub    $0x8,%esp
f010118b:	ff 75 08             	pushl  0x8(%ebp)
f010118e:	68 ec 12 12 f0       	push   $0xf01212ec
f0101193:	e8 f3 fd ff ff       	call   f0100f8b <cprintf>
f0101198:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010119b:	a1 30 b5 17 f0       	mov    0xf017b530,%eax
f01011a0:	40                   	inc    %eax
f01011a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f01011a4:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f01011ab:	00 00 00 
f01011ae:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011b4:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01011ba:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011c3:	83 ec 0c             	sub    $0xc,%esp
f01011c6:	6a 00                	push   $0x0
f01011c8:	e8 cb fc ff ff       	call   f0100e98 <iscons>
f01011cd:	83 c4 10             	add    $0x10,%esp
f01011d0:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011e1:	e8 99 fc ff ff       	call   f0100e7f <getchar>
f01011e6:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011e9:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011ef:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011f5:	39 c2                	cmp    %eax,%edx
f01011f7:	7e 0c                	jle    f0101205 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011ff:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f0101205:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0101209:	79 22                	jns    f010122d <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f010120b:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f010120f:	0f 84 94 0a 00 00    	je     f0101ca9 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f0101215:	83 ec 08             	sub    $0x8,%esp
f0101218:	ff 75 94             	pushl  -0x6c(%ebp)
f010121b:	68 ef 12 12 f0       	push   $0xf01212ef
f0101220:	e8 66 fd ff ff       	call   f0100f8b <cprintf>
f0101225:	83 c4 10             	add    $0x10,%esp
			return;
f0101228:	e9 7c 0a 00 00       	jmp    f0101ca9 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010122d:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101234:	75 2a                	jne    f0101260 <command_prompt_readline+0xe9>
			if (commandidx)
f0101236:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010123a:	74 03                	je     f010123f <command_prompt_readline+0xc8>
				commandidx--;
f010123c:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010123f:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101245:	50                   	push   %eax
f0101246:	ff 75 0c             	pushl  0xc(%ebp)
f0101249:	ff 75 f4             	pushl  -0xc(%ebp)
f010124c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101252:	50                   	push   %eax
f0101253:	e8 63 fd ff ff       	call   f0100fbb <clearandwritecommand>
f0101258:	83 c4 10             	add    $0x10,%esp
f010125b:	e9 32 0a 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101260:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101267:	75 3b                	jne    f01012a4 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f0101269:	a1 30 b5 17 f0       	mov    0xf017b530,%eax
f010126e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101271:	7d 03                	jge    f0101276 <command_prompt_readline+0xff>
				commandidx++;
f0101273:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101276:	a1 30 b5 17 f0       	mov    0xf017b530,%eax
f010127b:	85 c0                	test   %eax,%eax
f010127d:	0f 88 0f 0a 00 00    	js     f0101c92 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101283:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101289:	50                   	push   %eax
f010128a:	ff 75 0c             	pushl  0xc(%ebp)
f010128d:	ff 75 f4             	pushl  -0xc(%ebp)
f0101290:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101296:	50                   	push   %eax
f0101297:	e8 1f fd ff ff       	call   f0100fbb <clearandwritecommand>
f010129c:	83 c4 10             	add    $0x10,%esp
f010129f:	e9 ee 09 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f01012a4:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f01012a8:	0f 85 6d 07 00 00    	jne    f0101a1b <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f01012ae:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f01012b2:	0f 84 fc 06 00 00    	je     f01019b4 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f01012b8:	83 ec 08             	sub    $0x8,%esp
f01012bb:	6a 64                	push   $0x64
f01012bd:	68 e0 cc 5e f0       	push   $0xf05ecce0
f01012c2:	e8 77 fe ff ff       	call   f010113e <clear_prefix_list>
f01012c7:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ca:	83 ec 0c             	sub    $0xc,%esp
f01012cd:	ff 75 0c             	pushl  0xc(%ebp)
f01012d0:	e8 0a d9 01 00       	call   f011ebdf <strlen>
f01012d5:	83 c4 10             	add    $0x10,%esp
f01012d8:	85 c0                	test   %eax,%eax
f01012da:	0f 84 bd 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
f01012e0:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012e7:	0f 84 b0 09 00 00    	je     f0101c9d <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012f7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012fd:	83 ec 08             	sub    $0x8,%esp
f0101300:	ff 75 0c             	pushl  0xc(%ebp)
f0101303:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101309:	50                   	push   %eax
f010130a:	e8 1f d9 01 00       	call   f011ec2e <strcpy>
f010130f:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f0101312:	83 ec 0c             	sub    $0xc,%esp
f0101315:	ff 75 0c             	pushl  0xc(%ebp)
f0101318:	e8 c2 d8 01 00       	call   f011ebdf <strlen>
f010131d:	83 c4 10             	add    $0x10,%esp
f0101320:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101323:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101326:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101329:	8b 45 0c             	mov    0xc(%ebp),%eax
f010132c:	01 d0                	add    %edx,%eax
f010132e:	8a 00                	mov    (%eax),%al
f0101330:	3c 20                	cmp    $0x20,%al
f0101332:	0f 84 6b 09 00 00    	je     f0101ca3 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101338:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010133e:	50                   	push   %eax
f010133f:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101345:	50                   	push   %eax
f0101346:	68 ff 12 12 f0       	push   $0xf01212ff
f010134b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101351:	50                   	push   %eax
f0101352:	e8 9d de 01 00       	call   f011f1f4 <strsplit>
f0101357:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010135a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101361:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101367:	83 f8 01             	cmp    $0x1,%eax
f010136a:	0f 8e 28 01 00 00    	jle    f0101498 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101370:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101376:	83 ec 08             	sub    $0x8,%esp
f0101379:	68 04 13 12 f0       	push   $0xf0121304
f010137e:	50                   	push   %eax
f010137f:	e8 67 d9 01 00       	call   f011eceb <strcmp>
f0101384:	83 c4 10             	add    $0x10,%esp
f0101387:	85 c0                	test   %eax,%eax
f0101389:	74 3c                	je     f01013c7 <command_prompt_readline+0x250>
f010138b:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101391:	83 ec 08             	sub    $0x8,%esp
f0101394:	68 08 13 12 f0       	push   $0xf0121308
f0101399:	50                   	push   %eax
f010139a:	e8 4c d9 01 00       	call   f011eceb <strcmp>
f010139f:	83 c4 10             	add    $0x10,%esp
f01013a2:	85 c0                	test   %eax,%eax
f01013a4:	74 21                	je     f01013c7 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f01013a6:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ac:	83 ec 08             	sub    $0x8,%esp
f01013af:	68 0d 13 12 f0       	push   $0xf012130d
f01013b4:	50                   	push   %eax
f01013b5:	e8 31 d9 01 00       	call   f011eceb <strcmp>
f01013ba:	83 c4 10             	add    $0x10,%esp
f01013bd:	85 c0                	test   %eax,%eax
f01013bf:	74 06                	je     f01013c7 <command_prompt_readline+0x250>
						continue;
f01013c1:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013c2:	e9 d6 08 00 00       	jmp    f0101c9d <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013c7:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013cd:	83 ec 08             	sub    $0x8,%esp
f01013d0:	68 0d 13 12 f0       	push   $0xf012130d
f01013d5:	50                   	push   %eax
f01013d6:	e8 10 d9 01 00       	call   f011eceb <strcmp>
f01013db:	83 c4 10             	add    $0x10,%esp
f01013de:	85 c0                	test   %eax,%eax
f01013e0:	75 09                	jne    f01013eb <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013e2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013e9:	eb 07                	jmp    f01013f2 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013eb:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013f2:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013f9:	00 00 00 
f01013fc:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101402:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0101407:	b8 00 00 00 00       	mov    $0x0,%eax
f010140c:	89 d7                	mov    %edx,%edi
f010140e:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0101410:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101416:	48                   	dec    %eax
f0101417:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010141e:	83 ec 0c             	sub    $0xc,%esp
f0101421:	50                   	push   %eax
f0101422:	e8 b8 d7 01 00       	call   f011ebdf <strlen>
f0101427:	83 c4 10             	add    $0x10,%esp
f010142a:	8b 55 90             	mov    -0x70(%ebp),%edx
f010142d:	29 c2                	sub    %eax,%edx
f010142f:	89 d0                	mov    %edx,%eax
f0101431:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101434:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010143b:	eb 1d                	jmp    f010145a <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010143d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101440:	8d 50 01             	lea    0x1(%eax),%edx
f0101443:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101446:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f0101449:	8b 55 0c             	mov    0xc(%ebp),%edx
f010144c:	01 ca                	add    %ecx,%edx
f010144e:	8a 12                	mov    (%edx),%dl
f0101450:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101457:	ff 45 d8             	incl   -0x28(%ebp)
f010145a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010145d:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101460:	7c db                	jl     f010143d <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101462:	83 ec 08             	sub    $0x8,%esp
f0101465:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010146b:	50                   	push   %eax
f010146c:	ff 75 0c             	pushl  0xc(%ebp)
f010146f:	e8 ba d7 01 00       	call   f011ec2e <strcpy>
f0101474:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101477:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010147d:	48                   	dec    %eax
f010147e:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101485:	83 ec 08             	sub    $0x8,%esp
f0101488:	50                   	push   %eax
f0101489:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010148f:	50                   	push   %eax
f0101490:	e8 99 d7 01 00       	call   f011ec2e <strcpy>
f0101495:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101498:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f010149f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01014a5:	83 f8 01             	cmp    $0x1,%eax
f01014a8:	0f 85 30 01 00 00    	jne    f01015de <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01014ae:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01014b5:	e9 0f 01 00 00       	jmp    f01015c9 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f01014ba:	83 ec 0c             	sub    $0xc,%esp
f01014bd:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014c3:	50                   	push   %eax
f01014c4:	e8 16 d7 01 00       	call   f011ebdf <strlen>
f01014c9:	83 c4 10             	add    $0x10,%esp
f01014cc:	89 c1                	mov    %eax,%ecx
f01014ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014d1:	89 d0                	mov    %edx,%eax
f01014d3:	01 c0                	add    %eax,%eax
f01014d5:	01 d0                	add    %edx,%eax
f01014d7:	c1 e0 03             	shl    $0x3,%eax
f01014da:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f01014df:	8b 00                	mov    (%eax),%eax
f01014e1:	83 ec 04             	sub    $0x4,%esp
f01014e4:	51                   	push   %ecx
f01014e5:	50                   	push   %eax
f01014e6:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014ec:	50                   	push   %eax
f01014ed:	e8 31 d8 01 00       	call   f011ed23 <strncmp>
f01014f2:	83 c4 10             	add    $0x10,%esp
f01014f5:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014f8:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014fc:	0f 85 c4 00 00 00    	jne    f01015c6 <command_prompt_readline+0x44f>
							it_str = -1;
f0101502:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0101509:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0101510:	00 00 00 
f0101513:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101519:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010151e:	b8 00 00 00 00       	mov    $0x0,%eax
f0101523:	89 d7                	mov    %edx,%edi
f0101525:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101527:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010152e:	eb 2d                	jmp    f010155d <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101530:	ff 45 dc             	incl   -0x24(%ebp)
f0101533:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101536:	89 d0                	mov    %edx,%eax
f0101538:	01 c0                	add    %eax,%eax
f010153a:	01 d0                	add    %edx,%eax
f010153c:	c1 e0 03             	shl    $0x3,%eax
f010153f:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f0101544:	8b 10                	mov    (%eax),%edx
f0101546:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0101549:	01 d0                	add    %edx,%eax
f010154b:	8a 00                	mov    (%eax),%al
f010154d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101553:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101556:	01 ca                	add    %ecx,%edx
f0101558:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010155a:	ff 45 cc             	incl   -0x34(%ebp)
f010155d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101560:	89 d0                	mov    %edx,%eax
f0101562:	01 c0                	add    %eax,%eax
f0101564:	01 d0                	add    %edx,%eax
f0101566:	c1 e0 03             	shl    $0x3,%eax
f0101569:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f010156e:	8b 00                	mov    (%eax),%eax
f0101570:	83 ec 0c             	sub    $0xc,%esp
f0101573:	50                   	push   %eax
f0101574:	e8 66 d6 01 00       	call   f011ebdf <strlen>
f0101579:	83 c4 10             	add    $0x10,%esp
f010157c:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010157f:	7f af                	jg     f0101530 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101581:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101584:	c1 e0 0a             	shl    $0xa,%eax
f0101587:	05 e0 cc 5e f0       	add    $0xf05ecce0,%eax
f010158c:	83 ec 04             	sub    $0x4,%esp
f010158f:	68 00 04 00 00       	push   $0x400
f0101594:	6a 00                	push   $0x0
f0101596:	50                   	push   %eax
f0101597:	e8 31 d8 01 00       	call   f011edcd <memset>
f010159c:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f010159f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01015a2:	40                   	inc    %eax
f01015a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01015a6:	c1 e2 0a             	shl    $0xa,%edx
f01015a9:	81 c2 e0 cc 5e f0    	add    $0xf05ecce0,%edx
f01015af:	83 ec 04             	sub    $0x4,%esp
f01015b2:	50                   	push   %eax
f01015b3:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01015b9:	50                   	push   %eax
f01015ba:	52                   	push   %edx
f01015bb:	e8 9c d6 01 00       	call   f011ec5c <strncpy>
f01015c0:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015c3:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015c6:	ff 45 d0             	incl   -0x30(%ebp)
f01015c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015cc:	a1 48 b9 17 f0       	mov    0xf017b948,%eax
f01015d1:	39 c2                	cmp    %eax,%edx
f01015d3:	0f 82 e1 fe ff ff    	jb     f01014ba <command_prompt_readline+0x343>
f01015d9:	e9 fe 02 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015de:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015e2:	0f 84 7b 01 00 00    	je     f0101763 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015e8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015ef:	e9 5c 01 00 00       	jmp    f0101750 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015f4:	83 ec 0c             	sub    $0xc,%esp
f01015f7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015fd:	50                   	push   %eax
f01015fe:	e8 dc d5 01 00       	call   f011ebdf <strlen>
f0101603:	83 c4 10             	add    $0x10,%esp
f0101606:	89 c1                	mov    %eax,%ecx
f0101608:	8b 1d e0 bc 17 f0    	mov    0xf017bce0,%ebx
f010160e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0101611:	89 d0                	mov    %edx,%eax
f0101613:	01 c0                	add    %eax,%eax
f0101615:	01 d0                	add    %edx,%eax
f0101617:	c1 e0 02             	shl    $0x2,%eax
f010161a:	01 d8                	add    %ebx,%eax
f010161c:	8b 00                	mov    (%eax),%eax
f010161e:	83 ec 04             	sub    $0x4,%esp
f0101621:	51                   	push   %ecx
f0101622:	50                   	push   %eax
f0101623:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101629:	50                   	push   %eax
f010162a:	e8 f4 d6 01 00       	call   f011ed23 <strncmp>
f010162f:	83 c4 10             	add    $0x10,%esp
f0101632:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101635:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f0101639:	0f 85 0e 01 00 00    	jne    f010174d <command_prompt_readline+0x5d6>
								it_str = -1;
f010163f:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101646:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010164d:	00 00 00 
f0101650:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101656:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010165b:	b8 00 00 00 00       	mov    $0x0,%eax
f0101660:	89 d7                	mov    %edx,%edi
f0101662:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101664:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010166a:	83 f8 01             	cmp    $0x1,%eax
f010166d:	7e 39                	jle    f01016a8 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010166f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101676:	eb 1d                	jmp    f0101695 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101678:	ff 45 dc             	incl   -0x24(%ebp)
f010167b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010167e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101681:	01 d0                	add    %edx,%eax
f0101683:	8a 00                	mov    (%eax),%al
f0101685:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010168b:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010168e:	01 ca                	add    %ecx,%edx
f0101690:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101692:	ff 45 c4             	incl   -0x3c(%ebp)
f0101695:	83 ec 0c             	sub    $0xc,%esp
f0101698:	ff 75 0c             	pushl  0xc(%ebp)
f010169b:	e8 3f d5 01 00       	call   f011ebdf <strlen>
f01016a0:	83 c4 10             	add    $0x10,%esp
f01016a3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01016a6:	7f d0                	jg     f0101678 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016a8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01016af:	eb 30                	jmp    f01016e1 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f01016b1:	ff 45 dc             	incl   -0x24(%ebp)
f01016b4:	8b 0d e0 bc 17 f0    	mov    0xf017bce0,%ecx
f01016ba:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016bd:	89 d0                	mov    %edx,%eax
f01016bf:	01 c0                	add    %eax,%eax
f01016c1:	01 d0                	add    %edx,%eax
f01016c3:	c1 e0 02             	shl    $0x2,%eax
f01016c6:	01 c8                	add    %ecx,%eax
f01016c8:	8b 10                	mov    (%eax),%edx
f01016ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016cd:	01 d0                	add    %edx,%eax
f01016cf:	8a 00                	mov    (%eax),%al
f01016d1:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016da:	01 ca                	add    %ecx,%edx
f01016dc:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016de:	ff 45 c0             	incl   -0x40(%ebp)
f01016e1:	8b 0d e0 bc 17 f0    	mov    0xf017bce0,%ecx
f01016e7:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016ea:	89 d0                	mov    %edx,%eax
f01016ec:	01 c0                	add    %eax,%eax
f01016ee:	01 d0                	add    %edx,%eax
f01016f0:	c1 e0 02             	shl    $0x2,%eax
f01016f3:	01 c8                	add    %ecx,%eax
f01016f5:	8b 00                	mov    (%eax),%eax
f01016f7:	83 ec 0c             	sub    $0xc,%esp
f01016fa:	50                   	push   %eax
f01016fb:	e8 df d4 01 00       	call   f011ebdf <strlen>
f0101700:	83 c4 10             	add    $0x10,%esp
f0101703:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0101706:	7f a9                	jg     f01016b1 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101708:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010170b:	c1 e0 0a             	shl    $0xa,%eax
f010170e:	05 e0 cc 5e f0       	add    $0xf05ecce0,%eax
f0101713:	83 ec 04             	sub    $0x4,%esp
f0101716:	68 00 04 00 00       	push   $0x400
f010171b:	6a 00                	push   $0x0
f010171d:	50                   	push   %eax
f010171e:	e8 aa d6 01 00       	call   f011edcd <memset>
f0101723:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101726:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101729:	40                   	inc    %eax
f010172a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010172d:	c1 e2 0a             	shl    $0xa,%edx
f0101730:	81 c2 e0 cc 5e f0    	add    $0xf05ecce0,%edx
f0101736:	83 ec 04             	sub    $0x4,%esp
f0101739:	50                   	push   %eax
f010173a:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101740:	50                   	push   %eax
f0101741:	52                   	push   %edx
f0101742:	e8 15 d5 01 00       	call   f011ec5c <strncpy>
f0101747:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010174a:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010174d:	ff 45 c8             	incl   -0x38(%ebp)
f0101750:	a1 e4 bc 17 f0       	mov    0xf017bce4,%eax
f0101755:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101758:	0f 8c 96 fe ff ff    	jl     f01015f4 <command_prompt_readline+0x47d>
f010175e:	e9 79 01 00 00       	jmp    f01018dc <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101763:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101767:	0f 84 6f 01 00 00    	je     f01018dc <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010176d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101774:	e9 53 01 00 00       	jmp    f01018cc <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0101779:	83 ec 0c             	sub    $0xc,%esp
f010177c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101782:	50                   	push   %eax
f0101783:	e8 57 d4 01 00       	call   f011ebdf <strlen>
f0101788:	83 c4 10             	add    $0x10,%esp
f010178b:	89 c1                	mov    %eax,%ecx
f010178d:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101790:	89 d0                	mov    %edx,%eax
f0101792:	01 c0                	add    %eax,%eax
f0101794:	01 d0                	add    %edx,%eax
f0101796:	c1 e0 02             	shl    $0x2,%eax
f0101799:	05 00 bd 17 f0       	add    $0xf017bd00,%eax
f010179e:	8b 00                	mov    (%eax),%eax
f01017a0:	83 ec 04             	sub    $0x4,%esp
f01017a3:	51                   	push   %ecx
f01017a4:	50                   	push   %eax
f01017a5:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01017ab:	50                   	push   %eax
f01017ac:	e8 72 d5 01 00       	call   f011ed23 <strncmp>
f01017b1:	83 c4 10             	add    $0x10,%esp
f01017b4:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f01017b7:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01017bb:	0f 85 08 01 00 00    	jne    f01018c9 <command_prompt_readline+0x752>
								it_str = -1;
f01017c1:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017c8:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017cf:	00 00 00 
f01017d2:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017d8:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01017e2:	89 d7                	mov    %edx,%edi
f01017e4:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017e6:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017ec:	83 f8 01             	cmp    $0x1,%eax
f01017ef:	7e 39                	jle    f010182a <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017f8:	eb 1d                	jmp    f0101817 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017fa:	ff 45 dc             	incl   -0x24(%ebp)
f01017fd:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0101800:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101803:	01 d0                	add    %edx,%eax
f0101805:	8a 00                	mov    (%eax),%al
f0101807:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010180d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101810:	01 ca                	add    %ecx,%edx
f0101812:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101814:	ff 45 b8             	incl   -0x48(%ebp)
f0101817:	83 ec 0c             	sub    $0xc,%esp
f010181a:	ff 75 0c             	pushl  0xc(%ebp)
f010181d:	e8 bd d3 01 00       	call   f011ebdf <strlen>
f0101822:	83 c4 10             	add    $0x10,%esp
f0101825:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101828:	7f d0                	jg     f01017fa <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010182a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101831:	eb 2d                	jmp    f0101860 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101833:	ff 45 dc             	incl   -0x24(%ebp)
f0101836:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101839:	89 d0                	mov    %edx,%eax
f010183b:	01 c0                	add    %eax,%eax
f010183d:	01 d0                	add    %edx,%eax
f010183f:	c1 e0 02             	shl    $0x2,%eax
f0101842:	05 00 bd 17 f0       	add    $0xf017bd00,%eax
f0101847:	8b 10                	mov    (%eax),%edx
f0101849:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010184c:	01 d0                	add    %edx,%eax
f010184e:	8a 00                	mov    (%eax),%al
f0101850:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101856:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101859:	01 ca                	add    %ecx,%edx
f010185b:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010185d:	ff 45 b4             	incl   -0x4c(%ebp)
f0101860:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101863:	89 d0                	mov    %edx,%eax
f0101865:	01 c0                	add    %eax,%eax
f0101867:	01 d0                	add    %edx,%eax
f0101869:	c1 e0 02             	shl    $0x2,%eax
f010186c:	05 00 bd 17 f0       	add    $0xf017bd00,%eax
f0101871:	8b 00                	mov    (%eax),%eax
f0101873:	83 ec 0c             	sub    $0xc,%esp
f0101876:	50                   	push   %eax
f0101877:	e8 63 d3 01 00       	call   f011ebdf <strlen>
f010187c:	83 c4 10             	add    $0x10,%esp
f010187f:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101882:	7f af                	jg     f0101833 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101884:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101887:	c1 e0 0a             	shl    $0xa,%eax
f010188a:	05 e0 cc 5e f0       	add    $0xf05ecce0,%eax
f010188f:	83 ec 04             	sub    $0x4,%esp
f0101892:	68 00 04 00 00       	push   $0x400
f0101897:	6a 00                	push   $0x0
f0101899:	50                   	push   %eax
f010189a:	e8 2e d5 01 00       	call   f011edcd <memset>
f010189f:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01018a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018a5:	40                   	inc    %eax
f01018a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01018a9:	c1 e2 0a             	shl    $0xa,%edx
f01018ac:	81 c2 e0 cc 5e f0    	add    $0xf05ecce0,%edx
f01018b2:	83 ec 04             	sub    $0x4,%esp
f01018b5:	50                   	push   %eax
f01018b6:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01018bc:	50                   	push   %eax
f01018bd:	52                   	push   %edx
f01018be:	e8 99 d3 01 00       	call   f011ec5c <strncpy>
f01018c3:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018c6:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018c9:	ff 45 bc             	incl   -0x44(%ebp)
f01018cc:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018cf:	a1 b4 bd 17 f0       	mov    0xf017bdb4,%eax
f01018d4:	39 c2                	cmp    %eax,%edx
f01018d6:	0f 82 9d fe ff ff    	jb     f0101779 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018dc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018df:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018e2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018e6:	0f 84 a6 03 00 00    	je     f0101c92 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018ec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018f9:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0101900:	eb 1f                	jmp    f0101921 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0101902:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101905:	8d 50 01             	lea    0x1(%eax),%edx
f0101908:	89 55 dc             	mov    %edx,-0x24(%ebp)
f010190b:	89 c2                	mov    %eax,%edx
f010190d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101910:	01 c2                	add    %eax,%edx
f0101912:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0101915:	05 e0 cc 5e f0       	add    $0xf05ecce0,%eax
f010191a:	8a 00                	mov    (%eax),%al
f010191c:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f010191e:	ff 45 b0             	incl   -0x50(%ebp)
f0101921:	83 ec 0c             	sub    $0xc,%esp
f0101924:	68 e0 cc 5e f0       	push   $0xf05ecce0
f0101929:	e8 b1 d2 01 00       	call   f011ebdf <strlen>
f010192e:	83 c4 10             	add    $0x10,%esp
f0101931:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101934:	7f cc                	jg     f0101902 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101936:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010193d:	eb 10                	jmp    f010194f <command_prompt_readline+0x7d8>
						cputchar('\b');}
f010193f:	83 ec 0c             	sub    $0xc,%esp
f0101942:	6a 08                	push   $0x8
f0101944:	e8 1f f5 ff ff       	call   f0100e68 <cputchar>
f0101949:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010194c:	ff 45 ac             	incl   -0x54(%ebp)
f010194f:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101952:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101955:	7c e8                	jl     f010193f <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101957:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010195e:	eb 1c                	jmp    f010197c <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101960:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101966:	01 d0                	add    %edx,%eax
f0101968:	8a 00                	mov    (%eax),%al
f010196a:	0f be c0             	movsbl %al,%eax
f010196d:	83 ec 0c             	sub    $0xc,%esp
f0101970:	50                   	push   %eax
f0101971:	e8 f2 f4 ff ff       	call   f0100e68 <cputchar>
f0101976:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101979:	ff 45 a8             	incl   -0x58(%ebp)
f010197c:	83 ec 0c             	sub    $0xc,%esp
f010197f:	ff 75 0c             	pushl  0xc(%ebp)
f0101982:	e8 58 d2 01 00       	call   f011ebdf <strlen>
f0101987:	83 c4 10             	add    $0x10,%esp
f010198a:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010198d:	7f d1                	jg     f0101960 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f010198f:	83 ec 0c             	sub    $0xc,%esp
f0101992:	ff 75 0c             	pushl  0xc(%ebp)
f0101995:	e8 45 d2 01 00       	call   f011ebdf <strlen>
f010199a:	83 c4 10             	add    $0x10,%esp
f010199d:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f01019a3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01019a9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f01019af:	e9 de 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f01019b4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01019b8:	0f 8e d4 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
f01019be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019c1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ca:	40                   	inc    %eax
f01019cb:	99                   	cltd   
f01019cc:	f7 7d ec             	idivl  -0x14(%ebp)
f01019cf:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019d5:	c1 e0 0a             	shl    $0xa,%eax
f01019d8:	8d 98 e0 cc 5e f0    	lea    -0xfa13320(%eax),%ebx
f01019de:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019e4:	c1 e0 0a             	shl    $0xa,%eax
f01019e7:	05 e0 cc 5e f0       	add    $0xf05ecce0,%eax
f01019ec:	83 ec 0c             	sub    $0xc,%esp
f01019ef:	50                   	push   %eax
f01019f0:	e8 ea d1 01 00       	call   f011ebdf <strlen>
f01019f5:	83 c4 10             	add    $0x10,%esp
f01019f8:	83 ec 0c             	sub    $0xc,%esp
f01019fb:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0101a01:	52                   	push   %edx
f0101a02:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0101a08:	52                   	push   %edx
f0101a09:	ff 75 0c             	pushl  0xc(%ebp)
f0101a0c:	53                   	push   %ebx
f0101a0d:	50                   	push   %eax
f0101a0e:	e8 75 f6 ff ff       	call   f0101088 <RoundAutoCompleteCommandWithTheSamePrefix>
f0101a13:	83 c4 20             	add    $0x20,%esp
f0101a16:	e9 77 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0101a1b:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a22:	75 2e                	jne    f0101a52 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a24:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a2a:	85 c0                	test   %eax,%eax
f0101a2c:	0f 8e 60 02 00 00    	jle    f0101c92 <command_prompt_readline+0xb1b>
				i--;
f0101a32:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a38:	48                   	dec    %eax
f0101a39:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a3f:	83 ec 0c             	sub    $0xc,%esp
f0101a42:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a45:	e8 1e f4 ff ff       	call   f0100e68 <cputchar>
f0101a4a:	83 c4 10             	add    $0x10,%esp
f0101a4d:	e9 40 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a52:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a59:	75 34                	jne    f0101a8f <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a5b:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a61:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a67:	39 c2                	cmp    %eax,%edx
f0101a69:	0f 8d 23 02 00 00    	jge    f0101c92 <command_prompt_readline+0xb1b>
				i++;
f0101a6f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a75:	40                   	inc    %eax
f0101a76:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a7c:	83 ec 0c             	sub    $0xc,%esp
f0101a7f:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a82:	e8 e1 f3 ff ff       	call   f0100e68 <cputchar>
f0101a87:	83 c4 10             	add    $0x10,%esp
f0101a8a:	e9 03 02 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a8f:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a96:	75 4c                	jne    f0101ae4 <command_prompt_readline+0x96d>
f0101a98:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a9e:	85 c0                	test   %eax,%eax
f0101aa0:	7e 42                	jle    f0101ae4 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101aa2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101aa8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101aab:	eb 1a                	jmp    f0101ac7 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101aad:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101ab0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101ab3:	01 c2                	add    %eax,%edx
f0101ab5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101ab8:	8d 48 01             	lea    0x1(%eax),%ecx
f0101abb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101abe:	01 c8                	add    %ecx,%eax
f0101ac0:	8a 00                	mov    (%eax),%al
f0101ac2:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101ac4:	ff 45 a4             	incl   -0x5c(%ebp)
f0101ac7:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101acd:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ad0:	7e db                	jle    f0101aad <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ad2:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ad8:	48                   	dec    %eax
f0101ad9:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101adf:	e9 ae 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ae4:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ae8:	7e 60                	jle    f0101b4a <command_prompt_readline+0x9d3>
f0101aea:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101af0:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101af5:	7f 53                	jg     f0101b4a <command_prompt_readline+0x9d3>
f0101af7:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101afe:	74 4a                	je     f0101b4a <command_prompt_readline+0x9d3>
f0101b00:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101b07:	74 41                	je     f0101b4a <command_prompt_readline+0x9d3>
			if (echoing)
f0101b09:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b0d:	74 0e                	je     f0101b1d <command_prompt_readline+0x9a6>
				cputchar(c);
f0101b0f:	83 ec 0c             	sub    $0xc,%esp
f0101b12:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b15:	e8 4e f3 ff ff       	call   f0100e68 <cputchar>
f0101b1a:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101b1d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b23:	8d 50 01             	lea    0x1(%eax),%edx
f0101b26:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b2c:	89 c2                	mov    %eax,%edx
f0101b2e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b31:	01 d0                	add    %edx,%eax
f0101b33:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b36:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b38:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b3e:	40                   	inc    %eax
f0101b3f:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b45:	e9 48 01 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b4a:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b4e:	75 60                	jne    f0101bb0 <command_prompt_readline+0xa39>
f0101b50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b56:	85 c0                	test   %eax,%eax
f0101b58:	7e 56                	jle    f0101bb0 <command_prompt_readline+0xa39>

			if (echoing)
f0101b5a:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b5e:	74 0e                	je     f0101b6e <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b60:	83 ec 0c             	sub    $0xc,%esp
f0101b63:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b66:	e8 fd f2 ff ff       	call   f0100e68 <cputchar>
f0101b6b:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b6e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b74:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b77:	eb 1a                	jmp    f0101b93 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b79:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b7c:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b82:	01 c2                	add    %eax,%edx
f0101b84:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b8a:	01 c8                	add    %ecx,%eax
f0101b8c:	8a 00                	mov    (%eax),%al
f0101b8e:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b90:	ff 45 a0             	incl   -0x60(%ebp)
f0101b93:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b99:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b9c:	7e db                	jle    f0101b79 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b9e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ba4:	48                   	dec    %eax
f0101ba5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101bab:	e9 e2 00 00 00       	jmp    f0101c92 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101bb0:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101bb4:	74 0a                	je     f0101bc0 <command_prompt_readline+0xa49>
f0101bb6:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101bba:	0f 85 d2 00 00 00    	jne    f0101c92 <command_prompt_readline+0xb1b>

			if (echoing)
f0101bc0:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101bc4:	74 0e                	je     f0101bd4 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101bc6:	83 ec 0c             	sub    $0xc,%esp
f0101bc9:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bcc:	e8 97 f2 ff ff       	call   f0100e68 <cputchar>
f0101bd1:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bd4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bda:	89 c2                	mov    %eax,%edx
f0101bdc:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bdf:	01 d0                	add    %edx,%eax
f0101be1:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101be4:	a1 30 b5 17 f0       	mov    0xf017b530,%eax
f0101be9:	83 f8 13             	cmp    $0x13,%eax
f0101bec:	75 56                	jne    f0101c44 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bee:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bf5:	eb 2d                	jmp    f0101c24 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bf7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bfa:	40                   	inc    %eax
f0101bfb:	c1 e0 0a             	shl    $0xa,%eax
f0101bfe:	8d 90 e0 5c 60 f0    	lea    -0xf9fa320(%eax),%edx
f0101c04:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101c07:	c1 e0 0a             	shl    $0xa,%eax
f0101c0a:	05 e0 5c 60 f0       	add    $0xf0605ce0,%eax
f0101c0f:	83 ec 04             	sub    $0x4,%esp
f0101c12:	68 00 04 00 00       	push   $0x400
f0101c17:	52                   	push   %edx
f0101c18:	50                   	push   %eax
f0101c19:	e8 df d1 01 00       	call   f011edfd <memcpy>
f0101c1e:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c21:	ff 45 9c             	incl   -0x64(%ebp)
f0101c24:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c28:	7e cd                	jle    f0101bf7 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c2a:	83 ec 04             	sub    $0x4,%esp
f0101c2d:	68 00 04 00 00       	push   $0x400
f0101c32:	ff 75 0c             	pushl  0xc(%ebp)
f0101c35:	68 e0 a8 60 f0       	push   $0xf060a8e0
f0101c3a:	e8 be d1 01 00       	call   f011edfd <memcpy>
f0101c3f:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c42:	eb 68                	jmp    f0101cac <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c44:	a1 30 b5 17 f0       	mov    0xf017b530,%eax
f0101c49:	c1 e0 0a             	shl    $0xa,%eax
f0101c4c:	05 e0 5c 60 f0       	add    $0xf0605ce0,%eax
f0101c51:	83 ec 08             	sub    $0x8,%esp
f0101c54:	ff 75 0c             	pushl  0xc(%ebp)
f0101c57:	50                   	push   %eax
f0101c58:	e8 8e d0 01 00       	call   f011eceb <strcmp>
f0101c5d:	83 c4 10             	add    $0x10,%esp
f0101c60:	85 c0                	test   %eax,%eax
f0101c62:	74 48                	je     f0101cac <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c64:	a1 30 b5 17 f0       	mov    0xf017b530,%eax
f0101c69:	40                   	inc    %eax
f0101c6a:	a3 30 b5 17 f0       	mov    %eax,0xf017b530
f0101c6f:	a1 30 b5 17 f0       	mov    0xf017b530,%eax
f0101c74:	c1 e0 0a             	shl    $0xa,%eax
f0101c77:	05 e0 5c 60 f0       	add    $0xf0605ce0,%eax
f0101c7c:	83 ec 04             	sub    $0x4,%esp
f0101c7f:	68 00 04 00 00       	push   $0x400
f0101c84:	ff 75 0c             	pushl  0xc(%ebp)
f0101c87:	50                   	push   %eax
f0101c88:	e8 70 d1 01 00       	call   f011edfd <memcpy>
f0101c8d:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c90:	eb 1a                	jmp    f0101cac <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c92:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c95:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c98:	e9 44 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c9d:	90                   	nop
f0101c9e:	e9 3e f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101ca3:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101ca4:	e9 38 f5 ff ff       	jmp    f01011e1 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101ca9:	90                   	nop
f0101caa:	eb 01                	jmp    f0101cad <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101cac:	90                   	nop

		}
		last_c = c;
	}
}
f0101cad:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101cb0:	5b                   	pop    %ebx
f0101cb1:	5f                   	pop    %edi
f0101cb2:	5d                   	pop    %ebp
f0101cb3:	c3                   	ret    

f0101cb4 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101cb4:	55                   	push   %ebp
f0101cb5:	89 e5                	mov    %esp,%ebp
f0101cb7:	57                   	push   %edi
f0101cb8:	56                   	push   %esi
f0101cb9:	53                   	push   %ebx
f0101cba:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101cc0:	a1 1c cc 5e f0       	mov    0xf05ecc1c,%eax
f0101cc5:	85 c0                	test   %eax,%eax
f0101cc7:	0f 84 85 00 00 00    	je     f0101d52 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101ccd:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cd3:	bb 17 13 12 f0       	mov    $0xf0121317,%ebx
f0101cd8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cdd:	89 c7                	mov    %eax,%edi
f0101cdf:	89 de                	mov    %ebx,%esi
f0101ce1:	89 d1                	mov    %edx,%ecx
f0101ce3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101ce5:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ceb:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cf0:	b0 00                	mov    $0x0,%al
f0101cf2:	89 d7                	mov    %edx,%edi
f0101cf4:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cf6:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cfc:	bb 17 17 12 f0       	mov    $0xf0121717,%ebx
f0101d01:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d06:	89 c7                	mov    %eax,%edi
f0101d08:	89 de                	mov    %ebx,%esi
f0101d0a:	89 d1                	mov    %edx,%ecx
f0101d0c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d0e:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101d14:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d19:	b0 00                	mov    $0x0,%al
f0101d1b:	89 d7                	mov    %edx,%edi
f0101d1d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d1f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d25:	bb 17 1b 12 f0       	mov    $0xf0121b17,%ebx
f0101d2a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d2f:	89 c7                	mov    %eax,%edi
f0101d31:	89 de                	mov    %ebx,%esi
f0101d33:	89 d1                	mov    %edx,%ecx
f0101d35:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d37:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d3d:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d42:	b0 00                	mov    $0x0,%al
f0101d44:	89 d7                	mov    %edx,%edi
f0101d46:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d48:	c7 05 1c cc 5e f0 00 	movl   $0x0,0xf05ecc1c
f0101d4f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d52:	c7 05 ac cb 5e f0 00 	movl   $0x0,0xf05ecbac
f0101d59:	00 00 00 
f0101d5c:	c7 05 b0 cb 5e f0 00 	movl   $0x0,0xf05ecbb0
f0101d63:	00 00 00 
f0101d66:	c7 05 b8 cb 5e f0 00 	movl   $0x0,0xf05ecbb8
f0101d6d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d70:	83 ec 04             	sub    $0x4,%esp
f0101d73:	68 00 04 00 00       	push   $0x400
f0101d78:	6a 00                	push   $0x0
f0101d7a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d80:	50                   	push   %eax
f0101d81:	e8 47 d0 01 00       	call   f011edcd <memset>
f0101d86:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d89:	83 ec 08             	sub    $0x8,%esp
f0101d8c:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d92:	50                   	push   %eax
f0101d93:	68 11 13 12 f0       	push   $0xf0121311
f0101d98:	e8 da f3 ff ff       	call   f0101177 <command_prompt_readline>
f0101d9d:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101da0:	83 ec 0c             	sub    $0xc,%esp
f0101da3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101da9:	50                   	push   %eax
f0101daa:	e8 4c 01 00 00       	call   f0101efb <execute_command>
f0101daf:	83 c4 10             	add    $0x10,%esp
f0101db2:	85 c0                	test   %eax,%eax
f0101db4:	78 02                	js     f0101db8 <run_command_prompt+0x104>
				break;
	}
f0101db6:	eb b8                	jmp    f0101d70 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101db8:	90                   	nop
	}
}
f0101db9:	90                   	nop
f0101dba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101dbd:	5b                   	pop    %ebx
f0101dbe:	5e                   	pop    %esi
f0101dbf:	5f                   	pop    %edi
f0101dc0:	5d                   	pop    %ebp
f0101dc1:	c3                   	ret    

f0101dc2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101dc2:	55                   	push   %ebp
f0101dc3:	89 e5                	mov    %esp,%ebp
f0101dc5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101dc8:	9c                   	pushf  
f0101dc9:	58                   	pop    %eax
f0101dca:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101dd0:	25 00 02 00 00       	and    $0x200,%eax
f0101dd5:	85 c0                	test   %eax,%eax
f0101dd7:	74 01                	je     f0101dda <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dd9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dda:	e8 ff 90 00 00       	call   f010aede <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101ddf:	e8 60 53 00 00       	call   f0107144 <mycpu>
f0101de4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dea:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101df1:	00 00 00 
		c->intena = 0;
f0101df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101df7:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101dfe:	00 00 00 
		c->scheduler = NULL;
f0101e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e04:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e0e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101e15:	00 00 00 
		c->proc = NULL;
f0101e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e1b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e22:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e25:	89 e0                	mov    %esp,%eax
f0101e27:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e2a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e2d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e33:	8b 40 08             	mov    0x8(%eax),%eax
f0101e36:	05 00 80 00 00       	add    $0x8000,%eax
f0101e3b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e41:	8b 40 08             	mov    0x8(%eax),%eax
f0101e44:	05 00 10 00 00       	add    $0x1000,%eax
f0101e49:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e55:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e5a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e5d:	73 44                	jae    f0101ea3 <get_into_prompt+0xe1>
f0101e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e62:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e65:	72 3c                	jb     f0101ea3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e67:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e6a:	a3 c0 cc 5e f0       	mov    %eax,0xf05eccc0
			m = cpuStackTop - cur_esp;
f0101e6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e72:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e75:	a3 e0 ac 60 f0       	mov    %eax,0xf060ace0
			while (--m >= 0)
f0101e7a:	eb 11                	jmp    f0101e8d <get_into_prompt+0xcb>
				*p++ = 0;
f0101e7c:	a1 c0 cc 5e f0       	mov    0xf05eccc0,%eax
f0101e81:	8d 50 01             	lea    0x1(%eax),%edx
f0101e84:	89 15 c0 cc 5e f0    	mov    %edx,0xf05eccc0
f0101e8a:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e8d:	a1 e0 ac 60 f0       	mov    0xf060ace0,%eax
f0101e92:	48                   	dec    %eax
f0101e93:	a3 e0 ac 60 f0       	mov    %eax,0xf060ace0
f0101e98:	a1 e0 ac 60 f0       	mov    0xf060ace0,%eax
f0101e9d:	85 c0                	test   %eax,%eax
f0101e9f:	79 db                	jns    f0101e7c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101ea1:	eb 3a                	jmp    f0101edd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101ea3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101ea6:	a3 c0 cc 5e f0       	mov    %eax,0xf05eccc0
			m = cpuStackTop - cpuStackBottom;
f0101eab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101eae:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101eb1:	a3 e0 ac 60 f0       	mov    %eax,0xf060ace0
			while (--m >= 0)
f0101eb6:	eb 11                	jmp    f0101ec9 <get_into_prompt+0x107>
				*p++ = 0;
f0101eb8:	a1 c0 cc 5e f0       	mov    0xf05eccc0,%eax
f0101ebd:	8d 50 01             	lea    0x1(%eax),%edx
f0101ec0:	89 15 c0 cc 5e f0    	mov    %edx,0xf05eccc0
f0101ec6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101ec9:	a1 e0 ac 60 f0       	mov    0xf060ace0,%eax
f0101ece:	48                   	dec    %eax
f0101ecf:	a3 e0 ac 60 f0       	mov    %eax,0xf060ace0
f0101ed4:	a1 e0 ac 60 f0       	mov    0xf060ace0,%eax
f0101ed9:	85 c0                	test   %eax,%eax
f0101edb:	79 db                	jns    f0101eb8 <get_into_prompt+0xf6>
f0101edd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ee4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ee7:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101ee9:	83 ec 0c             	sub    $0xc,%esp
f0101eec:	6a 00                	push   $0x0
f0101eee:	e8 c1 fd ff ff       	call   f0101cb4 <run_command_prompt>
f0101ef3:	83 c4 10             	add    $0x10,%esp
	}
f0101ef6:	e9 cd fe ff ff       	jmp    f0101dc8 <get_into_prompt+0x6>

f0101efb <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101efb:	55                   	push   %ebp
f0101efc:	89 e5                	mov    %esp,%ebp
f0101efe:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101f01:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101f04:	50                   	push   %eax
f0101f05:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101f08:	50                   	push   %eax
f0101f09:	68 ff 12 12 f0       	push   $0xf01212ff
f0101f0e:	ff 75 08             	pushl  0x8(%ebp)
f0101f11:	e8 de d2 01 00       	call   f011f1f4 <strsplit>
f0101f16:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101f19:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f1c:	85 c0                	test   %eax,%eax
f0101f1e:	75 0a                	jne    f0101f2a <execute_command+0x2f>
		return 0;
f0101f20:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f25:	e9 a4 02 00 00       	jmp    f01021ce <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f2d:	83 ec 08             	sub    $0x8,%esp
f0101f30:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f33:	52                   	push   %edx
f0101f34:	50                   	push   %eax
f0101f35:	e8 96 02 00 00       	call   f01021d0 <process_command>
f0101f3a:	83 c4 10             	add    $0x10,%esp
f0101f3d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f40:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f44:	75 19                	jne    f0101f5f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f46:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f49:	83 ec 08             	sub    $0x8,%esp
f0101f4c:	50                   	push   %eax
f0101f4d:	68 17 1f 12 f0       	push   $0xf0121f17
f0101f52:	e8 34 f0 ff ff       	call   f0100f8b <cprintf>
f0101f57:	83 c4 10             	add    $0x10,%esp
f0101f5a:	e9 6a 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f5f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f63:	75 4f                	jne    f0101fb4 <execute_command+0xb9>

	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f65:	a1 b8 cb 5e f0       	mov    0xf05ecbb8,%eax
f0101f6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//cprintf("here%d\n",numOfFoundCmds);
		if (numOfFoundCmds != 1)
f0101f6d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f71:	74 17                	je     f0101f8a <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f73:	83 ec 04             	sub    $0x4,%esp
f0101f76:	68 30 1f 12 f0       	push   $0xf0121f30
f0101f7b:	68 8d 01 00 00       	push   $0x18d
f0101f80:	68 81 1f 12 f0       	push   $0xf0121f81
f0101f85:	e8 af e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f8a:	a1 ac cb 5e f0       	mov    0xf05ecbac,%eax
f0101f8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f95:	8b 50 04             	mov    0x4(%eax),%edx
f0101f98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f9b:	8b 00                	mov    (%eax),%eax
f0101f9d:	83 ec 04             	sub    $0x4,%esp
f0101fa0:	52                   	push   %edx
f0101fa1:	50                   	push   %eax
f0101fa2:	68 9c 1f 12 f0       	push   $0xf0121f9c
f0101fa7:	e8 df ef ff ff       	call   f0100f8b <cprintf>
f0101fac:	83 c4 10             	add    $0x10,%esp
f0101faf:	e9 15 02 00 00       	jmp    f01021c9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101fb4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101fb8:	0f 85 e6 01 00 00    	jne    f01021a4 <execute_command+0x2a9>
	{
		int i = 1;
f0101fbe:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fc5:	a1 b8 cb 5e f0       	mov    0xf05ecbb8,%eax
f0101fca:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fcd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fd1:	75 17                	jne    f0101fea <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fd3:	83 ec 04             	sub    $0x4,%esp
f0101fd6:	68 cc 1f 12 f0       	push   $0xf0121fcc
f0101fdb:	68 98 01 00 00       	push   $0x198
f0101fe0:	68 81 1f 12 f0       	push   $0xf0121f81
f0101fe5:	e8 4f e3 ff ff       	call   f0100339 <_panic>
		}
		struct Command * cmd = NULL;
f0101fea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101ff1:	a1 ac cb 5e f0       	mov    0xf05ecbac,%eax
f0101ff6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101ff9:	eb 28                	jmp    f0102023 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101ffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101ffe:	8b 10                	mov    (%eax),%edx
f0102000:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102003:	8d 48 01             	lea    0x1(%eax),%ecx
f0102006:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0102009:	83 ec 04             	sub    $0x4,%esp
f010200c:	52                   	push   %edx
f010200d:	50                   	push   %eax
f010200e:	68 f6 1f 12 f0       	push   $0xf0121ff6
f0102013:	e8 73 ef ff ff       	call   f0100f8b <cprintf>
f0102018:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f010201b:	a1 b4 cb 5e f0       	mov    0xf05ecbb4,%eax
f0102020:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102023:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102027:	74 08                	je     f0102031 <execute_command+0x136>
f0102029:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202c:	8b 40 10             	mov    0x10(%eax),%eax
f010202f:	eb 05                	jmp    f0102036 <execute_command+0x13b>
f0102031:	b8 00 00 00 00       	mov    $0x0,%eax
f0102036:	a3 b4 cb 5e f0       	mov    %eax,0xf05ecbb4
f010203b:	a1 b4 cb 5e f0       	mov    0xf05ecbb4,%eax
f0102040:	85 c0                	test   %eax,%eax
f0102042:	75 b7                	jne    f0101ffb <execute_command+0x100>
f0102044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102048:	75 b1                	jne    f0101ffb <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010204a:	83 ec 08             	sub    $0x8,%esp
f010204d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102050:	68 00 20 12 f0       	push   $0xf0122000
f0102055:	e8 31 ef ff ff       	call   f0100f8b <cprintf>
f010205a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010205d:	e8 1d ee ff ff       	call   f0100e7f <getchar>
f0102062:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102065:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102069:	83 ec 0c             	sub    $0xc,%esp
f010206c:	50                   	push   %eax
f010206d:	e8 f6 ed ff ff       	call   f0100e68 <cputchar>
f0102072:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102075:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010207c:	eb 40                	jmp    f01020be <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010207e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102081:	89 d0                	mov    %edx,%eax
f0102083:	c1 e0 02             	shl    $0x2,%eax
f0102086:	01 d0                	add    %edx,%eax
f0102088:	01 c0                	add    %eax,%eax
f010208a:	89 c2                	mov    %eax,%edx
f010208c:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102090:	83 e8 30             	sub    $0x30,%eax
f0102093:	01 d0                	add    %edx,%eax
f0102095:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102098:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010209c:	7e 2c                	jle    f01020ca <execute_command+0x1cf>
f010209e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020a1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020a4:	7f 24                	jg     f01020ca <execute_command+0x1cf>
				break;

			Chose = getchar();
f01020a6:	e8 d4 ed ff ff       	call   f0100e7f <getchar>
f01020ab:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f01020ae:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020b2:	83 ec 0c             	sub    $0xc,%esp
f01020b5:	50                   	push   %eax
f01020b6:	e8 ad ed ff ff       	call   f0100e68 <cputchar>
f01020bb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f01020be:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020c2:	7e 06                	jle    f01020ca <execute_command+0x1cf>
f01020c4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020c8:	7e b4                	jle    f010207e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ca:	83 ec 0c             	sub    $0xc,%esp
f01020cd:	6a 0a                	push   $0xa
f01020cf:	e8 94 ed ff ff       	call   f0100e68 <cputchar>
f01020d4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020d7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020db:	0f 8e e8 00 00 00    	jle    f01021c9 <execute_command+0x2ce>
f01020e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020e4:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020e7:	0f 8f dc 00 00 00    	jg     f01021c9 <execute_command+0x2ce>
		{
			int c = 1;
f01020ed:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020f4:	a1 ac cb 5e f0       	mov    0xf05ecbac,%eax
f01020f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020fc:	eb 75                	jmp    f0102173 <execute_command+0x278>
			{
				if (c++ == selection)
f01020fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102101:	8d 50 01             	lea    0x1(%eax),%edx
f0102104:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102107:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010210a:	75 5f                	jne    f010216b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010210c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010210f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102112:	85 c0                	test   %eax,%eax
f0102114:	75 31                	jne    f0102147 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102116:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102119:	8b 00                	mov    (%eax),%eax
f010211b:	83 ec 08             	sub    $0x8,%esp
f010211e:	50                   	push   %eax
f010211f:	68 63 20 12 f0       	push   $0xf0122063
f0102124:	e8 62 ee ff ff       	call   f0100f8b <cprintf>
f0102129:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010212c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212f:	8b 40 08             	mov    0x8(%eax),%eax
f0102132:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102135:	83 ec 08             	sub    $0x8,%esp
f0102138:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010213b:	51                   	push   %ecx
f010213c:	52                   	push   %edx
f010213d:	ff d0                	call   *%eax
f010213f:	83 c4 10             	add    $0x10,%esp
f0102142:	e9 87 00 00 00       	jmp    f01021ce <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102147:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010214a:	8b 50 04             	mov    0x4(%eax),%edx
f010214d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102150:	8b 00                	mov    (%eax),%eax
f0102152:	83 ec 04             	sub    $0x4,%esp
f0102155:	52                   	push   %edx
f0102156:	50                   	push   %eax
f0102157:	68 6c 20 12 f0       	push   $0xf012206c
f010215c:	e8 2a ee ff ff       	call   f0100f8b <cprintf>
f0102161:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102164:	b8 00 00 00 00       	mov    $0x0,%eax
f0102169:	eb 63                	jmp    f01021ce <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010216b:	a1 b4 cb 5e f0       	mov    0xf05ecbb4,%eax
f0102170:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102173:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102177:	74 08                	je     f0102181 <execute_command+0x286>
f0102179:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010217c:	8b 40 10             	mov    0x10(%eax),%eax
f010217f:	eb 05                	jmp    f0102186 <execute_command+0x28b>
f0102181:	b8 00 00 00 00       	mov    $0x0,%eax
f0102186:	a3 b4 cb 5e f0       	mov    %eax,0xf05ecbb4
f010218b:	a1 b4 cb 5e f0       	mov    0xf05ecbb4,%eax
f0102190:	85 c0                	test   %eax,%eax
f0102192:	0f 85 66 ff ff ff    	jne    f01020fe <execute_command+0x203>
f0102198:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010219c:	0f 85 5c ff ff ff    	jne    f01020fe <execute_command+0x203>
f01021a2:	eb 25                	jmp    f01021c9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01021a4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01021a7:	89 d0                	mov    %edx,%eax
f01021a9:	01 c0                	add    %eax,%eax
f01021ab:	01 d0                	add    %edx,%eax
f01021ad:	c1 e0 03             	shl    $0x3,%eax
f01021b0:	05 48 b5 17 f0       	add    $0xf017b548,%eax
f01021b5:	8b 00                	mov    (%eax),%eax
f01021b7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01021ba:	83 ec 08             	sub    $0x8,%esp
f01021bd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021c0:	51                   	push   %ecx
f01021c1:	52                   	push   %edx
f01021c2:	ff d0                	call   *%eax
f01021c4:	83 c4 10             	add    $0x10,%esp
f01021c7:	eb 05                	jmp    f01021ce <execute_command+0x2d3>
	}
	return 0;
f01021c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021ce:	c9                   	leave  
f01021cf:	c3                   	ret    

f01021d0 <process_command>:

int process_command(int number_of_arguments, char** arguments)
{
f01021d0:	55                   	push   %ebp
f01021d1:	89 e5                	mov    %esp,%ebp
f01021d3:	83 ec 28             	sub    $0x28,%esp
	struct Command * it = NULL;         //<<<<-------||
f01021d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(it, &foundCommands){ // ||-clear the list each time //<-mousa
f01021dd:	a1 ac cb 5e f0       	mov    0xf05ecbac,%eax
f01021e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01021e5:	e9 90 00 00 00       	jmp    f010227a <process_command+0xaa>
				LIST_REMOVE(&foundCommands,it);//----||
f01021ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01021ee:	75 17                	jne    f0102207 <process_command+0x37>
f01021f0:	83 ec 04             	sub    $0x4,%esp
f01021f3:	68 74 20 12 f0       	push   $0xf0122074
f01021f8:	68 cd 01 00 00       	push   $0x1cd
f01021fd:	68 81 1f 12 f0       	push   $0xf0121f81
f0102202:	e8 32 e1 ff ff       	call   f0100339 <_panic>
f0102207:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010220a:	8b 40 10             	mov    0x10(%eax),%eax
f010220d:	85 c0                	test   %eax,%eax
f010220f:	74 11                	je     f0102222 <process_command+0x52>
f0102211:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102214:	8b 40 10             	mov    0x10(%eax),%eax
f0102217:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010221a:	8b 52 14             	mov    0x14(%edx),%edx
f010221d:	89 50 14             	mov    %edx,0x14(%eax)
f0102220:	eb 0b                	jmp    f010222d <process_command+0x5d>
f0102222:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102225:	8b 40 14             	mov    0x14(%eax),%eax
f0102228:	a3 b0 cb 5e f0       	mov    %eax,0xf05ecbb0
f010222d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102230:	8b 40 14             	mov    0x14(%eax),%eax
f0102233:	85 c0                	test   %eax,%eax
f0102235:	74 11                	je     f0102248 <process_command+0x78>
f0102237:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010223a:	8b 40 14             	mov    0x14(%eax),%eax
f010223d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102240:	8b 52 10             	mov    0x10(%edx),%edx
f0102243:	89 50 10             	mov    %edx,0x10(%eax)
f0102246:	eb 0b                	jmp    f0102253 <process_command+0x83>
f0102248:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010224b:	8b 40 10             	mov    0x10(%eax),%eax
f010224e:	a3 ac cb 5e f0       	mov    %eax,0xf05ecbac
f0102253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102256:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010225d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102260:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0102267:	a1 b8 cb 5e f0       	mov    0xf05ecbb8,%eax
f010226c:	48                   	dec    %eax
f010226d:	a3 b8 cb 5e f0       	mov    %eax,0xf05ecbb8
}

int process_command(int number_of_arguments, char** arguments)
{
	struct Command * it = NULL;         //<<<<-------||
				LIST_FOREACH(it, &foundCommands){ // ||-clear the list each time //<-mousa
f0102272:	a1 b4 cb 5e f0       	mov    0xf05ecbb4,%eax
f0102277:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010227a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010227e:	74 08                	je     f0102288 <process_command+0xb8>
f0102280:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102283:	8b 40 10             	mov    0x10(%eax),%eax
f0102286:	eb 05                	jmp    f010228d <process_command+0xbd>
f0102288:	b8 00 00 00 00       	mov    $0x0,%eax
f010228d:	a3 b4 cb 5e f0       	mov    %eax,0xf05ecbb4
f0102292:	a1 b4 cb 5e f0       	mov    0xf05ecbb4,%eax
f0102297:	85 c0                	test   %eax,%eax
f0102299:	0f 85 4b ff ff ff    	jne    f01021ea <process_command+0x1a>
f010229f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01022a3:	0f 85 41 ff ff ff    	jne    f01021ea <process_command+0x1a>
				LIST_REMOVE(&foundCommands,it);//----||
			}                           //-----------||
	//TODO: [PROJECT'24.MS1 - #01] [1] PLAY WITH CODE! - process_command

int flag=0;
f01022a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	//
	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01022b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01022b7:	e9 42 02 00 00       	jmp    f01024fe <process_command+0x32e>
	{
		if (strcmp(arguments[0], commands[i].name) == 0)
f01022bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01022bf:	89 d0                	mov    %edx,%eax
f01022c1:	01 c0                	add    %eax,%eax
f01022c3:	01 d0                	add    %edx,%eax
f01022c5:	c1 e0 03             	shl    $0x3,%eax
f01022c8:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f01022cd:	8b 10                	mov    (%eax),%edx
f01022cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01022d2:	8b 00                	mov    (%eax),%eax
f01022d4:	83 ec 08             	sub    $0x8,%esp
f01022d7:	52                   	push   %edx
f01022d8:	50                   	push   %eax
f01022d9:	e8 0d ca 01 00       	call   f011eceb <strcmp>
f01022de:	83 c4 10             	add    $0x10,%esp
f01022e1:	85 c0                	test   %eax,%eax
f01022e3:	0f 85 e9 00 00 00    	jne    f01023d2 <process_command+0x202>
		{

			LIST_INSERT_HEAD(&foundCommands,&commands[i]);
f01022e9:	8b 15 ac cb 5e f0    	mov    0xf05ecbac,%edx
f01022ef:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01022f2:	89 c8                	mov    %ecx,%eax
f01022f4:	01 c0                	add    %eax,%eax
f01022f6:	01 c8                	add    %ecx,%eax
f01022f8:	c1 e0 03             	shl    $0x3,%eax
f01022fb:	05 50 b5 17 f0       	add    $0xf017b550,%eax
f0102300:	89 10                	mov    %edx,(%eax)
f0102302:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102305:	89 d0                	mov    %edx,%eax
f0102307:	01 c0                	add    %eax,%eax
f0102309:	01 d0                	add    %edx,%eax
f010230b:	c1 e0 03             	shl    $0x3,%eax
f010230e:	05 50 b5 17 f0       	add    $0xf017b550,%eax
f0102313:	8b 00                	mov    (%eax),%eax
f0102315:	85 c0                	test   %eax,%eax
f0102317:	74 1c                	je     f0102335 <process_command+0x165>
f0102319:	8b 15 ac cb 5e f0    	mov    0xf05ecbac,%edx
f010231f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0102322:	89 c8                	mov    %ecx,%eax
f0102324:	01 c0                	add    %eax,%eax
f0102326:	01 c8                	add    %ecx,%eax
f0102328:	c1 e0 03             	shl    $0x3,%eax
f010232b:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f0102330:	89 42 14             	mov    %eax,0x14(%edx)
f0102333:	eb 16                	jmp    f010234b <process_command+0x17b>
f0102335:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102338:	89 d0                	mov    %edx,%eax
f010233a:	01 c0                	add    %eax,%eax
f010233c:	01 d0                	add    %edx,%eax
f010233e:	c1 e0 03             	shl    $0x3,%eax
f0102341:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f0102346:	a3 b0 cb 5e f0       	mov    %eax,0xf05ecbb0
f010234b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010234e:	89 d0                	mov    %edx,%eax
f0102350:	01 c0                	add    %eax,%eax
f0102352:	01 d0                	add    %edx,%eax
f0102354:	c1 e0 03             	shl    $0x3,%eax
f0102357:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f010235c:	a3 ac cb 5e f0       	mov    %eax,0xf05ecbac
f0102361:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102364:	89 d0                	mov    %edx,%eax
f0102366:	01 c0                	add    %eax,%eax
f0102368:	01 d0                	add    %edx,%eax
f010236a:	c1 e0 03             	shl    $0x3,%eax
f010236d:	05 54 b5 17 f0       	add    $0xf017b554,%eax
f0102372:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0102378:	a1 b8 cb 5e f0       	mov    0xf05ecbb8,%eax
f010237d:	40                   	inc    %eax
f010237e:	a3 b8 cb 5e f0       	mov    %eax,0xf05ecbb8



			 if(((number_of_arguments-1)==commands[i].num_of_args||(commands[i].num_of_args==-1&&(number_of_arguments-1)>0)))//number_of_arguments-->because it's the whole input:)
f0102383:	8b 45 08             	mov    0x8(%ebp),%eax
f0102386:	8d 48 ff             	lea    -0x1(%eax),%ecx
f0102389:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010238c:	89 d0                	mov    %edx,%eax
f010238e:	01 c0                	add    %eax,%eax
f0102390:	01 d0                	add    %edx,%eax
f0102392:	c1 e0 03             	shl    $0x3,%eax
f0102395:	05 4c b5 17 f0       	add    $0xf017b54c,%eax
f010239a:	8b 00                	mov    (%eax),%eax
f010239c:	39 c1                	cmp    %eax,%ecx
f010239e:	74 20                	je     f01023c0 <process_command+0x1f0>
f01023a0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023a3:	89 d0                	mov    %edx,%eax
f01023a5:	01 c0                	add    %eax,%eax
f01023a7:	01 d0                	add    %edx,%eax
f01023a9:	c1 e0 03             	shl    $0x3,%eax
f01023ac:	05 4c b5 17 f0       	add    $0xf017b54c,%eax
f01023b1:	8b 00                	mov    (%eax),%eax
f01023b3:	83 f8 ff             	cmp    $0xffffffff,%eax
f01023b6:	75 10                	jne    f01023c8 <process_command+0x1f8>
f01023b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01023bb:	48                   	dec    %eax
f01023bc:	85 c0                	test   %eax,%eax
f01023be:	7e 08                	jle    f01023c8 <process_command+0x1f8>
			 {
			return i;
f01023c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01023c3:	e9 58 01 00 00       	jmp    f0102520 <process_command+0x350>
			 }

		  else
		   { //cprintf("%d",number_of_arguments-1);
			 // cprintf("iam in the invlid args");
			return CMD_INV_NUM_ARGS;
f01023c8:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f01023cd:	e9 4e 01 00 00       	jmp    f0102520 <process_command+0x350>
		  }
		}
		else
		{

			int c= 0 ;
f01023d2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
			int beg=0 ;
f01023d9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		for (int cc = 0; cc < strlen(commands[i].name); cc++)
f01023e0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f01023e7:	eb 33                	jmp    f010241c <process_command+0x24c>
		{
			if(arguments[0][beg]== commands[i].name[cc])
f01023e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01023ec:	8b 10                	mov    (%eax),%edx
f01023ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01023f1:	01 d0                	add    %edx,%eax
f01023f3:	8a 08                	mov    (%eax),%cl
f01023f5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01023f8:	89 d0                	mov    %edx,%eax
f01023fa:	01 c0                	add    %eax,%eax
f01023fc:	01 d0                	add    %edx,%eax
f01023fe:	c1 e0 03             	shl    $0x3,%eax
f0102401:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f0102406:	8b 10                	mov    (%eax),%edx
f0102408:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010240b:	01 d0                	add    %edx,%eax
f010240d:	8a 00                	mov    (%eax),%al
f010240f:	38 c1                	cmp    %al,%cl
f0102411:	75 06                	jne    f0102419 <process_command+0x249>
		{
		  beg++ ;
f0102413:	ff 45 e4             	incl   -0x1c(%ebp)
		  c++ ;
f0102416:	ff 45 e8             	incl   -0x18(%ebp)
		else
		{

			int c= 0 ;
			int beg=0 ;
		for (int cc = 0; cc < strlen(commands[i].name); cc++)
f0102419:	ff 45 e0             	incl   -0x20(%ebp)
f010241c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010241f:	89 d0                	mov    %edx,%eax
f0102421:	01 c0                	add    %eax,%eax
f0102423:	01 d0                	add    %edx,%eax
f0102425:	c1 e0 03             	shl    $0x3,%eax
f0102428:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f010242d:	8b 00                	mov    (%eax),%eax
f010242f:	83 ec 0c             	sub    $0xc,%esp
f0102432:	50                   	push   %eax
f0102433:	e8 a7 c7 01 00       	call   f011ebdf <strlen>
f0102438:	83 c4 10             	add    $0x10,%esp
f010243b:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f010243e:	7f a9                	jg     f01023e9 <process_command+0x219>

		}



		  if(c == strlen(arguments[0]))
f0102440:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102443:	8b 00                	mov    (%eax),%eax
f0102445:	83 ec 0c             	sub    $0xc,%esp
f0102448:	50                   	push   %eax
f0102449:	e8 91 c7 01 00       	call   f011ebdf <strlen>
f010244e:	83 c4 10             	add    $0x10,%esp
f0102451:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0102454:	0f 85 a1 00 00 00    	jne    f01024fb <process_command+0x32b>
	        {
            flag=1;
f010245a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

            	LIST_INSERT_HEAD(&foundCommands,&commands[i]);
f0102461:	8b 15 ac cb 5e f0    	mov    0xf05ecbac,%edx
f0102467:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010246a:	89 c8                	mov    %ecx,%eax
f010246c:	01 c0                	add    %eax,%eax
f010246e:	01 c8                	add    %ecx,%eax
f0102470:	c1 e0 03             	shl    $0x3,%eax
f0102473:	05 50 b5 17 f0       	add    $0xf017b550,%eax
f0102478:	89 10                	mov    %edx,(%eax)
f010247a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010247d:	89 d0                	mov    %edx,%eax
f010247f:	01 c0                	add    %eax,%eax
f0102481:	01 d0                	add    %edx,%eax
f0102483:	c1 e0 03             	shl    $0x3,%eax
f0102486:	05 50 b5 17 f0       	add    $0xf017b550,%eax
f010248b:	8b 00                	mov    (%eax),%eax
f010248d:	85 c0                	test   %eax,%eax
f010248f:	74 1c                	je     f01024ad <process_command+0x2dd>
f0102491:	8b 15 ac cb 5e f0    	mov    0xf05ecbac,%edx
f0102497:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010249a:	89 c8                	mov    %ecx,%eax
f010249c:	01 c0                	add    %eax,%eax
f010249e:	01 c8                	add    %ecx,%eax
f01024a0:	c1 e0 03             	shl    $0x3,%eax
f01024a3:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f01024a8:	89 42 14             	mov    %eax,0x14(%edx)
f01024ab:	eb 16                	jmp    f01024c3 <process_command+0x2f3>
f01024ad:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024b0:	89 d0                	mov    %edx,%eax
f01024b2:	01 c0                	add    %eax,%eax
f01024b4:	01 d0                	add    %edx,%eax
f01024b6:	c1 e0 03             	shl    $0x3,%eax
f01024b9:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f01024be:	a3 b0 cb 5e f0       	mov    %eax,0xf05ecbb0
f01024c3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024c6:	89 d0                	mov    %edx,%eax
f01024c8:	01 c0                	add    %eax,%eax
f01024ca:	01 d0                	add    %edx,%eax
f01024cc:	c1 e0 03             	shl    $0x3,%eax
f01024cf:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f01024d4:	a3 ac cb 5e f0       	mov    %eax,0xf05ecbac
f01024d9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01024dc:	89 d0                	mov    %edx,%eax
f01024de:	01 c0                	add    %eax,%eax
f01024e0:	01 d0                	add    %edx,%eax
f01024e2:	c1 e0 03             	shl    $0x3,%eax
f01024e5:	05 54 b5 17 f0       	add    $0xf017b554,%eax
f01024ea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01024f0:	a1 b8 cb 5e f0       	mov    0xf05ecbb8,%eax
f01024f5:	40                   	inc    %eax
f01024f6:	a3 b8 cb 5e f0       	mov    %eax,0xf05ecbb8
			}                           //-----------||
	//TODO: [PROJECT'24.MS1 - #01] [1] PLAY WITH CODE! - process_command

int flag=0;
	//
	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01024fb:	ff 45 ec             	incl   -0x14(%ebp)
f01024fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0102501:	a1 48 b9 17 f0       	mov    0xf017b948,%eax
f0102506:	39 c2                	cmp    %eax,%edx
f0102508:	0f 82 ae fd ff ff    	jb     f01022bc <process_command+0xec>

		 }

	}

	  if (flag == 1)
f010250e:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0102512:	75 07                	jne    f010251b <process_command+0x34b>
	  {
		return CMD_MATCHED;
f0102514:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0102519:	eb 05                	jmp    f0102520 <process_command+0x350>
	  }

	return CMD_INVALID;
f010251b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f0102520:	c9                   	leave  
f0102521:	c3                   	ret    

f0102522 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f0102522:	55                   	push   %ebp
f0102523:	89 e5                	mov    %esp,%ebp
f0102525:	c7 05 f0 c9 5e f0 00 	movl   $0x0,0xf05ec9f0
f010252c:	00 00 00 
f010252f:	90                   	nop
f0102530:	5d                   	pop    %ebp
f0102531:	c3                   	ret    

f0102532 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102532:	55                   	push   %ebp
f0102533:	89 e5                	mov    %esp,%ebp
f0102535:	c7 05 f0 c9 5e f0 01 	movl   $0x1,0xf05ec9f0
f010253c:	00 00 00 
f010253f:	90                   	nop
f0102540:	5d                   	pop    %ebp
f0102541:	c3                   	ret    

f0102542 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102542:	55                   	push   %ebp
f0102543:	89 e5                	mov    %esp,%ebp
f0102545:	c7 05 f0 c9 5e f0 02 	movl   $0x2,0xf05ec9f0
f010254c:	00 00 00 
f010254f:	90                   	nop
f0102550:	5d                   	pop    %ebp
f0102551:	c3                   	ret    

f0102552 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102552:	55                   	push   %ebp
f0102553:	89 e5                	mov    %esp,%ebp
f0102555:	c7 05 f0 c9 5e f0 03 	movl   $0x3,0xf05ec9f0
f010255c:	00 00 00 
f010255f:	90                   	nop
f0102560:	5d                   	pop    %ebp
f0102561:	c3                   	ret    

f0102562 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102562:	55                   	push   %ebp
f0102563:	89 e5                	mov    %esp,%ebp
f0102565:	c7 05 f0 c9 5e f0 04 	movl   $0x4,0xf05ec9f0
f010256c:	00 00 00 
f010256f:	90                   	nop
f0102570:	5d                   	pop    %ebp
f0102571:	c3                   	ret    

f0102572 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102572:	55                   	push   %ebp
f0102573:	89 e5                	mov    %esp,%ebp
f0102575:	a1 f0 c9 5e f0       	mov    0xf05ec9f0,%eax
f010257a:	85 c0                	test   %eax,%eax
f010257c:	75 04                	jne    f0102582 <isKHeapPlacementStrategyCONTALLOC+0x10>
f010257e:	b0 01                	mov    $0x1,%al
f0102580:	eb 02                	jmp    f0102584 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102582:	b0 00                	mov    $0x0,%al
f0102584:	5d                   	pop    %ebp
f0102585:	c3                   	ret    

f0102586 <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f0102586:	55                   	push   %ebp
f0102587:	89 e5                	mov    %esp,%ebp
f0102589:	a1 f0 c9 5e f0       	mov    0xf05ec9f0,%eax
f010258e:	83 f8 01             	cmp    $0x1,%eax
f0102591:	75 04                	jne    f0102597 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102593:	b0 01                	mov    $0x1,%al
f0102595:	eb 02                	jmp    f0102599 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f0102597:	b0 00                	mov    $0x0,%al
f0102599:	5d                   	pop    %ebp
f010259a:	c3                   	ret    

f010259b <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f010259b:	55                   	push   %ebp
f010259c:	89 e5                	mov    %esp,%ebp
f010259e:	a1 f0 c9 5e f0       	mov    0xf05ec9f0,%eax
f01025a3:	83 f8 02             	cmp    $0x2,%eax
f01025a6:	75 04                	jne    f01025ac <isKHeapPlacementStrategyBESTFIT+0x11>
f01025a8:	b0 01                	mov    $0x1,%al
f01025aa:	eb 02                	jmp    f01025ae <isKHeapPlacementStrategyBESTFIT+0x13>
f01025ac:	b0 00                	mov    $0x0,%al
f01025ae:	5d                   	pop    %ebp
f01025af:	c3                   	ret    

f01025b0 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f01025b0:	55                   	push   %ebp
f01025b1:	89 e5                	mov    %esp,%ebp
f01025b3:	a1 f0 c9 5e f0       	mov    0xf05ec9f0,%eax
f01025b8:	83 f8 03             	cmp    $0x3,%eax
f01025bb:	75 04                	jne    f01025c1 <isKHeapPlacementStrategyNEXTFIT+0x11>
f01025bd:	b0 01                	mov    $0x1,%al
f01025bf:	eb 02                	jmp    f01025c3 <isKHeapPlacementStrategyNEXTFIT+0x13>
f01025c1:	b0 00                	mov    $0x0,%al
f01025c3:	5d                   	pop    %ebp
f01025c4:	c3                   	ret    

f01025c5 <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f01025c5:	55                   	push   %ebp
f01025c6:	89 e5                	mov    %esp,%ebp
f01025c8:	a1 f0 c9 5e f0       	mov    0xf05ec9f0,%eax
f01025cd:	83 f8 04             	cmp    $0x4,%eax
f01025d0:	75 04                	jne    f01025d6 <isKHeapPlacementStrategyWORSTFIT+0x11>
f01025d2:	b0 01                	mov    $0x1,%al
f01025d4:	eb 02                	jmp    f01025d8 <isKHeapPlacementStrategyWORSTFIT+0x13>
f01025d6:	b0 00                	mov    $0x0,%al
f01025d8:	5d                   	pop    %ebp
f01025d9:	c3                   	ret    

f01025da <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01025da:	55                   	push   %ebp
f01025db:	89 e5                	mov    %esp,%ebp
f01025dd:	c7 05 44 c9 5e f0 01 	movl   $0x1,0xf05ec944
f01025e4:	00 00 00 
f01025e7:	90                   	nop
f01025e8:	5d                   	pop    %ebp
f01025e9:	c3                   	ret    

f01025ea <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01025ea:	55                   	push   %ebp
f01025eb:	89 e5                	mov    %esp,%ebp
f01025ed:	c7 05 44 c9 5e f0 02 	movl   $0x2,0xf05ec944
f01025f4:	00 00 00 
f01025f7:	90                   	nop
f01025f8:	5d                   	pop    %ebp
f01025f9:	c3                   	ret    

f01025fa <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01025fa:	55                   	push   %ebp
f01025fb:	89 e5                	mov    %esp,%ebp
f01025fd:	c7 05 44 c9 5e f0 03 	movl   $0x3,0xf05ec944
f0102604:	00 00 00 
f0102607:	90                   	nop
f0102608:	5d                   	pop    %ebp
f0102609:	c3                   	ret    

f010260a <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f010260a:	55                   	push   %ebp
f010260b:	89 e5                	mov    %esp,%ebp
f010260d:	c7 05 44 c9 5e f0 04 	movl   $0x4,0xf05ec944
f0102614:	00 00 00 
f0102617:	90                   	nop
f0102618:	5d                   	pop    %ebp
f0102619:	c3                   	ret    

f010261a <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f010261a:	55                   	push   %ebp
f010261b:	89 e5                	mov    %esp,%ebp
f010261d:	a1 44 c9 5e f0       	mov    0xf05ec944,%eax
f0102622:	83 f8 01             	cmp    $0x1,%eax
f0102625:	75 04                	jne    f010262b <isUHeapPlacementStrategyFIRSTFIT+0x11>
f0102627:	b0 01                	mov    $0x1,%al
f0102629:	eb 02                	jmp    f010262d <isUHeapPlacementStrategyFIRSTFIT+0x13>
f010262b:	b0 00                	mov    $0x0,%al
f010262d:	5d                   	pop    %ebp
f010262e:	c3                   	ret    

f010262f <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f010262f:	55                   	push   %ebp
f0102630:	89 e5                	mov    %esp,%ebp
f0102632:	a1 44 c9 5e f0       	mov    0xf05ec944,%eax
f0102637:	83 f8 02             	cmp    $0x2,%eax
f010263a:	75 04                	jne    f0102640 <isUHeapPlacementStrategyBESTFIT+0x11>
f010263c:	b0 01                	mov    $0x1,%al
f010263e:	eb 02                	jmp    f0102642 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102640:	b0 00                	mov    $0x0,%al
f0102642:	5d                   	pop    %ebp
f0102643:	c3                   	ret    

f0102644 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102644:	55                   	push   %ebp
f0102645:	89 e5                	mov    %esp,%ebp
f0102647:	a1 44 c9 5e f0       	mov    0xf05ec944,%eax
f010264c:	83 f8 03             	cmp    $0x3,%eax
f010264f:	75 04                	jne    f0102655 <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102651:	b0 01                	mov    $0x1,%al
f0102653:	eb 02                	jmp    f0102657 <isUHeapPlacementStrategyNEXTFIT+0x13>
f0102655:	b0 00                	mov    $0x0,%al
f0102657:	5d                   	pop    %ebp
f0102658:	c3                   	ret    

f0102659 <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f0102659:	55                   	push   %ebp
f010265a:	89 e5                	mov    %esp,%ebp
f010265c:	a1 44 c9 5e f0       	mov    0xf05ec944,%eax
f0102661:	83 f8 04             	cmp    $0x4,%eax
f0102664:	75 04                	jne    f010266a <isUHeapPlacementStrategyWORSTFIT+0x11>
f0102666:	b0 01                	mov    $0x1,%al
f0102668:	eb 02                	jmp    f010266c <isUHeapPlacementStrategyWORSTFIT+0x13>
f010266a:	b0 00                	mov    $0x0,%al
f010266c:	5d                   	pop    %ebp
f010266d:	c3                   	ret    

f010266e <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f010266e:	55                   	push   %ebp
f010266f:	89 e5                	mov    %esp,%ebp
f0102671:	53                   	push   %ebx
f0102672:	83 ec 04             	sub    $0x4,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102675:	8b 45 08             	mov    0x8(%ebp),%eax
f0102678:	c1 e8 0c             	shr    $0xc,%eax
f010267b:	89 c2                	mov    %eax,%edx
f010267d:	a1 f8 c6 5e f0       	mov    0xf05ec6f8,%eax
f0102682:	39 c2                	cmp    %eax,%edx
f0102684:	72 14                	jb     f010269a <to_frame_info+0x2c>
		panic("to_frame_info called with invalid pa");
f0102686:	83 ec 04             	sub    $0x4,%esp
f0102689:	68 94 20 12 f0       	push   $0xf0122094
f010268e:	6a 55                	push   $0x55
f0102690:	68 bc 20 12 f0       	push   $0xf01220bc
f0102695:	e8 9f dc ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f010269a:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f01026a0:	8b 45 08             	mov    0x8(%ebp),%eax
f01026a3:	c1 e8 0c             	shr    $0xc,%eax
f01026a6:	89 c2                	mov    %eax,%edx
f01026a8:	89 d0                	mov    %edx,%eax
f01026aa:	01 c0                	add    %eax,%eax
f01026ac:	01 d0                	add    %edx,%eax
f01026ae:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f01026b5:	01 d8                	add    %ebx,%eax
f01026b7:	01 d0                	add    %edx,%eax
f01026b9:	01 c8                	add    %ecx,%eax
}
f01026bb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01026be:	c9                   	leave  
f01026bf:	c3                   	ret    

f01026c0 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f01026c0:	55                   	push   %ebp
f01026c1:	89 e5                	mov    %esp,%ebp
f01026c3:	53                   	push   %ebx
f01026c4:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01026c7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01026ce:	eb 3b                	jmp    f010270b <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f01026d0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01026d3:	89 d0                	mov    %edx,%eax
f01026d5:	01 c0                	add    %eax,%eax
f01026d7:	01 d0                	add    %edx,%eax
f01026d9:	c1 e0 03             	shl    $0x3,%eax
f01026dc:	05 44 b5 17 f0       	add    $0xf017b544,%eax
f01026e1:	8b 10                	mov    (%eax),%edx
f01026e3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01026e6:	89 c8                	mov    %ecx,%eax
f01026e8:	01 c0                	add    %eax,%eax
f01026ea:	01 c8                	add    %ecx,%eax
f01026ec:	c1 e0 03             	shl    $0x3,%eax
f01026ef:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f01026f4:	8b 00                	mov    (%eax),%eax
f01026f6:	83 ec 04             	sub    $0x4,%esp
f01026f9:	52                   	push   %edx
f01026fa:	50                   	push   %eax
f01026fb:	68 3f 29 12 f0       	push   $0xf012293f
f0102700:	e8 86 e8 ff ff       	call   f0100f8b <cprintf>
f0102705:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102708:	ff 45 f4             	incl   -0xc(%ebp)
f010270b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010270e:	a1 48 b9 17 f0       	mov    0xf017b948,%eax
f0102713:	39 c2                	cmp    %eax,%edx
f0102715:	72 b9                	jb     f01026d0 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f0102717:	83 ec 0c             	sub    $0xc,%esp
f010271a:	68 48 29 12 f0       	push   $0xf0122948
f010271f:	e8 67 e8 ff ff       	call   f0100f8b <cprintf>
f0102724:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102727:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010272e:	eb 42                	jmp    f0102772 <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f0102730:	8b 0d e0 bc 17 f0    	mov    0xf017bce0,%ecx
f0102736:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102739:	89 d0                	mov    %edx,%eax
f010273b:	01 c0                	add    %eax,%eax
f010273d:	01 d0                	add    %edx,%eax
f010273f:	c1 e0 02             	shl    $0x2,%eax
f0102742:	01 c8                	add    %ecx,%eax
f0102744:	8b 50 04             	mov    0x4(%eax),%edx
f0102747:	8b 1d e0 bc 17 f0    	mov    0xf017bce0,%ebx
f010274d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102750:	89 c8                	mov    %ecx,%eax
f0102752:	01 c0                	add    %eax,%eax
f0102754:	01 c8                	add    %ecx,%eax
f0102756:	c1 e0 02             	shl    $0x2,%eax
f0102759:	01 d8                	add    %ebx,%eax
f010275b:	8b 00                	mov    (%eax),%eax
f010275d:	83 ec 04             	sub    $0x4,%esp
f0102760:	52                   	push   %edx
f0102761:	50                   	push   %eax
f0102762:	68 5d 29 12 f0       	push   $0xf012295d
f0102767:	e8 1f e8 ff ff       	call   f0100f8b <cprintf>
f010276c:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f010276f:	ff 45 f4             	incl   -0xc(%ebp)
f0102772:	a1 e4 bc 17 f0       	mov    0xf017bce4,%eax
f0102777:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010277a:	7c b4                	jl     f0102730 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f010277c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102781:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102784:	c9                   	leave  
f0102785:	c3                   	ret    

f0102786 <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f0102786:	55                   	push   %ebp
f0102787:	89 e5                	mov    %esp,%ebp
f0102789:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f010278c:	83 ec 0c             	sub    $0xc,%esp
f010278f:	68 79 29 12 f0       	push   $0xf0122979
f0102794:	e8 f2 e7 ff ff       	call   f0100f8b <cprintf>
f0102799:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f010279c:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f01027a1:	83 ec 04             	sub    $0x4,%esp
f01027a4:	50                   	push   %eax
f01027a5:	68 0c 00 10 f0       	push   $0xf010000c
f01027aa:	68 94 29 12 f0       	push   $0xf0122994
f01027af:	e8 d7 e7 ff ff       	call   f0100f8b <cprintf>
f01027b4:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f01027b7:	b8 b5 0e 12 00       	mov    $0x120eb5,%eax
f01027bc:	83 ec 04             	sub    $0x4,%esp
f01027bf:	50                   	push   %eax
f01027c0:	68 b5 0e 12 f0       	push   $0xf0120eb5
f01027c5:	68 d0 29 12 f0       	push   $0xf01229d0
f01027ca:	e8 bc e7 ff ff       	call   f0100f8b <cprintf>
f01027cf:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f01027d2:	b8 10 37 5c 00       	mov    $0x5c3710,%eax
f01027d7:	83 ec 04             	sub    $0x4,%esp
f01027da:	50                   	push   %eax
f01027db:	68 10 37 5c f0       	push   $0xf05c3710
f01027e0:	68 0c 2a 12 f0       	push   $0xf0122a0c
f01027e5:	e8 a1 e7 ff ff       	call   f0100f8b <cprintf>
f01027ea:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01027ed:	b8 f4 f5 60 00       	mov    $0x60f5f4,%eax
f01027f2:	83 ec 04             	sub    $0x4,%esp
f01027f5:	50                   	push   %eax
f01027f6:	68 f4 f5 60 f0       	push   $0xf060f5f4
f01027fb:	68 54 2a 12 f0       	push   $0xf0122a54
f0102800:	e8 86 e7 ff ff       	call   f0100f8b <cprintf>
f0102805:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f0102808:	b8 f4 f5 60 f0       	mov    $0xf060f5f4,%eax
f010280d:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f0102813:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f0102818:	29 c2                	sub    %eax,%edx
f010281a:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f010281c:	85 c0                	test   %eax,%eax
f010281e:	79 05                	jns    f0102825 <command_kernel_info+0x9f>
f0102820:	05 ff 03 00 00       	add    $0x3ff,%eax
f0102825:	c1 f8 0a             	sar    $0xa,%eax
f0102828:	83 ec 08             	sub    $0x8,%esp
f010282b:	50                   	push   %eax
f010282c:	68 90 2a 12 f0       	push   $0xf0122a90
f0102831:	e8 55 e7 ff ff       	call   f0100f8b <cprintf>
f0102836:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f0102839:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010283e:	c9                   	leave  
f010283f:	c3                   	ret    

f0102840 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102840:	55                   	push   %ebp
f0102841:	89 e5                	mov    %esp,%ebp
f0102843:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f0102846:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f010284a:	75 37                	jne    f0102883 <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f010284c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010284f:	83 c0 04             	add    $0x4,%eax
f0102852:	8b 00                	mov    (%eax),%eax
f0102854:	83 ec 04             	sub    $0x4,%esp
f0102857:	6a 10                	push   $0x10
f0102859:	6a 00                	push   $0x0
f010285b:	50                   	push   %eax
f010285c:	e8 de c6 01 00       	call   f011ef3f <strtol>
f0102861:	83 c4 10             	add    $0x10,%esp
f0102864:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f0102867:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010286a:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f010286d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102870:	83 c0 08             	add    $0x8,%eax
f0102873:	8b 00                	mov    (%eax),%eax
f0102875:	8a 00                	mov    (%eax),%al
f0102877:	88 c2                	mov    %al,%dl
f0102879:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010287c:	88 10                	mov    %dl,(%eax)
f010287e:	e9 b9 00 00 00       	jmp    f010293c <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f0102883:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102887:	0f 85 9f 00 00 00    	jne    f010292c <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f010288d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102890:	83 c0 04             	add    $0x4,%eax
f0102893:	8b 00                	mov    (%eax),%eax
f0102895:	83 ec 04             	sub    $0x4,%esp
f0102898:	6a 0a                	push   $0xa
f010289a:	6a 00                	push   $0x0
f010289c:	50                   	push   %eax
f010289d:	e8 9d c6 01 00       	call   f011ef3f <strtol>
f01028a2:	83 c4 10             	add    $0x10,%esp
f01028a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f01028a8:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f01028af:	83 ec 04             	sub    $0x4,%esp
f01028b2:	6a 00                	push   $0x0
f01028b4:	8d 45 d0             	lea    -0x30(%ebp),%eax
f01028b7:	50                   	push   %eax
f01028b8:	ff 75 f4             	pushl  -0xc(%ebp)
f01028bb:	e8 e9 83 00 00       	call   f010aca9 <envid2env>
f01028c0:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f01028c3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028c6:	83 c0 08             	add    $0x8,%eax
f01028c9:	8b 00                	mov    (%eax),%eax
f01028cb:	83 ec 04             	sub    $0x4,%esp
f01028ce:	6a 10                	push   $0x10
f01028d0:	6a 00                	push   $0x0
f01028d2:	50                   	push   %eax
f01028d3:	e8 67 c6 01 00       	call   f011ef3f <strtol>
f01028d8:	83 c4 10             	add    $0x10,%esp
f01028db:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01028de:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028e1:	85 c0                	test   %eax,%eax
f01028e3:	75 07                	jne    f01028ec <command_writeusermem+0xac>
f01028e5:	b8 00 00 00 00       	mov    $0x0,%eax
f01028ea:	eb 55                	jmp    f0102941 <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01028ec:	0f 20 d8             	mov    %cr3,%eax
f01028ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01028f2:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01028f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01028f8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01028fb:	8b 40 68             	mov    0x68(%eax),%eax
f01028fe:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102901:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102904:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102907:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010290a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f010290d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102910:	83 c0 0c             	add    $0xc,%eax
f0102913:	8b 00                	mov    (%eax),%eax
f0102915:	8a 00                	mov    (%eax),%al
f0102917:	88 c2                	mov    %al,%dl
f0102919:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010291c:	88 10                	mov    %dl,(%eax)
f010291e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102921:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102924:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102927:	0f 22 d8             	mov    %eax,%cr3
f010292a:	eb 10                	jmp    f010293c <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f010292c:	83 ec 0c             	sub    $0xc,%esp
f010292f:	68 bc 2a 12 f0       	push   $0xf0122abc
f0102934:	e8 52 e6 ff ff       	call   f0100f8b <cprintf>
f0102939:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f010293c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102941:	c9                   	leave  
f0102942:	c3                   	ret    

f0102943 <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f0102943:	55                   	push   %ebp
f0102944:	89 e5                	mov    %esp,%ebp
f0102946:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102949:	8b 45 0c             	mov    0xc(%ebp),%eax
f010294c:	83 c0 04             	add    $0x4,%eax
f010294f:	8b 00                	mov    (%eax),%eax
f0102951:	83 ec 04             	sub    $0x4,%esp
f0102954:	6a 10                	push   $0x10
f0102956:	6a 00                	push   $0x0
f0102958:	50                   	push   %eax
f0102959:	e8 e1 c5 01 00       	call   f011ef3f <strtol>
f010295e:	83 c4 10             	add    $0x10,%esp
f0102961:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102966:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f0102969:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102970:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102973:	83 c0 08             	add    $0x8,%eax
f0102976:	8b 00                	mov    (%eax),%eax
f0102978:	83 ec 0c             	sub    $0xc,%esp
f010297b:	50                   	push   %eax
f010297c:	e8 5e c2 01 00       	call   f011ebdf <strlen>
f0102981:	83 c4 10             	add    $0x10,%esp
f0102984:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f0102987:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010298e:	eb 1c                	jmp    f01029ac <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102990:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102993:	83 c0 08             	add    $0x8,%eax
f0102996:	8b 10                	mov    (%eax),%edx
f0102998:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010299b:	01 d0                	add    %edx,%eax
f010299d:	8a 00                	mov    (%eax),%al
f010299f:	88 c2                	mov    %al,%dl
f01029a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01029a4:	88 10                	mov    %dl,(%eax)
		address++;
f01029a6:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f01029a9:	ff 45 f0             	incl   -0x10(%ebp)
f01029ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01029af:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01029b2:	7c dc                	jl     f0102990 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f01029b4:	b8 00 00 00 00       	mov    $0x0,%eax


}
f01029b9:	c9                   	leave  
f01029ba:	c3                   	ret    

f01029bb <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f01029bb:	55                   	push   %ebp
f01029bc:	89 e5                	mov    %esp,%ebp
f01029be:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f01029c1:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01029c5:	75 42                	jne    f0102a09 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f01029c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01029ca:	83 c0 04             	add    $0x4,%eax
f01029cd:	8b 00                	mov    (%eax),%eax
f01029cf:	83 ec 04             	sub    $0x4,%esp
f01029d2:	6a 10                	push   $0x10
f01029d4:	6a 00                	push   $0x0
f01029d6:	50                   	push   %eax
f01029d7:	e8 63 c5 01 00       	call   f011ef3f <strtol>
f01029dc:	83 c4 10             	add    $0x10,%esp
f01029df:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01029e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029e5:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01029e8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029eb:	8a 00                	mov    (%eax),%al
f01029ed:	0f b6 c0             	movzbl %al,%eax
f01029f0:	83 ec 04             	sub    $0x4,%esp
f01029f3:	50                   	push   %eax
f01029f4:	ff 75 d8             	pushl  -0x28(%ebp)
f01029f7:	68 e6 2a 12 f0       	push   $0xf0122ae6
f01029fc:	e8 8a e5 ff ff       	call   f0100f8b <cprintf>
f0102a01:	83 c4 10             	add    $0x10,%esp
f0102a04:	e9 c4 00 00 00       	jmp    f0102acd <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f0102a09:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102a0d:	0f 85 aa 00 00 00    	jne    f0102abd <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102a13:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a16:	83 c0 04             	add    $0x4,%eax
f0102a19:	8b 00                	mov    (%eax),%eax
f0102a1b:	83 ec 04             	sub    $0x4,%esp
f0102a1e:	6a 0a                	push   $0xa
f0102a20:	6a 00                	push   $0x0
f0102a22:	50                   	push   %eax
f0102a23:	e8 17 c5 01 00       	call   f011ef3f <strtol>
f0102a28:	83 c4 10             	add    $0x10,%esp
f0102a2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102a2e:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102a35:	83 ec 04             	sub    $0x4,%esp
f0102a38:	6a 00                	push   $0x0
f0102a3a:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102a3d:	50                   	push   %eax
f0102a3e:	ff 75 f4             	pushl  -0xc(%ebp)
f0102a41:	e8 63 82 00 00       	call   f010aca9 <envid2env>
f0102a46:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102a49:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a4c:	83 c0 08             	add    $0x8,%eax
f0102a4f:	8b 00                	mov    (%eax),%eax
f0102a51:	83 ec 04             	sub    $0x4,%esp
f0102a54:	6a 10                	push   $0x10
f0102a56:	6a 00                	push   $0x0
f0102a58:	50                   	push   %eax
f0102a59:	e8 e1 c4 01 00       	call   f011ef3f <strtol>
f0102a5e:	83 c4 10             	add    $0x10,%esp
f0102a61:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f0102a64:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a67:	85 c0                	test   %eax,%eax
f0102a69:	75 07                	jne    f0102a72 <command_readusermem+0xb7>
f0102a6b:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a70:	eb 60                	jmp    f0102ad2 <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102a72:	0f 20 d8             	mov    %cr3,%eax
f0102a75:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f0102a78:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102a7b:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102a7e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102a81:	8b 40 68             	mov    0x68(%eax),%eax
f0102a84:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102a87:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102a8a:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102a8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102a90:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102a93:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a96:	8a 00                	mov    (%eax),%al
f0102a98:	0f b6 c0             	movzbl %al,%eax
f0102a9b:	83 ec 04             	sub    $0x4,%esp
f0102a9e:	50                   	push   %eax
f0102a9f:	ff 75 f0             	pushl  -0x10(%ebp)
f0102aa2:	68 e6 2a 12 f0       	push   $0xf0122ae6
f0102aa7:	e8 df e4 ff ff       	call   f0100f8b <cprintf>
f0102aac:	83 c4 10             	add    $0x10,%esp
f0102aaf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102ab2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0102ab5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102ab8:	0f 22 d8             	mov    %eax,%cr3
f0102abb:	eb 10                	jmp    f0102acd <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102abd:	83 ec 0c             	sub    $0xc,%esp
f0102ac0:	68 00 2b 12 f0       	push   $0xf0122b00
f0102ac5:	e8 c1 e4 ff ff       	call   f0100f8b <cprintf>
f0102aca:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102acd:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0102ad2:	c9                   	leave  
f0102ad3:	c3                   	ret    

f0102ad4 <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f0102ad4:	55                   	push   %ebp
f0102ad5:	89 e5                	mov    %esp,%ebp
f0102ad7:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0102ada:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102add:	83 c0 04             	add    $0x4,%eax
f0102ae0:	8b 00                	mov    (%eax),%eax
f0102ae2:	83 ec 04             	sub    $0x4,%esp
f0102ae5:	6a 10                	push   $0x10
f0102ae7:	6a 00                	push   $0x0
f0102ae9:	50                   	push   %eax
f0102aea:	e8 50 c4 01 00       	call   f011ef3f <strtol>
f0102aef:	83 c4 10             	add    $0x10,%esp
f0102af2:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0102af7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f0102afa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f0102b01:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102b04:	8a 00                	mov    (%eax),%al
f0102b06:	0f b6 c0             	movzbl %al,%eax
f0102b09:	83 ec 08             	sub    $0x8,%esp
f0102b0c:	50                   	push   %eax
f0102b0d:	68 2a 2b 12 f0       	push   $0xf0122b2a
f0102b12:	e8 74 e4 ff ff       	call   f0100f8b <cprintf>
f0102b17:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0102b1a:	83 ec 0c             	sub    $0xc,%esp
f0102b1d:	68 2d 2b 12 f0       	push   $0xf0122b2d
f0102b22:	e8 64 e4 ff ff       	call   f0100f8b <cprintf>
f0102b27:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102b2a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102b2f:	c9                   	leave  
f0102b30:	c3                   	ret    

f0102b31 <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102b31:	55                   	push   %ebp
f0102b32:	89 e5                	mov    %esp,%ebp
f0102b34:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102b37:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b3a:	83 c0 04             	add    $0x4,%eax
f0102b3d:	8b 00                	mov    (%eax),%eax
f0102b3f:	83 ec 04             	sub    $0x4,%esp
f0102b42:	6a 0a                	push   $0xa
f0102b44:	6a 00                	push   $0x0
f0102b46:	50                   	push   %eax
f0102b47:	e8 f3 c3 01 00       	call   f011ef3f <strtol>
f0102b4c:	83 c4 10             	add    $0x10,%esp
f0102b4f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102b52:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0102b59:	83 ec 04             	sub    $0x4,%esp
f0102b5c:	6a 00                	push   $0x0
f0102b5e:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102b61:	50                   	push   %eax
f0102b62:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b65:	e8 3f 81 00 00       	call   f010aca9 <envid2env>
f0102b6a:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102b6d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b70:	83 c0 08             	add    $0x8,%eax
f0102b73:	8b 00                	mov    (%eax),%eax
f0102b75:	83 ec 04             	sub    $0x4,%esp
f0102b78:	6a 10                	push   $0x10
f0102b7a:	6a 00                	push   $0x0
f0102b7c:	50                   	push   %eax
f0102b7d:	e8 bd c3 01 00       	call   f011ef3f <strtol>
f0102b82:	83 c4 10             	add    $0x10,%esp
f0102b85:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0102b88:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b8b:	83 c0 0c             	add    $0xc,%eax
f0102b8e:	8b 00                	mov    (%eax),%eax
f0102b90:	83 ec 04             	sub    $0x4,%esp
f0102b93:	6a 0a                	push   $0xa
f0102b95:	6a 00                	push   $0x0
f0102b97:	50                   	push   %eax
f0102b98:	e8 a2 c3 01 00       	call   f011ef3f <strtol>
f0102b9d:	83 c4 10             	add    $0x10,%esp
f0102ba0:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102ba3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102ba6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f0102ba9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102bac:	85 c0                	test   %eax,%eax
f0102bae:	75 07                	jne    f0102bb7 <command_readuserblock+0x86>
f0102bb0:	b8 00 00 00 00       	mov    $0x0,%eax
f0102bb5:	eb 65                	jmp    f0102c1c <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102bb7:	0f 20 d8             	mov    %cr3,%eax
f0102bba:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102bbd:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102bc0:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102bc3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102bc6:	8b 40 68             	mov    0x68(%eax),%eax
f0102bc9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0102bcc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102bcf:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f0102bd2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102bd9:	eb 28                	jmp    f0102c03 <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f0102bdb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102bde:	8a 00                	mov    (%eax),%al
f0102be0:	0f b6 d0             	movzbl %al,%edx
f0102be3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102be6:	8a 00                	mov    (%eax),%al
f0102be8:	0f b6 c0             	movzbl %al,%eax
f0102beb:	52                   	push   %edx
f0102bec:	50                   	push   %eax
f0102bed:	ff 75 f4             	pushl  -0xc(%ebp)
f0102bf0:	68 2f 2b 12 f0       	push   $0xf0122b2f
f0102bf5:	e8 91 e3 ff ff       	call   f0100f8b <cprintf>
f0102bfa:	83 c4 10             	add    $0x10,%esp
		ptr++;
f0102bfd:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f0102c00:	ff 45 f0             	incl   -0x10(%ebp)
f0102c03:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c06:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0102c09:	7c d0                	jl     f0102bdb <command_readuserblock+0xaa>
f0102c0b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102c0e:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0102c11:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102c14:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0102c17:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102c1c:	c9                   	leave  
f0102c1d:	c3                   	ret    

f0102c1e <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f0102c1e:	55                   	push   %ebp
f0102c1f:	89 e5                	mov    %esp,%ebp
f0102c21:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102c24:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c27:	83 c0 04             	add    $0x4,%eax
f0102c2a:	8b 00                	mov    (%eax),%eax
f0102c2c:	83 ec 04             	sub    $0x4,%esp
f0102c2f:	6a 0a                	push   $0xa
f0102c31:	6a 00                	push   $0x0
f0102c33:	50                   	push   %eax
f0102c34:	e8 06 c3 01 00       	call   f011ef3f <strtol>
f0102c39:	83 c4 10             	add    $0x10,%esp
f0102c3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102c3f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0102c46:	83 ec 04             	sub    $0x4,%esp
f0102c49:	6a 00                	push   $0x0
f0102c4b:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102c4e:	50                   	push   %eax
f0102c4f:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c52:	e8 52 80 00 00       	call   f010aca9 <envid2env>
f0102c57:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102c5a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c5d:	85 c0                	test   %eax,%eax
f0102c5f:	75 0a                	jne    f0102c6b <command_remove_table+0x4d>
f0102c61:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c66:	e9 c7 00 00 00       	jmp    f0102d32 <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102c6b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c6e:	83 c0 08             	add    $0x8,%eax
f0102c71:	8b 00                	mov    (%eax),%eax
f0102c73:	83 ec 04             	sub    $0x4,%esp
f0102c76:	6a 10                	push   $0x10
f0102c78:	6a 00                	push   $0x0
f0102c7a:	50                   	push   %eax
f0102c7b:	e8 bf c2 01 00       	call   f011ef3f <strtol>
f0102c80:	83 c4 10             	add    $0x10,%esp
f0102c83:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0102c86:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c89:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102c8c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102c8f:	8b 40 64             	mov    0x64(%eax),%eax
f0102c92:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102c95:	c1 ea 16             	shr    $0x16,%edx
f0102c98:	c1 e2 02             	shl    $0x2,%edx
f0102c9b:	01 d0                	add    %edx,%eax
f0102c9d:	8b 00                	mov    (%eax),%eax
f0102c9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0102ca4:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f0102ca7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102caa:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f0102caf:	77 1c                	ja     f0102ccd <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f0102cb1:	83 ec 0c             	sub    $0xc,%esp
f0102cb4:	ff 75 e8             	pushl  -0x18(%ebp)
f0102cb7:	e8 1b 64 00 00       	call   f01090d7 <kheap_virtual_address>
f0102cbc:	83 c4 10             	add    $0x10,%esp
f0102cbf:	83 ec 0c             	sub    $0xc,%esp
f0102cc2:	50                   	push   %eax
f0102cc3:	e8 d5 62 00 00       	call   f0108f9d <kfree>
f0102cc8:	83 c4 10             	add    $0x10,%esp
f0102ccb:	eb 28                	jmp    f0102cf5 <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f0102ccd:	83 ec 0c             	sub    $0xc,%esp
f0102cd0:	ff 75 e8             	pushl  -0x18(%ebp)
f0102cd3:	e8 96 f9 ff ff       	call   f010266e <to_frame_info>
f0102cd8:	83 c4 10             	add    $0x10,%esp
f0102cdb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f0102cde:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102ce1:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102ce7:	83 ec 0c             	sub    $0xc,%esp
f0102cea:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102ced:	e8 e4 56 00 00       	call   f01083d6 <free_frame>
f0102cf2:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0102cf5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102cf8:	c1 e8 16             	shr    $0x16,%eax
f0102cfb:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f0102cfe:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102d01:	8b 40 64             	mov    0x64(%eax),%eax
f0102d04:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102d07:	c1 e2 02             	shl    $0x2,%edx
f0102d0a:	01 c2                	add    %eax,%edx
f0102d0c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102d0f:	8b 40 64             	mov    0x64(%eax),%eax
f0102d12:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0102d15:	c1 e1 02             	shl    $0x2,%ecx
f0102d18:	01 c8                	add    %ecx,%eax
f0102d1a:	8b 00                	mov    (%eax),%eax
f0102d1c:	83 e0 fe             	and    $0xfffffffe,%eax
f0102d1f:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0102d21:	0f 20 d8             	mov    %cr3,%eax
f0102d24:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0102d27:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102d2a:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0102d2d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102d32:	c9                   	leave  
f0102d33:	c3                   	ret    

f0102d34 <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0102d34:	55                   	push   %ebp
f0102d35:	89 e5                	mov    %esp,%ebp
f0102d37:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0102d3a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0102d3e:	7e 06                	jle    f0102d46 <command_allocuserpage+0x12>
f0102d40:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102d44:	7e 1a                	jle    f0102d60 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0102d46:	83 ec 0c             	sub    $0xc,%esp
f0102d49:	68 40 2b 12 f0       	push   $0xf0122b40
f0102d4e:	e8 38 e2 ff ff       	call   f0100f8b <cprintf>
f0102d53:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102d56:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d5b:	e9 46 01 00 00       	jmp    f0102ea6 <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d60:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d63:	83 c0 04             	add    $0x4,%eax
f0102d66:	8b 00                	mov    (%eax),%eax
f0102d68:	83 ec 04             	sub    $0x4,%esp
f0102d6b:	6a 0a                	push   $0xa
f0102d6d:	6a 00                	push   $0x0
f0102d6f:	50                   	push   %eax
f0102d70:	e8 ca c1 01 00       	call   f011ef3f <strtol>
f0102d75:	83 c4 10             	add    $0x10,%esp
f0102d78:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102d7b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102d82:	83 ec 04             	sub    $0x4,%esp
f0102d85:	6a 00                	push   $0x0
f0102d87:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102d8a:	50                   	push   %eax
f0102d8b:	ff 75 f0             	pushl  -0x10(%ebp)
f0102d8e:	e8 16 7f 00 00       	call   f010aca9 <envid2env>
f0102d93:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102d96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102d99:	85 c0                	test   %eax,%eax
f0102d9b:	75 0a                	jne    f0102da7 <command_allocuserpage+0x73>
f0102d9d:	b8 00 00 00 00       	mov    $0x0,%eax
f0102da2:	e9 ff 00 00 00       	jmp    f0102ea6 <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102da7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102daa:	83 c0 08             	add    $0x8,%eax
f0102dad:	8b 00                	mov    (%eax),%eax
f0102daf:	83 ec 04             	sub    $0x4,%esp
f0102db2:	6a 10                	push   $0x10
f0102db4:	6a 00                	push   $0x0
f0102db6:	50                   	push   %eax
f0102db7:	e8 83 c1 01 00       	call   f011ef3f <strtol>
f0102dbc:	83 c4 10             	add    $0x10,%esp
f0102dbf:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102dc2:	83 ec 0c             	sub    $0xc,%esp
f0102dc5:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102dc8:	50                   	push   %eax
f0102dc9:	e8 b4 54 00 00       	call   f0108282 <allocate_frame>
f0102dce:	83 c4 10             	add    $0x10,%esp
f0102dd1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102dd4:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102dd8:	75 1a                	jne    f0102df4 <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102dda:	83 ec 0c             	sub    $0xc,%esp
f0102ddd:	68 6a 2b 12 f0       	push   $0xf0122b6a
f0102de2:	e8 a4 e1 ff ff       	call   f0100f8b <cprintf>
f0102de7:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102dea:	b8 00 00 00 00       	mov    $0x0,%eax
f0102def:	e9 b2 00 00 00       	jmp    f0102ea6 <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102df4:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102df8:	75 1d                	jne    f0102e17 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102dfa:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102dfd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e00:	8b 40 64             	mov    0x64(%eax),%eax
f0102e03:	6a 06                	push   $0x6
f0102e05:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e08:	52                   	push   %edx
f0102e09:	50                   	push   %eax
f0102e0a:	e8 40 59 00 00       	call   f010874f <map_frame>
f0102e0f:	83 c4 10             	add    $0x10,%esp
f0102e12:	e9 8a 00 00 00       	jmp    f0102ea1 <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102e17:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102e1b:	0f 85 80 00 00 00    	jne    f0102ea1 <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102e21:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e24:	83 c0 0c             	add    $0xc,%eax
f0102e27:	8b 00                	mov    (%eax),%eax
f0102e29:	8a 00                	mov    (%eax),%al
f0102e2b:	3c 72                	cmp    $0x72,%al
f0102e2d:	74 0e                	je     f0102e3d <command_allocuserpage+0x109>
f0102e2f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e32:	83 c0 0c             	add    $0xc,%eax
f0102e35:	8b 00                	mov    (%eax),%eax
f0102e37:	8a 00                	mov    (%eax),%al
f0102e39:	3c 52                	cmp    $0x52,%al
f0102e3b:	75 09                	jne    f0102e46 <command_allocuserpage+0x112>
			rw = 0 ;
f0102e3d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102e44:	eb 3c                	jmp    f0102e82 <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102e46:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e49:	83 c0 0c             	add    $0xc,%eax
f0102e4c:	8b 00                	mov    (%eax),%eax
f0102e4e:	8a 00                	mov    (%eax),%al
f0102e50:	3c 77                	cmp    $0x77,%al
f0102e52:	74 0e                	je     f0102e62 <command_allocuserpage+0x12e>
f0102e54:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e57:	83 c0 0c             	add    $0xc,%eax
f0102e5a:	8b 00                	mov    (%eax),%eax
f0102e5c:	8a 00                	mov    (%eax),%al
f0102e5e:	3c 57                	cmp    $0x57,%al
f0102e60:	75 09                	jne    f0102e6b <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102e62:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102e69:	eb 17                	jmp    f0102e82 <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102e6b:	83 ec 0c             	sub    $0xc,%esp
f0102e6e:	68 84 2b 12 f0       	push   $0xf0122b84
f0102e73:	e8 13 e1 ff ff       	call   f0100f8b <cprintf>
f0102e78:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102e7b:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102e82:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102e85:	83 c8 04             	or     $0x4,%eax
f0102e88:	89 c1                	mov    %eax,%ecx
f0102e8a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102e8d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102e90:	8b 40 64             	mov    0x64(%eax),%eax
f0102e93:	51                   	push   %ecx
f0102e94:	ff 75 ec             	pushl  -0x14(%ebp)
f0102e97:	52                   	push   %edx
f0102e98:	50                   	push   %eax
f0102e99:	e8 b1 58 00 00       	call   f010874f <map_frame>
f0102e9e:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102ea1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ea6:	c9                   	leave  
f0102ea7:	c3                   	ret    

f0102ea8 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102ea8:	55                   	push   %ebp
f0102ea9:	89 e5                	mov    %esp,%ebp
f0102eab:	56                   	push   %esi
f0102eac:	53                   	push   %ebx
f0102ead:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102eb0:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102eb3:	83 ec 0c             	sub    $0xc,%esp
f0102eb6:	50                   	push   %eax
f0102eb7:	e8 75 5b 00 00       	call   f0108a31 <calculate_available_frames>
f0102ebc:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102ebf:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102ec2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102ec5:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102ec8:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102ecb:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102ece:	01 de                	add    %ebx,%esi
f0102ed0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102ed3:	01 f3                	add    %esi,%ebx
f0102ed5:	83 ec 0c             	sub    $0xc,%esp
f0102ed8:	51                   	push   %ecx
f0102ed9:	52                   	push   %edx
f0102eda:	50                   	push   %eax
f0102edb:	53                   	push   %ebx
f0102edc:	68 c8 2b 12 f0       	push   $0xf0122bc8
f0102ee1:	e8 a5 e0 ff ff       	call   f0100f8b <cprintf>
f0102ee6:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102ee9:	a1 10 cb 5e f0       	mov    0xf05ecb10,%eax
f0102eee:	83 ec 08             	sub    $0x8,%esp
f0102ef1:	50                   	push   %eax
f0102ef2:	68 20 2c 12 f0       	push   $0xf0122c20
f0102ef7:	e8 8f e0 ff ff       	call   f0100f8b <cprintf>
f0102efc:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102eff:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102f04:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102f07:	5b                   	pop    %ebx
f0102f08:	5e                   	pop    %esi
f0102f09:	5d                   	pop    %ebp
f0102f0a:	c3                   	ret    

f0102f0b <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102f0b:	55                   	push   %ebp
f0102f0c:	89 e5                	mov    %esp,%ebp
f0102f0e:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102f11:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102f18:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102f1f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102f26:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0102f2d:	8b 45 08             	mov    0x8(%ebp),%eax
f0102f30:	83 f8 04             	cmp    $0x4,%eax
f0102f33:	0f 84 94 00 00 00    	je     f0102fcd <CreateEnv+0xc2>
f0102f39:	83 f8 05             	cmp    $0x5,%eax
f0102f3c:	74 0e                	je     f0102f4c <CreateEnv+0x41>
f0102f3e:	83 f8 03             	cmp    $0x3,%eax
f0102f41:	0f 84 ec 00 00 00    	je     f0103033 <CreateEnv+0x128>
f0102f47:	e9 2f 01 00 00       	jmp    f010307b <CreateEnv+0x170>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102f4c:	83 ec 0c             	sub    $0xc,%esp
f0102f4f:	6a 02                	push   $0x2
f0102f51:	e8 08 b8 00 00       	call   f010e75e <isPageReplacmentAlgorithmLRU>
f0102f56:	83 c4 10             	add    $0x10,%esp
f0102f59:	85 c0                	test   %eax,%eax
f0102f5b:	75 1a                	jne    f0102f77 <CreateEnv+0x6c>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0102f5d:	83 ec 0c             	sub    $0xc,%esp
f0102f60:	68 5c 2c 12 f0       	push   $0xf0122c5c
f0102f65:	e8 21 e0 ff ff       	call   f0100f8b <cprintf>
f0102f6a:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0102f6d:	b8 00 00 00 00       	mov    $0x0,%eax
f0102f72:	e9 ff 01 00 00       	jmp    f0103176 <CreateEnv+0x26b>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0102f77:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f7a:	83 c0 10             	add    $0x10,%eax
f0102f7d:	8b 00                	mov    (%eax),%eax
f0102f7f:	83 ec 04             	sub    $0x4,%esp
f0102f82:	6a 0a                	push   $0xa
f0102f84:	6a 00                	push   $0x0
f0102f86:	50                   	push   %eax
f0102f87:	e8 b3 bf 01 00       	call   f011ef3f <strtol>
f0102f8c:	83 c4 10             	add    $0x10,%esp
f0102f8f:	89 45 ec             	mov    %eax,-0x14(%ebp)
			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102f92:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f95:	83 c0 0c             	add    $0xc,%eax
f0102f98:	8b 00                	mov    (%eax),%eax
f0102f9a:	83 ec 04             	sub    $0x4,%esp
f0102f9d:	6a 0a                	push   $0xa
f0102f9f:	6a 00                	push   $0x0
f0102fa1:	50                   	push   %eax
f0102fa2:	e8 98 bf 01 00       	call   f011ef3f <strtol>
f0102fa7:	83 c4 10             	add    $0x10,%esp
f0102faa:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0102fad:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fb0:	83 c0 08             	add    $0x8,%eax
f0102fb3:	8b 00                	mov    (%eax),%eax
f0102fb5:	83 ec 04             	sub    $0x4,%esp
f0102fb8:	6a 0a                	push   $0xa
f0102fba:	6a 00                	push   $0x0
f0102fbc:	50                   	push   %eax
f0102fbd:	e8 7d bf 01 00       	call   f011ef3f <strtol>
f0102fc2:	83 c4 10             	add    $0x10,%esp
f0102fc5:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0102fc8:	e9 c8 00 00 00       	jmp    f0103095 <CreateEnv+0x18a>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102fcd:	83 ec 0c             	sub    $0xc,%esp
f0102fd0:	6a 02                	push   $0x2
f0102fd2:	e8 87 b7 00 00       	call   f010e75e <isPageReplacmentAlgorithmLRU>
f0102fd7:	83 c4 10             	add    $0x10,%esp
f0102fda:	85 c0                	test   %eax,%eax
f0102fdc:	75 1d                	jne    f0102ffb <CreateEnv+0xf0>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0102fde:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fe1:	83 c0 0c             	add    $0xc,%eax
f0102fe4:	8b 00                	mov    (%eax),%eax
f0102fe6:	83 ec 04             	sub    $0x4,%esp
f0102fe9:	6a 0a                	push   $0xa
f0102feb:	6a 00                	push   $0x0
f0102fed:	50                   	push   %eax
f0102fee:	e8 4c bf 01 00       	call   f011ef3f <strtol>
f0102ff3:	83 c4 10             	add    $0x10,%esp
f0102ff6:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0102ff9:	eb 1b                	jmp    f0103016 <CreateEnv+0x10b>
			}
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0102ffb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ffe:	83 c0 0c             	add    $0xc,%eax
f0103001:	8b 00                	mov    (%eax),%eax
f0103003:	83 ec 04             	sub    $0x4,%esp
f0103006:	6a 0a                	push   $0xa
f0103008:	6a 00                	push   $0x0
f010300a:	50                   	push   %eax
f010300b:	e8 2f bf 01 00       	call   f011ef3f <strtol>
f0103010:	83 c4 10             	add    $0x10,%esp
f0103013:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103016:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103019:	83 c0 08             	add    $0x8,%eax
f010301c:	8b 00                	mov    (%eax),%eax
f010301e:	83 ec 04             	sub    $0x4,%esp
f0103021:	6a 0a                	push   $0xa
f0103023:	6a 00                	push   $0x0
f0103025:	50                   	push   %eax
f0103026:	e8 14 bf 01 00       	call   f011ef3f <strtol>
f010302b:	83 c4 10             	add    $0x10,%esp
f010302e:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103031:	eb 62                	jmp    f0103095 <CreateEnv+0x18a>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103033:	83 ec 0c             	sub    $0xc,%esp
f0103036:	6a 02                	push   $0x2
f0103038:	e8 21 b7 00 00       	call   f010e75e <isPageReplacmentAlgorithmLRU>
f010303d:	83 c4 10             	add    $0x10,%esp
f0103040:	85 c0                	test   %eax,%eax
f0103042:	74 1a                	je     f010305e <CreateEnv+0x153>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f0103044:	83 ec 0c             	sub    $0xc,%esp
f0103047:	68 08 2d 12 f0       	push   $0xf0122d08
f010304c:	e8 3a df ff ff       	call   f0100f8b <cprintf>
f0103051:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103054:	b8 00 00 00 00       	mov    $0x0,%eax
f0103059:	e9 18 01 00 00       	jmp    f0103176 <CreateEnv+0x26b>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f010305e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103061:	83 c0 08             	add    $0x8,%eax
f0103064:	8b 00                	mov    (%eax),%eax
f0103066:	83 ec 04             	sub    $0x4,%esp
f0103069:	6a 0a                	push   $0xa
f010306b:	6a 00                	push   $0x0
f010306d:	50                   	push   %eax
f010306e:	e8 cc be 01 00       	call   f011ef3f <strtol>
f0103073:	83 c4 10             	add    $0x10,%esp
f0103076:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103079:	eb 1a                	jmp    f0103095 <CreateEnv+0x18a>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f010307b:	83 ec 0c             	sub    $0xc,%esp
f010307e:	68 98 2d 12 f0       	push   $0xf0122d98
f0103083:	e8 03 df ff ff       	call   f0100f8b <cprintf>
f0103088:	83 c4 10             	add    $0x10,%esp
			return NULL;
f010308b:	b8 00 00 00 00       	mov    $0x0,%eax
f0103090:	e9 e1 00 00 00       	jmp    f0103176 <CreateEnv+0x26b>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103095:	83 ec 0c             	sub    $0xc,%esp
f0103098:	6a 02                	push   $0x2
f010309a:	e8 bf b6 00 00       	call   f010e75e <isPageReplacmentAlgorithmLRU>
f010309f:	83 c4 10             	add    $0x10,%esp
f01030a2:	85 c0                	test   %eax,%eax
f01030a4:	74 23                	je     f01030c9 <CreateEnv+0x1be>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f01030a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01030a9:	48                   	dec    %eax
f01030aa:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01030ad:	73 1a                	jae    f01030c9 <CreateEnv+0x1be>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f01030af:	83 ec 0c             	sub    $0xc,%esp
f01030b2:	68 30 2e 12 f0       	push   $0xf0122e30
f01030b7:	e8 cf de ff ff       	call   f0100f8b <cprintf>
f01030bc:	83 c4 10             	add    $0x10,%esp
				return NULL;
f01030bf:	b8 00 00 00 00       	mov    $0x0,%eax
f01030c4:	e9 ad 00 00 00       	jmp    f0103176 <CreateEnv+0x26b>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f01030c9:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f01030cd:	76 19                	jbe    f01030e8 <CreateEnv+0x1dd>
f01030cf:	68 88 2e 12 f0       	push   $0xf0122e88
f01030d4:	68 cd 2e 12 f0       	push   $0xf0122ecd
f01030d9:	68 a4 01 00 00       	push   $0x1a4
f01030de:	68 e2 2e 12 f0       	push   $0xf0122ee2
f01030e3:	e8 51 d2 ff ff       	call   f0100339 <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f01030e8:	83 7d e8 64          	cmpl   $0x64,-0x18(%ebp)
f01030ec:	76 19                	jbe    f0103107 <CreateEnv+0x1fc>
f01030ee:	68 88 2e 12 f0       	push   $0xf0122e88
f01030f3:	68 cd 2e 12 f0       	push   $0xf0122ecd
f01030f8:	68 c0 01 00 00       	push   $0x1c0
f01030fd:	68 e2 2e 12 f0       	push   $0xf0122ee2
f0103102:	e8 32 d2 ff ff       	call   f0100339 <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f0103107:	8b 45 0c             	mov    0xc(%ebp),%eax
f010310a:	83 c0 04             	add    $0x4,%eax
f010310d:	8b 00                	mov    (%eax),%eax
f010310f:	ff 75 e8             	pushl  -0x18(%ebp)
f0103112:	ff 75 f0             	pushl  -0x10(%ebp)
f0103115:	ff 75 f4             	pushl  -0xc(%ebp)
f0103118:	50                   	push   %eax
f0103119:	e8 bd 70 00 00       	call   f010a1db <env_create>
f010311e:	83 c4 10             	add    $0x10,%esp
f0103121:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (BSDSchedNiceVal != -100)
f0103124:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f0103128:	74 49                	je     f0103173 <CreateEnv+0x268>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f010312a:	83 ec 08             	sub    $0x8,%esp
f010312d:	ff 75 ec             	pushl  -0x14(%ebp)
f0103130:	68 f6 2e 12 f0       	push   $0xf0122ef6
f0103135:	e8 51 de ff ff       	call   f0100f8b <cprintf>
f010313a:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f010313d:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f0103141:	7c 06                	jl     f0103149 <CreateEnv+0x23e>
f0103143:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103147:	7e 19                	jle    f0103162 <CreateEnv+0x257>
f0103149:	68 08 2f 12 f0       	push   $0xf0122f08
f010314e:	68 cd 2e 12 f0       	push   $0xf0122ecd
f0103153:	68 c5 01 00 00       	push   $0x1c5
f0103158:	68 e2 2e 12 f0       	push   $0xf0122ee2
f010315d:	e8 d7 d1 ff ff       	call   f0100339 <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f0103162:	83 ec 08             	sub    $0x8,%esp
f0103165:	ff 75 ec             	pushl  -0x14(%ebp)
f0103168:	ff 75 e4             	pushl  -0x1c(%ebp)
f010316b:	e8 57 35 00 00       	call   f01066c7 <env_set_nice>
f0103170:	83 c4 10             	add    $0x10,%esp
	}
	return env;
f0103173:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f0103176:	c9                   	leave  
f0103177:	c3                   	ret    

f0103178 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0103178:	55                   	push   %ebp
f0103179:	89 e5                	mov    %esp,%ebp
f010317b:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f010317e:	83 ec 08             	sub    $0x8,%esp
f0103181:	ff 75 0c             	pushl  0xc(%ebp)
f0103184:	ff 75 08             	pushl  0x8(%ebp)
f0103187:	e8 7f fd ff ff       	call   f0102f0b <CreateEnv>
f010318c:	83 c4 10             	add    $0x10,%esp
f010318f:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f0103192:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103196:	75 07                	jne    f010319f <command_run_program+0x27>
f0103198:	b8 00 00 00 00       	mov    $0x0,%eax
f010319d:	eb 46                	jmp    f01031e5 <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f010319f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031a2:	8b 40 10             	mov    0x10(%eax),%eax
f01031a5:	83 ec 08             	sub    $0x8,%esp
f01031a8:	50                   	push   %eax
f01031a9:	68 38 2f 12 f0       	push   $0xf0122f38
f01031ae:	e8 d8 dd ff ff       	call   f0100f8b <cprintf>
f01031b3:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f01031b6:	83 ec 0c             	sub    $0xc,%esp
f01031b9:	ff 75 f4             	pushl  -0xc(%ebp)
f01031bc:	e8 9c 25 00 00       	call   f010575d <sched_new_env>
f01031c1:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f01031c4:	c7 05 10 cb 5e f0 00 	movl   $0x0,0xf05ecb10
f01031cb:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f01031ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031d1:	8b 40 10             	mov    0x10(%eax),%eax
f01031d4:	83 ec 0c             	sub    $0xc,%esp
f01031d7:	50                   	push   %eax
f01031d8:	e8 d6 25 00 00       	call   f01057b3 <sched_run_env>
f01031dd:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031e5:	c9                   	leave  
f01031e6:	c3                   	ret    

f01031e7 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f01031e7:	55                   	push   %ebp
f01031e8:	89 e5                	mov    %esp,%ebp
f01031ea:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f01031ed:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031f0:	83 c0 04             	add    $0x4,%eax
f01031f3:	8b 00                	mov    (%eax),%eax
f01031f5:	83 ec 04             	sub    $0x4,%esp
f01031f8:	6a 0a                	push   $0xa
f01031fa:	6a 00                	push   $0x0
f01031fc:	50                   	push   %eax
f01031fd:	e8 3d bd 01 00       	call   f011ef3f <strtol>
f0103202:	83 c4 10             	add    $0x10,%esp
f0103205:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f0103208:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010320b:	83 ec 0c             	sub    $0xc,%esp
f010320e:	50                   	push   %eax
f010320f:	e8 e5 28 00 00       	call   f0105af9 <sched_kill_env>
f0103214:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103217:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010321c:	c9                   	leave  
f010321d:	c3                   	ret    

f010321e <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f010321e:	55                   	push   %ebp
f010321f:	89 e5                	mov    %esp,%ebp
f0103221:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103224:	83 ec 08             	sub    $0x8,%esp
f0103227:	ff 75 0c             	pushl  0xc(%ebp)
f010322a:	ff 75 08             	pushl  0x8(%ebp)
f010322d:	e8 d9 fc ff ff       	call   f0102f0b <CreateEnv>
f0103232:	83 c4 10             	add    $0x10,%esp
f0103235:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103238:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010323c:	75 07                	jne    f0103245 <commnad_load_env+0x27>
		return 0 ;
f010323e:	b8 00 00 00 00       	mov    $0x0,%eax
f0103243:	eb 2a                	jmp    f010326f <commnad_load_env+0x51>

	sched_new_env(env) ;
f0103245:	83 ec 0c             	sub    $0xc,%esp
f0103248:	ff 75 f4             	pushl  -0xc(%ebp)
f010324b:	e8 0d 25 00 00       	call   f010575d <sched_new_env>
f0103250:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103256:	8b 40 10             	mov    0x10(%eax),%eax
f0103259:	83 ec 08             	sub    $0x8,%esp
f010325c:	50                   	push   %eax
f010325d:	68 38 2f 12 f0       	push   $0xf0122f38
f0103262:	e8 24 dd ff ff       	call   f0100f8b <cprintf>
f0103267:	83 c4 10             	add    $0x10,%esp
	return 0;
f010326a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010326f:	c9                   	leave  
f0103270:	c3                   	ret    

f0103271 <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f0103271:	55                   	push   %ebp
f0103272:	89 e5                	mov    %esp,%ebp
f0103274:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0103277:	c7 05 10 cb 5e f0 00 	movl   $0x0,0xf05ecb10
f010327e:	00 00 00 
	sched_run_all();
f0103281:	e8 30 2e 00 00       	call   f01060b6 <sched_run_all>

	return 0 ;
f0103286:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010328b:	c9                   	leave  
f010328c:	c3                   	ret    

f010328d <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f010328d:	55                   	push   %ebp
f010328e:	89 e5                	mov    %esp,%ebp
f0103290:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f0103293:	e8 fd 2b 00 00       	call   f0105e95 <sched_print_all>

	return 0 ;
f0103298:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010329d:	c9                   	leave  
f010329e:	c3                   	ret    

f010329f <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f010329f:	55                   	push   %ebp
f01032a0:	89 e5                	mov    %esp,%ebp
f01032a2:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f01032a5:	e8 a1 2e 00 00       	call   f010614b <sched_kill_all>

	return 0 ;
f01032aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032af:	c9                   	leave  
f01032b0:	c3                   	ret    

f01032b1 <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f01032b1:	55                   	push   %ebp
f01032b2:	89 e5                	mov    %esp,%ebp
f01032b4:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f01032b7:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01032bb:	7f 1a                	jg     f01032d7 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f01032bd:	83 ec 0c             	sub    $0xc,%esp
f01032c0:	68 50 2f 12 f0       	push   $0xf0122f50
f01032c5:	e8 c1 dc ff ff       	call   f0100f8b <cprintf>
f01032ca:	83 c4 10             	add    $0x10,%esp
		return 0;
f01032cd:	b8 00 00 00 00       	mov    $0x0,%eax
f01032d2:	e9 83 00 00 00       	jmp    f010335a <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f01032d7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032da:	83 c0 04             	add    $0x4,%eax
f01032dd:	8b 00                	mov    (%eax),%eax
f01032df:	83 ec 04             	sub    $0x4,%esp
f01032e2:	6a 0a                	push   $0xa
f01032e4:	6a 00                	push   $0x0
f01032e6:	50                   	push   %eax
f01032e7:	e8 53 bc 01 00       	call   f011ef3f <strtol>
f01032ec:	83 c4 10             	add    $0x10,%esp
f01032ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f01032f2:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01032f6:	75 20                	jne    f0103318 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f01032f8:	83 ec 0c             	sub    $0xc,%esp
f01032fb:	ff 75 f4             	pushl  -0xc(%ebp)
f01032fe:	e8 d0 b3 00 00       	call   f010e6d3 <setPageReplacmentAlgorithmLRU>
f0103303:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f0103306:	83 ec 0c             	sub    $0xc,%esp
f0103309:	68 b0 2f 12 f0       	push   $0xf0122fb0
f010330e:	e8 78 dc ff ff       	call   f0100f8b <cprintf>
f0103313:	83 c4 10             	add    $0x10,%esp
f0103316:	eb 3d                	jmp    f0103355 <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f0103318:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010331c:	75 20                	jne    f010333e <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f010331e:	83 ec 0c             	sub    $0xc,%esp
f0103321:	ff 75 f4             	pushl  -0xc(%ebp)
f0103324:	e8 aa b3 00 00       	call   f010e6d3 <setPageReplacmentAlgorithmLRU>
f0103329:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f010332c:	83 ec 0c             	sub    $0xc,%esp
f010332f:	68 f4 2f 12 f0       	push   $0xf0122ff4
f0103334:	e8 52 dc ff ff       	call   f0100f8b <cprintf>
f0103339:	83 c4 10             	add    $0x10,%esp
f010333c:	eb 17                	jmp    f0103355 <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f010333e:	83 ec 0c             	sub    $0xc,%esp
f0103341:	68 34 30 12 f0       	push   $0xf0123034
f0103346:	e8 40 dc ff ff       	call   f0100f8b <cprintf>
f010334b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010334e:	b8 00 00 00 00       	mov    $0x0,%eax
f0103353:	eb 05                	jmp    f010335a <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f0103355:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010335a:	c9                   	leave  
f010335b:	c3                   	ret    

f010335c <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f010335c:	55                   	push   %ebp
f010335d:	89 e5                	mov    %esp,%ebp
f010335f:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f0103362:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103365:	83 c0 04             	add    $0x4,%eax
f0103368:	8b 00                	mov    (%eax),%eax
f010336a:	83 ec 04             	sub    $0x4,%esp
f010336d:	6a 0a                	push   $0xa
f010336f:	6a 00                	push   $0x0
f0103371:	50                   	push   %eax
f0103372:	e8 c8 bb 01 00       	call   f011ef3f <strtol>
f0103377:	83 c4 10             	add    $0x10,%esp
f010337a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f010337d:	83 ec 0c             	sub    $0xc,%esp
f0103380:	ff 75 f4             	pushl  -0xc(%ebp)
f0103383:	e8 be b3 00 00       	call   f010e746 <setPageReplacmentAlgorithmNchanceCLOCK>
f0103388:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f010338b:	83 ec 0c             	sub    $0xc,%esp
f010338e:	68 88 30 12 f0       	push   $0xf0123088
f0103393:	e8 f3 db ff ff       	call   f0100f8b <cprintf>
f0103398:	83 c4 10             	add    $0x10,%esp
	return 0;
f010339b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033a0:	c9                   	leave  
f01033a1:	c3                   	ret    

f01033a2 <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f01033a2:	55                   	push   %ebp
f01033a3:	89 e5                	mov    %esp,%ebp
f01033a5:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f01033a8:	e8 59 b3 00 00       	call   f010e706 <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f01033ad:	83 ec 0c             	sub    $0xc,%esp
f01033b0:	68 bc 30 12 f0       	push   $0xf01230bc
f01033b5:	e8 d1 db ff ff       	call   f0100f8b <cprintf>
f01033ba:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033c2:	c9                   	leave  
f01033c3:	c3                   	ret    

f01033c4 <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f01033c4:	55                   	push   %ebp
f01033c5:	89 e5                	mov    %esp,%ebp
f01033c7:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f01033ca:	e8 47 b3 00 00       	call   f010e716 <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f01033cf:	83 ec 0c             	sub    $0xc,%esp
f01033d2:	68 e8 30 12 f0       	push   $0xf01230e8
f01033d7:	e8 af db ff ff       	call   f0100f8b <cprintf>
f01033dc:	83 c4 10             	add    $0x10,%esp
	return 0;
f01033df:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033e4:	c9                   	leave  
f01033e5:	c3                   	ret    

f01033e6 <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f01033e6:	55                   	push   %ebp
f01033e7:	89 e5                	mov    %esp,%ebp
f01033e9:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f01033ec:	e8 35 b3 00 00       	call   f010e726 <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f01033f1:	83 ec 0c             	sub    $0xc,%esp
f01033f4:	68 10 31 12 f0       	push   $0xf0123110
f01033f9:	e8 8d db ff ff       	call   f0100f8b <cprintf>
f01033fe:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103401:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103406:	c9                   	leave  
f0103407:	c3                   	ret    

f0103408 <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f0103408:	55                   	push   %ebp
f0103409:	89 e5                	mov    %esp,%ebp
f010340b:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f010340e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103411:	83 c0 04             	add    $0x4,%eax
f0103414:	8b 00                	mov    (%eax),%eax
f0103416:	83 ec 04             	sub    $0x4,%esp
f0103419:	6a 0a                	push   $0xa
f010341b:	6a 00                	push   $0x0
f010341d:	50                   	push   %eax
f010341e:	e8 1c bb 01 00       	call   f011ef3f <strtol>
f0103423:	83 c4 10             	add    $0x10,%esp
f0103426:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f0103429:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f010342d:	83 ec 0c             	sub    $0xc,%esp
f0103430:	50                   	push   %eax
f0103431:	e8 a9 35 00 00       	call   f01069df <sched_init_RR>
f0103436:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f0103439:	a1 24 c8 5e f0       	mov    0xf05ec824,%eax
f010343e:	8a 00                	mov    (%eax),%al
f0103440:	0f b6 c0             	movzbl %al,%eax
f0103443:	83 ec 08             	sub    $0x8,%esp
f0103446:	50                   	push   %eax
f0103447:	68 44 31 12 f0       	push   $0xf0123144
f010344c:	e8 3a db ff ff       	call   f0100f8b <cprintf>
f0103451:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103454:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103459:	c9                   	leave  
f010345a:	c3                   	ret    

f010345b <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f010345b:	55                   	push   %ebp
f010345c:	89 e5                	mov    %esp,%ebp
f010345e:	53                   	push   %ebx
f010345f:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0103462:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103465:	83 c0 04             	add    $0x4,%eax
f0103468:	8b 00                	mov    (%eax),%eax
f010346a:	83 ec 04             	sub    $0x4,%esp
f010346d:	6a 0a                	push   $0xa
f010346f:	6a 00                	push   $0x0
f0103471:	50                   	push   %eax
f0103472:	e8 c8 ba 01 00       	call   f011ef3f <strtol>
f0103477:	83 c4 10             	add    $0x10,%esp
f010347a:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f010347d:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0103484:	eb 2e                	jmp    f01034b4 <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f0103486:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103489:	8d 58 fe             	lea    -0x2(%eax),%ebx
f010348c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010348f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103496:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103499:	01 d0                	add    %edx,%eax
f010349b:	8b 00                	mov    (%eax),%eax
f010349d:	83 ec 04             	sub    $0x4,%esp
f01034a0:	6a 0a                	push   $0xa
f01034a2:	6a 00                	push   $0x0
f01034a4:	50                   	push   %eax
f01034a5:	e8 95 ba 01 00       	call   f011ef3f <strtol>
f01034aa:	83 c4 10             	add    $0x10,%esp
f01034ad:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f01034b1:	ff 45 f4             	incl   -0xc(%ebp)
f01034b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01034b7:	3b 45 08             	cmp    0x8(%ebp),%eax
f01034ba:	7c ca                	jl     f0103486 <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f01034bc:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f01034c0:	83 ec 08             	sub    $0x8,%esp
f01034c3:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f01034c6:	52                   	push   %edx
f01034c7:	50                   	push   %eax
f01034c8:	e8 c0 35 00 00       	call   f0106a8d <sched_init_MLFQ>
f01034cd:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f01034d0:	83 ec 0c             	sub    $0xc,%esp
f01034d3:	68 7c 31 12 f0       	push   $0xf012317c
f01034d8:	e8 ae da ff ff       	call   f0100f8b <cprintf>
f01034dd:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01034e0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01034e7:	eb 24                	jmp    f010350d <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f01034e9:	8b 15 24 c8 5e f0    	mov    0xf05ec824,%edx
f01034ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01034f2:	01 d0                	add    %edx,%eax
f01034f4:	8a 00                	mov    (%eax),%al
f01034f6:	0f b6 c0             	movzbl %al,%eax
f01034f9:	83 ec 08             	sub    $0x8,%esp
f01034fc:	50                   	push   %eax
f01034fd:	68 a9 31 12 f0       	push   $0xf01231a9
f0103502:	e8 84 da ff ff       	call   f0100f8b <cprintf>
f0103507:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f010350a:	ff 45 f0             	incl   -0x10(%ebp)
f010350d:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f0103512:	0f b6 c0             	movzbl %al,%eax
f0103515:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103518:	7f cf                	jg     f01034e9 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f010351a:	83 ec 0c             	sub    $0xc,%esp
f010351d:	68 2d 2b 12 f0       	push   $0xf0122b2d
f0103522:	e8 64 da ff ff       	call   f0100f8b <cprintf>
f0103527:	83 c4 10             	add    $0x10,%esp
	return 0;
f010352a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010352f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103532:	c9                   	leave  
f0103533:	c3                   	ret    

f0103534 <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f0103534:	55                   	push   %ebp
f0103535:	89 e5                	mov    %esp,%ebp
f0103537:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010353a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010353d:	83 c0 04             	add    $0x4,%eax
f0103540:	8b 00                	mov    (%eax),%eax
f0103542:	83 ec 04             	sub    $0x4,%esp
f0103545:	6a 0a                	push   $0xa
f0103547:	6a 00                	push   $0x0
f0103549:	50                   	push   %eax
f010354a:	e8 f0 b9 01 00       	call   f011ef3f <strtol>
f010354f:	83 c4 10             	add    $0x10,%esp
f0103552:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f0103555:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103558:	83 c0 08             	add    $0x8,%eax
f010355b:	8b 00                	mov    (%eax),%eax
f010355d:	83 ec 04             	sub    $0x4,%esp
f0103560:	6a 0a                	push   $0xa
f0103562:	6a 00                	push   $0x0
f0103564:	50                   	push   %eax
f0103565:	e8 d5 b9 01 00       	call   f011ef3f <strtol>
f010356a:	83 c4 10             	add    $0x10,%esp
f010356d:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f0103570:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103574:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0103578:	83 ec 08             	sub    $0x8,%esp
f010357b:	52                   	push   %edx
f010357c:	50                   	push   %eax
f010357d:	e8 33 35 00 00       	call   f0106ab5 <sched_init_BSD>
f0103582:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f0103585:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0103589:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f010358d:	83 ec 04             	sub    $0x4,%esp
f0103590:	52                   	push   %edx
f0103591:	50                   	push   %eax
f0103592:	68 b0 31 12 f0       	push   $0xf01231b0
f0103597:	e8 ef d9 ff ff       	call   f0100f8b <cprintf>
f010359c:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010359f:	83 ec 0c             	sub    $0xc,%esp
f01035a2:	68 2d 2b 12 f0       	push   $0xf0122b2d
f01035a7:	e8 df d9 ff ff       	call   f0100f8b <cprintf>
f01035ac:	83 c4 10             	add    $0x10,%esp
	return 0;
f01035af:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01035b4:	c9                   	leave  
f01035b5:	c3                   	ret    

f01035b6 <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f01035b6:	55                   	push   %ebp
f01035b7:	89 e5                	mov    %esp,%ebp
f01035b9:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f01035bc:	e8 77 31 00 00       	call   f0106738 <isSchedMethodMLFQ>
f01035c1:	85 c0                	test   %eax,%eax
f01035c3:	74 5c                	je     f0103621 <command_print_sch_method+0x6b>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f01035c5:	83 ec 0c             	sub    $0xc,%esp
f01035c8:	68 ec 31 12 f0       	push   $0xf01231ec
f01035cd:	e8 b9 d9 ff ff       	call   f0100f8b <cprintf>
f01035d2:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f01035d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01035dc:	eb 24                	jmp    f0103602 <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f01035de:	8b 15 24 c8 5e f0    	mov    0xf05ec824,%edx
f01035e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01035e7:	01 d0                	add    %edx,%eax
f01035e9:	8a 00                	mov    (%eax),%al
f01035eb:	0f b6 c0             	movzbl %al,%eax
f01035ee:	83 ec 08             	sub    $0x8,%esp
f01035f1:	50                   	push   %eax
f01035f2:	68 a9 31 12 f0       	push   $0xf01231a9
f01035f7:	e8 8f d9 ff ff       	call   f0100f8b <cprintf>
f01035fc:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f01035ff:	ff 45 f4             	incl   -0xc(%ebp)
f0103602:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f0103607:	0f b6 c0             	movzbl %al,%eax
f010360a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010360d:	7f cf                	jg     f01035de <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f010360f:	83 ec 0c             	sub    $0xc,%esp
f0103612:	68 2d 2b 12 f0       	push   $0xf0122b2d
f0103617:	e8 6f d9 ff ff       	call   f0100f8b <cprintf>
f010361c:	83 c4 10             	add    $0x10,%esp
f010361f:	eb 65                	jmp    f0103686 <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodRR())
f0103621:	e8 f8 30 00 00       	call   f010671e <isSchedMethodRR>
f0103626:	85 c0                	test   %eax,%eax
f0103628:	74 1d                	je     f0103647 <command_print_sch_method+0x91>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f010362a:	a1 24 c8 5e f0       	mov    0xf05ec824,%eax
f010362f:	8a 00                	mov    (%eax),%al
f0103631:	0f b6 c0             	movzbl %al,%eax
f0103634:	83 ec 08             	sub    $0x8,%esp
f0103637:	50                   	push   %eax
f0103638:	68 20 32 12 f0       	push   $0xf0123220
f010363d:	e8 49 d9 ff ff       	call   f0100f8b <cprintf>
f0103642:	83 c4 10             	add    $0x10,%esp
f0103645:	eb 3f                	jmp    f0103686 <command_print_sch_method+0xd0>
	}
	else if (isSchedMethodBSD())
f0103647:	e8 07 31 00 00       	call   f0106753 <isSchedMethodBSD>
f010364c:	85 c0                	test   %eax,%eax
f010364e:	74 26                	je     f0103676 <command_print_sch_method+0xc0>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103650:	a1 24 c8 5e f0       	mov    0xf05ec824,%eax
f0103655:	8a 00                	mov    (%eax),%al
f0103657:	0f b6 d0             	movzbl %al,%edx
f010365a:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f010365f:	0f b6 c0             	movzbl %al,%eax
f0103662:	83 ec 04             	sub    $0x4,%esp
f0103665:	52                   	push   %edx
f0103666:	50                   	push   %eax
f0103667:	68 b0 31 12 f0       	push   $0xf01231b0
f010366c:	e8 1a d9 ff ff       	call   f0100f8b <cprintf>
f0103671:	83 c4 10             	add    $0x10,%esp
f0103674:	eb 10                	jmp    f0103686 <command_print_sch_method+0xd0>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f0103676:	83 ec 0c             	sub    $0xc,%esp
f0103679:	68 5c 32 12 f0       	push   $0xf012325c
f010367e:	e8 08 d9 ff ff       	call   f0100f8b <cprintf>
f0103683:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103686:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010368b:	c9                   	leave  
f010368c:	c3                   	ret    

f010368d <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f010368d:	55                   	push   %ebp
f010368e:	89 e5                	mov    %esp,%ebp
f0103690:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f0103693:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103696:	83 c0 04             	add    $0x4,%eax
f0103699:	8b 00                	mov    (%eax),%eax
f010369b:	83 ec 04             	sub    $0x4,%esp
f010369e:	6a 0a                	push   $0xa
f01036a0:	6a 00                	push   $0x0
f01036a2:	50                   	push   %eax
f01036a3:	e8 97 b8 01 00       	call   f011ef3f <strtol>
f01036a8:	83 c4 10             	add    $0x10,%esp
f01036ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f01036ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01036b1:	0f b6 c0             	movzbl %al,%eax
f01036b4:	83 ec 0c             	sub    $0xc,%esp
f01036b7:	50                   	push   %eax
f01036b8:	e8 76 a6 01 00       	call   f011dd33 <chksch>
f01036bd:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f01036c0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01036c4:	75 12                	jne    f01036d8 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f01036c6:	83 ec 0c             	sub    $0xc,%esp
f01036c9:	68 84 32 12 f0       	push   $0xf0123284
f01036ce:	e8 b8 d8 ff ff       	call   f0100f8b <cprintf>
f01036d3:	83 c4 10             	add    $0x10,%esp
f01036d6:	eb 16                	jmp    f01036ee <command_sch_test+0x61>
	else if (status == 1)
f01036d8:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f01036dc:	75 10                	jne    f01036ee <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f01036de:	83 ec 0c             	sub    $0xc,%esp
f01036e1:	68 ac 32 12 f0       	push   $0xf01232ac
f01036e6:	e8 a0 d8 ff ff       	call   f0100f8b <cprintf>
f01036eb:	83 c4 10             	add    $0x10,%esp
	return 0;
f01036ee:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036f3:	c9                   	leave  
f01036f4:	c3                   	ret    

f01036f5 <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f01036f5:	55                   	push   %ebp
f01036f6:	89 e5                	mov    %esp,%ebp
f01036f8:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f01036fb:	e8 74 b0 00 00       	call   f010e774 <isPageReplacmentAlgorithmCLOCK>
f0103700:	85 c0                	test   %eax,%eax
f0103702:	74 15                	je     f0103719 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f0103704:	83 ec 0c             	sub    $0xc,%esp
f0103707:	68 d0 32 12 f0       	push   $0xf01232d0
f010370c:	e8 7a d8 ff ff       	call   f0100f8b <cprintf>
f0103711:	83 c4 10             	add    $0x10,%esp
f0103714:	e9 8c 00 00 00       	jmp    f01037a5 <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0103719:	83 ec 0c             	sub    $0xc,%esp
f010371c:	6a 01                	push   $0x1
f010371e:	e8 3b b0 00 00       	call   f010e75e <isPageReplacmentAlgorithmLRU>
f0103723:	83 c4 10             	add    $0x10,%esp
f0103726:	85 c0                	test   %eax,%eax
f0103728:	74 12                	je     f010373c <command_print_page_rep+0x47>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f010372a:	83 ec 0c             	sub    $0xc,%esp
f010372d:	68 f8 32 12 f0       	push   $0xf01232f8
f0103732:	e8 54 d8 ff ff       	call   f0100f8b <cprintf>
f0103737:	83 c4 10             	add    $0x10,%esp
f010373a:	eb 69                	jmp    f01037a5 <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010373c:	83 ec 0c             	sub    $0xc,%esp
f010373f:	6a 02                	push   $0x2
f0103741:	e8 18 b0 00 00       	call   f010e75e <isPageReplacmentAlgorithmLRU>
f0103746:	83 c4 10             	add    $0x10,%esp
f0103749:	85 c0                	test   %eax,%eax
f010374b:	74 12                	je     f010375f <command_print_page_rep+0x6a>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f010374d:	83 ec 0c             	sub    $0xc,%esp
f0103750:	68 38 33 12 f0       	push   $0xf0123338
f0103755:	e8 31 d8 ff ff       	call   f0100f8b <cprintf>
f010375a:	83 c4 10             	add    $0x10,%esp
f010375d:	eb 46                	jmp    f01037a5 <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmFIFO())
f010375f:	e8 2b b0 00 00       	call   f010e78f <isPageReplacmentAlgorithmFIFO>
f0103764:	85 c0                	test   %eax,%eax
f0103766:	74 12                	je     f010377a <command_print_page_rep+0x85>
		cprintf("Page replacement algorithm is FIFO\n");
f0103768:	83 ec 0c             	sub    $0xc,%esp
f010376b:	68 74 33 12 f0       	push   $0xf0123374
f0103770:	e8 16 d8 ff ff       	call   f0100f8b <cprintf>
f0103775:	83 c4 10             	add    $0x10,%esp
f0103778:	eb 2b                	jmp    f01037a5 <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f010377a:	e8 2b b0 00 00       	call   f010e7aa <isPageReplacmentAlgorithmModifiedCLOCK>
f010377f:	85 c0                	test   %eax,%eax
f0103781:	74 12                	je     f0103795 <command_print_page_rep+0xa0>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f0103783:	83 ec 0c             	sub    $0xc,%esp
f0103786:	68 98 33 12 f0       	push   $0xf0123398
f010378b:	e8 fb d7 ff ff       	call   f0100f8b <cprintf>
f0103790:	83 c4 10             	add    $0x10,%esp
f0103793:	eb 10                	jmp    f01037a5 <command_print_page_rep+0xb0>
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f0103795:	83 ec 0c             	sub    $0xc,%esp
f0103798:	68 c8 33 12 f0       	push   $0xf01233c8
f010379d:	e8 e9 d7 ff ff       	call   f0100f8b <cprintf>
f01037a2:	83 c4 10             	add    $0x10,%esp

	return 0;
f01037a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037aa:	c9                   	leave  
f01037ab:	c3                   	ret    

f01037ac <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01037ac:	55                   	push   %ebp
f01037ad:	89 e5                	mov    %esp,%ebp
f01037af:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f01037b2:	e8 23 ee ff ff       	call   f01025da <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f01037b7:	83 ec 0c             	sub    $0xc,%esp
f01037ba:	68 f4 33 12 f0       	push   $0xf01233f4
f01037bf:	e8 c7 d7 ff ff       	call   f0100f8b <cprintf>
f01037c4:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037c7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037cc:	c9                   	leave  
f01037cd:	c3                   	ret    

f01037ce <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f01037ce:	55                   	push   %ebp
f01037cf:	89 e5                	mov    %esp,%ebp
f01037d1:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f01037d4:	e8 11 ee ff ff       	call   f01025ea <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f01037d9:	83 ec 0c             	sub    $0xc,%esp
f01037dc:	68 24 34 12 f0       	push   $0xf0123424
f01037e1:	e8 a5 d7 ff ff       	call   f0100f8b <cprintf>
f01037e6:	83 c4 10             	add    $0x10,%esp
	return 0;
f01037e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01037ee:	c9                   	leave  
f01037ef:	c3                   	ret    

f01037f0 <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01037f0:	55                   	push   %ebp
f01037f1:	89 e5                	mov    %esp,%ebp
f01037f3:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f01037f6:	e8 ff ed ff ff       	call   f01025fa <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01037fb:	83 ec 0c             	sub    $0xc,%esp
f01037fe:	68 54 34 12 f0       	push   $0xf0123454
f0103803:	e8 83 d7 ff ff       	call   f0100f8b <cprintf>
f0103808:	83 c4 10             	add    $0x10,%esp
	return 0;
f010380b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103810:	c9                   	leave  
f0103811:	c3                   	ret    

f0103812 <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f0103812:	55                   	push   %ebp
f0103813:	89 e5                	mov    %esp,%ebp
f0103815:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f0103818:	e8 ed ed ff ff       	call   f010260a <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f010381d:	83 ec 0c             	sub    $0xc,%esp
f0103820:	68 84 34 12 f0       	push   $0xf0123484
f0103825:	e8 61 d7 ff ff       	call   f0100f8b <cprintf>
f010382a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010382d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103832:	c9                   	leave  
f0103833:	c3                   	ret    

f0103834 <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f0103834:	55                   	push   %ebp
f0103835:	89 e5                	mov    %esp,%ebp
f0103837:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f010383a:	e8 db ed ff ff       	call   f010261a <isUHeapPlacementStrategyFIRSTFIT>
f010383f:	84 c0                	test   %al,%al
f0103841:	74 12                	je     f0103855 <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f0103843:	83 ec 0c             	sub    $0xc,%esp
f0103846:	68 b4 34 12 f0       	push   $0xf01234b4
f010384b:	e8 3b d7 ff ff       	call   f0100f8b <cprintf>
f0103850:	83 c4 10             	add    $0x10,%esp
f0103853:	eb 61                	jmp    f01038b6 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f0103855:	e8 d5 ed ff ff       	call   f010262f <isUHeapPlacementStrategyBESTFIT>
f010385a:	84 c0                	test   %al,%al
f010385c:	74 12                	je     f0103870 <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f010385e:	83 ec 0c             	sub    $0xc,%esp
f0103861:	68 e0 34 12 f0       	push   $0xf01234e0
f0103866:	e8 20 d7 ff ff       	call   f0100f8b <cprintf>
f010386b:	83 c4 10             	add    $0x10,%esp
f010386e:	eb 46                	jmp    f01038b6 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f0103870:	e8 cf ed ff ff       	call   f0102644 <isUHeapPlacementStrategyNEXTFIT>
f0103875:	84 c0                	test   %al,%al
f0103877:	74 12                	je     f010388b <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0103879:	83 ec 0c             	sub    $0xc,%esp
f010387c:	68 0c 35 12 f0       	push   $0xf012350c
f0103881:	e8 05 d7 ff ff       	call   f0100f8b <cprintf>
f0103886:	83 c4 10             	add    $0x10,%esp
f0103889:	eb 2b                	jmp    f01038b6 <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f010388b:	e8 c9 ed ff ff       	call   f0102659 <isUHeapPlacementStrategyWORSTFIT>
f0103890:	84 c0                	test   %al,%al
f0103892:	74 12                	je     f01038a6 <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f0103894:	83 ec 0c             	sub    $0xc,%esp
f0103897:	68 38 35 12 f0       	push   $0xf0123538
f010389c:	e8 ea d6 ff ff       	call   f0100f8b <cprintf>
f01038a1:	83 c4 10             	add    $0x10,%esp
f01038a4:	eb 10                	jmp    f01038b6 <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f01038a6:	83 ec 0c             	sub    $0xc,%esp
f01038a9:	68 64 35 12 f0       	push   $0xf0123564
f01038ae:	e8 d8 d6 ff ff       	call   f0100f8b <cprintf>
f01038b3:	83 c4 10             	add    $0x10,%esp

	return 0;
f01038b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038bb:	c9                   	leave  
f01038bc:	c3                   	ret    

f01038bd <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f01038bd:	55                   	push   %ebp
f01038be:	89 e5                	mov    %esp,%ebp
f01038c0:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f01038c3:	e8 5a ec ff ff       	call   f0102522 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01038c8:	83 ec 0c             	sub    $0xc,%esp
f01038cb:	68 90 35 12 f0       	push   $0xf0123590
f01038d0:	e8 b6 d6 ff ff       	call   f0100f8b <cprintf>
f01038d5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038d8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038dd:	c9                   	leave  
f01038de:	c3                   	ret    

f01038df <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01038df:	55                   	push   %ebp
f01038e0:	89 e5                	mov    %esp,%ebp
f01038e2:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f01038e5:	e8 48 ec ff ff       	call   f0102532 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01038ea:	83 ec 0c             	sub    $0xc,%esp
f01038ed:	68 90 35 12 f0       	push   $0xf0123590
f01038f2:	e8 94 d6 ff ff       	call   f0100f8b <cprintf>
f01038f7:	83 c4 10             	add    $0x10,%esp
	return 0;
f01038fa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01038ff:	c9                   	leave  
f0103900:	c3                   	ret    

f0103901 <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103901:	55                   	push   %ebp
f0103902:	89 e5                	mov    %esp,%ebp
f0103904:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f0103907:	e8 36 ec ff ff       	call   f0102542 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f010390c:	83 ec 0c             	sub    $0xc,%esp
f010390f:	68 c4 35 12 f0       	push   $0xf01235c4
f0103914:	e8 72 d6 ff ff       	call   f0100f8b <cprintf>
f0103919:	83 c4 10             	add    $0x10,%esp
	return 0;
f010391c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103921:	c9                   	leave  
f0103922:	c3                   	ret    

f0103923 <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f0103923:	55                   	push   %ebp
f0103924:	89 e5                	mov    %esp,%ebp
f0103926:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f0103929:	e8 24 ec ff ff       	call   f0102552 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f010392e:	83 ec 0c             	sub    $0xc,%esp
f0103931:	68 f4 35 12 f0       	push   $0xf01235f4
f0103936:	e8 50 d6 ff ff       	call   f0100f8b <cprintf>
f010393b:	83 c4 10             	add    $0x10,%esp
	return 0;
f010393e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103943:	c9                   	leave  
f0103944:	c3                   	ret    

f0103945 <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f0103945:	55                   	push   %ebp
f0103946:	89 e5                	mov    %esp,%ebp
f0103948:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f010394b:	e8 12 ec ff ff       	call   f0102562 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103950:	83 ec 0c             	sub    $0xc,%esp
f0103953:	68 24 36 12 f0       	push   $0xf0123624
f0103958:	e8 2e d6 ff ff       	call   f0100f8b <cprintf>
f010395d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103960:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103965:	c9                   	leave  
f0103966:	c3                   	ret    

f0103967 <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f0103967:	55                   	push   %ebp
f0103968:	89 e5                	mov    %esp,%ebp
f010396a:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f010396d:	e8 00 ec ff ff       	call   f0102572 <isKHeapPlacementStrategyCONTALLOC>
f0103972:	84 c0                	test   %al,%al
f0103974:	74 12                	je     f0103988 <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f0103976:	83 ec 0c             	sub    $0xc,%esp
f0103979:	68 58 36 12 f0       	push   $0xf0123658
f010397e:	e8 08 d6 ff ff       	call   f0100f8b <cprintf>
f0103983:	83 c4 10             	add    $0x10,%esp
f0103986:	eb 7c                	jmp    f0103a04 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f0103988:	e8 f9 eb ff ff       	call   f0102586 <isKHeapPlacementStrategyFIRSTFIT>
f010398d:	84 c0                	test   %al,%al
f010398f:	74 12                	je     f01039a3 <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0103991:	83 ec 0c             	sub    $0xc,%esp
f0103994:	68 94 36 12 f0       	push   $0xf0123694
f0103999:	e8 ed d5 ff ff       	call   f0100f8b <cprintf>
f010399e:	83 c4 10             	add    $0x10,%esp
f01039a1:	eb 61                	jmp    f0103a04 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f01039a3:	e8 f3 eb ff ff       	call   f010259b <isKHeapPlacementStrategyBESTFIT>
f01039a8:	84 c0                	test   %al,%al
f01039aa:	74 12                	je     f01039be <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f01039ac:	83 ec 0c             	sub    $0xc,%esp
f01039af:	68 c4 36 12 f0       	push   $0xf01236c4
f01039b4:	e8 d2 d5 ff ff       	call   f0100f8b <cprintf>
f01039b9:	83 c4 10             	add    $0x10,%esp
f01039bc:	eb 46                	jmp    f0103a04 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f01039be:	e8 ed eb ff ff       	call   f01025b0 <isKHeapPlacementStrategyNEXTFIT>
f01039c3:	84 c0                	test   %al,%al
f01039c5:	74 12                	je     f01039d9 <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f01039c7:	83 ec 0c             	sub    $0xc,%esp
f01039ca:	68 f0 36 12 f0       	push   $0xf01236f0
f01039cf:	e8 b7 d5 ff ff       	call   f0100f8b <cprintf>
f01039d4:	83 c4 10             	add    $0x10,%esp
f01039d7:	eb 2b                	jmp    f0103a04 <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f01039d9:	e8 e7 eb ff ff       	call   f01025c5 <isKHeapPlacementStrategyWORSTFIT>
f01039de:	84 c0                	test   %al,%al
f01039e0:	74 12                	je     f01039f4 <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f01039e2:	83 ec 0c             	sub    $0xc,%esp
f01039e5:	68 1c 37 12 f0       	push   $0xf012371c
f01039ea:	e8 9c d5 ff ff       	call   f0100f8b <cprintf>
f01039ef:	83 c4 10             	add    $0x10,%esp
f01039f2:	eb 10                	jmp    f0103a04 <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f01039f4:	83 ec 0c             	sub    $0xc,%esp
f01039f7:	68 4c 37 12 f0       	push   $0xf012374c
f01039fc:	e8 8a d5 ff ff       	call   f0100f8b <cprintf>
f0103a01:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103a04:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a09:	c9                   	leave  
f0103a0a:	c3                   	ret    

f0103a0b <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103a0b:	55                   	push   %ebp
f0103a0c:	89 e5                	mov    %esp,%ebp
f0103a0e:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103a11:	e8 0b ae 00 00       	call   f010e821 <isBufferingEnabled>
f0103a16:	84 c0                	test   %al,%al
f0103a18:	75 12                	jne    f0103a2c <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103a1a:	83 ec 0c             	sub    $0xc,%esp
f0103a1d:	68 7c 37 12 f0       	push   $0xf012377c
f0103a22:	e8 64 d5 ff ff       	call   f0100f8b <cprintf>
f0103a27:	83 c4 10             	add    $0x10,%esp
f0103a2a:	eb 1d                	jmp    f0103a49 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f0103a2c:	83 ec 0c             	sub    $0xc,%esp
f0103a2f:	6a 00                	push   $0x0
f0103a31:	e8 c5 ad 00 00       	call   f010e7fb <enableModifiedBuffer>
f0103a36:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0103a39:	83 ec 0c             	sub    $0xc,%esp
f0103a3c:	68 b8 37 12 f0       	push   $0xf01237b8
f0103a41:	e8 45 d5 ff ff       	call   f0100f8b <cprintf>
f0103a46:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a49:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a4e:	c9                   	leave  
f0103a4f:	c3                   	ret    

f0103a50 <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103a50:	55                   	push   %ebp
f0103a51:	89 e5                	mov    %esp,%ebp
f0103a53:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103a56:	e8 c6 ad 00 00       	call   f010e821 <isBufferingEnabled>
f0103a5b:	84 c0                	test   %al,%al
f0103a5d:	75 12                	jne    f0103a71 <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103a5f:	83 ec 0c             	sub    $0xc,%esp
f0103a62:	68 7c 37 12 f0       	push   $0xf012377c
f0103a67:	e8 1f d5 ff ff       	call   f0100f8b <cprintf>
f0103a6c:	83 c4 10             	add    $0x10,%esp
f0103a6f:	eb 1d                	jmp    f0103a8e <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0103a71:	83 ec 0c             	sub    $0xc,%esp
f0103a74:	6a 01                	push   $0x1
f0103a76:	e8 80 ad 00 00       	call   f010e7fb <enableModifiedBuffer>
f0103a7b:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0103a7e:	83 ec 0c             	sub    $0xc,%esp
f0103a81:	68 dc 37 12 f0       	push   $0xf01237dc
f0103a86:	e8 00 d5 ff ff       	call   f0100f8b <cprintf>
f0103a8b:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a93:	c9                   	leave  
f0103a94:	c3                   	ret    

f0103a95 <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0103a95:	55                   	push   %ebp
f0103a96:	89 e5                	mov    %esp,%ebp
f0103a98:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0103a9b:	83 ec 0c             	sub    $0xc,%esp
f0103a9e:	6a 00                	push   $0x0
f0103aa0:	e8 6e ad 00 00       	call   f010e813 <enableBuffering>
f0103aa5:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0103aa8:	83 ec 0c             	sub    $0xc,%esp
f0103aab:	6a 00                	push   $0x0
f0103aad:	e8 49 ad 00 00       	call   f010e7fb <enableModifiedBuffer>
f0103ab2:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0103ab5:	83 ec 0c             	sub    $0xc,%esp
f0103ab8:	68 fc 37 12 f0       	push   $0xf01237fc
f0103abd:	e8 c9 d4 ff ff       	call   f0100f8b <cprintf>
f0103ac2:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103ac5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103aca:	c9                   	leave  
f0103acb:	c3                   	ret    

f0103acc <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103acc:	55                   	push   %ebp
f0103acd:	89 e5                	mov    %esp,%ebp
f0103acf:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103ad2:	83 ec 0c             	sub    $0xc,%esp
f0103ad5:	6a 01                	push   $0x1
f0103ad7:	e8 37 ad 00 00       	call   f010e813 <enableBuffering>
f0103adc:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103adf:	83 ec 0c             	sub    $0xc,%esp
f0103ae2:	6a 01                	push   $0x1
f0103ae4:	e8 12 ad 00 00       	call   f010e7fb <enableModifiedBuffer>
f0103ae9:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103aec:	e8 48 ad 00 00       	call   f010e839 <getModifiedBufferLength>
f0103af1:	85 c0                	test   %eax,%eax
f0103af3:	75 59                	jne    f0103b4e <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0103af5:	83 ec 0c             	sub    $0xc,%esp
f0103af8:	68 18 38 12 f0       	push   $0xf0123818
f0103afd:	e8 89 d4 ff ff       	call   f0100f8b <cprintf>
f0103b02:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0103b05:	83 ec 08             	sub    $0x8,%esp
f0103b08:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103b0b:	50                   	push   %eax
f0103b0c:	68 48 38 12 f0       	push   $0xf0123848
f0103b11:	e8 c1 ae 01 00       	call   f011e9d7 <readline>
f0103b16:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0103b19:	83 ec 04             	sub    $0x4,%esp
f0103b1c:	6a 0a                	push   $0xa
f0103b1e:	6a 00                	push   $0x0
f0103b20:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103b23:	50                   	push   %eax
f0103b24:	e8 16 b4 01 00       	call   f011ef3f <strtol>
f0103b29:	83 c4 10             	add    $0x10,%esp
f0103b2c:	83 ec 0c             	sub    $0xc,%esp
f0103b2f:	50                   	push   %eax
f0103b30:	e8 f6 ac 00 00       	call   f010e82b <setModifiedBufferLength>
f0103b35:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103b38:	e8 fc ac 00 00       	call   f010e839 <getModifiedBufferLength>
f0103b3d:	83 ec 08             	sub    $0x8,%esp
f0103b40:	50                   	push   %eax
f0103b41:	68 74 38 12 f0       	push   $0xf0123874
f0103b46:	e8 40 d4 ff ff       	call   f0100f8b <cprintf>
f0103b4b:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103b4e:	83 ec 0c             	sub    $0xc,%esp
f0103b51:	68 99 38 12 f0       	push   $0xf0123899
f0103b56:	e8 30 d4 ff ff       	call   f0100f8b <cprintf>
f0103b5b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103b5e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b63:	c9                   	leave  
f0103b64:	c3                   	ret    

f0103b65 <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103b65:	55                   	push   %ebp
f0103b66:	89 e5                	mov    %esp,%ebp
f0103b68:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103b6b:	e8 b1 ac 00 00       	call   f010e821 <isBufferingEnabled>
f0103b70:	84 c0                	test   %al,%al
f0103b72:	75 12                	jne    f0103b86 <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103b74:	83 ec 0c             	sub    $0xc,%esp
f0103b77:	68 b4 38 12 f0       	push   $0xf01238b4
f0103b7c:	e8 0a d4 ff ff       	call   f0100f8b <cprintf>
f0103b81:	83 c4 10             	add    $0x10,%esp
f0103b84:	eb 19                	jmp    f0103b9f <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103b86:	e8 7e ac 00 00       	call   f010e809 <isModifiedBufferEnabled>
f0103b8b:	84 c0                	test   %al,%al
f0103b8d:	75 10                	jne    f0103b9f <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103b8f:	83 ec 0c             	sub    $0xc,%esp
f0103b92:	68 04 39 12 f0       	push   $0xf0123904
f0103b97:	e8 ef d3 ff ff       	call   f0100f8b <cprintf>
f0103b9c:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0103b9f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103ba2:	83 c0 04             	add    $0x4,%eax
f0103ba5:	8b 00                	mov    (%eax),%eax
f0103ba7:	83 ec 04             	sub    $0x4,%esp
f0103baa:	6a 0a                	push   $0xa
f0103bac:	6a 00                	push   $0x0
f0103bae:	50                   	push   %eax
f0103baf:	e8 8b b3 01 00       	call   f011ef3f <strtol>
f0103bb4:	83 c4 10             	add    $0x10,%esp
f0103bb7:	83 ec 0c             	sub    $0xc,%esp
f0103bba:	50                   	push   %eax
f0103bbb:	e8 6b ac 00 00       	call   f010e82b <setModifiedBufferLength>
f0103bc0:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103bc3:	e8 71 ac 00 00       	call   f010e839 <getModifiedBufferLength>
f0103bc8:	83 ec 08             	sub    $0x8,%esp
f0103bcb:	50                   	push   %eax
f0103bcc:	68 74 38 12 f0       	push   $0xf0123874
f0103bd1:	e8 b5 d3 ff ff       	call   f0100f8b <cprintf>
f0103bd6:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103bd9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103bde:	c9                   	leave  
f0103bdf:	c3                   	ret    

f0103be0 <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103be0:	55                   	push   %ebp
f0103be1:	89 e5                	mov    %esp,%ebp
f0103be3:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103be6:	e8 36 ac 00 00       	call   f010e821 <isBufferingEnabled>
f0103beb:	84 c0                	test   %al,%al
f0103bed:	75 12                	jne    f0103c01 <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103bef:	83 ec 0c             	sub    $0xc,%esp
f0103bf2:	68 b4 38 12 f0       	push   $0xf01238b4
f0103bf7:	e8 8f d3 ff ff       	call   f0100f8b <cprintf>
f0103bfc:	83 c4 10             	add    $0x10,%esp
f0103bff:	eb 19                	jmp    f0103c1a <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103c01:	e8 03 ac 00 00       	call   f010e809 <isModifiedBufferEnabled>
f0103c06:	84 c0                	test   %al,%al
f0103c08:	75 10                	jne    f0103c1a <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103c0a:	83 ec 0c             	sub    $0xc,%esp
f0103c0d:	68 04 39 12 f0       	push   $0xf0123904
f0103c12:	e8 74 d3 ff ff       	call   f0100f8b <cprintf>
f0103c17:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103c1a:	e8 1a ac 00 00       	call   f010e839 <getModifiedBufferLength>
f0103c1f:	83 ec 08             	sub    $0x8,%esp
f0103c22:	50                   	push   %eax
f0103c23:	68 4a 39 12 f0       	push   $0xf012394a
f0103c28:	e8 5e d3 ff ff       	call   f0100f8b <cprintf>
f0103c2d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103c30:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103c35:	c9                   	leave  
f0103c36:	c3                   	ret    

f0103c37 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0103c37:	55                   	push   %ebp
f0103c38:	89 e5                	mov    %esp,%ebp
f0103c3a:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103c3d:	83 ec 08             	sub    $0x8,%esp
f0103c40:	ff 75 0c             	pushl  0xc(%ebp)
f0103c43:	ff 75 08             	pushl  0x8(%ebp)
f0103c46:	e8 56 b5 00 00       	call   f010f1a1 <tst_handler>
f0103c4b:	83 c4 10             	add    $0x10,%esp
}
f0103c4e:	c9                   	leave  
f0103c4f:	c3                   	ret    

f0103c50 <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103c50:	55                   	push   %ebp
f0103c51:	89 e5                	mov    %esp,%ebp
f0103c53:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c56:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c59:	05 00 14 00 00       	add    $0x1400,%eax
f0103c5e:	c1 e0 03             	shl    $0x3,%eax
f0103c61:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c64:	83 ec 04             	sub    $0x4,%esp
f0103c67:	6a 08                	push   $0x8
f0103c69:	ff 75 0c             	pushl  0xc(%ebp)
f0103c6c:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c6f:	e8 53 b7 01 00       	call   f011f3c7 <ide_read>
f0103c74:	83 c4 10             	add    $0x10,%esp
f0103c77:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103c7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103c7d:	c9                   	leave  
f0103c7e:	c3                   	ret    

f0103c7f <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103c7f:	55                   	push   %ebp
f0103c80:	89 e5                	mov    %esp,%ebp
f0103c82:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0103c85:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c88:	05 00 14 00 00       	add    $0x1400,%eax
f0103c8d:	c1 e0 03             	shl    $0x3,%eax
f0103c90:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0103c93:	83 ec 04             	sub    $0x4,%esp
f0103c96:	6a 08                	push   $0x8
f0103c98:	ff 75 0c             	pushl  0xc(%ebp)
f0103c9b:	ff 75 f4             	pushl  -0xc(%ebp)
f0103c9e:	e8 64 b8 01 00       	call   f011f507 <ide_write>
f0103ca3:	83 c4 10             	add    $0x10,%esp
f0103ca6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103ca9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103cad:	74 14                	je     f0103cc3 <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103caf:	83 ec 04             	sub    $0x4,%esp
f0103cb2:	68 68 39 12 f0       	push   $0xf0123968
f0103cb7:	6a 2f                	push   $0x2f
f0103cb9:	68 7f 39 12 f0       	push   $0xf012397f
f0103cbe:	e8 76 c6 ff ff       	call   f0100339 <_panic>
	return success;
f0103cc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103cc6:	c9                   	leave  
f0103cc7:	c3                   	ret    

f0103cc8 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0103cc8:	55                   	push   %ebp
f0103cc9:	89 e5                	mov    %esp,%ebp
f0103ccb:	56                   	push   %esi
f0103ccc:	53                   	push   %ebx
f0103ccd:	83 ec 10             	sub    $0x10,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0103cd0:	c7 05 20 cb 5e f0 00 	movl   $0x0,0xf05ecb20
f0103cd7:	00 00 00 
f0103cda:	c7 05 24 cb 5e f0 00 	movl   $0x0,0xf05ecb24
f0103ce1:	00 00 00 
f0103ce4:	c7 05 2c cb 5e f0 00 	movl   $0x0,0xf05ecb2c
f0103ceb:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103cee:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0103cf5:	e9 20 01 00 00       	jmp    f0103e1a <initialize_disk_page_file+0x152>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0103cfa:	8b 0d 24 c2 5e f0    	mov    0xf05ec224,%ecx
f0103d00:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d03:	89 d0                	mov    %edx,%eax
f0103d05:	01 c0                	add    %eax,%eax
f0103d07:	01 d0                	add    %edx,%eax
f0103d09:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0103d10:	01 d8                	add    %ebx,%eax
f0103d12:	01 d0                	add    %edx,%eax
f0103d14:	01 c8                	add    %ecx,%eax
f0103d16:	83 ec 0c             	sub    $0xc,%esp
f0103d19:	50                   	push   %eax
f0103d1a:	e8 48 45 00 00       	call   f0108267 <initialize_frame_info>
f0103d1f:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0103d22:	8b 0d 24 c2 5e f0    	mov    0xf05ec224,%ecx
f0103d28:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d2b:	89 d0                	mov    %edx,%eax
f0103d2d:	01 c0                	add    %eax,%eax
f0103d2f:	01 d0                	add    %edx,%eax
f0103d31:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0103d38:	01 d8                	add    %ebx,%eax
f0103d3a:	01 d0                	add    %edx,%eax
f0103d3c:	01 c8                	add    %ecx,%eax
f0103d3e:	85 c0                	test   %eax,%eax
f0103d40:	75 14                	jne    f0103d56 <initialize_disk_page_file+0x8e>
f0103d42:	83 ec 04             	sub    $0x4,%esp
f0103d45:	68 9c 39 12 f0       	push   $0xf012399c
f0103d4a:	6a 56                	push   $0x56
f0103d4c:	68 7f 39 12 f0       	push   $0xf012397f
f0103d51:	e8 e3 c5 ff ff       	call   f0100339 <_panic>
f0103d56:	8b 0d 24 c2 5e f0    	mov    0xf05ec224,%ecx
f0103d5c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d5f:	89 d0                	mov    %edx,%eax
f0103d61:	01 c0                	add    %eax,%eax
f0103d63:	01 d0                	add    %edx,%eax
f0103d65:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0103d6c:	01 d8                	add    %ebx,%eax
f0103d6e:	01 d0                	add    %edx,%eax
f0103d70:	01 c8                	add    %ecx,%eax
f0103d72:	8b 15 20 cb 5e f0    	mov    0xf05ecb20,%edx
f0103d78:	89 10                	mov    %edx,(%eax)
f0103d7a:	8b 00                	mov    (%eax),%eax
f0103d7c:	85 c0                	test   %eax,%eax
f0103d7e:	74 27                	je     f0103da7 <initialize_disk_page_file+0xdf>
f0103d80:	8b 0d 20 cb 5e f0    	mov    0xf05ecb20,%ecx
f0103d86:	8b 1d 24 c2 5e f0    	mov    0xf05ec224,%ebx
f0103d8c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103d8f:	89 d0                	mov    %edx,%eax
f0103d91:	01 c0                	add    %eax,%eax
f0103d93:	01 d0                	add    %edx,%eax
f0103d95:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f0103d9c:	01 f0                	add    %esi,%eax
f0103d9e:	01 d0                	add    %edx,%eax
f0103da0:	01 d8                	add    %ebx,%eax
f0103da2:	89 41 04             	mov    %eax,0x4(%ecx)
f0103da5:	eb 21                	jmp    f0103dc8 <initialize_disk_page_file+0x100>
f0103da7:	8b 0d 24 c2 5e f0    	mov    0xf05ec224,%ecx
f0103dad:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103db0:	89 d0                	mov    %edx,%eax
f0103db2:	01 c0                	add    %eax,%eax
f0103db4:	01 d0                	add    %edx,%eax
f0103db6:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0103dbd:	01 d8                	add    %ebx,%eax
f0103dbf:	01 d0                	add    %edx,%eax
f0103dc1:	01 c8                	add    %ecx,%eax
f0103dc3:	a3 24 cb 5e f0       	mov    %eax,0xf05ecb24
f0103dc8:	8b 0d 24 c2 5e f0    	mov    0xf05ec224,%ecx
f0103dce:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103dd1:	89 d0                	mov    %edx,%eax
f0103dd3:	01 c0                	add    %eax,%eax
f0103dd5:	01 d0                	add    %edx,%eax
f0103dd7:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0103dde:	01 d8                	add    %ebx,%eax
f0103de0:	01 d0                	add    %edx,%eax
f0103de2:	01 c8                	add    %ecx,%eax
f0103de4:	a3 20 cb 5e f0       	mov    %eax,0xf05ecb20
f0103de9:	8b 0d 24 c2 5e f0    	mov    0xf05ec224,%ecx
f0103def:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103df2:	89 d0                	mov    %edx,%eax
f0103df4:	01 c0                	add    %eax,%eax
f0103df6:	01 d0                	add    %edx,%eax
f0103df8:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0103dff:	01 d8                	add    %ebx,%eax
f0103e01:	01 d0                	add    %edx,%eax
f0103e03:	01 c8                	add    %ecx,%eax
f0103e05:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103e0c:	a1 2c cb 5e f0       	mov    0xf05ecb2c,%eax
f0103e11:	40                   	inc    %eax
f0103e12:	a3 2c cb 5e f0       	mov    %eax,0xf05ecb2c
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0103e17:	ff 45 f4             	incl   -0xc(%ebp)
f0103e1a:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0103e21:	0f 8e d3 fe ff ff    	jle    f0103cfa <initialize_disk_page_file+0x32>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f0103e27:	90                   	nop
f0103e28:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0103e2b:	5b                   	pop    %ebx
f0103e2c:	5e                   	pop    %esi
f0103e2d:	5d                   	pop    %ebp
f0103e2e:	c3                   	ret    

f0103e2f <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103e2f:	55                   	push   %ebp
f0103e30:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0103e32:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e35:	8b 15 24 c2 5e f0    	mov    0xf05ec224,%edx
f0103e3b:	29 d0                	sub    %edx,%eax
f0103e3d:	c1 f8 02             	sar    $0x2,%eax
f0103e40:	89 c2                	mov    %eax,%edx
f0103e42:	89 d0                	mov    %edx,%eax
f0103e44:	c1 e0 03             	shl    $0x3,%eax
f0103e47:	01 d0                	add    %edx,%eax
f0103e49:	c1 e0 03             	shl    $0x3,%eax
f0103e4c:	01 d0                	add    %edx,%eax
f0103e4e:	c1 e0 03             	shl    $0x3,%eax
f0103e51:	01 d0                	add    %edx,%eax
f0103e53:	c1 e0 03             	shl    $0x3,%eax
f0103e56:	01 d0                	add    %edx,%eax
f0103e58:	89 c1                	mov    %eax,%ecx
f0103e5a:	c1 e1 0f             	shl    $0xf,%ecx
f0103e5d:	01 c8                	add    %ecx,%eax
f0103e5f:	c1 e0 03             	shl    $0x3,%eax
f0103e62:	01 d0                	add    %edx,%eax
f0103e64:	f7 d8                	neg    %eax
}
f0103e66:	5d                   	pop    %ebp
f0103e67:	c3                   	ret    

f0103e68 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103e68:	55                   	push   %ebp
f0103e69:	89 e5                	mov    %esp,%ebp
f0103e6b:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103e6e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103e75:	83 ec 0c             	sub    $0xc,%esp
f0103e78:	68 30 cb 5e f0       	push   $0xf05ecb30
f0103e7d:	e8 3d ad 00 00       	call   f010ebbf <acquire_spinlock>
f0103e82:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0103e85:	a1 20 cb 5e f0       	mov    0xf05ecb20,%eax
f0103e8a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0103e8d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103e91:	75 0c                	jne    f0103e9f <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0103e93:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0103e9a:	e9 a2 00 00 00       	jmp    f0103f41 <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0103e9f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103ea3:	75 14                	jne    f0103eb9 <allocate_disk_frame+0x51>
f0103ea5:	83 ec 04             	sub    $0x4,%esp
f0103ea8:	68 bf 39 12 f0       	push   $0xf01239bf
f0103ead:	6a 7b                	push   $0x7b
f0103eaf:	68 7f 39 12 f0       	push   $0xf012397f
f0103eb4:	e8 80 c4 ff ff       	call   f0100339 <_panic>
f0103eb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103ebc:	8b 00                	mov    (%eax),%eax
f0103ebe:	85 c0                	test   %eax,%eax
f0103ec0:	74 10                	je     f0103ed2 <allocate_disk_frame+0x6a>
f0103ec2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103ec5:	8b 00                	mov    (%eax),%eax
f0103ec7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103eca:	8b 52 04             	mov    0x4(%edx),%edx
f0103ecd:	89 50 04             	mov    %edx,0x4(%eax)
f0103ed0:	eb 0b                	jmp    f0103edd <allocate_disk_frame+0x75>
f0103ed2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103ed5:	8b 40 04             	mov    0x4(%eax),%eax
f0103ed8:	a3 24 cb 5e f0       	mov    %eax,0xf05ecb24
f0103edd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103ee0:	8b 40 04             	mov    0x4(%eax),%eax
f0103ee3:	85 c0                	test   %eax,%eax
f0103ee5:	74 0f                	je     f0103ef6 <allocate_disk_frame+0x8e>
f0103ee7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103eea:	8b 40 04             	mov    0x4(%eax),%eax
f0103eed:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103ef0:	8b 12                	mov    (%edx),%edx
f0103ef2:	89 10                	mov    %edx,(%eax)
f0103ef4:	eb 0a                	jmp    f0103f00 <allocate_disk_frame+0x98>
f0103ef6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103ef9:	8b 00                	mov    (%eax),%eax
f0103efb:	a3 20 cb 5e f0       	mov    %eax,0xf05ecb20
f0103f00:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103f03:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103f09:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103f0c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103f13:	a1 2c cb 5e f0       	mov    0xf05ecb2c,%eax
f0103f18:	48                   	dec    %eax
f0103f19:	a3 2c cb 5e f0       	mov    %eax,0xf05ecb2c
			initialize_frame_info(ptr_frame_info);
f0103f1e:	83 ec 0c             	sub    $0xc,%esp
f0103f21:	ff 75 f0             	pushl  -0x10(%ebp)
f0103f24:	e8 3e 43 00 00       	call   f0108267 <initialize_frame_info>
f0103f29:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0103f2c:	83 ec 0c             	sub    $0xc,%esp
f0103f2f:	ff 75 f0             	pushl  -0x10(%ebp)
f0103f32:	e8 f8 fe ff ff       	call   f0103e2f <to_disk_frame_number>
f0103f37:	83 c4 10             	add    $0x10,%esp
f0103f3a:	89 c2                	mov    %eax,%edx
f0103f3c:	8b 45 08             	mov    0x8(%ebp),%eax
f0103f3f:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103f41:	83 ec 0c             	sub    $0xc,%esp
f0103f44:	68 30 cb 5e f0       	push   $0xf05ecb30
f0103f49:	e8 f8 ac 00 00       	call   f010ec46 <release_spinlock>
f0103f4e:	83 c4 10             	add    $0x10,%esp

	return ret;
f0103f51:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103f54:	c9                   	leave  
f0103f55:	c3                   	ret    

f0103f56 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0103f56:	55                   	push   %ebp
f0103f57:	89 e5                	mov    %esp,%ebp
f0103f59:	56                   	push   %esi
f0103f5a:	53                   	push   %ebx
	// Fill this function in
	if(dfn == 0) return;
f0103f5b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0103f5f:	0f 84 1a 01 00 00    	je     f010407f <free_disk_frame+0x129>
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103f65:	83 ec 0c             	sub    $0xc,%esp
f0103f68:	68 30 cb 5e f0       	push   $0xf05ecb30
f0103f6d:	e8 4d ac 00 00       	call   f010ebbf <acquire_spinlock>
f0103f72:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0103f75:	8b 0d 24 c2 5e f0    	mov    0xf05ec224,%ecx
f0103f7b:	8b 55 08             	mov    0x8(%ebp),%edx
f0103f7e:	89 d0                	mov    %edx,%eax
f0103f80:	01 c0                	add    %eax,%eax
f0103f82:	01 d0                	add    %edx,%eax
f0103f84:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0103f8b:	01 d8                	add    %ebx,%eax
f0103f8d:	01 d0                	add    %edx,%eax
f0103f8f:	01 c8                	add    %ecx,%eax
f0103f91:	85 c0                	test   %eax,%eax
f0103f93:	75 17                	jne    f0103fac <free_disk_frame+0x56>
f0103f95:	83 ec 04             	sub    $0x4,%esp
f0103f98:	68 9c 39 12 f0       	push   $0xf012399c
f0103f9d:	68 8e 00 00 00       	push   $0x8e
f0103fa2:	68 7f 39 12 f0       	push   $0xf012397f
f0103fa7:	e8 8d c3 ff ff       	call   f0100339 <_panic>
f0103fac:	8b 0d 24 c2 5e f0    	mov    0xf05ec224,%ecx
f0103fb2:	8b 55 08             	mov    0x8(%ebp),%edx
f0103fb5:	89 d0                	mov    %edx,%eax
f0103fb7:	01 c0                	add    %eax,%eax
f0103fb9:	01 d0                	add    %edx,%eax
f0103fbb:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0103fc2:	01 d8                	add    %ebx,%eax
f0103fc4:	01 d0                	add    %edx,%eax
f0103fc6:	01 c8                	add    %ecx,%eax
f0103fc8:	8b 15 20 cb 5e f0    	mov    0xf05ecb20,%edx
f0103fce:	89 10                	mov    %edx,(%eax)
f0103fd0:	8b 00                	mov    (%eax),%eax
f0103fd2:	85 c0                	test   %eax,%eax
f0103fd4:	74 27                	je     f0103ffd <free_disk_frame+0xa7>
f0103fd6:	8b 0d 20 cb 5e f0    	mov    0xf05ecb20,%ecx
f0103fdc:	8b 1d 24 c2 5e f0    	mov    0xf05ec224,%ebx
f0103fe2:	8b 55 08             	mov    0x8(%ebp),%edx
f0103fe5:	89 d0                	mov    %edx,%eax
f0103fe7:	01 c0                	add    %eax,%eax
f0103fe9:	01 d0                	add    %edx,%eax
f0103feb:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f0103ff2:	01 f0                	add    %esi,%eax
f0103ff4:	01 d0                	add    %edx,%eax
f0103ff6:	01 d8                	add    %ebx,%eax
f0103ff8:	89 41 04             	mov    %eax,0x4(%ecx)
f0103ffb:	eb 21                	jmp    f010401e <free_disk_frame+0xc8>
f0103ffd:	8b 0d 24 c2 5e f0    	mov    0xf05ec224,%ecx
f0104003:	8b 55 08             	mov    0x8(%ebp),%edx
f0104006:	89 d0                	mov    %edx,%eax
f0104008:	01 c0                	add    %eax,%eax
f010400a:	01 d0                	add    %edx,%eax
f010400c:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0104013:	01 d8                	add    %ebx,%eax
f0104015:	01 d0                	add    %edx,%eax
f0104017:	01 c8                	add    %ecx,%eax
f0104019:	a3 24 cb 5e f0       	mov    %eax,0xf05ecb24
f010401e:	8b 0d 24 c2 5e f0    	mov    0xf05ec224,%ecx
f0104024:	8b 55 08             	mov    0x8(%ebp),%edx
f0104027:	89 d0                	mov    %edx,%eax
f0104029:	01 c0                	add    %eax,%eax
f010402b:	01 d0                	add    %edx,%eax
f010402d:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0104034:	01 d8                	add    %ebx,%eax
f0104036:	01 d0                	add    %edx,%eax
f0104038:	01 c8                	add    %ecx,%eax
f010403a:	a3 20 cb 5e f0       	mov    %eax,0xf05ecb20
f010403f:	8b 0d 24 c2 5e f0    	mov    0xf05ec224,%ecx
f0104045:	8b 55 08             	mov    0x8(%ebp),%edx
f0104048:	89 d0                	mov    %edx,%eax
f010404a:	01 c0                	add    %eax,%eax
f010404c:	01 d0                	add    %edx,%eax
f010404e:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0104055:	01 d8                	add    %ebx,%eax
f0104057:	01 d0                	add    %edx,%eax
f0104059:	01 c8                	add    %ecx,%eax
f010405b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104062:	a1 2c cb 5e f0       	mov    0xf05ecb2c,%eax
f0104067:	40                   	inc    %eax
f0104068:	a3 2c cb 5e f0       	mov    %eax,0xf05ecb2c
	}
	release_spinlock(&DiskFrameLists.dfllock);
f010406d:	83 ec 0c             	sub    $0xc,%esp
f0104070:	68 30 cb 5e f0       	push   $0xf05ecb30
f0104075:	e8 cc ab 00 00       	call   f010ec46 <release_spinlock>
f010407a:	83 c4 10             	add    $0x10,%esp
f010407d:	eb 01                	jmp    f0104080 <free_disk_frame+0x12a>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f010407f:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f0104080:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104083:	5b                   	pop    %ebx
f0104084:	5e                   	pop    %esi
f0104085:	5d                   	pop    %ebp
f0104086:	c3                   	ret    

f0104087 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0104087:	55                   	push   %ebp
f0104088:	89 e5                	mov    %esp,%ebp
f010408a:	53                   	push   %ebx
f010408b:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f010408e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104091:	c1 e8 16             	shr    $0x16,%eax
f0104094:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010409b:	8b 45 08             	mov    0x8(%ebp),%eax
f010409e:	01 d0                	add    %edx,%eax
f01040a0:	8b 00                	mov    (%eax),%eax
f01040a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01040a5:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01040ac:	77 1d                	ja     f01040cb <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f01040ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01040b1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01040b6:	83 ec 0c             	sub    $0xc,%esp
f01040b9:	50                   	push   %eax
f01040ba:	e8 18 50 00 00       	call   f01090d7 <kheap_virtual_address>
f01040bf:	83 c4 10             	add    $0x10,%esp
f01040c2:	89 c2                	mov    %eax,%edx
f01040c4:	8b 45 14             	mov    0x14(%ebp),%eax
f01040c7:	89 10                	mov    %edx,(%eax)
f01040c9:	eb 44                	jmp    f010410f <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f01040cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01040ce:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01040d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01040d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01040d9:	c1 e8 0c             	shr    $0xc,%eax
f01040dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01040df:	a1 f8 c6 5e f0       	mov    0xf05ec6f8,%eax
f01040e4:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01040e7:	72 17                	jb     f0104100 <get_disk_page_table+0x79>
f01040e9:	ff 75 f0             	pushl  -0x10(%ebp)
f01040ec:	68 e0 39 12 f0       	push   $0xf01239e0
f01040f1:	68 9d 00 00 00       	push   $0x9d
f01040f6:	68 7f 39 12 f0       	push   $0xf012397f
f01040fb:	e8 39 c2 ff ff       	call   f0100339 <_panic>
f0104100:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104103:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104108:	89 c2                	mov    %eax,%edx
f010410a:	8b 45 14             	mov    0x14(%ebp),%eax
f010410d:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f010410f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104113:	0f 85 80 00 00 00    	jne    f0104199 <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f0104119:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010411d:	74 6a                	je     f0104189 <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f010411f:	83 ec 0c             	sub    $0xc,%esp
f0104122:	68 00 10 00 00       	push   $0x1000
f0104127:	e8 04 4d 00 00       	call   f0108e30 <kmalloc>
f010412c:	83 c4 10             	add    $0x10,%esp
f010412f:	89 c2                	mov    %eax,%edx
f0104131:	8b 45 14             	mov    0x14(%ebp),%eax
f0104134:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f0104136:	8b 45 14             	mov    0x14(%ebp),%eax
f0104139:	8b 00                	mov    (%eax),%eax
f010413b:	85 c0                	test   %eax,%eax
f010413d:	75 07                	jne    f0104146 <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f010413f:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f0104144:	eb 58                	jmp    f010419e <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f0104146:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104149:	c1 e8 16             	shr    $0x16,%eax
f010414c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104153:	8b 45 08             	mov    0x8(%ebp),%eax
f0104156:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f0104159:	8b 45 14             	mov    0x14(%ebp),%eax
f010415c:	8b 00                	mov    (%eax),%eax
f010415e:	83 ec 0c             	sub    $0xc,%esp
f0104161:	50                   	push   %eax
f0104162:	e8 2f 4f 00 00       	call   f0109096 <kheap_physical_address>
f0104167:	83 c4 10             	add    $0x10,%esp
f010416a:	83 c8 01             	or     $0x1,%eax
f010416d:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f010416f:	8b 45 14             	mov    0x14(%ebp),%eax
f0104172:	8b 00                	mov    (%eax),%eax
f0104174:	83 ec 04             	sub    $0x4,%esp
f0104177:	68 00 10 00 00       	push   $0x1000
f010417c:	6a 00                	push   $0x0
f010417e:	50                   	push   %eax
f010417f:	e8 49 ac 01 00       	call   f011edcd <memset>
f0104184:	83 c4 10             	add    $0x10,%esp
f0104187:	eb 10                	jmp    f0104199 <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f0104189:	8b 45 14             	mov    0x14(%ebp),%eax
f010418c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f0104192:	b8 00 00 00 00       	mov    $0x0,%eax
f0104197:	eb 05                	jmp    f010419e <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f0104199:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010419e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01041a1:	c9                   	leave  
f01041a2:	c3                   	ret    

f01041a3 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f01041a3:	55                   	push   %ebp
f01041a4:	89 e5                	mov    %esp,%ebp
f01041a6:	83 ec 28             	sub    $0x28,%esp
f01041a9:	8b 45 10             	mov    0x10(%ebp),%eax
f01041ac:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f01041af:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f01041b3:	74 72                	je     f0104227 <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f01041b5:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f01041bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01041bf:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f01041c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01041c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01041ca:	ba 00 00 00 00       	mov    $0x0,%edx
f01041cf:	f7 75 f4             	divl   -0xc(%ebp)
f01041d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01041d5:	29 d0                	sub    %edx,%eax
f01041d7:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01041da:	73 2f                	jae    f010420b <pf_add_empty_env_page+0x68>
f01041dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01041df:	8b 50 6c             	mov    0x6c(%eax),%edx
f01041e2:	b8 00 00 00 00       	mov    $0x0,%eax
f01041e7:	29 d0                	sub    %edx,%eax
f01041e9:	c1 e0 0c             	shl    $0xc,%eax
f01041ec:	2d 00 20 40 11       	sub    $0x11402000,%eax
f01041f1:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01041f4:	76 15                	jbe    f010420b <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f01041f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01041f9:	8b 80 a8 05 00 00    	mov    0x5a8(%eax),%eax
f01041ff:	8d 50 01             	lea    0x1(%eax),%edx
f0104202:	8b 45 08             	mov    0x8(%ebp),%eax
f0104205:	89 90 a8 05 00 00    	mov    %edx,0x5a8(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f010420b:	a1 f4 c9 5e f0       	mov    0xf05ec9f4,%eax
f0104210:	83 ec 04             	sub    $0x4,%esp
f0104213:	50                   	push   %eax
f0104214:	ff 75 0c             	pushl  0xc(%ebp)
f0104217:	ff 75 08             	pushl  0x8(%ebp)
f010421a:	e8 b2 00 00 00       	call   f01042d1 <pf_add_env_page>
f010421f:	83 c4 10             	add    $0x10,%esp
f0104222:	e9 a8 00 00 00       	jmp    f01042cf <pf_add_empty_env_page+0x12c>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0104227:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f010422e:	76 19                	jbe    f0104249 <pf_add_empty_env_page+0xa6>
f0104230:	68 10 3a 12 f0       	push   $0xf0123a10
f0104235:	68 36 3a 12 f0       	push   $0xf0123a36
f010423a:	68 dc 00 00 00       	push   $0xdc
f010423f:	68 7f 39 12 f0       	push   $0xf012397f
f0104244:	e8 f0 c0 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0104249:	8b 45 08             	mov    0x8(%ebp),%eax
f010424c:	83 c0 74             	add    $0x74,%eax
f010424f:	83 ec 08             	sub    $0x8,%esp
f0104252:	50                   	push   %eax
f0104253:	ff 75 08             	pushl  0x8(%ebp)
f0104256:	e8 95 05 00 00       	call   f01047f0 <get_disk_page_directory>
f010425b:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f010425e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104261:	8b 40 74             	mov    0x74(%eax),%eax
f0104264:	8d 55 ec             	lea    -0x14(%ebp),%edx
f0104267:	52                   	push   %edx
f0104268:	6a 01                	push   $0x1
f010426a:	ff 75 0c             	pushl  0xc(%ebp)
f010426d:	50                   	push   %eax
f010426e:	e8 14 fe ff ff       	call   f0104087 <get_disk_page_table>
f0104273:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104276:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104279:	8b 55 0c             	mov    0xc(%ebp),%edx
f010427c:	c1 ea 0c             	shr    $0xc,%edx
f010427f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104285:	c1 e2 02             	shl    $0x2,%edx
f0104288:	01 d0                	add    %edx,%eax
f010428a:	8b 00                	mov    (%eax),%eax
f010428c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f010428f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104292:	85 c0                	test   %eax,%eax
f0104294:	75 34                	jne    f01042ca <pf_add_empty_env_page+0x127>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0104296:	83 ec 0c             	sub    $0xc,%esp
f0104299:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010429c:	50                   	push   %eax
f010429d:	e8 c6 fb ff ff       	call   f0103e68 <allocate_disk_frame>
f01042a2:	83 c4 10             	add    $0x10,%esp
f01042a5:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01042a8:	75 07                	jne    f01042b1 <pf_add_empty_env_page+0x10e>
f01042aa:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01042af:	eb 1e                	jmp    f01042cf <pf_add_empty_env_page+0x12c>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01042b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01042b4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01042b7:	c1 ea 0c             	shr    $0xc,%edx
f01042ba:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01042c0:	c1 e2 02             	shl    $0x2,%edx
f01042c3:	01 c2                	add    %eax,%edx
f01042c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01042c8:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f01042ca:	b8 00 00 00 00       	mov    $0x0,%eax

}
f01042cf:	c9                   	leave  
f01042d0:	c3                   	ret    

f01042d1 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f01042d1:	55                   	push   %ebp
f01042d2:	89 e5                	mov    %esp,%ebp
f01042d4:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f01042d7:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01042de:	76 19                	jbe    f01042f9 <pf_add_env_page+0x28>
f01042e0:	68 10 3a 12 f0       	push   $0xf0123a10
f01042e5:	68 36 3a 12 f0       	push   $0xf0123a36
f01042ea:	68 f1 00 00 00       	push   $0xf1
f01042ef:	68 7f 39 12 f0       	push   $0xf012397f
f01042f4:	e8 40 c0 ff ff       	call   f0100339 <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01042f9:	8b 45 08             	mov    0x8(%ebp),%eax
f01042fc:	83 c0 74             	add    $0x74,%eax
f01042ff:	83 ec 08             	sub    $0x8,%esp
f0104302:	50                   	push   %eax
f0104303:	ff 75 08             	pushl  0x8(%ebp)
f0104306:	e8 e5 04 00 00       	call   f01047f0 <get_disk_page_directory>
f010430b:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f010430e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104311:	8b 40 74             	mov    0x74(%eax),%eax
f0104314:	8d 55 f0             	lea    -0x10(%ebp),%edx
f0104317:	52                   	push   %edx
f0104318:	6a 01                	push   $0x1
f010431a:	ff 75 0c             	pushl  0xc(%ebp)
f010431d:	50                   	push   %eax
f010431e:	e8 64 fd ff ff       	call   f0104087 <get_disk_page_table>
f0104323:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104326:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104329:	8b 55 0c             	mov    0xc(%ebp),%edx
f010432c:	c1 ea 0c             	shr    $0xc,%edx
f010432f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104335:	c1 e2 02             	shl    $0x2,%edx
f0104338:	01 d0                	add    %edx,%eax
f010433a:	8b 00                	mov    (%eax),%eax
f010433c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f010433f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104342:	85 c0                	test   %eax,%eax
f0104344:	75 34                	jne    f010437a <pf_add_env_page+0xa9>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0104346:	83 ec 0c             	sub    $0xc,%esp
f0104349:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010434c:	50                   	push   %eax
f010434d:	e8 16 fb ff ff       	call   f0103e68 <allocate_disk_frame>
f0104352:	83 c4 10             	add    $0x10,%esp
f0104355:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104358:	75 07                	jne    f0104361 <pf_add_env_page+0x90>
f010435a:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010435f:	eb 31                	jmp    f0104392 <pf_add_env_page+0xc1>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0104361:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104364:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104367:	c1 ea 0c             	shr    $0xc,%edx
f010436a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104370:	c1 e2 02             	shl    $0x2,%edx
f0104373:	01 c2                	add    %eax,%edx
f0104375:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104378:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f010437a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010437d:	83 ec 08             	sub    $0x8,%esp
f0104380:	ff 75 10             	pushl  0x10(%ebp)
f0104383:	50                   	push   %eax
f0104384:	e8 f6 f8 ff ff       	call   f0103c7f <write_disk_page>
f0104389:	83 c4 10             	add    $0x10,%esp
f010438c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f010438f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104392:	c9                   	leave  
f0104393:	c3                   	ret    

f0104394 <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f0104394:	55                   	push   %ebp
f0104395:	89 e5                	mov    %esp,%ebp
f0104397:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f010439a:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01043a1:	76 19                	jbe    f01043bc <pf_update_env_page+0x28>
f01043a3:	68 10 3a 12 f0       	push   $0xf0123a10
f01043a8:	68 36 3a 12 f0       	push   $0xf0123a36
f01043ad:	68 13 01 00 00       	push   $0x113
f01043b2:	68 7f 39 12 f0       	push   $0xf012397f
f01043b7:	e8 7d bf ff ff       	call   f0100339 <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01043bc:	8b 45 08             	mov    0x8(%ebp),%eax
f01043bf:	83 c0 74             	add    $0x74,%eax
f01043c2:	83 ec 08             	sub    $0x8,%esp
f01043c5:	50                   	push   %eax
f01043c6:	ff 75 08             	pushl  0x8(%ebp)
f01043c9:	e8 22 04 00 00       	call   f01047f0 <get_disk_page_directory>
f01043ce:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01043d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01043d4:	8b 40 74             	mov    0x74(%eax),%eax
f01043d7:	8d 55 dc             	lea    -0x24(%ebp),%edx
f01043da:	52                   	push   %edx
f01043db:	6a 00                	push   $0x0
f01043dd:	ff 75 0c             	pushl  0xc(%ebp)
f01043e0:	50                   	push   %eax
f01043e1:	e8 a1 fc ff ff       	call   f0104087 <get_disk_page_table>
f01043e6:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f01043e9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01043ec:	85 c0                	test   %eax,%eax
f01043ee:	74 29                	je     f0104419 <pf_update_env_page+0x85>
f01043f0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01043f3:	85 c0                	test   %eax,%eax
f01043f5:	0f 84 c5 00 00 00    	je     f01044c0 <pf_update_env_page+0x12c>
f01043fb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01043fe:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104401:	c1 ea 0c             	shr    $0xc,%edx
f0104404:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010440a:	c1 e2 02             	shl    $0x2,%edx
f010440d:	01 d0                	add    %edx,%eax
f010440f:	8b 00                	mov    (%eax),%eax
f0104411:	85 c0                	test   %eax,%eax
f0104413:	0f 85 a7 00 00 00    	jne    f01044c0 <pf_update_env_page+0x12c>
	{

		uint32 VA = (uint32)virtual_address ;
f0104419:	8b 45 0c             	mov    0xc(%ebp),%eax
f010441c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if ((VA >= USER_HEAP_START && VA < USER_HEAP_MAX) || (VA >= USTACKBOTTOM && VA < USTACKTOP))
f010441f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104422:	85 c0                	test   %eax,%eax
f0104424:	79 09                	jns    f010442f <pf_update_env_page+0x9b>
f0104426:	81 7d f4 ff ff ff 9f 	cmpl   $0x9fffffff,-0xc(%ebp)
f010442d:	76 30                	jbe    f010445f <pf_update_env_page+0xcb>
f010442f:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0104436:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104439:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010443e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0104441:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104444:	ba 00 00 00 00       	mov    $0x0,%edx
f0104449:	f7 75 f0             	divl   -0x10(%ebp)
f010444c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010444f:	29 d0                	sub    %edx,%eax
f0104451:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0104454:	77 53                	ja     f01044a9 <pf_update_env_page+0x115>
f0104456:	81 7d f4 ff df bf ee 	cmpl   $0xeebfdfff,-0xc(%ebp)
f010445d:	77 4a                	ja     f01044a9 <pf_update_env_page+0x115>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, VA, 0);
f010445f:	83 ec 04             	sub    $0x4,%esp
f0104462:	6a 00                	push   $0x0
f0104464:	ff 75 f4             	pushl  -0xc(%ebp)
f0104467:	ff 75 08             	pushl  0x8(%ebp)
f010446a:	e8 34 fd ff ff       	call   f01041a3 <pf_add_empty_env_page>
f010446f:	83 c4 10             	add    $0x10,%esp
f0104472:	89 45 e8             	mov    %eax,-0x18(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f0104475:	83 7d e8 f8          	cmpl   $0xfffffff8,-0x18(%ebp)
f0104479:	75 17                	jne    f0104492 <pf_update_env_page+0xfe>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f010447b:	83 ec 04             	sub    $0x4,%esp
f010447e:	68 4c 3a 12 f0       	push   $0xf0123a4c
f0104483:	68 43 01 00 00       	push   $0x143
f0104488:	68 7f 39 12 f0       	push   $0xf012397f
f010448d:	e8 a7 be ff ff       	call   f0100339 <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f0104492:	8b 45 08             	mov    0x8(%ebp),%eax
f0104495:	8b 80 a8 05 00 00    	mov    0x5a8(%eax),%eax
f010449b:	8d 50 01             	lea    0x1(%eax),%edx
f010449e:	8b 45 08             	mov    0x8(%ebp),%eax
f01044a1:	89 90 a8 05 00 00    	mov    %edx,0x5a8(%eax)
f01044a7:	eb 17                	jmp    f01044c0 <pf_update_env_page+0x12c>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f01044a9:	83 ec 04             	sub    $0x4,%esp
f01044ac:	68 98 3a 12 f0       	push   $0xf0123a98
f01044b1:	68 4c 01 00 00       	push   $0x14c
f01044b6:	68 7f 39 12 f0       	push   $0xf012397f
f01044bb:	e8 79 be ff ff       	call   f0100339 <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01044c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01044c3:	8b 40 74             	mov    0x74(%eax),%eax
f01044c6:	8d 55 dc             	lea    -0x24(%ebp),%edx
f01044c9:	52                   	push   %edx
f01044ca:	6a 00                	push   $0x0
f01044cc:	ff 75 0c             	pushl  0xc(%ebp)
f01044cf:	50                   	push   %eax
f01044d0:	e8 b2 fb ff ff       	call   f0104087 <get_disk_page_table>
f01044d5:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01044d8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01044db:	8b 55 0c             	mov    0xc(%ebp),%edx
f01044de:	c1 ea 0c             	shr    $0xc,%edx
f01044e1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01044e7:	c1 e2 02             	shl    $0x2,%edx
f01044ea:	01 d0                	add    %edx,%eax
f01044ec:	8b 00                	mov    (%eax),%eax
f01044ee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unused VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, USER_LIMIT, 0);
f01044f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01044f4:	8b 40 64             	mov    0x64(%eax),%eax
f01044f7:	6a 00                	push   $0x0
f01044f9:	68 00 00 80 ef       	push   $0xef800000
f01044fe:	ff 75 10             	pushl  0x10(%ebp)
f0104501:	50                   	push   %eax
f0104502:	e8 48 42 00 00       	call   f010874f <map_frame>
f0104507:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN(USER_LIMIT, PAGE_SIZE));
f010450a:	c7 45 e0 00 00 80 ef 	movl   $0xef800000,-0x20(%ebp)
f0104511:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0104514:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104519:	83 ec 08             	sub    $0x8,%esp
f010451c:	50                   	push   %eax
f010451d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0104520:	e8 5a f7 ff ff       	call   f0103c7f <write_disk_page>
f0104525:	83 c4 10             	add    $0x10,%esp
f0104528:	89 45 e8             	mov    %eax,-0x18(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f010452b:	8b 45 10             	mov    0x10(%ebp),%eax
f010452e:	8b 40 08             	mov    0x8(%eax),%eax
f0104531:	40                   	inc    %eax
f0104532:	8b 55 10             	mov    0x10(%ebp),%edx
f0104535:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, USER_LIMIT);
f0104539:	8b 45 08             	mov    0x8(%ebp),%eax
f010453c:	8b 40 64             	mov    0x64(%eax),%eax
f010453f:	83 ec 08             	sub    $0x8,%esp
f0104542:	68 00 00 80 ef       	push   $0xef800000
f0104547:	50                   	push   %eax
f0104548:	e8 62 43 00 00       	call   f01088af <unmap_frame>
f010454d:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f0104550:	8b 45 10             	mov    0x10(%ebp),%eax
f0104553:	8b 40 08             	mov    0x8(%eax),%eax
f0104556:	48                   	dec    %eax
f0104557:	8b 55 10             	mov    0x10(%ebp),%edx
f010455a:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f010455e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104561:	8b 80 a4 05 00 00    	mov    0x5a4(%eax),%eax
f0104567:	8d 50 01             	lea    0x1(%eax),%edx
f010456a:	8b 45 08             	mov    0x8(%ebp),%eax
f010456d:	89 90 a4 05 00 00    	mov    %edx,0x5a4(%eax)
	//======================

	return ret;
f0104573:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0104576:	c9                   	leave  
f0104577:	c3                   	ret    

f0104578 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f0104578:	55                   	push   %ebp
f0104579:	89 e5                	mov    %esp,%ebp
f010457b:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f010457e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104581:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104584:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104587:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010458c:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010458f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104592:	8b 40 74             	mov    0x74(%eax),%eax
f0104595:	85 c0                	test   %eax,%eax
f0104597:	75 0a                	jne    f01045a3 <pf_read_env_page+0x2b>
f0104599:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010459e:	e9 90 00 00 00       	jmp    f0104633 <pf_read_env_page+0xbb>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f01045a3:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01045a9:	8b 40 74             	mov    0x74(%eax),%eax
f01045ac:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f01045af:	51                   	push   %ecx
f01045b0:	6a 00                	push   $0x0
f01045b2:	52                   	push   %edx
f01045b3:	50                   	push   %eax
f01045b4:	e8 ce fa ff ff       	call   f0104087 <get_disk_page_table>
f01045b9:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01045bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01045bf:	85 c0                	test   %eax,%eax
f01045c1:	75 07                	jne    f01045ca <pf_read_env_page+0x52>
f01045c3:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01045c8:	eb 69                	jmp    f0104633 <pf_read_env_page+0xbb>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01045ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01045cd:	8b 55 0c             	mov    0xc(%ebp),%edx
f01045d0:	c1 ea 0c             	shr    $0xc,%edx
f01045d3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01045d9:	c1 e2 02             	shl    $0x2,%edx
f01045dc:	01 d0                	add    %edx,%eax
f01045de:	8b 00                	mov    (%eax),%eax
f01045e0:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01045e3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01045e7:	75 07                	jne    f01045f0 <pf_read_env_page+0x78>
f01045e9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01045ee:	eb 43                	jmp    f0104633 <pf_read_env_page+0xbb>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f01045f0:	83 ec 08             	sub    $0x8,%esp
f01045f3:	ff 75 0c             	pushl  0xc(%ebp)
f01045f6:	ff 75 f0             	pushl  -0x10(%ebp)
f01045f9:	e8 52 f6 ff ff       	call   f0103c50 <read_disk_page>
f01045fe:	83 c4 10             	add    $0x10,%esp
f0104601:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104604:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104607:	8b 45 08             	mov    0x8(%ebp),%eax
f010460a:	8b 40 64             	mov    0x64(%eax),%eax
f010460d:	6a 40                	push   $0x40
f010460f:	6a 00                	push   $0x0
f0104611:	52                   	push   %edx
f0104612:	50                   	push   %eax
f0104613:	e8 e6 4a 00 00       	call   f01090fe <pt_set_page_permissions>
f0104618:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f010461b:	8b 45 08             	mov    0x8(%ebp),%eax
f010461e:	8b 80 a0 05 00 00    	mov    0x5a0(%eax),%eax
f0104624:	8d 50 01             	lea    0x1(%eax),%edx
f0104627:	8b 45 08             	mov    0x8(%ebp),%eax
f010462a:	89 90 a0 05 00 00    	mov    %edx,0x5a0(%eax)
	//======================

	return disk_read_error;
f0104630:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104633:	c9                   	leave  
f0104634:	c3                   	ret    

f0104635 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f0104635:	55                   	push   %ebp
f0104636:	89 e5                	mov    %esp,%ebp
f0104638:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010463b:	8b 45 08             	mov    0x8(%ebp),%eax
f010463e:	8b 40 74             	mov    0x74(%eax),%eax
f0104641:	85 c0                	test   %eax,%eax
f0104643:	74 62                	je     f01046a7 <pf_remove_env_page+0x72>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104645:	8b 45 08             	mov    0x8(%ebp),%eax
f0104648:	8b 40 74             	mov    0x74(%eax),%eax
f010464b:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010464e:	52                   	push   %edx
f010464f:	6a 00                	push   $0x0
f0104651:	ff 75 0c             	pushl  0xc(%ebp)
f0104654:	50                   	push   %eax
f0104655:	e8 2d fa ff ff       	call   f0104087 <get_disk_page_table>
f010465a:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f010465d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104660:	85 c0                	test   %eax,%eax
f0104662:	74 46                	je     f01046aa <pf_remove_env_page+0x75>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104664:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104667:	8b 55 0c             	mov    0xc(%ebp),%edx
f010466a:	c1 ea 0c             	shr    $0xc,%edx
f010466d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104673:	c1 e2 02             	shl    $0x2,%edx
f0104676:	01 d0                	add    %edx,%eax
f0104678:	8b 00                	mov    (%eax),%eax
f010467a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f010467d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104680:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104683:	c1 ea 0c             	shr    $0xc,%edx
f0104686:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010468c:	c1 e2 02             	shl    $0x2,%edx
f010468f:	01 d0                	add    %edx,%eax
f0104691:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104697:	83 ec 0c             	sub    $0xc,%esp
f010469a:	ff 75 f4             	pushl  -0xc(%ebp)
f010469d:	e8 b4 f8 ff ff       	call   f0103f56 <free_disk_frame>
f01046a2:	83 c4 10             	add    $0x10,%esp
f01046a5:	eb 04                	jmp    f01046ab <pf_remove_env_page+0x76>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f01046a7:	90                   	nop
f01046a8:	eb 01                	jmp    f01046ab <pf_remove_env_page+0x76>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f01046aa:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f01046ab:	c9                   	leave  
f01046ac:	c3                   	ret    

f01046ad <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f01046ad:	55                   	push   %ebp
f01046ae:	89 e5                	mov    %esp,%ebp
f01046b0:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01046b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01046ba:	e9 b8 00 00 00       	jmp    f0104777 <pf_free_env+0xca>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f01046bf:	8b 45 08             	mov    0x8(%ebp),%eax
f01046c2:	8b 40 74             	mov    0x74(%eax),%eax
f01046c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01046c8:	c1 e2 02             	shl    $0x2,%edx
f01046cb:	01 d0                	add    %edx,%eax
f01046cd:	8b 00                	mov    (%eax),%eax
f01046cf:	83 e0 01             	and    $0x1,%eax
f01046d2:	85 c0                	test   %eax,%eax
f01046d4:	0f 84 99 00 00 00    	je     f0104773 <pf_free_env+0xc6>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f01046da:	8b 45 08             	mov    0x8(%ebp),%eax
f01046dd:	8b 40 74             	mov    0x74(%eax),%eax
f01046e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01046e3:	c1 e2 02             	shl    $0x2,%edx
f01046e6:	01 d0                	add    %edx,%eax
f01046e8:	8b 00                	mov    (%eax),%eax
f01046ea:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01046ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f01046f2:	83 ec 0c             	sub    $0xc,%esp
f01046f5:	ff 75 ec             	pushl  -0x14(%ebp)
f01046f8:	e8 da 49 00 00       	call   f01090d7 <kheap_virtual_address>
f01046fd:	83 c4 10             	add    $0x10,%esp
f0104700:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f0104703:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010470a:	eb 3a                	jmp    f0104746 <pf_free_env+0x99>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f010470c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010470f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104716:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104719:	01 d0                	add    %edx,%eax
f010471b:	8b 00                	mov    (%eax),%eax
f010471d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f0104720:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104723:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010472a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010472d:	01 d0                	add    %edx,%eax
f010472f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f0104735:	83 ec 0c             	sub    $0xc,%esp
f0104738:	ff 75 e4             	pushl  -0x1c(%ebp)
f010473b:	e8 16 f8 ff ff       	call   f0103f56 <free_disk_frame>
f0104740:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f0104743:	ff 45 f0             	incl   -0x10(%ebp)
f0104746:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f010474d:	76 bd                	jbe    f010470c <pf_free_env+0x5f>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f010474f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104752:	8b 40 74             	mov    0x74(%eax),%eax
f0104755:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104758:	c1 e2 02             	shl    $0x2,%edx
f010475b:	01 d0                	add    %edx,%eax
f010475d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f0104763:	83 ec 0c             	sub    $0xc,%esp
f0104766:	ff 75 e8             	pushl  -0x18(%ebp)
f0104769:	e8 2f 48 00 00       	call   f0108f9d <kfree>
f010476e:	83 c4 10             	add    $0x10,%esp
f0104771:	eb 01                	jmp    f0104774 <pf_free_env+0xc7>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f0104773:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104774:	ff 45 f4             	incl   -0xc(%ebp)
f0104777:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010477e:	0f 86 3b ff ff ff    	jbe    f01046bf <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f0104784:	8b 45 08             	mov    0x8(%ebp),%eax
f0104787:	8b 40 74             	mov    0x74(%eax),%eax
f010478a:	83 ec 0c             	sub    $0xc,%esp
f010478d:	50                   	push   %eax
f010478e:	e8 0a 48 00 00       	call   f0108f9d <kfree>
f0104793:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f0104796:	8b 45 08             	mov    0x8(%ebp),%eax
f0104799:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	ptr_env->disk_env_pgdir_PA = 0;
f01047a0:	8b 45 08             	mov    0x8(%ebp),%eax
f01047a3:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f01047aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01047ad:	8b 40 7c             	mov    0x7c(%eax),%eax
f01047b0:	85 c0                	test   %eax,%eax
f01047b2:	74 39                	je     f01047ed <pf_free_env+0x140>
		return;
	__pf_remove_env_all_tables(ptr_env);
f01047b4:	83 ec 0c             	sub    $0xc,%esp
f01047b7:	ff 75 08             	pushl  0x8(%ebp)
f01047ba:	e8 f1 02 00 00       	call   f0104ab0 <__pf_remove_env_all_tables>
f01047bf:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f01047c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01047c5:	8b 40 7c             	mov    0x7c(%eax),%eax
f01047c8:	83 ec 0c             	sub    $0xc,%esp
f01047cb:	50                   	push   %eax
f01047cc:	e8 cc 47 00 00       	call   f0108f9d <kfree>
f01047d1:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f01047d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01047d7:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	ptr_env->disk_env_tabledir_PA = 0;
f01047de:	8b 45 08             	mov    0x8(%ebp),%eax
f01047e1:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f01047e8:	00 00 00 
f01047eb:	eb 01                	jmp    f01047ee <pf_free_env+0x141>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f01047ed:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f01047ee:	c9                   	leave  
f01047ef:	c3                   	ret    

f01047f0 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f01047f0:	55                   	push   %ebp
f01047f1:	89 e5                	mov    %esp,%ebp
f01047f3:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f01047f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01047f9:	8b 50 74             	mov    0x74(%eax),%edx
f01047fc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01047ff:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f0104801:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104804:	8b 00                	mov    (%eax),%eax
f0104806:	85 c0                	test   %eax,%eax
f0104808:	75 58                	jne    f0104862 <get_disk_page_directory+0x72>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f010480a:	83 ec 0c             	sub    $0xc,%esp
f010480d:	68 00 10 00 00       	push   $0x1000
f0104812:	e8 19 46 00 00       	call   f0108e30 <kmalloc>
f0104817:	83 c4 10             	add    $0x10,%esp
f010481a:	89 c2                	mov    %eax,%edx
f010481c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010481f:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f0104821:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104824:	8b 00                	mov    (%eax),%eax
f0104826:	85 c0                	test   %eax,%eax
f0104828:	75 07                	jne    f0104831 <get_disk_page_directory+0x41>
			{
				return E_NO_VM;
f010482a:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010482f:	eb 36                	jmp    f0104867 <get_disk_page_directory+0x77>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f0104831:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104834:	8b 00                	mov    (%eax),%eax
f0104836:	83 ec 0c             	sub    $0xc,%esp
f0104839:	50                   	push   %eax
f010483a:	e8 57 48 00 00       	call   f0109096 <kheap_physical_address>
f010483f:	83 c4 10             	add    $0x10,%esp
f0104842:	89 c2                	mov    %eax,%edx
f0104844:	8b 45 08             	mov    0x8(%ebp),%eax
f0104847:	89 50 78             	mov    %edx,0x78(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f010484a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010484d:	8b 00                	mov    (%eax),%eax
f010484f:	83 ec 04             	sub    $0x4,%esp
f0104852:	68 00 10 00 00       	push   $0x1000
f0104857:	6a 00                	push   $0x0
f0104859:	50                   	push   %eax
f010485a:	e8 6e a5 01 00       	call   f011edcd <memset>
f010485f:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104862:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104867:	c9                   	leave  
f0104868:	c3                   	ret    

f0104869 <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f0104869:	55                   	push   %ebp
f010486a:	89 e5                	mov    %esp,%ebp
f010486c:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f010486f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0104876:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010487d:	eb 78                	jmp    f01048f7 <pf_calculate_allocated_pages+0x8e>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f010487f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104882:	8b 40 74             	mov    0x74(%eax),%eax
f0104885:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104888:	c1 e2 02             	shl    $0x2,%edx
f010488b:	01 d0                	add    %edx,%eax
f010488d:	8b 00                	mov    (%eax),%eax
f010488f:	83 e0 01             	and    $0x1,%eax
f0104892:	85 c0                	test   %eax,%eax
f0104894:	74 5d                	je     f01048f3 <pf_calculate_allocated_pages+0x8a>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f0104896:	8b 45 08             	mov    0x8(%ebp),%eax
f0104899:	8b 40 74             	mov    0x74(%eax),%eax
f010489c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010489f:	c1 e2 02             	shl    $0x2,%edx
f01048a2:	01 d0                	add    %edx,%eax
f01048a4:	8b 00                	mov    (%eax),%eax
f01048a6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01048ab:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f01048ae:	83 ec 0c             	sub    $0xc,%esp
f01048b1:	ff 75 e8             	pushl  -0x18(%ebp)
f01048b4:	e8 1e 48 00 00       	call   f01090d7 <kheap_virtual_address>
f01048b9:	83 c4 10             	add    $0x10,%esp
f01048bc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f01048bf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01048c6:	eb 20                	jmp    f01048e8 <pf_calculate_allocated_pages+0x7f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f01048c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01048cb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01048d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01048d5:	01 d0                	add    %edx,%eax
f01048d7:	8b 00                	mov    (%eax),%eax
f01048d9:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f01048dc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01048e0:	74 03                	je     f01048e5 <pf_calculate_allocated_pages+0x7c>
				counter ++;
f01048e2:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f01048e5:	ff 45 ec             	incl   -0x14(%ebp)
f01048e8:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f01048ef:	76 d7                	jbe    f01048c8 <pf_calculate_allocated_pages+0x5f>
f01048f1:	eb 01                	jmp    f01048f4 <pf_calculate_allocated_pages+0x8b>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f01048f3:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f01048f4:	ff 45 f4             	incl   -0xc(%ebp)
f01048f7:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f01048fe:	0f 86 7b ff ff ff    	jbe    f010487f <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f0104904:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104907:	c9                   	leave  
f0104908:	c3                   	ret    

f0104909 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f0104909:	55                   	push   %ebp
f010490a:	89 e5                	mov    %esp,%ebp
f010490c:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f010490f:	83 ec 0c             	sub    $0xc,%esp
f0104912:	68 30 cb 5e f0       	push   $0xf05ecb30
f0104917:	e8 a3 a2 00 00       	call   f010ebbf <acquire_spinlock>
f010491c:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f010491f:	a1 2c cb 5e f0       	mov    0xf05ecb2c,%eax
f0104924:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0104927:	83 ec 0c             	sub    $0xc,%esp
f010492a:	68 30 cb 5e f0       	push   $0xf05ecb30
f010492f:	e8 12 a3 00 00       	call   f010ec46 <release_spinlock>
f0104934:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f0104937:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f010493a:	c9                   	leave  
f010493b:	c3                   	ret    

f010493c <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f010493c:	55                   	push   %ebp
f010493d:	89 e5                	mov    %esp,%ebp
f010493f:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f0104942:	8b 45 08             	mov    0x8(%ebp),%eax
f0104945:	8b 50 7c             	mov    0x7c(%eax),%edx
f0104948:	8b 45 0c             	mov    0xc(%ebp),%eax
f010494b:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f010494d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104950:	8b 00                	mov    (%eax),%eax
f0104952:	85 c0                	test   %eax,%eax
f0104954:	75 5b                	jne    f01049b1 <get_disk_table_directory+0x75>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f0104956:	83 ec 0c             	sub    $0xc,%esp
f0104959:	68 00 10 00 00       	push   $0x1000
f010495e:	e8 cd 44 00 00       	call   f0108e30 <kmalloc>
f0104963:	83 c4 10             	add    $0x10,%esp
f0104966:	89 c2                	mov    %eax,%edx
f0104968:	8b 45 0c             	mov    0xc(%ebp),%eax
f010496b:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f010496d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104970:	8b 00                	mov    (%eax),%eax
f0104972:	85 c0                	test   %eax,%eax
f0104974:	75 07                	jne    f010497d <get_disk_table_directory+0x41>
			{
				return E_NO_VM;
f0104976:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010497b:	eb 39                	jmp    f01049b6 <get_disk_table_directory+0x7a>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f010497d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104980:	8b 00                	mov    (%eax),%eax
f0104982:	83 ec 0c             	sub    $0xc,%esp
f0104985:	50                   	push   %eax
f0104986:	e8 0b 47 00 00       	call   f0109096 <kheap_physical_address>
f010498b:	83 c4 10             	add    $0x10,%esp
f010498e:	89 c2                	mov    %eax,%edx
f0104990:	8b 45 08             	mov    0x8(%ebp),%eax
f0104993:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f0104999:	8b 45 0c             	mov    0xc(%ebp),%eax
f010499c:	8b 00                	mov    (%eax),%eax
f010499e:	83 ec 04             	sub    $0x4,%esp
f01049a1:	68 00 10 00 00       	push   $0x1000
f01049a6:	6a 00                	push   $0x0
f01049a8:	50                   	push   %eax
f01049a9:	e8 1f a4 01 00       	call   f011edcd <memset>
f01049ae:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01049b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01049b6:	c9                   	leave  
f01049b7:	c3                   	ret    

f01049b8 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f01049b8:	55                   	push   %ebp
f01049b9:	89 e5                	mov    %esp,%ebp
f01049bb:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f01049be:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01049c5:	76 19                	jbe    f01049e0 <__pf_write_env_table+0x28>
f01049c7:	68 10 3a 12 f0       	push   $0xf0123a10
f01049cc:	68 36 3a 12 f0       	push   $0xf0123a36
f01049d1:	68 91 02 00 00       	push   $0x291
f01049d6:	68 7f 39 12 f0       	push   $0xf012397f
f01049db:	e8 59 b9 ff ff       	call   f0100339 <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f01049e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01049e3:	83 c0 7c             	add    $0x7c,%eax
f01049e6:	83 ec 08             	sub    $0x8,%esp
f01049e9:	50                   	push   %eax
f01049ea:	ff 75 08             	pushl  0x8(%ebp)
f01049ed:	e8 4a ff ff ff       	call   f010493c <get_disk_table_directory>
f01049f2:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f01049f5:	8b 45 08             	mov    0x8(%ebp),%eax
f01049f8:	8b 40 7c             	mov    0x7c(%eax),%eax
f01049fb:	8b 55 0c             	mov    0xc(%ebp),%edx
f01049fe:	c1 ea 16             	shr    $0x16,%edx
f0104a01:	c1 e2 02             	shl    $0x2,%edx
f0104a04:	01 d0                	add    %edx,%eax
f0104a06:	8b 00                	mov    (%eax),%eax
f0104a08:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f0104a0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104a0e:	85 c0                	test   %eax,%eax
f0104a10:	75 31                	jne    f0104a43 <__pf_write_env_table+0x8b>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0104a12:	83 ec 0c             	sub    $0xc,%esp
f0104a15:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0104a18:	50                   	push   %eax
f0104a19:	e8 4a f4 ff ff       	call   f0103e68 <allocate_disk_frame>
f0104a1e:	83 c4 10             	add    $0x10,%esp
f0104a21:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0104a24:	75 07                	jne    f0104a2d <__pf_write_env_table+0x75>
f0104a26:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0104a2b:	eb 2e                	jmp    f0104a5b <__pf_write_env_table+0xa3>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f0104a2d:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a30:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a33:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104a36:	c1 ea 16             	shr    $0x16,%edx
f0104a39:	c1 e2 02             	shl    $0x2,%edx
f0104a3c:	01 c2                	add    %eax,%edx
f0104a3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104a41:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f0104a43:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104a46:	83 ec 08             	sub    $0x8,%esp
f0104a49:	ff 75 10             	pushl  0x10(%ebp)
f0104a4c:	50                   	push   %eax
f0104a4d:	e8 2d f2 ff ff       	call   f0103c7f <write_disk_page>
f0104a52:	83 c4 10             	add    $0x10,%esp
f0104a55:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f0104a58:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104a5b:	c9                   	leave  
f0104a5c:	c3                   	ret    

f0104a5d <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104a5d:	55                   	push   %ebp
f0104a5e:	89 e5                	mov    %esp,%ebp
f0104a60:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a63:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a66:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a69:	85 c0                	test   %eax,%eax
f0104a6b:	75 07                	jne    f0104a74 <__pf_read_env_table+0x17>
f0104a6d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a72:	eb 3a                	jmp    f0104aae <__pf_read_env_table+0x51>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104a74:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a77:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104a7a:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104a7d:	c1 ea 16             	shr    $0x16,%edx
f0104a80:	c1 e2 02             	shl    $0x2,%edx
f0104a83:	01 d0                	add    %edx,%eax
f0104a85:	8b 00                	mov    (%eax),%eax
f0104a87:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104a8a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104a8e:	75 07                	jne    f0104a97 <__pf_read_env_table+0x3a>
f0104a90:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104a95:	eb 17                	jmp    f0104aae <__pf_read_env_table+0x51>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0104a97:	83 ec 08             	sub    $0x8,%esp
f0104a9a:	ff 75 10             	pushl  0x10(%ebp)
f0104a9d:	ff 75 f4             	pushl  -0xc(%ebp)
f0104aa0:	e8 ab f1 ff ff       	call   f0103c50 <read_disk_page>
f0104aa5:	83 c4 10             	add    $0x10,%esp
f0104aa8:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104aab:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104aae:	c9                   	leave  
f0104aaf:	c3                   	ret    

f0104ab0 <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0104ab0:	55                   	push   %ebp
f0104ab1:	89 e5                	mov    %esp,%ebp
f0104ab3:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104ab6:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ab9:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104abc:	85 c0                	test   %eax,%eax
f0104abe:	74 4c                	je     f0104b0c <__pf_remove_env_all_tables+0x5c>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104ac0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104ac7:	eb 38                	jmp    f0104b01 <__pf_remove_env_all_tables+0x51>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104ac9:	8b 45 08             	mov    0x8(%ebp),%eax
f0104acc:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104acf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104ad2:	c1 e2 02             	shl    $0x2,%edx
f0104ad5:	01 d0                	add    %edx,%eax
f0104ad7:	8b 00                	mov    (%eax),%eax
f0104ad9:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0104adc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104adf:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104ae2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104ae5:	c1 e2 02             	shl    $0x2,%edx
f0104ae8:	01 d0                	add    %edx,%eax
f0104aea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0104af0:	83 ec 0c             	sub    $0xc,%esp
f0104af3:	ff 75 f0             	pushl  -0x10(%ebp)
f0104af6:	e8 5b f4 ff ff       	call   f0103f56 <free_disk_frame>
f0104afb:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104afe:	ff 45 f4             	incl   -0xc(%ebp)
f0104b01:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104b08:	76 bf                	jbe    f0104ac9 <__pf_remove_env_all_tables+0x19>
f0104b0a:	eb 01                	jmp    f0104b0d <__pf_remove_env_all_tables+0x5d>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104b0c:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0104b0d:	c9                   	leave  
f0104b0e:	c3                   	ret    

f0104b0f <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0104b0f:	55                   	push   %ebp
f0104b10:	89 e5                	mov    %esp,%ebp
f0104b12:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0104b15:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104b19:	75 10                	jne    f0104b2b <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0104b1b:	83 ec 0c             	sub    $0xc,%esp
f0104b1e:	68 14 3b 12 f0       	push   $0xf0123b14
f0104b23:	e8 63 c4 ff ff       	call   f0100f8b <cprintf>
f0104b28:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0104b2b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b2e:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104b31:	85 c0                	test   %eax,%eax
f0104b33:	74 3d                	je     f0104b72 <__pf_remove_env_table+0x63>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104b35:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b38:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104b3b:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104b3e:	c1 ea 16             	shr    $0x16,%edx
f0104b41:	c1 e2 02             	shl    $0x2,%edx
f0104b44:	01 d0                	add    %edx,%eax
f0104b46:	8b 00                	mov    (%eax),%eax
f0104b48:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0104b4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b4e:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104b51:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104b54:	c1 ea 16             	shr    $0x16,%edx
f0104b57:	c1 e2 02             	shl    $0x2,%edx
f0104b5a:	01 d0                	add    %edx,%eax
f0104b5c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0104b62:	83 ec 0c             	sub    $0xc,%esp
f0104b65:	ff 75 f4             	pushl  -0xc(%ebp)
f0104b68:	e8 e9 f3 ff ff       	call   f0103f56 <free_disk_frame>
f0104b6d:	83 c4 10             	add    $0x10,%esp
f0104b70:	eb 01                	jmp    f0104b73 <__pf_remove_env_table+0x64>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104b72:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104b73:	c9                   	leave  
f0104b74:	c3                   	ret    

f0104b75 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104b75:	55                   	push   %ebp
f0104b76:	89 e5                	mov    %esp,%ebp
f0104b78:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104b7b:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104b82:	eb 1f                	jmp    f0104ba3 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104b84:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104b87:	83 ec 04             	sub    $0x4,%esp
f0104b8a:	6a 08                	push   $0x8
f0104b8c:	ff 75 08             	pushl  0x8(%ebp)
f0104b8f:	50                   	push   %eax
f0104b90:	e8 72 a9 01 00       	call   f011f507 <ide_write>
f0104b95:	83 c4 10             	add    $0x10,%esp
f0104b98:	85 c0                	test   %eax,%eax
f0104b9a:	75 12                	jne    f0104bae <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0104b9c:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104ba3:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104baa:	7e d8                	jle    f0104b84 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104bac:	eb 01                	jmp    f0104baf <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0104bae:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0104baf:	90                   	nop
f0104bb0:	c9                   	leave  
f0104bb1:	c3                   	ret    

f0104bb2 <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104bb2:	55                   	push   %ebp
  pushl %eax
f0104bb3:	50                   	push   %eax
  pushl %ebx
f0104bb4:	53                   	push   %ebx
  pushl %ecx
f0104bb5:	51                   	push   %ecx
  pushl %edx
f0104bb6:	52                   	push   %edx
  pushl %esi
f0104bb7:	56                   	push   %esi
  pushl %edi
f0104bb8:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104bb9:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0104bbd:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0104bc1:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104bc3:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104bc5:	5f                   	pop    %edi
  popl %esi
f0104bc6:	5e                   	pop    %esi
  popl %edx
f0104bc7:	5a                   	pop    %edx
  popl %ecx
f0104bc8:	59                   	pop    %ecx
  popl %ebx
f0104bc9:	5b                   	pop    %ebx
  popl %eax
f0104bca:	58                   	pop    %eax
  popl %ebp
f0104bcb:	5d                   	pop    %ebp
  ret
f0104bcc:	c3                   	ret    

f0104bcd <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0104bcd:	55                   	push   %ebp
f0104bce:	89 e5                	mov    %esp,%ebp
f0104bd0:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104bd3:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bd6:	0f b6 c0             	movzbl %al,%eax
f0104bd9:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104be0:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104be3:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104be6:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104be9:	ee                   	out    %al,(%dx)
f0104bea:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104bf1:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104bf4:	89 c2                	mov    %eax,%edx
f0104bf6:	ec                   	in     (%dx),%al
f0104bf7:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104bfa:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0104bfd:	0f b6 c0             	movzbl %al,%eax
}
f0104c00:	c9                   	leave  
f0104c01:	c3                   	ret    

f0104c02 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104c02:	55                   	push   %ebp
f0104c03:	89 e5                	mov    %esp,%ebp
f0104c05:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104c08:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c0b:	0f b6 c0             	movzbl %al,%eax
f0104c0e:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0104c15:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104c18:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104c1b:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104c1e:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0104c1f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104c22:	0f b6 c0             	movzbl %al,%eax
f0104c25:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0104c2c:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104c2f:	8a 45 f7             	mov    -0x9(%ebp),%al
f0104c32:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0104c35:	ee                   	out    %al,(%dx)
}
f0104c36:	90                   	nop
f0104c37:	c9                   	leave  
f0104c38:	c3                   	ret    

f0104c39 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0104c39:	55                   	push   %ebp
f0104c3a:	89 e5                	mov    %esp,%ebp
f0104c3c:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0104c3f:	c7 05 08 cb 5e f0 00 	movl   $0x0,0xf05ecb08
f0104c46:	00 00 00 
f0104c49:	c7 05 0c cb 5e f0 00 	movl   $0x0,0xf05ecb0c
f0104c50:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0104c53:	83 ec 08             	sub    $0x8,%esp
f0104c56:	68 f7 6b 10 f0       	push   $0xf0106bf7
f0104c5b:	6a 00                	push   $0x0
f0104c5d:	e8 88 87 00 00       	call   f010d3ea <irq_install_handler>
f0104c62:	83 c4 10             	add    $0x10,%esp
}
f0104c65:	90                   	nop
f0104c66:	c9                   	leave  
f0104c67:	c3                   	ret    

f0104c68 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0104c68:	55                   	push   %ebp
f0104c69:	89 e5                	mov    %esp,%ebp
f0104c6b:	53                   	push   %ebx
f0104c6c:	83 ec 24             	sub    $0x24,%esp
f0104c6f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c72:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104c75:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104c7c:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104c80:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104c83:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104c86:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104c87:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104c8b:	77 48                	ja     f0104cd5 <kclock_start+0x6d>
f0104c8d:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104c94:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104c98:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104c9b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c9e:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0104c9f:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104ca3:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104ca8:	99                   	cltd   
f0104ca9:	f7 fb                	idiv   %ebx
f0104cab:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104cb1:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104cb5:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104cba:	99                   	cltd   
f0104cbb:	f7 fb                	idiv   %ebx
f0104cbd:	89 c3                	mov    %eax,%ebx
f0104cbf:	89 c8                	mov    %ecx,%eax
f0104cc1:	99                   	cltd   
f0104cc2:	f7 fb                	idiv   %ebx
f0104cc4:	0f b7 c0             	movzwl %ax,%eax
f0104cc7:	83 ec 0c             	sub    $0xc,%esp
f0104cca:	50                   	push   %eax
f0104ccb:	e8 b3 01 00 00       	call   f0104e83 <kclock_write_cnt0_LSB_first>
f0104cd0:	83 c4 10             	add    $0x10,%esp
f0104cd3:	eb 13                	jmp    f0104ce8 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104cd5:	6a 35                	push   $0x35
f0104cd7:	68 38 3b 12 f0       	push   $0xf0123b38
f0104cdc:	6a 41                	push   $0x41
f0104cde:	68 94 3b 12 f0       	push   $0xf0123b94
f0104ce3:	e8 51 b6 ff ff       	call   f0100339 <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104ce8:	83 ec 0c             	sub    $0xc,%esp
f0104ceb:	6a 00                	push   $0x0
f0104ced:	e8 3a 23 00 00       	call   f010702c <irq_clear_mask>
f0104cf2:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104cf5:	90                   	nop
f0104cf6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104cf9:	c9                   	leave  
f0104cfa:	c3                   	ret    

f0104cfb <kclock_stop>:

void
kclock_stop(void)
{
f0104cfb:	55                   	push   %ebp
f0104cfc:	89 e5                	mov    %esp,%ebp
f0104cfe:	83 ec 18             	sub    $0x18,%esp
f0104d01:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104d08:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104d0c:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104d0f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d12:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0104d13:	83 ec 0c             	sub    $0xc,%esp
f0104d16:	6a 00                	push   $0x0
f0104d18:	e8 9a 22 00 00       	call   f0106fb7 <irq_set_mask>
f0104d1d:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0104d20:	90                   	nop
f0104d21:	c9                   	leave  
f0104d22:	c3                   	ret    

f0104d23 <kclock_resume>:

void
kclock_resume(void)
{
f0104d23:	55                   	push   %ebp
f0104d24:	89 e5                	mov    %esp,%ebp
f0104d26:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0104d29:	e8 f5 01 00 00       	call   f0104f23 <kclock_read_cnt0_latch>
f0104d2e:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0104d32:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0104d37:	77 06                	ja     f0104d3f <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0104d39:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0104d3f:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d43:	83 e0 01             	and    $0x1,%eax
f0104d46:	66 85 c0             	test   %ax,%ax
f0104d49:	74 09                	je     f0104d54 <kclock_resume+0x31>
		cnt0++;
f0104d4b:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0104d4f:	40                   	inc    %eax
f0104d50:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0104d54:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104d5b:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104d5f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104d62:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104d65:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104d66:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0104d6a:	83 ec 0c             	sub    $0xc,%esp
f0104d6d:	50                   	push   %eax
f0104d6e:	e8 10 01 00 00       	call   f0104e83 <kclock_write_cnt0_LSB_first>
f0104d73:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104d76:	83 ec 0c             	sub    $0xc,%esp
f0104d79:	6a 00                	push   $0x0
f0104d7b:	e8 ac 22 00 00       	call   f010702c <irq_clear_mask>
f0104d80:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104d83:	90                   	nop
f0104d84:	c9                   	leave  
f0104d85:	c3                   	ret    

f0104d86 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104d86:	55                   	push   %ebp
f0104d87:	89 e5                	mov    %esp,%ebp
f0104d89:	83 ec 28             	sub    $0x28,%esp
f0104d8c:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d8f:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104d92:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104d99:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104d9d:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104da0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104da3:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104da4:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104da8:	83 ec 0c             	sub    $0xc,%esp
f0104dab:	50                   	push   %eax
f0104dac:	e8 d2 00 00 00       	call   f0104e83 <kclock_write_cnt0_LSB_first>
f0104db1:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104db4:	83 ec 0c             	sub    $0xc,%esp
f0104db7:	6a 00                	push   $0x0
f0104db9:	e8 6e 22 00 00       	call   f010702c <irq_clear_mask>
f0104dbe:	83 c4 10             	add    $0x10,%esp
}
f0104dc1:	90                   	nop
f0104dc2:	c9                   	leave  
f0104dc3:	c3                   	ret    

f0104dc4 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104dc4:	55                   	push   %ebp
f0104dc5:	89 e5                	mov    %esp,%ebp
f0104dc7:	56                   	push   %esi
f0104dc8:	53                   	push   %ebx
f0104dc9:	83 ec 20             	sub    $0x20,%esp
f0104dcc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104dcf:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104dd2:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104dd6:	0f 87 8a 00 00 00    	ja     f0104e66 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104ddc:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104de0:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104de5:	99                   	cltd   
f0104de6:	f7 fe                	idiv   %esi
f0104de8:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104dee:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104df2:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104df7:	99                   	cltd   
f0104df8:	f7 fb                	idiv   %ebx
f0104dfa:	89 c6                	mov    %eax,%esi
f0104dfc:	89 c8                	mov    %ecx,%eax
f0104dfe:	99                   	cltd   
f0104dff:	f7 fe                	idiv   %esi
f0104e01:	89 c3                	mov    %eax,%ebx
f0104e03:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104e07:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104e0c:	99                   	cltd   
f0104e0d:	f7 f9                	idiv   %ecx
f0104e0f:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104e15:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104e19:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104e1e:	99                   	cltd   
f0104e1f:	f7 fe                	idiv   %esi
f0104e21:	89 c6                	mov    %eax,%esi
f0104e23:	89 c8                	mov    %ecx,%eax
f0104e25:	99                   	cltd   
f0104e26:	f7 fe                	idiv   %esi
f0104e28:	25 01 00 00 80       	and    $0x80000001,%eax
f0104e2d:	85 c0                	test   %eax,%eax
f0104e2f:	79 05                	jns    f0104e36 <kclock_set_quantum+0x72>
f0104e31:	48                   	dec    %eax
f0104e32:	83 c8 fe             	or     $0xfffffffe,%eax
f0104e35:	40                   	inc    %eax
f0104e36:	01 d8                	add    %ebx,%eax
f0104e38:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104e3b:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104e42:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104e46:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104e49:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e4c:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104e4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104e50:	0f b7 c0             	movzwl %ax,%eax
f0104e53:	83 ec 0c             	sub    $0xc,%esp
f0104e56:	50                   	push   %eax
f0104e57:	e8 27 00 00 00       	call   f0104e83 <kclock_write_cnt0_LSB_first>
f0104e5c:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0104e5f:	e8 97 fe ff ff       	call   f0104cfb <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0104e64:	eb 16                	jmp    f0104e7c <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104e66:	6a 35                	push   $0x35
f0104e68:	68 38 3b 12 f0       	push   $0xf0123b38
f0104e6d:	68 ea 00 00 00       	push   $0xea
f0104e72:	68 94 3b 12 f0       	push   $0xf0123b94
f0104e77:	e8 bd b4 ff ff       	call   f0100339 <_panic>
	}
}
f0104e7c:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104e7f:	5b                   	pop    %ebx
f0104e80:	5e                   	pop    %esi
f0104e81:	5d                   	pop    %ebp
f0104e82:	c3                   	ret    

f0104e83 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0104e83:	55                   	push   %ebp
f0104e84:	89 e5                	mov    %esp,%ebp
f0104e86:	83 ec 28             	sub    $0x28,%esp
f0104e89:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e8c:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0104e90:	e8 72 23 00 00       	call   f0107207 <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0104e95:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104e98:	0f b6 c0             	movzbl %al,%eax
f0104e9b:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0104ea2:	88 45 ee             	mov    %al,-0x12(%ebp)
f0104ea5:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104ea8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104eab:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0104eac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104eaf:	66 c1 e8 08          	shr    $0x8,%ax
f0104eb3:	0f b6 c0             	movzbl %al,%eax
f0104eb6:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0104ebd:	88 45 ef             	mov    %al,-0x11(%ebp)
f0104ec0:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104ec3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104ec6:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0104ec7:	e8 8d 23 00 00       	call   f0107259 <popcli>

}
f0104ecc:	90                   	nop
f0104ecd:	c9                   	leave  
f0104ece:	c3                   	ret    

f0104ecf <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0104ecf:	55                   	push   %ebp
f0104ed0:	89 e5                	mov    %esp,%ebp
f0104ed2:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0104ed5:	e8 2d 23 00 00       	call   f0107207 <pushcli>
f0104eda:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104ee1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104ee4:	89 c2                	mov    %eax,%edx
f0104ee6:	ec                   	in     (%dx),%al
f0104ee7:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0104eea:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104eed:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104ef0:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104ef7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104efa:	89 c2                	mov    %eax,%edx
f0104efc:	ec                   	in     (%dx),%al
f0104efd:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0104f00:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104f03:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104f06:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0104f0a:	c1 e0 08             	shl    $0x8,%eax
f0104f0d:	89 c2                	mov    %eax,%edx
f0104f0f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104f13:	09 d0                	or     %edx,%eax
f0104f15:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0104f19:	e8 3b 23 00 00       	call   f0107259 <popcli>
	return cnt0 ;
f0104f1e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104f21:	c9                   	leave  
f0104f22:	c3                   	ret    

f0104f23 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0104f23:	55                   	push   %ebp
f0104f24:	89 e5                	mov    %esp,%ebp
f0104f26:	83 ec 30             	sub    $0x30,%esp
f0104f29:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f30:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104f33:	89 c2                	mov    %eax,%edx
f0104f35:	ec                   	in     (%dx),%al
f0104f36:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0104f39:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0104f3c:	88 45 ff             	mov    %al,-0x1(%ebp)
f0104f3f:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104f46:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f4a:	8a 45 dc             	mov    -0x24(%ebp),%al
f0104f4d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104f50:	ee                   	out    %al,(%dx)
f0104f51:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f58:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104f5b:	89 c2                	mov    %eax,%edx
f0104f5d:	ec                   	in     (%dx),%al
f0104f5e:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0104f61:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104f64:	88 45 f3             	mov    %al,-0xd(%ebp)
f0104f67:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104f6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104f71:	89 c2                	mov    %eax,%edx
f0104f73:	ec                   	in     (%dx),%al
f0104f74:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0104f77:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104f7a:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104f7d:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0104f81:	c1 e0 08             	shl    $0x8,%eax
f0104f84:	89 c2                	mov    %eax,%edx
f0104f86:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0104f8a:	09 d0                	or     %edx,%eax
f0104f8c:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0104f90:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0104f94:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0104f9b:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104f9e:	8a 45 df             	mov    -0x21(%ebp),%al
f0104fa1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0104fa4:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0104fa5:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0104fa8:	c9                   	leave  
f0104fa9:	c3                   	ret    

f0104faa <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0104faa:	55                   	push   %ebp
f0104fab:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104fad:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104fb1:	74 1d                	je     f0104fd0 <init_queue+0x26>
	{
		LIST_INIT(queue);
f0104fb3:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fb6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104fbc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fbf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104fc6:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fc9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0104fd0:	90                   	nop
f0104fd1:	5d                   	pop    %ebp
f0104fd2:	c3                   	ret    

f0104fd3 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0104fd3:	55                   	push   %ebp
f0104fd4:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104fd6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104fda:	74 08                	je     f0104fe4 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0104fdc:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fdf:	8b 40 0c             	mov    0xc(%eax),%eax
f0104fe2:	eb 05                	jmp    f0104fe9 <queue_size+0x16>
	}
	else
	{
		return 0;
f0104fe4:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0104fe9:	5d                   	pop    %ebp
f0104fea:	c3                   	ret    

f0104feb <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0104feb:	55                   	push   %ebp
f0104fec:	89 e5                	mov    %esp,%ebp
f0104fee:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104ff1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104ff5:	75 16                	jne    f010500d <enqueue+0x22>
f0104ff7:	68 a8 3b 12 f0       	push   $0xf0123ba8
f0104ffc:	68 b6 3b 12 f0       	push   $0xf0123bb6
f0105001:	6a 34                	push   $0x34
f0105003:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105008:	e8 2c b3 ff ff       	call   f0100339 <_panic>
	if(env != NULL)
f010500d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105011:	74 66                	je     f0105079 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0105013:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105017:	75 14                	jne    f010502d <enqueue+0x42>
f0105019:	83 ec 04             	sub    $0x4,%esp
f010501c:	68 e4 3b 12 f0       	push   $0xf0123be4
f0105021:	6a 37                	push   $0x37
f0105023:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105028:	e8 0c b3 ff ff       	call   f0100339 <_panic>
f010502d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105030:	8b 10                	mov    (%eax),%edx
f0105032:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105035:	89 50 08             	mov    %edx,0x8(%eax)
f0105038:	8b 45 0c             	mov    0xc(%ebp),%eax
f010503b:	8b 40 08             	mov    0x8(%eax),%eax
f010503e:	85 c0                	test   %eax,%eax
f0105040:	74 0d                	je     f010504f <enqueue+0x64>
f0105042:	8b 45 08             	mov    0x8(%ebp),%eax
f0105045:	8b 00                	mov    (%eax),%eax
f0105047:	8b 55 0c             	mov    0xc(%ebp),%edx
f010504a:	89 50 0c             	mov    %edx,0xc(%eax)
f010504d:	eb 09                	jmp    f0105058 <enqueue+0x6d>
f010504f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105052:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105055:	89 50 04             	mov    %edx,0x4(%eax)
f0105058:	8b 45 08             	mov    0x8(%ebp),%eax
f010505b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010505e:	89 10                	mov    %edx,(%eax)
f0105060:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105063:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010506a:	8b 45 08             	mov    0x8(%ebp),%eax
f010506d:	8b 40 0c             	mov    0xc(%eax),%eax
f0105070:	8d 50 01             	lea    0x1(%eax),%edx
f0105073:	8b 45 08             	mov    0x8(%ebp),%eax
f0105076:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105079:	90                   	nop
f010507a:	c9                   	leave  
f010507b:	c3                   	ret    

f010507c <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f010507c:	55                   	push   %ebp
f010507d:	89 e5                	mov    %esp,%ebp
f010507f:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0105082:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105086:	75 0a                	jne    f0105092 <dequeue+0x16>
f0105088:	b8 00 00 00 00       	mov    $0x0,%eax
f010508d:	e9 a0 00 00 00       	jmp    f0105132 <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0105092:	8b 45 08             	mov    0x8(%ebp),%eax
f0105095:	8b 40 04             	mov    0x4(%eax),%eax
f0105098:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f010509b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010509f:	0f 84 8a 00 00 00    	je     f010512f <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f01050a5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01050a9:	75 14                	jne    f01050bf <dequeue+0x43>
f01050ab:	83 ec 04             	sub    $0x4,%esp
f01050ae:	68 07 3c 12 f0       	push   $0xf0123c07
f01050b3:	6a 44                	push   $0x44
f01050b5:	68 cb 3b 12 f0       	push   $0xf0123bcb
f01050ba:	e8 7a b2 ff ff       	call   f0100339 <_panic>
f01050bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050c2:	8b 40 08             	mov    0x8(%eax),%eax
f01050c5:	85 c0                	test   %eax,%eax
f01050c7:	74 11                	je     f01050da <dequeue+0x5e>
f01050c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050cc:	8b 40 08             	mov    0x8(%eax),%eax
f01050cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01050d2:	8b 52 0c             	mov    0xc(%edx),%edx
f01050d5:	89 50 0c             	mov    %edx,0xc(%eax)
f01050d8:	eb 0c                	jmp    f01050e6 <dequeue+0x6a>
f01050da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050dd:	8b 50 0c             	mov    0xc(%eax),%edx
f01050e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01050e3:	89 50 04             	mov    %edx,0x4(%eax)
f01050e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050e9:	8b 40 0c             	mov    0xc(%eax),%eax
f01050ec:	85 c0                	test   %eax,%eax
f01050ee:	74 11                	je     f0105101 <dequeue+0x85>
f01050f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050f3:	8b 40 0c             	mov    0xc(%eax),%eax
f01050f6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01050f9:	8b 52 08             	mov    0x8(%edx),%edx
f01050fc:	89 50 08             	mov    %edx,0x8(%eax)
f01050ff:	eb 0b                	jmp    f010510c <dequeue+0x90>
f0105101:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105104:	8b 50 08             	mov    0x8(%eax),%edx
f0105107:	8b 45 08             	mov    0x8(%ebp),%eax
f010510a:	89 10                	mov    %edx,(%eax)
f010510c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010510f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105116:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105119:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105120:	8b 45 08             	mov    0x8(%ebp),%eax
f0105123:	8b 40 0c             	mov    0xc(%eax),%eax
f0105126:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105129:	8b 45 08             	mov    0x8(%ebp),%eax
f010512c:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f010512f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0105132:	c9                   	leave  
f0105133:	c3                   	ret    

f0105134 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f0105134:	55                   	push   %ebp
f0105135:	89 e5                	mov    %esp,%ebp
f0105137:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f010513a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010513e:	75 16                	jne    f0105156 <remove_from_queue+0x22>
f0105140:	68 a8 3b 12 f0       	push   $0xf0123ba8
f0105145:	68 b6 3b 12 f0       	push   $0xf0123bb6
f010514a:	6a 4e                	push   $0x4e
f010514c:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105151:	e8 e3 b1 ff ff       	call   f0100339 <_panic>

	if (e != NULL)
f0105156:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010515a:	0f 84 8a 00 00 00    	je     f01051ea <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f0105160:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105164:	75 14                	jne    f010517a <remove_from_queue+0x46>
f0105166:	83 ec 04             	sub    $0x4,%esp
f0105169:	68 07 3c 12 f0       	push   $0xf0123c07
f010516e:	6a 52                	push   $0x52
f0105170:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105175:	e8 bf b1 ff ff       	call   f0100339 <_panic>
f010517a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010517d:	8b 40 08             	mov    0x8(%eax),%eax
f0105180:	85 c0                	test   %eax,%eax
f0105182:	74 11                	je     f0105195 <remove_from_queue+0x61>
f0105184:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105187:	8b 40 08             	mov    0x8(%eax),%eax
f010518a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010518d:	8b 52 0c             	mov    0xc(%edx),%edx
f0105190:	89 50 0c             	mov    %edx,0xc(%eax)
f0105193:	eb 0c                	jmp    f01051a1 <remove_from_queue+0x6d>
f0105195:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105198:	8b 50 0c             	mov    0xc(%eax),%edx
f010519b:	8b 45 08             	mov    0x8(%ebp),%eax
f010519e:	89 50 04             	mov    %edx,0x4(%eax)
f01051a1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01051a4:	8b 40 0c             	mov    0xc(%eax),%eax
f01051a7:	85 c0                	test   %eax,%eax
f01051a9:	74 11                	je     f01051bc <remove_from_queue+0x88>
f01051ab:	8b 45 0c             	mov    0xc(%ebp),%eax
f01051ae:	8b 40 0c             	mov    0xc(%eax),%eax
f01051b1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01051b4:	8b 52 08             	mov    0x8(%edx),%edx
f01051b7:	89 50 08             	mov    %edx,0x8(%eax)
f01051ba:	eb 0b                	jmp    f01051c7 <remove_from_queue+0x93>
f01051bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01051bf:	8b 50 08             	mov    0x8(%eax),%edx
f01051c2:	8b 45 08             	mov    0x8(%ebp),%eax
f01051c5:	89 10                	mov    %edx,(%eax)
f01051c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01051ca:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01051d1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01051d4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01051db:	8b 45 08             	mov    0x8(%ebp),%eax
f01051de:	8b 40 0c             	mov    0xc(%eax),%eax
f01051e1:	8d 50 ff             	lea    -0x1(%eax),%edx
f01051e4:	8b 45 08             	mov    0x8(%ebp),%eax
f01051e7:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f01051ea:	90                   	nop
f01051eb:	c9                   	leave  
f01051ec:	c3                   	ret    

f01051ed <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f01051ed:	55                   	push   %ebp
f01051ee:	89 e5                	mov    %esp,%ebp
f01051f0:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f01051f3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01051f7:	75 07                	jne    f0105200 <find_env_in_queue+0x13>
f01051f9:	b8 00 00 00 00       	mov    $0x0,%eax
f01051fe:	eb 58                	jmp    f0105258 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f0105200:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f0105207:	8b 45 08             	mov    0x8(%ebp),%eax
f010520a:	8b 00                	mov    (%eax),%eax
f010520c:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010520f:	eb 19                	jmp    f010522a <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f0105211:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0105214:	8b 40 10             	mov    0x10(%eax),%eax
f0105217:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010521a:	75 05                	jne    f0105221 <find_env_in_queue+0x34>
		{
			return ptr_env;
f010521c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010521f:	eb 37                	jmp    f0105258 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f0105221:	8b 45 08             	mov    0x8(%ebp),%eax
f0105224:	8b 40 08             	mov    0x8(%eax),%eax
f0105227:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010522a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f010522e:	74 08                	je     f0105238 <find_env_in_queue+0x4b>
f0105230:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0105233:	8b 40 08             	mov    0x8(%eax),%eax
f0105236:	eb 05                	jmp    f010523d <find_env_in_queue+0x50>
f0105238:	b8 00 00 00 00       	mov    $0x0,%eax
f010523d:	8b 55 08             	mov    0x8(%ebp),%edx
f0105240:	89 42 08             	mov    %eax,0x8(%edx)
f0105243:	8b 45 08             	mov    0x8(%ebp),%eax
f0105246:	8b 40 08             	mov    0x8(%eax),%eax
f0105249:	85 c0                	test   %eax,%eax
f010524b:	75 c4                	jne    f0105211 <find_env_in_queue+0x24>
f010524d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0105251:	75 be                	jne    f0105211 <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0105253:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0105258:	c9                   	leave  
f0105259:	c3                   	ret    

f010525a <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f010525a:	55                   	push   %ebp
f010525b:	89 e5                	mov    %esp,%ebp
f010525d:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_spinlock(&ProcessQueues.qlock);
f0105260:	83 ec 0c             	sub    $0xc,%esp
f0105263:	68 60 c4 5e f0       	push   $0xf05ec460
f0105268:	e8 52 99 00 00       	call   f010ebbf <acquire_spinlock>
f010526d:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f0105270:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105275:	85 c0                	test   %eax,%eax
f0105277:	74 11                	je     f010528a <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f0105279:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f010527e:	83 ec 0c             	sub    $0xc,%esp
f0105281:	50                   	push   %eax
f0105282:	e8 16 3d 00 00       	call   f0108f9d <kfree>
f0105287:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f010528a:	a1 24 c8 5e f0       	mov    0xf05ec824,%eax
f010528f:	85 c0                	test   %eax,%eax
f0105291:	74 11                	je     f01052a4 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f0105293:	a1 24 c8 5e f0       	mov    0xf05ec824,%eax
f0105298:	83 ec 0c             	sub    $0xc,%esp
f010529b:	50                   	push   %eax
f010529c:	e8 fc 3c 00 00       	call   f0108f9d <kfree>
f01052a1:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&ProcessQueues.qlock);
f01052a4:	83 ec 0c             	sub    $0xc,%esp
f01052a7:	68 60 c4 5e f0       	push   $0xf05ec460
f01052ac:	e8 95 99 00 00       	call   f010ec46 <release_spinlock>
f01052b1:	83 c4 10             	add    $0x10,%esp

#endif
}
f01052b4:	90                   	nop
f01052b5:	c9                   	leave  
f01052b6:	c3                   	ret    

f01052b7 <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f01052b7:	55                   	push   %ebp
f01052b8:	89 e5                	mov    %esp,%ebp
f01052ba:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01052bd:	83 ec 0c             	sub    $0xc,%esp
f01052c0:	68 60 c4 5e f0       	push   $0xf05ec460
f01052c5:	e8 0e 9b 00 00       	call   f010edd8 <holding_spinlock>
f01052ca:	83 c4 10             	add    $0x10,%esp
f01052cd:	85 c0                	test   %eax,%eax
f01052cf:	75 17                	jne    f01052e8 <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01052d1:	83 ec 04             	sub    $0x4,%esp
f01052d4:	68 28 3c 12 f0       	push   $0xf0123c28
f01052d9:	68 85 00 00 00       	push   $0x85
f01052de:	68 cb 3b 12 f0       	push   $0xf0123bcb
f01052e3:	e8 51 b0 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01052e8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052ec:	75 19                	jne    f0105307 <sched_insert_ready0+0x50>
f01052ee:	68 69 3c 12 f0       	push   $0xf0123c69
f01052f3:	68 b6 3b 12 f0       	push   $0xf0123bb6
f01052f8:	68 88 00 00 00       	push   $0x88
f01052fd:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105302:	e8 32 b0 ff ff       	call   f0100339 <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f0105307:	8b 45 08             	mov    0x8(%ebp),%eax
f010530a:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f0105311:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105316:	83 ec 08             	sub    $0x8,%esp
f0105319:	ff 75 08             	pushl  0x8(%ebp)
f010531c:	50                   	push   %eax
f010531d:	e8 c9 fc ff ff       	call   f0104feb <enqueue>
f0105322:	83 c4 10             	add    $0x10,%esp
	}
}
f0105325:	90                   	nop
f0105326:	c9                   	leave  
f0105327:	c3                   	ret    

f0105328 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f0105328:	55                   	push   %ebp
f0105329:	89 e5                	mov    %esp,%ebp
f010532b:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010532e:	83 ec 0c             	sub    $0xc,%esp
f0105331:	68 60 c4 5e f0       	push   $0xf05ec460
f0105336:	e8 9d 9a 00 00       	call   f010edd8 <holding_spinlock>
f010533b:	83 c4 10             	add    $0x10,%esp
f010533e:	85 c0                	test   %eax,%eax
f0105340:	75 17                	jne    f0105359 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105342:	83 ec 04             	sub    $0x4,%esp
f0105345:	68 28 3c 12 f0       	push   $0xf0123c28
f010534a:	68 97 00 00 00       	push   $0x97
f010534f:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105354:	e8 e0 af ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0105359:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010535d:	74 0b                	je     f010536a <sched_remove_ready+0x42>
f010535f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105362:	8b 40 18             	mov    0x18(%eax),%eax
f0105365:	83 f8 01             	cmp    $0x1,%eax
f0105368:	74 19                	je     f0105383 <sched_remove_ready+0x5b>
f010536a:	68 78 3c 12 f0       	push   $0xf0123c78
f010536f:	68 b6 3b 12 f0       	push   $0xf0123bb6
f0105374:	68 9a 00 00 00       	push   $0x9a
f0105379:	68 cb 3b 12 f0       	push   $0xf0123bcb
f010537e:	e8 b6 af ff ff       	call   f0100339 <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105383:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010538a:	e9 e4 00 00 00       	jmp    f0105473 <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f010538f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105392:	8b 40 10             	mov    0x10(%eax),%eax
f0105395:	89 c2                	mov    %eax,%edx
f0105397:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f010539c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010539f:	c1 e1 04             	shl    $0x4,%ecx
f01053a2:	01 c8                	add    %ecx,%eax
f01053a4:	83 ec 08             	sub    $0x8,%esp
f01053a7:	52                   	push   %edx
f01053a8:	50                   	push   %eax
f01053a9:	e8 3f fe ff ff       	call   f01051ed <find_env_in_queue>
f01053ae:	83 c4 10             	add    $0x10,%esp
f01053b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f01053b4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01053b8:	0f 84 b2 00 00 00    	je     f0105470 <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f01053be:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01053c2:	75 17                	jne    f01053db <sched_remove_ready+0xb3>
f01053c4:	83 ec 04             	sub    $0x4,%esp
f01053c7:	68 07 3c 12 f0       	push   $0xf0123c07
f01053cc:	68 a1 00 00 00       	push   $0xa1
f01053d1:	68 cb 3b 12 f0       	push   $0xf0123bcb
f01053d6:	e8 5e af ff ff       	call   f0100339 <_panic>
f01053db:	8b 45 08             	mov    0x8(%ebp),%eax
f01053de:	8b 40 08             	mov    0x8(%eax),%eax
f01053e1:	85 c0                	test   %eax,%eax
f01053e3:	74 11                	je     f01053f6 <sched_remove_ready+0xce>
f01053e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01053e8:	8b 40 08             	mov    0x8(%eax),%eax
f01053eb:	8b 55 08             	mov    0x8(%ebp),%edx
f01053ee:	8b 52 0c             	mov    0xc(%edx),%edx
f01053f1:	89 50 0c             	mov    %edx,0xc(%eax)
f01053f4:	eb 16                	jmp    f010540c <sched_remove_ready+0xe4>
f01053f6:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f01053fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01053fe:	c1 e2 04             	shl    $0x4,%edx
f0105401:	01 c2                	add    %eax,%edx
f0105403:	8b 45 08             	mov    0x8(%ebp),%eax
f0105406:	8b 40 0c             	mov    0xc(%eax),%eax
f0105409:	89 42 04             	mov    %eax,0x4(%edx)
f010540c:	8b 45 08             	mov    0x8(%ebp),%eax
f010540f:	8b 40 0c             	mov    0xc(%eax),%eax
f0105412:	85 c0                	test   %eax,%eax
f0105414:	74 11                	je     f0105427 <sched_remove_ready+0xff>
f0105416:	8b 45 08             	mov    0x8(%ebp),%eax
f0105419:	8b 40 0c             	mov    0xc(%eax),%eax
f010541c:	8b 55 08             	mov    0x8(%ebp),%edx
f010541f:	8b 52 08             	mov    0x8(%edx),%edx
f0105422:	89 50 08             	mov    %edx,0x8(%eax)
f0105425:	eb 15                	jmp    f010543c <sched_remove_ready+0x114>
f0105427:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f010542c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010542f:	c1 e2 04             	shl    $0x4,%edx
f0105432:	01 c2                	add    %eax,%edx
f0105434:	8b 45 08             	mov    0x8(%ebp),%eax
f0105437:	8b 40 08             	mov    0x8(%eax),%eax
f010543a:	89 02                	mov    %eax,(%edx)
f010543c:	8b 45 08             	mov    0x8(%ebp),%eax
f010543f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105446:	8b 45 08             	mov    0x8(%ebp),%eax
f0105449:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105450:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105455:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105458:	c1 e2 04             	shl    $0x4,%edx
f010545b:	01 d0                	add    %edx,%eax
f010545d:	8b 50 0c             	mov    0xc(%eax),%edx
f0105460:	4a                   	dec    %edx
f0105461:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f0105464:	8b 45 08             	mov    0x8(%ebp),%eax
f0105467:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f010546e:	eb 14                	jmp    f0105484 <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105470:	ff 45 f4             	incl   -0xc(%ebp)
f0105473:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f0105478:	0f b6 c0             	movzbl %al,%eax
f010547b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010547e:	0f 8f 0b ff ff ff    	jg     f010538f <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f0105484:	c9                   	leave  
f0105485:	c3                   	ret    

f0105486 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f0105486:	55                   	push   %ebp
f0105487:	89 e5                	mov    %esp,%ebp
f0105489:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010548c:	83 ec 0c             	sub    $0xc,%esp
f010548f:	68 60 c4 5e f0       	push   $0xf05ec460
f0105494:	e8 3f 99 00 00       	call   f010edd8 <holding_spinlock>
f0105499:	83 c4 10             	add    $0x10,%esp
f010549c:	85 c0                	test   %eax,%eax
f010549e:	75 17                	jne    f01054b7 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01054a0:	83 ec 04             	sub    $0x4,%esp
f01054a3:	68 28 3c 12 f0       	push   $0xf0123c28
f01054a8:	68 b0 00 00 00       	push   $0xb0
f01054ad:	68 cb 3b 12 f0       	push   $0xf0123bcb
f01054b2:	e8 82 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01054b7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01054bb:	75 19                	jne    f01054d6 <sched_insert_new+0x50>
f01054bd:	68 69 3c 12 f0       	push   $0xf0123c69
f01054c2:	68 b6 3b 12 f0       	push   $0xf0123bb6
f01054c7:	68 b3 00 00 00       	push   $0xb3
f01054cc:	68 cb 3b 12 f0       	push   $0xf0123bcb
f01054d1:	e8 63 ae ff ff       	call   f0100339 <_panic>
	{
		env->env_status = ENV_NEW ;
f01054d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01054d9:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f01054e0:	83 ec 08             	sub    $0x8,%esp
f01054e3:	ff 75 08             	pushl  0x8(%ebp)
f01054e6:	68 d0 c4 5e f0       	push   $0xf05ec4d0
f01054eb:	e8 fb fa ff ff       	call   f0104feb <enqueue>
f01054f0:	83 c4 10             	add    $0x10,%esp
	}
}
f01054f3:	90                   	nop
f01054f4:	c9                   	leave  
f01054f5:	c3                   	ret    

f01054f6 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f01054f6:	55                   	push   %ebp
f01054f7:	89 e5                	mov    %esp,%ebp
f01054f9:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01054fc:	83 ec 0c             	sub    $0xc,%esp
f01054ff:	68 60 c4 5e f0       	push   $0xf05ec460
f0105504:	e8 cf 98 00 00       	call   f010edd8 <holding_spinlock>
f0105509:	83 c4 10             	add    $0x10,%esp
f010550c:	85 c0                	test   %eax,%eax
f010550e:	75 17                	jne    f0105527 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105510:	83 ec 04             	sub    $0x4,%esp
f0105513:	68 28 3c 12 f0       	push   $0xf0123c28
f0105518:	68 c1 00 00 00       	push   $0xc1
f010551d:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105522:	e8 12 ae ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f0105527:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010552b:	74 0b                	je     f0105538 <sched_remove_new+0x42>
f010552d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105530:	8b 40 18             	mov    0x18(%eax),%eax
f0105533:	83 f8 04             	cmp    $0x4,%eax
f0105536:	74 19                	je     f0105551 <sched_remove_new+0x5b>
f0105538:	68 a4 3c 12 f0       	push   $0xf0123ca4
f010553d:	68 b6 3b 12 f0       	push   $0xf0123bb6
f0105542:	68 c4 00 00 00       	push   $0xc4
f0105547:	68 cb 3b 12 f0       	push   $0xf0123bcb
f010554c:	e8 e8 ad ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f0105551:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105555:	75 17                	jne    f010556e <sched_remove_new+0x78>
f0105557:	83 ec 04             	sub    $0x4,%esp
f010555a:	68 07 3c 12 f0       	push   $0xf0123c07
f010555f:	68 c6 00 00 00       	push   $0xc6
f0105564:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105569:	e8 cb ad ff ff       	call   f0100339 <_panic>
f010556e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105571:	8b 40 08             	mov    0x8(%eax),%eax
f0105574:	85 c0                	test   %eax,%eax
f0105576:	74 11                	je     f0105589 <sched_remove_new+0x93>
f0105578:	8b 45 08             	mov    0x8(%ebp),%eax
f010557b:	8b 40 08             	mov    0x8(%eax),%eax
f010557e:	8b 55 08             	mov    0x8(%ebp),%edx
f0105581:	8b 52 0c             	mov    0xc(%edx),%edx
f0105584:	89 50 0c             	mov    %edx,0xc(%eax)
f0105587:	eb 0b                	jmp    f0105594 <sched_remove_new+0x9e>
f0105589:	8b 45 08             	mov    0x8(%ebp),%eax
f010558c:	8b 40 0c             	mov    0xc(%eax),%eax
f010558f:	a3 d4 c4 5e f0       	mov    %eax,0xf05ec4d4
f0105594:	8b 45 08             	mov    0x8(%ebp),%eax
f0105597:	8b 40 0c             	mov    0xc(%eax),%eax
f010559a:	85 c0                	test   %eax,%eax
f010559c:	74 11                	je     f01055af <sched_remove_new+0xb9>
f010559e:	8b 45 08             	mov    0x8(%ebp),%eax
f01055a1:	8b 40 0c             	mov    0xc(%eax),%eax
f01055a4:	8b 55 08             	mov    0x8(%ebp),%edx
f01055a7:	8b 52 08             	mov    0x8(%edx),%edx
f01055aa:	89 50 08             	mov    %edx,0x8(%eax)
f01055ad:	eb 0b                	jmp    f01055ba <sched_remove_new+0xc4>
f01055af:	8b 45 08             	mov    0x8(%ebp),%eax
f01055b2:	8b 40 08             	mov    0x8(%eax),%eax
f01055b5:	a3 d0 c4 5e f0       	mov    %eax,0xf05ec4d0
f01055ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01055bd:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01055c4:	8b 45 08             	mov    0x8(%ebp),%eax
f01055c7:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01055ce:	a1 dc c4 5e f0       	mov    0xf05ec4dc,%eax
f01055d3:	48                   	dec    %eax
f01055d4:	a3 dc c4 5e f0       	mov    %eax,0xf05ec4dc
		env->env_status = ENV_UNKNOWN;
f01055d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01055dc:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f01055e3:	90                   	nop
f01055e4:	c9                   	leave  
f01055e5:	c3                   	ret    

f01055e6 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f01055e6:	55                   	push   %ebp
f01055e7:	89 e5                	mov    %esp,%ebp
f01055e9:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01055ec:	83 ec 0c             	sub    $0xc,%esp
f01055ef:	68 60 c4 5e f0       	push   $0xf05ec460
f01055f4:	e8 df 97 00 00       	call   f010edd8 <holding_spinlock>
f01055f9:	83 c4 10             	add    $0x10,%esp
f01055fc:	85 c0                	test   %eax,%eax
f01055fe:	75 17                	jne    f0105617 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105600:	83 ec 04             	sub    $0x4,%esp
f0105603:	68 28 3c 12 f0       	push   $0xf0123c28
f0105608:	68 d2 00 00 00       	push   $0xd2
f010560d:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105612:	e8 22 ad ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105617:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010561b:	75 19                	jne    f0105636 <sched_insert_exit+0x50>
f010561d:	68 69 3c 12 f0       	push   $0xf0123c69
f0105622:	68 b6 3b 12 f0       	push   $0xf0123bb6
f0105627:	68 d5 00 00 00       	push   $0xd5
f010562c:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105631:	e8 03 ad ff ff       	call   f0100339 <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f0105636:	e8 e6 91 00 00       	call   f010e821 <isBufferingEnabled>
f010563b:	84 c0                	test   %al,%al
f010563d:	74 0e                	je     f010564d <sched_insert_exit+0x67>
f010563f:	83 ec 0c             	sub    $0xc,%esp
f0105642:	ff 75 08             	pushl  0x8(%ebp)
f0105645:	e8 89 67 00 00       	call   f010bdd3 <cleanup_buffers>
f010564a:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f010564d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105650:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f0105657:	83 ec 08             	sub    $0x8,%esp
f010565a:	ff 75 08             	pushl  0x8(%ebp)
f010565d:	68 e0 c4 5e f0       	push   $0xf05ec4e0
f0105662:	e8 84 f9 ff ff       	call   f0104feb <enqueue>
f0105667:	83 c4 10             	add    $0x10,%esp
	}
}
f010566a:	90                   	nop
f010566b:	c9                   	leave  
f010566c:	c3                   	ret    

f010566d <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f010566d:	55                   	push   %ebp
f010566e:	89 e5                	mov    %esp,%ebp
f0105670:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105673:	83 ec 0c             	sub    $0xc,%esp
f0105676:	68 60 c4 5e f0       	push   $0xf05ec460
f010567b:	e8 58 97 00 00       	call   f010edd8 <holding_spinlock>
f0105680:	83 c4 10             	add    $0x10,%esp
f0105683:	85 c0                	test   %eax,%eax
f0105685:	75 17                	jne    f010569e <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105687:	83 ec 04             	sub    $0x4,%esp
f010568a:	68 28 3c 12 f0       	push   $0xf0123c28
f010568f:	68 e3 00 00 00       	push   $0xe3
f0105694:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105699:	e8 9b ac ff ff       	call   f0100339 <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f010569e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01056a2:	74 0b                	je     f01056af <sched_remove_exit+0x42>
f01056a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056a7:	8b 40 18             	mov    0x18(%eax),%eax
f01056aa:	83 f8 05             	cmp    $0x5,%eax
f01056ad:	74 19                	je     f01056c8 <sched_remove_exit+0x5b>
f01056af:	68 d0 3c 12 f0       	push   $0xf0123cd0
f01056b4:	68 b6 3b 12 f0       	push   $0xf0123bb6
f01056b9:	68 e6 00 00 00       	push   $0xe6
f01056be:	68 cb 3b 12 f0       	push   $0xf0123bcb
f01056c3:	e8 71 ac ff ff       	call   f0100339 <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f01056c8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01056cc:	75 17                	jne    f01056e5 <sched_remove_exit+0x78>
f01056ce:	83 ec 04             	sub    $0x4,%esp
f01056d1:	68 07 3c 12 f0       	push   $0xf0123c07
f01056d6:	68 e8 00 00 00       	push   $0xe8
f01056db:	68 cb 3b 12 f0       	push   $0xf0123bcb
f01056e0:	e8 54 ac ff ff       	call   f0100339 <_panic>
f01056e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01056e8:	8b 40 08             	mov    0x8(%eax),%eax
f01056eb:	85 c0                	test   %eax,%eax
f01056ed:	74 11                	je     f0105700 <sched_remove_exit+0x93>
f01056ef:	8b 45 08             	mov    0x8(%ebp),%eax
f01056f2:	8b 40 08             	mov    0x8(%eax),%eax
f01056f5:	8b 55 08             	mov    0x8(%ebp),%edx
f01056f8:	8b 52 0c             	mov    0xc(%edx),%edx
f01056fb:	89 50 0c             	mov    %edx,0xc(%eax)
f01056fe:	eb 0b                	jmp    f010570b <sched_remove_exit+0x9e>
f0105700:	8b 45 08             	mov    0x8(%ebp),%eax
f0105703:	8b 40 0c             	mov    0xc(%eax),%eax
f0105706:	a3 e4 c4 5e f0       	mov    %eax,0xf05ec4e4
f010570b:	8b 45 08             	mov    0x8(%ebp),%eax
f010570e:	8b 40 0c             	mov    0xc(%eax),%eax
f0105711:	85 c0                	test   %eax,%eax
f0105713:	74 11                	je     f0105726 <sched_remove_exit+0xb9>
f0105715:	8b 45 08             	mov    0x8(%ebp),%eax
f0105718:	8b 40 0c             	mov    0xc(%eax),%eax
f010571b:	8b 55 08             	mov    0x8(%ebp),%edx
f010571e:	8b 52 08             	mov    0x8(%edx),%edx
f0105721:	89 50 08             	mov    %edx,0x8(%eax)
f0105724:	eb 0b                	jmp    f0105731 <sched_remove_exit+0xc4>
f0105726:	8b 45 08             	mov    0x8(%ebp),%eax
f0105729:	8b 40 08             	mov    0x8(%eax),%eax
f010572c:	a3 e0 c4 5e f0       	mov    %eax,0xf05ec4e0
f0105731:	8b 45 08             	mov    0x8(%ebp),%eax
f0105734:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010573b:	8b 45 08             	mov    0x8(%ebp),%eax
f010573e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105745:	a1 ec c4 5e f0       	mov    0xf05ec4ec,%eax
f010574a:	48                   	dec    %eax
f010574b:	a3 ec c4 5e f0       	mov    %eax,0xf05ec4ec
		env->env_status = ENV_UNKNOWN;
f0105750:	8b 45 08             	mov    0x8(%ebp),%eax
f0105753:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f010575a:	90                   	nop
f010575b:	c9                   	leave  
f010575c:	c3                   	ret    

f010575d <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f010575d:	55                   	push   %ebp
f010575e:	89 e5                	mov    %esp,%ebp
f0105760:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105763:	83 ec 0c             	sub    $0xc,%esp
f0105766:	68 60 c4 5e f0       	push   $0xf05ec460
f010576b:	e8 4f 94 00 00       	call   f010ebbf <acquire_spinlock>
f0105770:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f0105773:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105777:	75 19                	jne    f0105792 <sched_new_env+0x35>
f0105779:	68 fb 3c 12 f0       	push   $0xf0123cfb
f010577e:	68 b6 3b 12 f0       	push   $0xf0123bb6
f0105783:	68 f6 00 00 00       	push   $0xf6
f0105788:	68 cb 3b 12 f0       	push   $0xf0123bcb
f010578d:	e8 a7 ab ff ff       	call   f0100339 <_panic>
	{
		sched_insert_new(e);
f0105792:	83 ec 0c             	sub    $0xc,%esp
f0105795:	ff 75 08             	pushl  0x8(%ebp)
f0105798:	e8 e9 fc ff ff       	call   f0105486 <sched_insert_new>
f010579d:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01057a0:	83 ec 0c             	sub    $0xc,%esp
f01057a3:	68 60 c4 5e f0       	push   $0xf05ec460
f01057a8:	e8 99 94 00 00       	call   f010ec46 <release_spinlock>
f01057ad:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f01057b0:	90                   	nop
f01057b1:	c9                   	leave  
f01057b2:	c3                   	ret    

f01057b3 <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f01057b3:	55                   	push   %ebp
f01057b4:	89 e5                	mov    %esp,%ebp
f01057b6:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01057b9:	83 ec 0c             	sub    $0xc,%esp
f01057bc:	68 60 c4 5e f0       	push   $0xf05ec460
f01057c1:	e8 f9 93 00 00       	call   f010ebbf <acquire_spinlock>
f01057c6:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01057c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01057d0:	a1 d0 c4 5e f0       	mov    0xf05ec4d0,%eax
f01057d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01057d8:	eb 53                	jmp    f010582d <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f01057da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01057dd:	8b 40 10             	mov    0x10(%eax),%eax
f01057e0:	3b 45 08             	cmp    0x8(%ebp),%eax
f01057e3:	75 40                	jne    f0105825 <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f01057e5:	83 ec 0c             	sub    $0xc,%esp
f01057e8:	ff 75 f4             	pushl  -0xc(%ebp)
f01057eb:	e8 06 fd ff ff       	call   f01054f6 <sched_remove_new>
f01057f0:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready0(ptr_env);
f01057f3:	83 ec 0c             	sub    $0xc,%esp
f01057f6:	ff 75 f4             	pushl  -0xc(%ebp)
f01057f9:	e8 b9 fa ff ff       	call   f01052b7 <sched_insert_ready0>
f01057fe:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f0105801:	e8 3e 19 00 00       	call   f0107144 <mycpu>
f0105806:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010580c:	85 c0                	test   %eax,%eax
f010580e:	75 46                	jne    f0105856 <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105810:	83 ec 0c             	sub    $0xc,%esp
f0105813:	68 60 c4 5e f0       	push   $0xf05ec460
f0105818:	e8 29 94 00 00       	call   f010ec46 <release_spinlock>
f010581d:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f0105820:	e8 ad 0f 00 00       	call   f01067d2 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105825:	a1 d8 c4 5e f0       	mov    0xf05ec4d8,%eax
f010582a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010582d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105831:	74 08                	je     f010583b <sched_run_env+0x88>
f0105833:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105836:	8b 40 08             	mov    0x8(%eax),%eax
f0105839:	eb 05                	jmp    f0105840 <sched_run_env+0x8d>
f010583b:	b8 00 00 00 00       	mov    $0x0,%eax
f0105840:	a3 d8 c4 5e f0       	mov    %eax,0xf05ec4d8
f0105845:	a1 d8 c4 5e f0       	mov    0xf05ec4d8,%eax
f010584a:	85 c0                	test   %eax,%eax
f010584c:	75 8c                	jne    f01057da <sched_run_env+0x27>
f010584e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105852:	75 86                	jne    f01057da <sched_run_env+0x27>
f0105854:	eb 01                	jmp    f0105857 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0105856:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105857:	83 ec 0c             	sub    $0xc,%esp
f010585a:	68 60 c4 5e f0       	push   $0xf05ec460
f010585f:	e8 e2 93 00 00       	call   f010ec46 <release_spinlock>
f0105864:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0105867:	90                   	nop
f0105868:	c9                   	leave  
f0105869:	c3                   	ret    

f010586a <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f010586a:	55                   	push   %ebp
f010586b:	89 e5                	mov    %esp,%ebp
f010586d:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f0105870:	83 ec 0c             	sub    $0xc,%esp
f0105873:	68 60 c4 5e f0       	push   $0xf05ec460
f0105878:	e8 5b 95 00 00       	call   f010edd8 <holding_spinlock>
f010587d:	83 c4 10             	add    $0x10,%esp
f0105880:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f0105883:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105887:	75 10                	jne    f0105899 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f0105889:	83 ec 0c             	sub    $0xc,%esp
f010588c:	68 60 c4 5e f0       	push   $0xf05ec460
f0105891:	e8 29 93 00 00       	call   f010ebbf <acquire_spinlock>
f0105896:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f0105899:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f01058a0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f01058a7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01058ab:	75 59                	jne    f0105906 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01058ad:	a1 d0 c4 5e f0       	mov    0xf05ec4d0,%eax
f01058b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01058b5:	eb 28                	jmp    f01058df <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f01058b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058ba:	8b 40 10             	mov    0x10(%eax),%eax
f01058bd:	3b 45 08             	cmp    0x8(%ebp),%eax
f01058c0:	75 15                	jne    f01058d7 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f01058c2:	83 ec 0c             	sub    $0xc,%esp
f01058c5:	ff 75 f4             	pushl  -0xc(%ebp)
f01058c8:	e8 29 fc ff ff       	call   f01054f6 <sched_remove_new>
f01058cd:	83 c4 10             	add    $0x10,%esp
				found = 1;
f01058d0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01058d7:	a1 d8 c4 5e f0       	mov    0xf05ec4d8,%eax
f01058dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01058df:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01058e3:	74 08                	je     f01058ed <sched_exit_env+0x83>
f01058e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058e8:	8b 40 08             	mov    0x8(%eax),%eax
f01058eb:	eb 05                	jmp    f01058f2 <sched_exit_env+0x88>
f01058ed:	b8 00 00 00 00       	mov    $0x0,%eax
f01058f2:	a3 d8 c4 5e f0       	mov    %eax,0xf05ec4d8
f01058f7:	a1 d8 c4 5e f0       	mov    0xf05ec4d8,%eax
f01058fc:	85 c0                	test   %eax,%eax
f01058fe:	75 b7                	jne    f01058b7 <sched_exit_env+0x4d>
f0105900:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105904:	75 b1                	jne    f01058b7 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f0105906:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010590a:	0f 85 67 01 00 00    	jne    f0105a77 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105910:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105917:	e9 47 01 00 00       	jmp    f0105a63 <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010591c:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105921:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105924:	c1 e2 04             	shl    $0x4,%edx
f0105927:	01 d0                	add    %edx,%eax
f0105929:	8b 00                	mov    (%eax),%eax
f010592b:	85 c0                	test   %eax,%eax
f010592d:	0f 84 27 01 00 00    	je     f0105a5a <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f0105933:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010593a:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f010593f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105942:	c1 e2 04             	shl    $0x4,%edx
f0105945:	01 d0                	add    %edx,%eax
f0105947:	8b 00                	mov    (%eax),%eax
f0105949:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010594c:	e9 d1 00 00 00       	jmp    f0105a22 <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f0105951:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105954:	8b 40 10             	mov    0x10(%eax),%eax
f0105957:	3b 45 08             	cmp    0x8(%ebp),%eax
f010595a:	0f 85 af 00 00 00    	jne    f0105a0f <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105960:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105964:	75 17                	jne    f010597d <sched_exit_env+0x113>
f0105966:	83 ec 04             	sub    $0x4,%esp
f0105969:	68 07 3c 12 f0       	push   $0xf0123c07
f010596e:	68 44 01 00 00       	push   $0x144
f0105973:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105978:	e8 bc a9 ff ff       	call   f0100339 <_panic>
f010597d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105980:	8b 40 08             	mov    0x8(%eax),%eax
f0105983:	85 c0                	test   %eax,%eax
f0105985:	74 11                	je     f0105998 <sched_exit_env+0x12e>
f0105987:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010598a:	8b 40 08             	mov    0x8(%eax),%eax
f010598d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105990:	8b 52 0c             	mov    0xc(%edx),%edx
f0105993:	89 50 0c             	mov    %edx,0xc(%eax)
f0105996:	eb 16                	jmp    f01059ae <sched_exit_env+0x144>
f0105998:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f010599d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059a0:	c1 e2 04             	shl    $0x4,%edx
f01059a3:	01 c2                	add    %eax,%edx
f01059a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059a8:	8b 40 0c             	mov    0xc(%eax),%eax
f01059ab:	89 42 04             	mov    %eax,0x4(%edx)
f01059ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059b1:	8b 40 0c             	mov    0xc(%eax),%eax
f01059b4:	85 c0                	test   %eax,%eax
f01059b6:	74 11                	je     f01059c9 <sched_exit_env+0x15f>
f01059b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059bb:	8b 40 0c             	mov    0xc(%eax),%eax
f01059be:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01059c1:	8b 52 08             	mov    0x8(%edx),%edx
f01059c4:	89 50 08             	mov    %edx,0x8(%eax)
f01059c7:	eb 15                	jmp    f01059de <sched_exit_env+0x174>
f01059c9:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f01059ce:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059d1:	c1 e2 04             	shl    $0x4,%edx
f01059d4:	01 c2                	add    %eax,%edx
f01059d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059d9:	8b 40 08             	mov    0x8(%eax),%eax
f01059dc:	89 02                	mov    %eax,(%edx)
f01059de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059e1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01059e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059eb:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01059f2:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f01059f7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01059fa:	c1 e2 04             	shl    $0x4,%edx
f01059fd:	01 d0                	add    %edx,%eax
f01059ff:	8b 50 0c             	mov    0xc(%eax),%edx
f0105a02:	4a                   	dec    %edx
f0105a03:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105a06:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105a0d:	eb 4b                	jmp    f0105a5a <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105a0f:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105a14:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105a17:	c1 e2 04             	shl    $0x4,%edx
f0105a1a:	01 d0                	add    %edx,%eax
f0105a1c:	8b 40 08             	mov    0x8(%eax),%eax
f0105a1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105a22:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105a27:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105a2a:	c1 e2 04             	shl    $0x4,%edx
f0105a2d:	01 d0                	add    %edx,%eax
f0105a2f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a33:	74 08                	je     f0105a3d <sched_exit_env+0x1d3>
f0105a35:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105a38:	8b 52 08             	mov    0x8(%edx),%edx
f0105a3b:	eb 05                	jmp    f0105a42 <sched_exit_env+0x1d8>
f0105a3d:	ba 00 00 00 00       	mov    $0x0,%edx
f0105a42:	89 50 08             	mov    %edx,0x8(%eax)
f0105a45:	8b 40 08             	mov    0x8(%eax),%eax
f0105a48:	85 c0                	test   %eax,%eax
f0105a4a:	0f 85 01 ff ff ff    	jne    f0105951 <sched_exit_env+0xe7>
f0105a50:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a54:	0f 85 f7 fe ff ff    	jne    f0105951 <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a5a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a5e:	75 16                	jne    f0105a76 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105a60:	ff 45 ec             	incl   -0x14(%ebp)
f0105a63:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f0105a68:	0f b6 c0             	movzbl %al,%eax
f0105a6b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105a6e:	0f 8f a8 fe ff ff    	jg     f010591c <sched_exit_env+0xb2>
f0105a74:	eb 01                	jmp    f0105a77 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0105a76:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f0105a77:	e8 dd 51 00 00       	call   f010ac59 <get_cpu_proc>
f0105a7c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0105a7f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0105a83:	75 19                	jne    f0105a9e <sched_exit_env+0x234>
f0105a85:	68 03 3d 12 f0       	push   $0xf0123d03
f0105a8a:	68 b6 3b 12 f0       	push   $0xf0123bb6
f0105a8f:	68 4e 01 00 00       	push   $0x14e
f0105a94:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105a99:	e8 9b a8 ff ff       	call   f0100339 <_panic>
	if (!found)
f0105a9e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105aa2:	75 18                	jne    f0105abc <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0105aa4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105aa7:	8b 40 10             	mov    0x10(%eax),%eax
f0105aaa:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105aad:	75 0d                	jne    f0105abc <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0105aaf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105ab2:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105ab5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105abc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ac0:	74 1e                	je     f0105ae0 <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0105ac2:	83 ec 0c             	sub    $0xc,%esp
f0105ac5:	ff 75 f4             	pushl  -0xc(%ebp)
f0105ac8:	e8 19 fb ff ff       	call   f01055e6 <sched_insert_exit>
f0105acd:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0105ad0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105ad3:	8b 40 10             	mov    0x10(%eax),%eax
f0105ad6:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105ad9:	75 05                	jne    f0105ae0 <sched_exit_env+0x276>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105adb:	e8 f2 52 00 00       	call   f010add2 <sched>
		}
	}
	if (!lock_already_held)
f0105ae0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105ae4:	75 10                	jne    f0105af6 <sched_exit_env+0x28c>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105ae6:	83 ec 0c             	sub    $0xc,%esp
f0105ae9:	68 60 c4 5e f0       	push   $0xf05ec460
f0105aee:	e8 53 91 00 00       	call   f010ec46 <release_spinlock>
f0105af3:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105af6:	90                   	nop
f0105af7:	c9                   	leave  
f0105af8:	c3                   	ret    

f0105af9 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105af9:	55                   	push   %ebp
f0105afa:	89 e5                	mov    %esp,%ebp
f0105afc:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105aff:	83 ec 0c             	sub    $0xc,%esp
f0105b02:	68 60 c4 5e f0       	push   $0xf05ec460
f0105b07:	e8 b3 90 00 00       	call   f010ebbf <acquire_spinlock>
f0105b0c:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105b0f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105b16:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105b1d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105b21:	75 79                	jne    f0105b9c <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b23:	a1 d0 c4 5e f0       	mov    0xf05ec4d0,%eax
f0105b28:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b2b:	eb 48                	jmp    f0105b75 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105b2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b30:	8b 40 10             	mov    0x10(%eax),%eax
f0105b33:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105b36:	75 35                	jne    f0105b6d <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0105b38:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b3b:	8d 50 20             	lea    0x20(%eax),%edx
f0105b3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b41:	8b 40 10             	mov    0x10(%eax),%eax
f0105b44:	83 ec 04             	sub    $0x4,%esp
f0105b47:	52                   	push   %edx
f0105b48:	50                   	push   %eax
f0105b49:	68 14 3d 12 f0       	push   $0xf0123d14
f0105b4e:	e8 38 b4 ff ff       	call   f0100f8b <cprintf>
f0105b53:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0105b56:	83 ec 0c             	sub    $0xc,%esp
f0105b59:	ff 75 f4             	pushl  -0xc(%ebp)
f0105b5c:	e8 95 f9 ff ff       	call   f01054f6 <sched_remove_new>
f0105b61:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105b64:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105b6b:	eb 2f                	jmp    f0105b9c <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b6d:	a1 d8 c4 5e f0       	mov    0xf05ec4d8,%eax
f0105b72:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b75:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b79:	74 08                	je     f0105b83 <sched_kill_env+0x8a>
f0105b7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b7e:	8b 40 08             	mov    0x8(%eax),%eax
f0105b81:	eb 05                	jmp    f0105b88 <sched_kill_env+0x8f>
f0105b83:	b8 00 00 00 00       	mov    $0x0,%eax
f0105b88:	a3 d8 c4 5e f0       	mov    %eax,0xf05ec4d8
f0105b8d:	a1 d8 c4 5e f0       	mov    0xf05ec4d8,%eax
f0105b92:	85 c0                	test   %eax,%eax
f0105b94:	75 97                	jne    f0105b2d <sched_kill_env+0x34>
f0105b96:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b9a:	75 91                	jne    f0105b2d <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105b9c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105ba0:	0f 85 85 01 00 00    	jne    f0105d2b <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105ba6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105bad:	e9 65 01 00 00       	jmp    f0105d17 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105bb2:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105bb7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105bba:	c1 e2 04             	shl    $0x4,%edx
f0105bbd:	01 d0                	add    %edx,%eax
f0105bbf:	8b 00                	mov    (%eax),%eax
f0105bc1:	85 c0                	test   %eax,%eax
f0105bc3:	0f 84 45 01 00 00    	je     f0105d0e <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0105bc9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105bd0:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105bd5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105bd8:	c1 e2 04             	shl    $0x4,%edx
f0105bdb:	01 d0                	add    %edx,%eax
f0105bdd:	8b 00                	mov    (%eax),%eax
f0105bdf:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105be2:	e9 ef 00 00 00       	jmp    f0105cd6 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0105be7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bea:	8b 40 10             	mov    0x10(%eax),%eax
f0105bed:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105bf0:	0f 85 cd 00 00 00    	jne    f0105cc3 <sched_kill_env+0x1ca>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105bf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bf9:	8d 50 20             	lea    0x20(%eax),%edx
f0105bfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105bff:	8b 40 10             	mov    0x10(%eax),%eax
f0105c02:	ff 75 ec             	pushl  -0x14(%ebp)
f0105c05:	52                   	push   %edx
f0105c06:	50                   	push   %eax
f0105c07:	68 3c 3d 12 f0       	push   $0xf0123d3c
f0105c0c:	e8 7a b3 ff ff       	call   f0100f8b <cprintf>
f0105c11:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105c14:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c18:	75 17                	jne    f0105c31 <sched_kill_env+0x138>
f0105c1a:	83 ec 04             	sub    $0x4,%esp
f0105c1d:	68 07 3c 12 f0       	push   $0xf0123c07
f0105c22:	68 91 01 00 00       	push   $0x191
f0105c27:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105c2c:	e8 08 a7 ff ff       	call   f0100339 <_panic>
f0105c31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c34:	8b 40 08             	mov    0x8(%eax),%eax
f0105c37:	85 c0                	test   %eax,%eax
f0105c39:	74 11                	je     f0105c4c <sched_kill_env+0x153>
f0105c3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c3e:	8b 40 08             	mov    0x8(%eax),%eax
f0105c41:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c44:	8b 52 0c             	mov    0xc(%edx),%edx
f0105c47:	89 50 0c             	mov    %edx,0xc(%eax)
f0105c4a:	eb 16                	jmp    f0105c62 <sched_kill_env+0x169>
f0105c4c:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105c51:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c54:	c1 e2 04             	shl    $0x4,%edx
f0105c57:	01 c2                	add    %eax,%edx
f0105c59:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c5c:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c5f:	89 42 04             	mov    %eax,0x4(%edx)
f0105c62:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c65:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c68:	85 c0                	test   %eax,%eax
f0105c6a:	74 11                	je     f0105c7d <sched_kill_env+0x184>
f0105c6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c6f:	8b 40 0c             	mov    0xc(%eax),%eax
f0105c72:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c75:	8b 52 08             	mov    0x8(%edx),%edx
f0105c78:	89 50 08             	mov    %edx,0x8(%eax)
f0105c7b:	eb 15                	jmp    f0105c92 <sched_kill_env+0x199>
f0105c7d:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105c82:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105c85:	c1 e2 04             	shl    $0x4,%edx
f0105c88:	01 c2                	add    %eax,%edx
f0105c8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c8d:	8b 40 08             	mov    0x8(%eax),%eax
f0105c90:	89 02                	mov    %eax,(%edx)
f0105c92:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c95:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105c9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c9f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105ca6:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105cab:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105cae:	c1 e2 04             	shl    $0x4,%edx
f0105cb1:	01 d0                	add    %edx,%eax
f0105cb3:	8b 50 0c             	mov    0xc(%eax),%edx
f0105cb6:	4a                   	dec    %edx
f0105cb7:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0105cba:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105cc1:	eb 4b                	jmp    f0105d0e <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105cc3:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105cc8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105ccb:	c1 e2 04             	shl    $0x4,%edx
f0105cce:	01 d0                	add    %edx,%eax
f0105cd0:	8b 40 08             	mov    0x8(%eax),%eax
f0105cd3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105cd6:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105cdb:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105cde:	c1 e2 04             	shl    $0x4,%edx
f0105ce1:	01 d0                	add    %edx,%eax
f0105ce3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ce7:	74 08                	je     f0105cf1 <sched_kill_env+0x1f8>
f0105ce9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105cec:	8b 52 08             	mov    0x8(%edx),%edx
f0105cef:	eb 05                	jmp    f0105cf6 <sched_kill_env+0x1fd>
f0105cf1:	ba 00 00 00 00       	mov    $0x0,%edx
f0105cf6:	89 50 08             	mov    %edx,0x8(%eax)
f0105cf9:	8b 40 08             	mov    0x8(%eax),%eax
f0105cfc:	85 c0                	test   %eax,%eax
f0105cfe:	0f 85 e3 fe ff ff    	jne    f0105be7 <sched_kill_env+0xee>
f0105d04:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d08:	0f 85 d9 fe ff ff    	jne    f0105be7 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0105d0e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d12:	75 16                	jne    f0105d2a <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105d14:	ff 45 ec             	incl   -0x14(%ebp)
f0105d17:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f0105d1c:	0f b6 c0             	movzbl %al,%eax
f0105d1f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105d22:	0f 8f 8a fe ff ff    	jg     f0105bb2 <sched_kill_env+0xb9>
f0105d28:	eb 01                	jmp    f0105d2b <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0105d2a:	90                   	nop
		}
	}
	if (!found)
f0105d2b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105d2f:	0f 85 80 00 00 00    	jne    f0105db5 <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0105d35:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105d3c:	a1 e0 c4 5e f0       	mov    0xf05ec4e0,%eax
f0105d41:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d44:	eb 48                	jmp    f0105d8e <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0105d46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d49:	8b 40 10             	mov    0x10(%eax),%eax
f0105d4c:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105d4f:	75 35                	jne    f0105d86 <sched_kill_env+0x28d>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f0105d51:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d54:	8d 50 20             	lea    0x20(%eax),%edx
f0105d57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d5a:	8b 40 10             	mov    0x10(%eax),%eax
f0105d5d:	83 ec 04             	sub    $0x4,%esp
f0105d60:	52                   	push   %edx
f0105d61:	50                   	push   %eax
f0105d62:	68 68 3d 12 f0       	push   $0xf0123d68
f0105d67:	e8 1f b2 ff ff       	call   f0100f8b <cprintf>
f0105d6c:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0105d6f:	83 ec 0c             	sub    $0xc,%esp
f0105d72:	ff 75 f4             	pushl  -0xc(%ebp)
f0105d75:	e8 f3 f8 ff ff       	call   f010566d <sched_remove_exit>
f0105d7a:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105d7d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105d84:	eb 2f                	jmp    f0105db5 <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105d86:	a1 e8 c4 5e f0       	mov    0xf05ec4e8,%eax
f0105d8b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d8e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d92:	74 08                	je     f0105d9c <sched_kill_env+0x2a3>
f0105d94:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d97:	8b 40 08             	mov    0x8(%eax),%eax
f0105d9a:	eb 05                	jmp    f0105da1 <sched_kill_env+0x2a8>
f0105d9c:	b8 00 00 00 00       	mov    $0x0,%eax
f0105da1:	a3 e8 c4 5e f0       	mov    %eax,0xf05ec4e8
f0105da6:	a1 e8 c4 5e f0       	mov    0xf05ec4e8,%eax
f0105dab:	85 c0                	test   %eax,%eax
f0105dad:	75 97                	jne    f0105d46 <sched_kill_env+0x24d>
f0105daf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105db3:	75 91                	jne    f0105d46 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105db5:	83 ec 0c             	sub    $0xc,%esp
f0105db8:	68 60 c4 5e f0       	push   $0xf05ec460
f0105dbd:	e8 84 8e 00 00       	call   f010ec46 <release_spinlock>
f0105dc2:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105dc5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105dc9:	74 23                	je     f0105dee <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0105dcb:	83 ec 0c             	sub    $0xc,%esp
f0105dce:	ff 75 f4             	pushl  -0xc(%ebp)
f0105dd1:	e8 3b 4e 00 00       	call   f010ac11 <env_free>
f0105dd6:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0105dd9:	83 ec 0c             	sub    $0xc,%esp
f0105ddc:	68 8e 3d 12 f0       	push   $0xf0123d8e
f0105de1:	e8 a5 b1 ff ff       	call   f0100f8b <cprintf>
f0105de6:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0105de9:	e9 a4 00 00 00       	jmp    f0105e92 <sched_kill_env+0x399>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0105dee:	e8 66 4e 00 00       	call   f010ac59 <get_cpu_proc>
f0105df3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0105df6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105dfa:	75 19                	jne    f0105e15 <sched_kill_env+0x31c>
f0105dfc:	68 03 3d 12 f0       	push   $0xf0123d03
f0105e01:	68 b6 3b 12 f0       	push   $0xf0123bb6
f0105e06:	68 b3 01 00 00       	push   $0x1b3
f0105e0b:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105e10:	e8 24 a5 ff ff       	call   f0100339 <_panic>

		if (cur_env->env_id == envId)
f0105e15:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105e18:	8b 40 10             	mov    0x10(%eax),%eax
f0105e1b:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105e1e:	75 72                	jne    f0105e92 <sched_kill_env+0x399>
		{
			ptr_env = cur_env;
f0105e20:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105e23:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0105e26:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e29:	8b 40 18             	mov    0x18(%eax),%eax
f0105e2c:	83 f8 02             	cmp    $0x2,%eax
f0105e2f:	74 19                	je     f0105e4a <sched_kill_env+0x351>
f0105e31:	68 94 3d 12 f0       	push   $0xf0123d94
f0105e36:	68 b6 3b 12 f0       	push   $0xf0123bb6
f0105e3b:	68 b8 01 00 00       	push   $0x1b8
f0105e40:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0105e45:	e8 ef a4 ff ff       	call   f0100339 <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105e4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e4d:	8d 50 20             	lea    0x20(%eax),%edx
f0105e50:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e53:	8b 40 10             	mov    0x10(%eax),%eax
f0105e56:	83 ec 04             	sub    $0x4,%esp
f0105e59:	52                   	push   %edx
f0105e5a:	50                   	push   %eax
f0105e5b:	68 b8 3d 12 f0       	push   $0xf0123db8
f0105e60:	e8 26 b1 ff ff       	call   f0100f8b <cprintf>
f0105e65:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105e68:	83 ec 0c             	sub    $0xc,%esp
f0105e6b:	ff 75 f4             	pushl  -0xc(%ebp)
f0105e6e:	e8 9e 4d 00 00       	call   f010ac11 <env_free>
f0105e73:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105e76:	83 ec 0c             	sub    $0xc,%esp
f0105e79:	68 8e 3d 12 f0       	push   $0xf0123d8e
f0105e7e:	e8 08 b1 ff ff       	call   f0100f8b <cprintf>
f0105e83:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0105e86:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f0105e8d:	e8 40 4f 00 00       	call   f010add2 <sched>
		}
	}

}
f0105e92:	90                   	nop
f0105e93:	c9                   	leave  
f0105e94:	c3                   	ret    

f0105e95 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0105e95:	55                   	push   %ebp
f0105e96:	89 e5                	mov    %esp,%ebp
f0105e98:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105e9b:	83 ec 0c             	sub    $0xc,%esp
f0105e9e:	68 60 c4 5e f0       	push   $0xf05ec460
f0105ea3:	e8 17 8d 00 00       	call   f010ebbf <acquire_spinlock>
f0105ea8:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105eab:	a1 d0 c4 5e f0       	mov    0xf05ec4d0,%eax
f0105eb0:	85 c0                	test   %eax,%eax
f0105eb2:	74 69                	je     f0105f1d <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0105eb4:	83 ec 0c             	sub    $0xc,%esp
f0105eb7:	68 e4 3d 12 f0       	push   $0xf0123de4
f0105ebc:	e8 ca b0 ff ff       	call   f0100f8b <cprintf>
f0105ec1:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105ec4:	a1 d0 c4 5e f0       	mov    0xf05ec4d0,%eax
f0105ec9:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ecc:	eb 26                	jmp    f0105ef4 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105ece:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ed1:	8d 50 20             	lea    0x20(%eax),%edx
f0105ed4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ed7:	8b 40 10             	mov    0x10(%eax),%eax
f0105eda:	83 ec 04             	sub    $0x4,%esp
f0105edd:	52                   	push   %edx
f0105ede:	50                   	push   %eax
f0105edf:	68 06 3e 12 f0       	push   $0xf0123e06
f0105ee4:	e8 a2 b0 ff ff       	call   f0100f8b <cprintf>
f0105ee9:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105eec:	a1 d8 c4 5e f0       	mov    0xf05ec4d8,%eax
f0105ef1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105ef4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ef8:	74 08                	je     f0105f02 <sched_print_all+0x6d>
f0105efa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105efd:	8b 40 08             	mov    0x8(%eax),%eax
f0105f00:	eb 05                	jmp    f0105f07 <sched_print_all+0x72>
f0105f02:	b8 00 00 00 00       	mov    $0x0,%eax
f0105f07:	a3 d8 c4 5e f0       	mov    %eax,0xf05ec4d8
f0105f0c:	a1 d8 c4 5e f0       	mov    0xf05ec4d8,%eax
f0105f11:	85 c0                	test   %eax,%eax
f0105f13:	75 b9                	jne    f0105ece <sched_print_all+0x39>
f0105f15:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f19:	75 b3                	jne    f0105ece <sched_print_all+0x39>
f0105f1b:	eb 10                	jmp    f0105f2d <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0105f1d:	83 ec 0c             	sub    $0xc,%esp
f0105f20:	68 10 3e 12 f0       	push   $0xf0123e10
f0105f25:	e8 61 b0 ff ff       	call   f0100f8b <cprintf>
f0105f2a:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105f2d:	83 ec 0c             	sub    $0xc,%esp
f0105f30:	68 2c 3e 12 f0       	push   $0xf0123e2c
f0105f35:	e8 51 b0 ff ff       	call   f0100f8b <cprintf>
f0105f3a:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105f3d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105f44:	e9 c7 00 00 00       	jmp    f0106010 <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105f49:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105f4e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f51:	c1 e2 04             	shl    $0x4,%edx
f0105f54:	01 d0                	add    %edx,%eax
f0105f56:	8b 00                	mov    (%eax),%eax
f0105f58:	85 c0                	test   %eax,%eax
f0105f5a:	0f 84 8a 00 00 00    	je     f0105fea <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0105f60:	83 ec 08             	sub    $0x8,%esp
f0105f63:	ff 75 f0             	pushl  -0x10(%ebp)
f0105f66:	68 60 3e 12 f0       	push   $0xf0123e60
f0105f6b:	e8 1b b0 ff ff       	call   f0100f8b <cprintf>
f0105f70:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105f73:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105f78:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f7b:	c1 e2 04             	shl    $0x4,%edx
f0105f7e:	01 d0                	add    %edx,%eax
f0105f80:	8b 00                	mov    (%eax),%eax
f0105f82:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f85:	eb 31                	jmp    f0105fb8 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105f87:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f8a:	8d 50 20             	lea    0x20(%eax),%edx
f0105f8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f90:	8b 40 10             	mov    0x10(%eax),%eax
f0105f93:	83 ec 04             	sub    $0x4,%esp
f0105f96:	52                   	push   %edx
f0105f97:	50                   	push   %eax
f0105f98:	68 06 3e 12 f0       	push   $0xf0123e06
f0105f9d:	e8 e9 af ff ff       	call   f0100f8b <cprintf>
f0105fa2:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105fa5:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105faa:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105fad:	c1 e2 04             	shl    $0x4,%edx
f0105fb0:	01 d0                	add    %edx,%eax
f0105fb2:	8b 40 08             	mov    0x8(%eax),%eax
f0105fb5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105fb8:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0105fbd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105fc0:	c1 e2 04             	shl    $0x4,%edx
f0105fc3:	01 d0                	add    %edx,%eax
f0105fc5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fc9:	74 08                	je     f0105fd3 <sched_print_all+0x13e>
f0105fcb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105fce:	8b 52 08             	mov    0x8(%edx),%edx
f0105fd1:	eb 05                	jmp    f0105fd8 <sched_print_all+0x143>
f0105fd3:	ba 00 00 00 00       	mov    $0x0,%edx
f0105fd8:	89 50 08             	mov    %edx,0x8(%eax)
f0105fdb:	8b 40 08             	mov    0x8(%eax),%eax
f0105fde:	85 c0                	test   %eax,%eax
f0105fe0:	75 a5                	jne    f0105f87 <sched_print_all+0xf2>
f0105fe2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fe6:	75 9f                	jne    f0105f87 <sched_print_all+0xf2>
f0105fe8:	eb 13                	jmp    f0105ffd <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0105fea:	83 ec 08             	sub    $0x8,%esp
f0105fed:	ff 75 f0             	pushl  -0x10(%ebp)
f0105ff0:	68 88 3e 12 f0       	push   $0xf0123e88
f0105ff5:	e8 91 af ff ff       	call   f0100f8b <cprintf>
f0105ffa:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0105ffd:	83 ec 0c             	sub    $0xc,%esp
f0106000:	68 2c 3e 12 f0       	push   $0xf0123e2c
f0106005:	e8 81 af ff ff       	call   f0100f8b <cprintf>
f010600a:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010600d:	ff 45 f0             	incl   -0x10(%ebp)
f0106010:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f0106015:	0f b6 c0             	movzbl %al,%eax
f0106018:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010601b:	0f 8f 28 ff ff ff    	jg     f0105f49 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106021:	a1 e0 c4 5e f0       	mov    0xf05ec4e0,%eax
f0106026:	85 c0                	test   %eax,%eax
f0106028:	74 69                	je     f0106093 <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f010602a:	83 ec 0c             	sub    $0xc,%esp
f010602d:	68 ac 3e 12 f0       	push   $0xf0123eac
f0106032:	e8 54 af ff ff       	call   f0100f8b <cprintf>
f0106037:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f010603a:	a1 e0 c4 5e f0       	mov    0xf05ec4e0,%eax
f010603f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106042:	eb 26                	jmp    f010606a <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106044:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106047:	8d 50 20             	lea    0x20(%eax),%edx
f010604a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010604d:	8b 40 10             	mov    0x10(%eax),%eax
f0106050:	83 ec 04             	sub    $0x4,%esp
f0106053:	52                   	push   %edx
f0106054:	50                   	push   %eax
f0106055:	68 06 3e 12 f0       	push   $0xf0123e06
f010605a:	e8 2c af ff ff       	call   f0100f8b <cprintf>
f010605f:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106062:	a1 e8 c4 5e f0       	mov    0xf05ec4e8,%eax
f0106067:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010606a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010606e:	74 08                	je     f0106078 <sched_print_all+0x1e3>
f0106070:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106073:	8b 40 08             	mov    0x8(%eax),%eax
f0106076:	eb 05                	jmp    f010607d <sched_print_all+0x1e8>
f0106078:	b8 00 00 00 00       	mov    $0x0,%eax
f010607d:	a3 e8 c4 5e f0       	mov    %eax,0xf05ec4e8
f0106082:	a1 e8 c4 5e f0       	mov    0xf05ec4e8,%eax
f0106087:	85 c0                	test   %eax,%eax
f0106089:	75 b9                	jne    f0106044 <sched_print_all+0x1af>
f010608b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010608f:	75 b3                	jne    f0106044 <sched_print_all+0x1af>
f0106091:	eb 10                	jmp    f01060a3 <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106093:	83 ec 0c             	sub    $0xc,%esp
f0106096:	68 ce 3e 12 f0       	push   $0xf0123ece
f010609b:	e8 eb ae ff ff       	call   f0100f8b <cprintf>
f01060a0:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060a3:	83 ec 0c             	sub    $0xc,%esp
f01060a6:	68 60 c4 5e f0       	push   $0xf05ec460
f01060ab:	e8 96 8b 00 00       	call   f010ec46 <release_spinlock>
f01060b0:	83 c4 10             	add    $0x10,%esp
}
f01060b3:	90                   	nop
f01060b4:	c9                   	leave  
f01060b5:	c3                   	ret    

f01060b6 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f01060b6:	55                   	push   %ebp
f01060b7:	89 e5                	mov    %esp,%ebp
f01060b9:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01060bc:	83 ec 0c             	sub    $0xc,%esp
f01060bf:	68 60 c4 5e f0       	push   $0xf05ec460
f01060c4:	e8 f6 8a 00 00       	call   f010ebbf <acquire_spinlock>
f01060c9:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01060cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f01060d3:	a1 dc c4 5e f0       	mov    0xf05ec4dc,%eax
f01060d8:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f01060db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01060e2:	eb 24                	jmp    f0106108 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f01060e4:	83 ec 0c             	sub    $0xc,%esp
f01060e7:	68 d0 c4 5e f0       	push   $0xf05ec4d0
f01060ec:	e8 8b ef ff ff       	call   f010507c <dequeue>
f01060f1:	83 c4 10             	add    $0x10,%esp
f01060f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(ptr_env);
f01060f7:	83 ec 0c             	sub    $0xc,%esp
f01060fa:	ff 75 f0             	pushl  -0x10(%ebp)
f01060fd:	e8 b5 f1 ff ff       	call   f01052b7 <sched_insert_ready0>
f0106102:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f0106105:	ff 45 f4             	incl   -0xc(%ebp)
f0106108:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010610b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010610e:	7c d4                	jl     f01060e4 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready0(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106110:	83 ec 0c             	sub    $0xc,%esp
f0106113:	68 60 c4 5e f0       	push   $0xf05ec460
f0106118:	e8 29 8b 00 00       	call   f010ec46 <release_spinlock>
f010611d:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f0106120:	e8 1f 10 00 00       	call   f0107144 <mycpu>
f0106125:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010612b:	85 c0                	test   %eax,%eax
f010612d:	75 05                	jne    f0106134 <sched_run_all+0x7e>
		fos_scheduler();
f010612f:	e8 9e 06 00 00       	call   f01067d2 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f0106134:	83 ec 04             	sub    $0x4,%esp
f0106137:	68 ec 3e 12 f0       	push   $0xf0123eec
f010613c:	68 15 02 00 00       	push   $0x215
f0106141:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0106146:	e8 ee a1 ff ff       	call   f0100339 <_panic>

f010614b <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f010614b:	55                   	push   %ebp
f010614c:	89 e5                	mov    %esp,%ebp
f010614e:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106151:	83 ec 0c             	sub    $0xc,%esp
f0106154:	68 60 c4 5e f0       	push   $0xf05ec460
f0106159:	e8 61 8a 00 00       	call   f010ebbf <acquire_spinlock>
f010615e:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0106161:	a1 d0 c4 5e f0       	mov    0xf05ec4d0,%eax
f0106166:	85 c0                	test   %eax,%eax
f0106168:	0f 84 95 00 00 00    	je     f0106203 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f010616e:	83 ec 0c             	sub    $0xc,%esp
f0106171:	68 28 3f 12 f0       	push   $0xf0123f28
f0106176:	e8 10 ae ff ff       	call   f0100f8b <cprintf>
f010617b:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010617e:	a1 d0 c4 5e f0       	mov    0xf05ec4d0,%eax
f0106183:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106186:	eb 52                	jmp    f01061da <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106188:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010618b:	8d 50 20             	lea    0x20(%eax),%edx
f010618e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106191:	8b 40 10             	mov    0x10(%eax),%eax
f0106194:	83 ec 04             	sub    $0x4,%esp
f0106197:	52                   	push   %edx
f0106198:	50                   	push   %eax
f0106199:	68 54 3f 12 f0       	push   $0xf0123f54
f010619e:	e8 e8 ad ff ff       	call   f0100f8b <cprintf>
f01061a3:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f01061a6:	83 ec 0c             	sub    $0xc,%esp
f01061a9:	ff 75 f4             	pushl  -0xc(%ebp)
f01061ac:	e8 45 f3 ff ff       	call   f01054f6 <sched_remove_new>
f01061b1:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01061b4:	83 ec 0c             	sub    $0xc,%esp
f01061b7:	ff 75 f4             	pushl  -0xc(%ebp)
f01061ba:	e8 52 4a 00 00       	call   f010ac11 <env_free>
f01061bf:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01061c2:	83 ec 0c             	sub    $0xc,%esp
f01061c5:	68 8e 3d 12 f0       	push   $0xf0123d8e
f01061ca:	e8 bc ad ff ff       	call   f0100f8b <cprintf>
f01061cf:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01061d2:	a1 d8 c4 5e f0       	mov    0xf05ec4d8,%eax
f01061d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01061da:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01061de:	74 08                	je     f01061e8 <sched_kill_all+0x9d>
f01061e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01061e3:	8b 40 08             	mov    0x8(%eax),%eax
f01061e6:	eb 05                	jmp    f01061ed <sched_kill_all+0xa2>
f01061e8:	b8 00 00 00 00       	mov    $0x0,%eax
f01061ed:	a3 d8 c4 5e f0       	mov    %eax,0xf05ec4d8
f01061f2:	a1 d8 c4 5e f0       	mov    0xf05ec4d8,%eax
f01061f7:	85 c0                	test   %eax,%eax
f01061f9:	75 8d                	jne    f0106188 <sched_kill_all+0x3d>
f01061fb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01061ff:	75 87                	jne    f0106188 <sched_kill_all+0x3d>
f0106201:	eb 10                	jmp    f0106213 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f0106203:	83 ec 0c             	sub    $0xc,%esp
f0106206:	68 67 3f 12 f0       	push   $0xf0123f67
f010620b:	e8 7b ad ff ff       	call   f0100f8b <cprintf>
f0106210:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0106213:	83 ec 0c             	sub    $0xc,%esp
f0106216:	68 2c 3e 12 f0       	push   $0xf0123e2c
f010621b:	e8 6b ad ff ff       	call   f0100f8b <cprintf>
f0106220:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106223:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010622a:	e9 96 01 00 00       	jmp    f01063c5 <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010622f:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0106234:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106237:	c1 e2 04             	shl    $0x4,%edx
f010623a:	01 d0                	add    %edx,%eax
f010623c:	8b 00                	mov    (%eax),%eax
f010623e:	85 c0                	test   %eax,%eax
f0106240:	0f 84 59 01 00 00    	je     f010639f <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0106246:	83 ec 08             	sub    $0x8,%esp
f0106249:	ff 75 f0             	pushl  -0x10(%ebp)
f010624c:	68 84 3f 12 f0       	push   $0xf0123f84
f0106251:	e8 35 ad ff ff       	call   f0100f8b <cprintf>
f0106256:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106259:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f010625e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106261:	c1 e2 04             	shl    $0x4,%edx
f0106264:	01 d0                	add    %edx,%eax
f0106266:	8b 00                	mov    (%eax),%eax
f0106268:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010626b:	e9 f5 00 00 00       	jmp    f0106365 <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0106270:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106273:	8d 50 20             	lea    0x20(%eax),%edx
f0106276:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106279:	8b 40 10             	mov    0x10(%eax),%eax
f010627c:	83 ec 04             	sub    $0x4,%esp
f010627f:	52                   	push   %edx
f0106280:	50                   	push   %eax
f0106281:	68 54 3f 12 f0       	push   $0xf0123f54
f0106286:	e8 00 ad ff ff       	call   f0100f8b <cprintf>
f010628b:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010628e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106292:	75 17                	jne    f01062ab <sched_kill_all+0x160>
f0106294:	83 ec 04             	sub    $0x4,%esp
f0106297:	68 07 3c 12 f0       	push   $0xf0123c07
f010629c:	68 37 02 00 00       	push   $0x237
f01062a1:	68 cb 3b 12 f0       	push   $0xf0123bcb
f01062a6:	e8 8e a0 ff ff       	call   f0100339 <_panic>
f01062ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062ae:	8b 40 08             	mov    0x8(%eax),%eax
f01062b1:	85 c0                	test   %eax,%eax
f01062b3:	74 11                	je     f01062c6 <sched_kill_all+0x17b>
f01062b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062b8:	8b 40 08             	mov    0x8(%eax),%eax
f01062bb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01062be:	8b 52 0c             	mov    0xc(%edx),%edx
f01062c1:	89 50 0c             	mov    %edx,0xc(%eax)
f01062c4:	eb 16                	jmp    f01062dc <sched_kill_all+0x191>
f01062c6:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f01062cb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062ce:	c1 e2 04             	shl    $0x4,%edx
f01062d1:	01 c2                	add    %eax,%edx
f01062d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062d6:	8b 40 0c             	mov    0xc(%eax),%eax
f01062d9:	89 42 04             	mov    %eax,0x4(%edx)
f01062dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062df:	8b 40 0c             	mov    0xc(%eax),%eax
f01062e2:	85 c0                	test   %eax,%eax
f01062e4:	74 11                	je     f01062f7 <sched_kill_all+0x1ac>
f01062e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062e9:	8b 40 0c             	mov    0xc(%eax),%eax
f01062ec:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01062ef:	8b 52 08             	mov    0x8(%edx),%edx
f01062f2:	89 50 08             	mov    %edx,0x8(%eax)
f01062f5:	eb 15                	jmp    f010630c <sched_kill_all+0x1c1>
f01062f7:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f01062fc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062ff:	c1 e2 04             	shl    $0x4,%edx
f0106302:	01 c2                	add    %eax,%edx
f0106304:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106307:	8b 40 08             	mov    0x8(%eax),%eax
f010630a:	89 02                	mov    %eax,(%edx)
f010630c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010630f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106316:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106319:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106320:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0106325:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106328:	c1 e2 04             	shl    $0x4,%edx
f010632b:	01 d0                	add    %edx,%eax
f010632d:	8b 50 0c             	mov    0xc(%eax),%edx
f0106330:	4a                   	dec    %edx
f0106331:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f0106334:	83 ec 0c             	sub    $0xc,%esp
f0106337:	ff 75 f4             	pushl  -0xc(%ebp)
f010633a:	e8 d2 48 00 00       	call   f010ac11 <env_free>
f010633f:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f0106342:	83 ec 0c             	sub    $0xc,%esp
f0106345:	68 8e 3d 12 f0       	push   $0xf0123d8e
f010634a:	e8 3c ac ff ff       	call   f0100f8b <cprintf>
f010634f:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106352:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0106357:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010635a:	c1 e2 04             	shl    $0x4,%edx
f010635d:	01 d0                	add    %edx,%eax
f010635f:	8b 40 08             	mov    0x8(%eax),%eax
f0106362:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106365:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f010636a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010636d:	c1 e2 04             	shl    $0x4,%edx
f0106370:	01 d0                	add    %edx,%eax
f0106372:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106376:	74 08                	je     f0106380 <sched_kill_all+0x235>
f0106378:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010637b:	8b 52 08             	mov    0x8(%edx),%edx
f010637e:	eb 05                	jmp    f0106385 <sched_kill_all+0x23a>
f0106380:	ba 00 00 00 00       	mov    $0x0,%edx
f0106385:	89 50 08             	mov    %edx,0x8(%eax)
f0106388:	8b 40 08             	mov    0x8(%eax),%eax
f010638b:	85 c0                	test   %eax,%eax
f010638d:	0f 85 dd fe ff ff    	jne    f0106270 <sched_kill_all+0x125>
f0106393:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106397:	0f 85 d3 fe ff ff    	jne    f0106270 <sched_kill_all+0x125>
f010639d:	eb 13                	jmp    f01063b2 <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f010639f:	83 ec 08             	sub    $0x8,%esp
f01063a2:	ff 75 f0             	pushl  -0x10(%ebp)
f01063a5:	68 88 3e 12 f0       	push   $0xf0123e88
f01063aa:	e8 dc ab ff ff       	call   f0100f8b <cprintf>
f01063af:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f01063b2:	83 ec 0c             	sub    $0xc,%esp
f01063b5:	68 2c 3e 12 f0       	push   $0xf0123e2c
f01063ba:	e8 cc ab ff ff       	call   f0100f8b <cprintf>
f01063bf:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01063c2:	ff 45 f0             	incl   -0x10(%ebp)
f01063c5:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f01063ca:	0f b6 c0             	movzbl %al,%eax
f01063cd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01063d0:	0f 8f 59 fe ff ff    	jg     f010622f <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f01063d6:	a1 e0 c4 5e f0       	mov    0xf05ec4e0,%eax
f01063db:	85 c0                	test   %eax,%eax
f01063dd:	0f 84 95 00 00 00    	je     f0106478 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f01063e3:	83 ec 0c             	sub    $0xc,%esp
f01063e6:	68 b8 3f 12 f0       	push   $0xf0123fb8
f01063eb:	e8 9b ab ff ff       	call   f0100f8b <cprintf>
f01063f0:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01063f3:	a1 e0 c4 5e f0       	mov    0xf05ec4e0,%eax
f01063f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01063fb:	eb 52                	jmp    f010644f <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01063fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106400:	8d 50 20             	lea    0x20(%eax),%edx
f0106403:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106406:	8b 40 10             	mov    0x10(%eax),%eax
f0106409:	83 ec 04             	sub    $0x4,%esp
f010640c:	52                   	push   %edx
f010640d:	50                   	push   %eax
f010640e:	68 54 3f 12 f0       	push   $0xf0123f54
f0106413:	e8 73 ab ff ff       	call   f0100f8b <cprintf>
f0106418:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f010641b:	83 ec 0c             	sub    $0xc,%esp
f010641e:	ff 75 f4             	pushl  -0xc(%ebp)
f0106421:	e8 47 f2 ff ff       	call   f010566d <sched_remove_exit>
f0106426:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106429:	83 ec 0c             	sub    $0xc,%esp
f010642c:	ff 75 f4             	pushl  -0xc(%ebp)
f010642f:	e8 dd 47 00 00       	call   f010ac11 <env_free>
f0106434:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0106437:	83 ec 0c             	sub    $0xc,%esp
f010643a:	68 8e 3d 12 f0       	push   $0xf0123d8e
f010643f:	e8 47 ab ff ff       	call   f0100f8b <cprintf>
f0106444:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106447:	a1 e8 c4 5e f0       	mov    0xf05ec4e8,%eax
f010644c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010644f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106453:	74 08                	je     f010645d <sched_kill_all+0x312>
f0106455:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106458:	8b 40 08             	mov    0x8(%eax),%eax
f010645b:	eb 05                	jmp    f0106462 <sched_kill_all+0x317>
f010645d:	b8 00 00 00 00       	mov    $0x0,%eax
f0106462:	a3 e8 c4 5e f0       	mov    %eax,0xf05ec4e8
f0106467:	a1 e8 c4 5e f0       	mov    0xf05ec4e8,%eax
f010646c:	85 c0                	test   %eax,%eax
f010646e:	75 8d                	jne    f01063fd <sched_kill_all+0x2b2>
f0106470:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106474:	75 87                	jne    f01063fd <sched_kill_all+0x2b2>
f0106476:	eb 10                	jmp    f0106488 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106478:	83 ec 0c             	sub    $0xc,%esp
f010647b:	68 ce 3e 12 f0       	push   $0xf0123ece
f0106480:	e8 06 ab ff ff       	call   f0100f8b <cprintf>
f0106485:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f0106488:	e8 cc 47 00 00       	call   f010ac59 <get_cpu_proc>
f010648d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f0106490:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106494:	74 6b                	je     f0106501 <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f0106496:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106499:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f010649c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010649f:	8b 40 18             	mov    0x18(%eax),%eax
f01064a2:	83 f8 02             	cmp    $0x2,%eax
f01064a5:	74 19                	je     f01064c0 <sched_kill_all+0x375>
f01064a7:	68 94 3d 12 f0       	push   $0xf0123d94
f01064ac:	68 b6 3b 12 f0       	push   $0xf0123bb6
f01064b1:	68 57 02 00 00       	push   $0x257
f01064b6:	68 cb 3b 12 f0       	push   $0xf0123bcb
f01064bb:	e8 79 9e ff ff       	call   f0100339 <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01064c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064c3:	8d 50 20             	lea    0x20(%eax),%edx
f01064c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01064c9:	8b 40 10             	mov    0x10(%eax),%eax
f01064cc:	83 ec 04             	sub    $0x4,%esp
f01064cf:	52                   	push   %edx
f01064d0:	50                   	push   %eax
f01064d1:	68 b8 3d 12 f0       	push   $0xf0123db8
f01064d6:	e8 b0 aa ff ff       	call   f0100f8b <cprintf>
f01064db:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f01064de:	83 ec 0c             	sub    $0xc,%esp
f01064e1:	ff 75 f4             	pushl  -0xc(%ebp)
f01064e4:	e8 28 47 00 00       	call   f010ac11 <env_free>
f01064e9:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f01064ec:	83 ec 0c             	sub    $0xc,%esp
f01064ef:	68 8e 3d 12 f0       	push   $0xf0123d8e
f01064f4:	e8 92 aa ff ff       	call   f0100f8b <cprintf>
f01064f9:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f01064fc:	e8 d1 48 00 00       	call   f010add2 <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106501:	83 ec 0c             	sub    $0xc,%esp
f0106504:	68 60 c4 5e f0       	push   $0xf05ec460
f0106509:	e8 38 87 00 00       	call   f010ec46 <release_spinlock>
f010650e:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f0106511:	e8 ac b8 ff ff       	call   f0101dc2 <get_into_prompt>

f0106516 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f0106516:	55                   	push   %ebp
f0106517:	89 e5                	mov    %esp,%ebp
f0106519:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010651c:	83 ec 0c             	sub    $0xc,%esp
f010651f:	68 60 c4 5e f0       	push   $0xf05ec460
f0106524:	e8 96 86 00 00       	call   f010ebbf <acquire_spinlock>
f0106529:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010652c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106533:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010653a:	e9 37 01 00 00       	jmp    f0106676 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010653f:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0106544:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106547:	c1 e2 04             	shl    $0x4,%edx
f010654a:	01 d0                	add    %edx,%eax
f010654c:	8b 00                	mov    (%eax),%eax
f010654e:	85 c0                	test   %eax,%eax
f0106550:	0f 84 1d 01 00 00    	je     f0106673 <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f0106556:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010655d:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0106562:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106565:	c1 e2 04             	shl    $0x4,%edx
f0106568:	01 d0                	add    %edx,%eax
f010656a:	8b 00                	mov    (%eax),%eax
f010656c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010656f:	e9 c7 00 00 00       	jmp    f010663b <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106574:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106578:	75 17                	jne    f0106591 <sched_exit_all_ready_envs+0x7b>
f010657a:	83 ec 04             	sub    $0x4,%esp
f010657d:	68 07 3c 12 f0       	push   $0xf0123c07
f0106582:	68 79 02 00 00       	push   $0x279
f0106587:	68 cb 3b 12 f0       	push   $0xf0123bcb
f010658c:	e8 a8 9d ff ff       	call   f0100339 <_panic>
f0106591:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106594:	8b 40 08             	mov    0x8(%eax),%eax
f0106597:	85 c0                	test   %eax,%eax
f0106599:	74 11                	je     f01065ac <sched_exit_all_ready_envs+0x96>
f010659b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010659e:	8b 40 08             	mov    0x8(%eax),%eax
f01065a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01065a4:	8b 52 0c             	mov    0xc(%edx),%edx
f01065a7:	89 50 0c             	mov    %edx,0xc(%eax)
f01065aa:	eb 16                	jmp    f01065c2 <sched_exit_all_ready_envs+0xac>
f01065ac:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f01065b1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065b4:	c1 e2 04             	shl    $0x4,%edx
f01065b7:	01 c2                	add    %eax,%edx
f01065b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065bc:	8b 40 0c             	mov    0xc(%eax),%eax
f01065bf:	89 42 04             	mov    %eax,0x4(%edx)
f01065c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065c5:	8b 40 0c             	mov    0xc(%eax),%eax
f01065c8:	85 c0                	test   %eax,%eax
f01065ca:	74 11                	je     f01065dd <sched_exit_all_ready_envs+0xc7>
f01065cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065cf:	8b 40 0c             	mov    0xc(%eax),%eax
f01065d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01065d5:	8b 52 08             	mov    0x8(%edx),%edx
f01065d8:	89 50 08             	mov    %edx,0x8(%eax)
f01065db:	eb 15                	jmp    f01065f2 <sched_exit_all_ready_envs+0xdc>
f01065dd:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f01065e2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01065e5:	c1 e2 04             	shl    $0x4,%edx
f01065e8:	01 c2                	add    %eax,%edx
f01065ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065ed:	8b 40 08             	mov    0x8(%eax),%eax
f01065f0:	89 02                	mov    %eax,(%edx)
f01065f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065f5:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01065fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01065ff:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106606:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f010660b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010660e:	c1 e2 04             	shl    $0x4,%edx
f0106611:	01 d0                	add    %edx,%eax
f0106613:	8b 50 0c             	mov    0xc(%eax),%edx
f0106616:	4a                   	dec    %edx
f0106617:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f010661a:	83 ec 0c             	sub    $0xc,%esp
f010661d:	ff 75 f4             	pushl  -0xc(%ebp)
f0106620:	e8 c1 ef ff ff       	call   f01055e6 <sched_insert_exit>
f0106625:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106628:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f010662d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106630:	c1 e2 04             	shl    $0x4,%edx
f0106633:	01 d0                	add    %edx,%eax
f0106635:	8b 40 08             	mov    0x8(%eax),%eax
f0106638:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010663b:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0106640:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106643:	c1 e2 04             	shl    $0x4,%edx
f0106646:	01 d0                	add    %edx,%eax
f0106648:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010664c:	74 08                	je     f0106656 <sched_exit_all_ready_envs+0x140>
f010664e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106651:	8b 52 08             	mov    0x8(%edx),%edx
f0106654:	eb 05                	jmp    f010665b <sched_exit_all_ready_envs+0x145>
f0106656:	ba 00 00 00 00       	mov    $0x0,%edx
f010665b:	89 50 08             	mov    %edx,0x8(%eax)
f010665e:	8b 40 08             	mov    0x8(%eax),%eax
f0106661:	85 c0                	test   %eax,%eax
f0106663:	0f 85 0b ff ff ff    	jne    f0106574 <sched_exit_all_ready_envs+0x5e>
f0106669:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010666d:	0f 85 01 ff ff ff    	jne    f0106574 <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106673:	ff 45 f0             	incl   -0x10(%ebp)
f0106676:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f010667b:	0f b6 c0             	movzbl %al,%eax
f010667e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106681:	0f 8f b8 fe ff ff    	jg     f010653f <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106687:	83 ec 0c             	sub    $0xc,%esp
f010668a:	68 60 c4 5e f0       	push   $0xf05ec460
f010668f:	e8 b2 85 00 00       	call   f010ec46 <release_spinlock>
f0106694:	83 c4 10             	add    $0x10,%esp
}
f0106697:	90                   	nop
f0106698:	c9                   	leave  
f0106699:	c3                   	ret    

f010669a <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f010669a:	55                   	push   %ebp
f010669b:	89 e5                	mov    %esp,%ebp
	return ticks;
f010669d:	a1 08 cb 5e f0       	mov    0xf05ecb08,%eax
f01066a2:	8b 15 0c cb 5e f0    	mov    0xf05ecb0c,%edx
}
f01066a8:	5d                   	pop    %ebp
f01066a9:	c3                   	ret    

f01066aa <env_get_nice>:
int env_get_nice(struct Env* e)
{
f01066aa:	55                   	push   %ebp
f01066ab:	89 e5                	mov    %esp,%ebp
f01066ad:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066b0:	83 ec 04             	sub    $0x4,%esp
f01066b3:	68 e4 3f 12 f0       	push   $0xf0123fe4
f01066b8:	68 8c 02 00 00       	push   $0x28c
f01066bd:	68 cb 3b 12 f0       	push   $0xf0123bcb
f01066c2:	e8 72 9c ff ff       	call   f0100339 <_panic>

f01066c7 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f01066c7:	55                   	push   %ebp
f01066c8:	89 e5                	mov    %esp,%ebp
f01066ca:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066cd:	83 ec 04             	sub    $0x4,%esp
f01066d0:	68 e4 3f 12 f0       	push   $0xf0123fe4
f01066d5:	68 94 02 00 00       	push   $0x294
f01066da:	68 cb 3b 12 f0       	push   $0xf0123bcb
f01066df:	e8 55 9c ff ff       	call   f0100339 <_panic>

f01066e4 <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f01066e4:	55                   	push   %ebp
f01066e5:	89 e5                	mov    %esp,%ebp
f01066e7:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01066ea:	83 ec 04             	sub    $0x4,%esp
f01066ed:	68 e4 3f 12 f0       	push   $0xf0123fe4
f01066f2:	68 9c 02 00 00       	push   $0x29c
f01066f7:	68 cb 3b 12 f0       	push   $0xf0123bcb
f01066fc:	e8 38 9c ff ff       	call   f0100339 <_panic>

f0106701 <get_load_average>:
}
int get_load_average()
{
f0106701:	55                   	push   %ebp
f0106702:	89 e5                	mov    %esp,%ebp
f0106704:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106707:	83 ec 04             	sub    $0x4,%esp
f010670a:	68 e4 3f 12 f0       	push   $0xf0123fe4
f010670f:	68 a4 02 00 00       	push   $0x2a4
f0106714:	68 cb 3b 12 f0       	push   $0xf0123bcb
f0106719:	e8 1b 9c ff ff       	call   f0100339 <_panic>

f010671e <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){if(scheduler_method == SCH_RR) return 1; return 0;}
f010671e:	55                   	push   %ebp
f010671f:	89 e5                	mov    %esp,%ebp
f0106721:	a1 5c c9 5e f0       	mov    0xf05ec95c,%eax
f0106726:	85 c0                	test   %eax,%eax
f0106728:	75 07                	jne    f0106731 <isSchedMethodRR+0x13>
f010672a:	b8 01 00 00 00       	mov    $0x1,%eax
f010672f:	eb 05                	jmp    f0106736 <isSchedMethodRR+0x18>
f0106731:	b8 00 00 00 00       	mov    $0x0,%eax
f0106736:	5d                   	pop    %ebp
f0106737:	c3                   	ret    

f0106738 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){if(scheduler_method == SCH_MLFQ) return 1; return 0;}
f0106738:	55                   	push   %ebp
f0106739:	89 e5                	mov    %esp,%ebp
f010673b:	a1 5c c9 5e f0       	mov    0xf05ec95c,%eax
f0106740:	83 f8 01             	cmp    $0x1,%eax
f0106743:	75 07                	jne    f010674c <isSchedMethodMLFQ+0x14>
f0106745:	b8 01 00 00 00       	mov    $0x1,%eax
f010674a:	eb 05                	jmp    f0106751 <isSchedMethodMLFQ+0x19>
f010674c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106751:	5d                   	pop    %ebp
f0106752:	c3                   	ret    

f0106753 <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){if(scheduler_method == SCH_BSD) return 1; return 0;}
f0106753:	55                   	push   %ebp
f0106754:	89 e5                	mov    %esp,%ebp
f0106756:	a1 5c c9 5e f0       	mov    0xf05ec95c,%eax
f010675b:	83 f8 02             	cmp    $0x2,%eax
f010675e:	75 07                	jne    f0106767 <isSchedMethodBSD+0x14>
f0106760:	b8 01 00 00 00       	mov    $0x1,%eax
f0106765:	eb 05                	jmp    f010676c <isSchedMethodBSD+0x19>
f0106767:	b8 00 00 00 00       	mov    $0x0,%eax
f010676c:	5d                   	pop    %ebp
f010676d:	c3                   	ret    

f010676e <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f010676e:	55                   	push   %ebp
f010676f:	89 e5                	mov    %esp,%ebp
f0106771:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f0106774:	c7 05 38 c6 5e f0 00 	movl   $0x0,0xf05ec638
f010677b:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f010677e:	83 ec 0c             	sub    $0xc,%esp
f0106781:	6a 0a                	push   $0xa
f0106783:	e8 57 02 00 00       	call   f01069df <sched_init_RR>
f0106788:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f010678b:	83 ec 0c             	sub    $0xc,%esp
f010678e:	68 d0 c4 5e f0       	push   $0xf05ec4d0
f0106793:	e8 12 e8 ff ff       	call   f0104faa <init_queue>
f0106798:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f010679b:	83 ec 0c             	sub    $0xc,%esp
f010679e:	68 e0 c4 5e f0       	push   $0xf05ec4e0
f01067a3:	e8 02 e8 ff ff       	call   f0104faa <init_queue>
f01067a8:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f01067ab:	e8 94 09 00 00       	call   f0107144 <mycpu>
f01067b0:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f01067b7:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f01067ba:	83 ec 08             	sub    $0x8,%esp
f01067bd:	68 f8 3f 12 f0       	push   $0xf0123ff8
f01067c2:	68 60 c4 5e f0       	push   $0xf05ec460
f01067c7:	e8 c2 83 00 00       	call   f010eb8e <init_spinlock>
f01067cc:	83 c4 10             	add    $0x10,%esp
}
f01067cf:	90                   	nop
f01067d0:	c9                   	leave  
f01067d1:	c3                   	ret    

f01067d2 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f01067d2:	55                   	push   %ebp
f01067d3:	89 e5                	mov    %esp,%ebp
f01067d5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01067d8:	9c                   	pushf  
f01067d9:	58                   	pop    %eax
f01067da:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f01067dd:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f01067e0:	25 00 02 00 00       	and    $0x200,%eax
f01067e5:	85 c0                	test   %eax,%eax
f01067e7:	74 14                	je     f01067fd <fos_scheduler+0x2b>
		panic("fos_scheduler: called while the interrupt is enabled!");
f01067e9:	83 ec 04             	sub    $0x4,%esp
f01067ec:	68 0c 40 12 f0       	push   $0xf012400c
f01067f1:	6a 37                	push   $0x37
f01067f3:	68 42 40 12 f0       	push   $0xf0124042
f01067f8:	e8 3c 9b ff ff       	call   f0100339 <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f01067fd:	e8 42 09 00 00       	call   f0107144 <mycpu>
f0106802:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f0106805:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106808:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f010680f:	00 00 00 

	chk1();
f0106812:	e8 84 75 01 00       	call   f011dd9b <chk1>
	c->scheduler_status = SCH_STARTED;
f0106817:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010681a:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f0106821:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f0106824:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f010682b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0106832:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f0106833:	83 ec 0c             	sub    $0xc,%esp
f0106836:	68 60 c4 5e f0       	push   $0xf05ec460
f010683b:	e8 7f 83 00 00       	call   f010ebbf <acquire_spinlock>
f0106840:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0106843:	a1 5c c9 5e f0       	mov    0xf05ec95c,%eax
f0106848:	8b 04 85 4c b9 17 f0 	mov    -0xfe846b4(,%eax,4),%eax
f010684f:	ff d0                	call   *%eax
f0106851:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f0106854:	e8 00 44 00 00       	call   f010ac59 <get_cpu_proc>
f0106859:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f010685c:	83 ec 0c             	sub    $0xc,%esp
f010685f:	ff 75 e8             	pushl  -0x18(%ebp)
f0106862:	e8 1b 44 00 00       	call   f010ac82 <set_cpu_proc>
f0106867:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f010686a:	83 ec 0c             	sub    $0xc,%esp
f010686d:	ff 75 e8             	pushl  -0x18(%ebp)
f0106870:	e8 2c 75 01 00       	call   f011dda1 <chk2>
f0106875:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f0106878:	83 ec 0c             	sub    $0xc,%esp
f010687b:	ff 75 e0             	pushl  -0x20(%ebp)
f010687e:	e8 ff 43 00 00       	call   f010ac82 <set_cpu_proc>
f0106883:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f0106886:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010688a:	0f 84 d6 00 00 00    	je     f0106966 <fos_scheduler+0x194>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f0106890:	83 ec 0c             	sub    $0xc,%esp
f0106893:	ff 75 e8             	pushl  -0x18(%ebp)
f0106896:	e8 e7 43 00 00       	call   f010ac82 <set_cpu_proc>
f010689b:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f010689e:	83 ec 0c             	sub    $0xc,%esp
f01068a1:	ff 75 e8             	pushl  -0x18(%ebp)
f01068a4:	e8 4c 46 00 00       	call   f010aef5 <switchuvm>
f01068a9:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f01068ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01068af:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f01068b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01068b9:	8b 40 04             	mov    0x4(%eax),%eax
f01068bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01068bf:	83 c2 04             	add    $0x4,%edx
f01068c2:	83 ec 08             	sub    $0x8,%esp
f01068c5:	50                   	push   %eax
f01068c6:	52                   	push   %edx
f01068c7:	e8 e6 e2 ff ff       	call   f0104bb2 <context_switch>
f01068cc:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01068cf:	9c                   	pushf  
f01068d0:	58                   	pop    %eax
f01068d1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f01068d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f01068d7:	25 00 02 00 00       	and    $0x200,%eax
f01068dc:	85 c0                	test   %eax,%eax
f01068de:	74 14                	je     f01068f4 <fos_scheduler+0x122>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f01068e0:	83 ec 04             	sub    $0x4,%esp
f01068e3:	68 54 40 12 f0       	push   $0xf0124054
f01068e8:	6a 74                	push   $0x74
f01068ea:	68 42 40 12 f0       	push   $0xf0124042
f01068ef:	e8 45 9a ff ff       	call   f0100339 <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f01068f4:	e8 02 e4 ff ff       	call   f0104cfb <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f01068f9:	e8 5b 43 00 00       	call   f010ac59 <get_cpu_proc>
f01068fe:	89 c2                	mov    %eax,%edx
f0106900:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106903:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0106909:	39 c2                	cmp    %eax,%edx
f010690b:	74 16                	je     f0106923 <fos_scheduler+0x151>
f010690d:	68 8b 40 12 f0       	push   $0xf012408b
f0106912:	68 a5 40 12 f0       	push   $0xf01240a5
f0106917:	6a 7d                	push   $0x7d
f0106919:	68 42 40 12 f0       	push   $0xf0124042
f010691e:	e8 16 9a ff ff       	call   f0100339 <_panic>
				int status = c->proc->env_status ;
f0106923:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106926:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010692c:	8b 40 18             	mov    0x18(%eax),%eax
f010692f:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f0106932:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f0106936:	75 16                	jne    f010694e <fos_scheduler+0x17c>
f0106938:	68 ba 40 12 f0       	push   $0xf01240ba
f010693d:	68 a5 40 12 f0       	push   $0xf01240a5
f0106942:	6a 7f                	push   $0x7f
f0106944:	68 42 40 12 f0       	push   $0xf0124042
f0106949:	e8 eb 99 ff ff       	call   f0100339 <_panic>
				if (status == ENV_READY)
f010694e:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106952:	74 12                	je     f0106966 <fos_scheduler+0x194>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0106954:	e8 85 45 00 00       	call   f010aede <switchkvm>
					set_cpu_proc(NULL);
f0106959:	83 ec 0c             	sub    $0xc,%esp
f010695c:	6a 00                	push   $0x0
f010695e:	e8 1f 43 00 00       	call   f010ac82 <set_cpu_proc>
f0106963:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0106966:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010696a:	0f 85 d3 fe ff ff    	jne    f0106843 <fos_scheduler+0x71>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0106970:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0106977:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010697e:	eb 36                	jmp    f01069b6 <fos_scheduler+0x1e4>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0106980:	8b 0d 70 39 5c f0    	mov    0xf05c3970,%ecx
f0106986:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106989:	89 d0                	mov    %edx,%eax
f010698b:	c1 e0 02             	shl    $0x2,%eax
f010698e:	01 d0                	add    %edx,%eax
f0106990:	01 c0                	add    %eax,%eax
f0106992:	01 d0                	add    %edx,%eax
f0106994:	c1 e0 02             	shl    $0x2,%eax
f0106997:	01 d0                	add    %edx,%eax
f0106999:	01 c0                	add    %eax,%eax
f010699b:	01 d0                	add    %edx,%eax
f010699d:	c1 e0 04             	shl    $0x4,%eax
f01069a0:	01 c8                	add    %ecx,%eax
f01069a2:	8b 40 18             	mov    0x18(%eax),%eax
f01069a5:	83 f8 03             	cmp    $0x3,%eax
f01069a8:	75 09                	jne    f01069b3 <fos_scheduler+0x1e1>
			{
				is_any_blocked = 1;
f01069aa:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f01069b1:	eb 0d                	jmp    f01069c0 <fos_scheduler+0x1ee>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f01069b3:	ff 45 f0             	incl   -0x10(%ebp)
f01069b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01069b9:	3d cf 02 00 00       	cmp    $0x2cf,%eax
f01069be:	76 c0                	jbe    f0106980 <fos_scheduler+0x1ae>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f01069c0:	83 ec 0c             	sub    $0xc,%esp
f01069c3:	68 60 c4 5e f0       	push   $0xf05ec460
f01069c8:	e8 79 82 00 00       	call   f010ec46 <release_spinlock>
f01069cd:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f01069d0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01069d4:	0f 8f 58 fe ff ff    	jg     f0106832 <fos_scheduler+0x60>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f01069da:	e8 e3 b3 ff ff       	call   f0101dc2 <get_into_prompt>

f01069df <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f01069df:	55                   	push   %ebp
f01069e0:	89 e5                	mov    %esp,%ebp
f01069e2:	83 ec 28             	sub    $0x28,%esp
f01069e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01069e8:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f01069eb:	c6 05 a0 cb 5e f0 01 	movb   $0x1,0xf05ecba0
#if USE_KHEAP
	sched_delete_ready_queues();
f01069f2:	e8 63 e8 ff ff       	call   f010525a <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f01069f7:	83 ec 0c             	sub    $0xc,%esp
f01069fa:	6a 10                	push   $0x10
f01069fc:	e8 2f 24 00 00       	call   f0108e30 <kmalloc>
f0106a01:	83 c4 10             	add    $0x10,%esp
f0106a04:	a3 f0 c4 5e f0       	mov    %eax,0xf05ec4f0
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f0106a09:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f0106a0e:	0f b6 c0             	movzbl %al,%eax
f0106a11:	83 ec 0c             	sub    $0xc,%esp
f0106a14:	50                   	push   %eax
f0106a15:	e8 16 24 00 00       	call   f0108e30 <kmalloc>
f0106a1a:	83 c4 10             	add    $0x10,%esp
f0106a1d:	a3 24 c8 5e f0       	mov    %eax,0xf05ec824
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f0106a22:	a1 24 c8 5e f0       	mov    0xf05ec824,%eax
f0106a27:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0106a2a:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f0106a2c:	a1 24 c8 5e f0       	mov    0xf05ec824,%eax
f0106a31:	8a 00                	mov    (%eax),%al
f0106a33:	0f b6 c0             	movzbl %al,%eax
f0106a36:	83 ec 0c             	sub    $0xc,%esp
f0106a39:	50                   	push   %eax
f0106a3a:	e8 85 e3 ff ff       	call   f0104dc4 <kclock_set_quantum>
f0106a3f:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0106a42:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0106a47:	83 ec 0c             	sub    $0xc,%esp
f0106a4a:	50                   	push   %eax
f0106a4b:	e8 5a e5 ff ff       	call   f0104faa <init_queue>
f0106a50:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106a53:	e8 cb e4 ff ff       	call   f0104f23 <kclock_read_cnt0_latch>
f0106a58:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f0106a5c:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0106a60:	83 ec 08             	sub    $0x8,%esp
f0106a63:	50                   	push   %eax
f0106a64:	68 d0 40 12 f0       	push   $0xf01240d0
f0106a69:	e8 1d a5 ff ff       	call   f0100f8b <cprintf>
f0106a6e:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106a71:	e8 ce 06 00 00       	call   f0107144 <mycpu>
f0106a76:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106a7d:	00 00 00 
	scheduler_method = SCH_RR;
f0106a80:	c7 05 5c c9 5e f0 00 	movl   $0x0,0xf05ec95c
f0106a87:	00 00 00 
	//=========================================
	//=========================================
}
f0106a8a:	90                   	nop
f0106a8b:	c9                   	leave  
f0106a8c:	c3                   	ret    

f0106a8d <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0106a8d:	55                   	push   %ebp
f0106a8e:	89 e5                	mov    %esp,%ebp
f0106a90:	83 ec 18             	sub    $0x18,%esp
f0106a93:	8b 45 08             	mov    0x8(%ebp),%eax
f0106a96:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f0106a99:	e8 bc e7 ff ff       	call   f010525a <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106a9e:	83 ec 04             	sub    $0x4,%esp
f0106aa1:	68 f8 40 12 f0       	push   $0xf01240f8
f0106aa6:	68 ce 00 00 00       	push   $0xce
f0106aab:	68 42 40 12 f0       	push   $0xf0124042
f0106ab0:	e8 84 98 ff ff       	call   f0100339 <_panic>

f0106ab5 <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106ab5:	55                   	push   %ebp
f0106ab6:	89 e5                	mov    %esp,%ebp
f0106ab8:	83 ec 18             	sub    $0x18,%esp
f0106abb:	8b 55 08             	mov    0x8(%ebp),%edx
f0106abe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106ac1:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106ac4:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106ac7:	83 ec 04             	sub    $0x4,%esp
f0106aca:	68 f8 40 12 f0       	push   $0xf01240f8
f0106acf:	68 e4 00 00 00       	push   $0xe4
f0106ad4:	68 42 40 12 f0       	push   $0xf0124042
f0106ad9:	e8 5b 98 ff ff       	call   f0100339 <_panic>

f0106ade <fos_scheduler_RR>:

//=========================
// [6] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0106ade:	55                   	push   %ebp
f0106adf:	89 e5                	mov    %esp,%ebp
f0106ae1:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106ae4:	83 ec 0c             	sub    $0xc,%esp
f0106ae7:	68 60 c4 5e f0       	push   $0xf05ec460
f0106aec:	e8 e7 82 00 00       	call   f010edd8 <holding_spinlock>
f0106af1:	83 c4 10             	add    $0x10,%esp
f0106af4:	85 c0                	test   %eax,%eax
f0106af6:	75 17                	jne    f0106b0f <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0106af8:	83 ec 04             	sub    $0x4,%esp
f0106afb:	68 0c 41 12 f0       	push   $0xf012410c
f0106b00:	68 fe 00 00 00       	push   $0xfe
f0106b05:	68 42 40 12 f0       	push   $0xf0124042
f0106b0a:	e8 2a 98 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0106b0f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0106b16:	e8 3e 41 00 00       	call   f010ac59 <get_cpu_proc>
f0106b1b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0106b1e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106b22:	74 14                	je     f0106b38 <fos_scheduler_RR+0x5a>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0106b24:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0106b29:	83 ec 08             	sub    $0x8,%esp
f0106b2c:	ff 75 f0             	pushl  -0x10(%ebp)
f0106b2f:	50                   	push   %eax
f0106b30:	e8 b6 e4 ff ff       	call   f0104feb <enqueue>
f0106b35:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0106b38:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f0106b3d:	83 ec 0c             	sub    $0xc,%esp
f0106b40:	50                   	push   %eax
f0106b41:	e8 36 e5 ff ff       	call   f010507c <dequeue>
f0106b46:	83 c4 10             	add    $0x10,%esp
f0106b49:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0106b4c:	a1 24 c8 5e f0       	mov    0xf05ec824,%eax
f0106b51:	8a 00                	mov    (%eax),%al
f0106b53:	0f b6 c0             	movzbl %al,%eax
f0106b56:	83 ec 0c             	sub    $0xc,%esp
f0106b59:	50                   	push   %eax
f0106b5a:	e8 65 e2 ff ff       	call   f0104dc4 <kclock_set_quantum>
f0106b5f:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106b62:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106b65:	c9                   	leave  
f0106b66:	c3                   	ret    

f0106b67 <fos_scheduler_MLFQ>:

//=========================
// [6] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106b67:	55                   	push   %ebp
f0106b68:	89 e5                	mov    %esp,%ebp
f0106b6a:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106b6d:	83 ec 0c             	sub    $0xc,%esp
f0106b70:	68 60 c4 5e f0       	push   $0xf05ec460
f0106b75:	e8 5e 82 00 00       	call   f010edd8 <holding_spinlock>
f0106b7a:	83 c4 10             	add    $0x10,%esp
f0106b7d:	85 c0                	test   %eax,%eax
f0106b7f:	75 17                	jne    f0106b98 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0106b81:	83 ec 04             	sub    $0x4,%esp
f0106b84:	68 58 41 12 f0       	push   $0xf0124158
f0106b89:	68 1d 01 00 00       	push   $0x11d
f0106b8e:	68 42 40 12 f0       	push   $0xf0124042
f0106b93:	e8 a1 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106b98:	83 ec 04             	sub    $0x4,%esp
f0106b9b:	68 f8 40 12 f0       	push   $0xf01240f8
f0106ba0:	68 23 01 00 00       	push   $0x123
f0106ba5:	68 42 40 12 f0       	push   $0xf0124042
f0106baa:	e8 8a 97 ff ff       	call   f0100339 <_panic>

f0106baf <fos_scheduler_BSD>:

//=========================
// [7] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0106baf:	55                   	push   %ebp
f0106bb0:	89 e5                	mov    %esp,%ebp
f0106bb2:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106bb5:	83 ec 0c             	sub    $0xc,%esp
f0106bb8:	68 60 c4 5e f0       	push   $0xf05ec460
f0106bbd:	e8 16 82 00 00       	call   f010edd8 <holding_spinlock>
f0106bc2:	83 c4 10             	add    $0x10,%esp
f0106bc5:	85 c0                	test   %eax,%eax
f0106bc7:	75 17                	jne    f0106be0 <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106bc9:	83 ec 04             	sub    $0x4,%esp
f0106bcc:	68 a8 41 12 f0       	push   $0xf01241a8
f0106bd1:	68 2e 01 00 00       	push   $0x12e
f0106bd6:	68 42 40 12 f0       	push   $0xf0124042
f0106bdb:	e8 59 97 ff ff       	call   f0100339 <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106be0:	83 ec 04             	sub    $0x4,%esp
f0106be3:	68 f8 40 12 f0       	push   $0xf01240f8
f0106be8:	68 34 01 00 00       	push   $0x134
f0106bed:	68 42 40 12 f0       	push   $0xf0124042
f0106bf2:	e8 42 97 ff ff       	call   f0100339 <_panic>

f0106bf7 <clock_interrupt_handler>:
//========================================
// [8] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0106bf7:	55                   	push   %ebp
f0106bf8:	89 e5                	mov    %esp,%ebp
f0106bfa:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodBSD())
f0106bfd:	e8 51 fb ff ff       	call   f0106753 <isSchedMethodBSD>
f0106c02:	85 c0                	test   %eax,%eax
f0106c04:	74 17                	je     f0106c1d <clock_interrupt_handler+0x26>
	{
		//[PROJECT] BSD Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f0106c06:	83 ec 04             	sub    $0x4,%esp
f0106c09:	68 f8 40 12 f0       	push   $0xf01240f8
f0106c0e:	68 43 01 00 00       	push   $0x143
f0106c13:	68 42 40 12 f0       	push   $0xf0124042
f0106c18:	e8 1c 97 ff ff       	call   f0100339 <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0106c1d:	a1 08 cb 5e f0       	mov    0xf05ecb08,%eax
f0106c22:	8b 15 0c cb 5e f0    	mov    0xf05ecb0c,%edx
f0106c28:	83 c0 01             	add    $0x1,%eax
f0106c2b:	83 d2 00             	adc    $0x0,%edx
f0106c2e:	a3 08 cb 5e f0       	mov    %eax,0xf05ecb08
f0106c33:	89 15 0c cb 5e f0    	mov    %edx,0xf05ecb0c
	struct Env* p = get_cpu_proc();
f0106c39:	e8 1b 40 00 00       	call   f010ac59 <get_cpu_proc>
f0106c3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0106c41:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c45:	74 30                	je     f0106c77 <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106c47:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c4a:	8b 80 ac 05 00 00    	mov    0x5ac(%eax),%eax
f0106c50:	8d 50 01             	lea    0x1(%eax),%edx
f0106c53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c56:	89 90 ac 05 00 00    	mov    %edx,0x5ac(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0106c5c:	83 ec 0c             	sub    $0xc,%esp
f0106c5f:	6a 01                	push   $0x1
f0106c61:	e8 f8 7a 00 00       	call   f010e75e <isPageReplacmentAlgorithmLRU>
f0106c66:	83 c4 10             	add    $0x10,%esp
f0106c69:	85 c0                	test   %eax,%eax
f0106c6b:	74 05                	je     f0106c72 <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0106c6d:	e8 08 00 00 00       	call   f0106c7a <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106c72:	e8 fc 40 00 00       	call   f010ad73 <yield>
	}
	/*****************************************/
}
f0106c77:	90                   	nop
f0106c78:	c9                   	leave  
f0106c79:	c3                   	ret    

f0106c7a <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106c7a:	55                   	push   %ebp
f0106c7b:	89 e5                	mov    %esp,%ebp
f0106c7d:	53                   	push   %ebx
f0106c7e:	83 ec 24             	sub    $0x24,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f0106c81:	e8 d3 3f 00 00       	call   f010ac59 <get_cpu_proc>
f0106c86:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106c89:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106c8d:	0f 84 a1 01 00 00    	je     f0106e34 <update_WS_time_stamps+0x1ba>
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106c93:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c96:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0106c9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c9f:	eb 78                	jmp    f0106d19 <update_WS_time_stamps+0x9f>
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106ca1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ca4:	8b 00                	mov    (%eax),%eax
f0106ca6:	89 45 e8             	mov    %eax,-0x18(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f0106ca9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cac:	8b 40 64             	mov    0x64(%eax),%eax
f0106caf:	83 ec 08             	sub    $0x8,%esp
f0106cb2:	ff 75 e8             	pushl  -0x18(%ebp)
f0106cb5:	50                   	push   %eax
f0106cb6:	e8 07 25 00 00       	call   f01091c2 <pt_get_page_permissions>
f0106cbb:	83 c4 10             	add    $0x10,%esp
f0106cbe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f0106cc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cc4:	8b 40 08             	mov    0x8(%eax),%eax
f0106cc7:	89 45 e0             	mov    %eax,-0x20(%ebp)

					if (perm & PERM_USED)
f0106cca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106ccd:	83 e0 20             	and    $0x20,%eax
f0106cd0:	85 c0                	test   %eax,%eax
f0106cd2:	74 2b                	je     f0106cff <update_WS_time_stamps+0x85>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106cd4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106cd7:	c1 e8 02             	shr    $0x2,%eax
f0106cda:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106cdf:	89 c2                	mov    %eax,%edx
f0106ce1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ce4:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f0106ce7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106cea:	8b 40 64             	mov    0x64(%eax),%eax
f0106ced:	6a 20                	push   $0x20
f0106cef:	6a 00                	push   $0x0
f0106cf1:	ff 75 e8             	pushl  -0x18(%ebp)
f0106cf4:	50                   	push   %eax
f0106cf5:	e8 04 24 00 00       	call   f01090fe <pt_set_page_permissions>
f0106cfa:	83 c4 10             	add    $0x10,%esp
f0106cfd:	eb 0e                	jmp    f0106d0d <update_WS_time_stamps+0x93>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f0106cff:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0106d02:	c1 e8 02             	shr    $0x2,%eax
f0106d05:	89 c2                	mov    %eax,%edx
f0106d07:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d0a:	89 50 08             	mov    %edx,0x8(%eax)
	{
		struct WorkingSetElement* wse ;
		{
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
f0106d0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d10:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0106d16:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106d19:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106d1d:	74 08                	je     f0106d27 <update_WS_time_stamps+0xad>
f0106d1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d22:	8b 40 10             	mov    0x10(%eax),%eax
f0106d25:	eb 05                	jmp    f0106d2c <update_WS_time_stamps+0xb2>
f0106d27:	b8 00 00 00 00       	mov    $0x0,%eax
f0106d2c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106d2f:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f0106d35:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106d38:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0106d3e:	85 c0                	test   %eax,%eax
f0106d40:	0f 85 5b ff ff ff    	jne    f0106ca1 <update_WS_time_stamps+0x27>
f0106d46:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106d4a:	0f 85 51 ff ff ff    	jne    f0106ca1 <update_WS_time_stamps+0x27>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106d50:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106d57:	e9 ce 00 00 00       	jmp    f0106e2a <update_WS_time_stamps+0x1b0>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f0106d5c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d5f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d62:	89 d0                	mov    %edx,%eax
f0106d64:	01 c0                	add    %eax,%eax
f0106d66:	01 d0                	add    %edx,%eax
f0106d68:	c1 e0 03             	shl    $0x3,%eax
f0106d6b:	01 c8                	add    %ecx,%eax
f0106d6d:	05 a4 00 00 00       	add    $0xa4,%eax
f0106d72:	8a 00                	mov    (%eax),%al
f0106d74:	3c 01                	cmp    $0x1,%al
f0106d76:	0f 84 ab 00 00 00    	je     f0106e27 <update_WS_time_stamps+0x1ad>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f0106d7c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d7f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d82:	89 d0                	mov    %edx,%eax
f0106d84:	01 c0                	add    %eax,%eax
f0106d86:	01 d0                	add    %edx,%eax
f0106d88:	c1 e0 03             	shl    $0x3,%eax
f0106d8b:	01 c8                	add    %ecx,%eax
f0106d8d:	05 a0 00 00 00       	add    $0xa0,%eax
f0106d92:	8b 00                	mov    (%eax),%eax
f0106d94:	89 45 dc             	mov    %eax,-0x24(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f0106d97:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106d9a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d9d:	89 d0                	mov    %edx,%eax
f0106d9f:	01 c0                	add    %eax,%eax
f0106da1:	01 d0                	add    %edx,%eax
f0106da3:	c1 e0 03             	shl    $0x3,%eax
f0106da6:	01 c8                	add    %ecx,%eax
f0106da8:	05 a8 00 00 00       	add    $0xa8,%eax
f0106dad:	8b 00                	mov    (%eax),%eax
f0106daf:	89 45 d8             	mov    %eax,-0x28(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f0106db2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106db5:	8b 40 64             	mov    0x64(%eax),%eax
f0106db8:	83 ec 08             	sub    $0x8,%esp
f0106dbb:	ff 75 dc             	pushl  -0x24(%ebp)
f0106dbe:	50                   	push   %eax
f0106dbf:	e8 da 24 00 00       	call   f010929e <pd_is_table_used>
f0106dc4:	83 c4 10             	add    $0x10,%esp
f0106dc7:	85 c0                	test   %eax,%eax
f0106dc9:	74 3c                	je     f0106e07 <update_WS_time_stamps+0x18d>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106dcb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106dce:	c1 e8 02             	shr    $0x2,%eax
f0106dd1:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106dd6:	89 c1                	mov    %eax,%ecx
f0106dd8:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106ddb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106dde:	89 d0                	mov    %edx,%eax
f0106de0:	01 c0                	add    %eax,%eax
f0106de2:	01 d0                	add    %edx,%eax
f0106de4:	c1 e0 03             	shl    $0x3,%eax
f0106de7:	01 d8                	add    %ebx,%eax
f0106de9:	05 a8 00 00 00       	add    $0xa8,%eax
f0106dee:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f0106df0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106df3:	8b 40 64             	mov    0x64(%eax),%eax
f0106df6:	83 ec 08             	sub    $0x8,%esp
f0106df9:	ff 75 dc             	pushl  -0x24(%ebp)
f0106dfc:	50                   	push   %eax
f0106dfd:	e8 c0 24 00 00       	call   f01092c2 <pd_set_table_unused>
f0106e02:	83 c4 10             	add    $0x10,%esp
f0106e05:	eb 20                	jmp    f0106e27 <update_WS_time_stamps+0x1ad>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f0106e07:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0106e0a:	c1 e8 02             	shr    $0x2,%eax
f0106e0d:	89 c1                	mov    %eax,%ecx
f0106e0f:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106e12:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106e15:	89 d0                	mov    %edx,%eax
f0106e17:	01 c0                	add    %eax,%eax
f0106e19:	01 d0                	add    %edx,%eax
f0106e1b:	c1 e0 03             	shl    $0x3,%eax
f0106e1e:	01 d8                	add    %ebx,%eax
f0106e20:	05 a8 00 00 00       	add    $0xa8,%eax
f0106e25:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106e27:	ff 45 f0             	incl   -0x10(%ebp)
f0106e2a:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0106e2e:	0f 8e 28 ff ff ff    	jle    f0106d5c <update_WS_time_stamps+0xe2>
						}
					}
				}
			}
		}
	}
f0106e34:	90                   	nop
f0106e35:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106e38:	c9                   	leave  
f0106e39:	c3                   	ret    

f0106e3a <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0106e3a:	55                   	push   %ebp
f0106e3b:	89 e5                	mov    %esp,%ebp
f0106e3d:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0106e40:	c7 05 6c 39 5c f0 01 	movl   $0x1,0xf05c396c
f0106e47:	00 00 00 
f0106e4a:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0106e51:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106e55:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0106e58:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106e5b:	ee                   	out    %al,(%dx)
f0106e5c:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0106e63:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0106e67:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0106e6a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106e6d:	ee                   	out    %al,(%dx)
f0106e6e:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0106e75:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0106e79:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0106e7c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106e7f:	ee                   	out    %al,(%dx)
f0106e80:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0106e87:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0106e8b:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0106e8e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0106e91:	ee                   	out    %al,(%dx)
f0106e92:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0106e99:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0106e9d:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0106ea0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0106ea3:	ee                   	out    %al,(%dx)
f0106ea4:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0106eab:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0106eaf:	8a 45 b7             	mov    -0x49(%ebp),%al
f0106eb2:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0106eb5:	ee                   	out    %al,(%dx)
f0106eb6:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0106ebd:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0106ec1:	8a 45 b8             	mov    -0x48(%ebp),%al
f0106ec4:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0106ec7:	ee                   	out    %al,(%dx)
f0106ec8:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0106ecf:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0106ed3:	8a 45 b9             	mov    -0x47(%ebp),%al
f0106ed6:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0106ed9:	ee                   	out    %al,(%dx)
f0106eda:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0106ee1:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0106ee5:	8a 45 ba             	mov    -0x46(%ebp),%al
f0106ee8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0106eeb:	ee                   	out    %al,(%dx)
f0106eec:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0106ef3:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0106ef7:	8a 45 bb             	mov    -0x45(%ebp),%al
f0106efa:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0106efd:	ee                   	out    %al,(%dx)
f0106efe:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0106f05:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0106f09:	8a 45 bc             	mov    -0x44(%ebp),%al
f0106f0c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0106f0f:	ee                   	out    %al,(%dx)
f0106f10:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0106f17:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0106f1b:	8a 45 bd             	mov    -0x43(%ebp),%al
f0106f1e:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0106f21:	ee                   	out    %al,(%dx)
f0106f22:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0106f29:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0106f2d:	8a 45 be             	mov    -0x42(%ebp),%al
f0106f30:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0106f33:	ee                   	out    %al,(%dx)
f0106f34:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0106f3b:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0106f3f:	8a 45 bf             	mov    -0x41(%ebp),%al
f0106f42:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0106f45:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0106f46:	66 a1 58 b9 17 f0    	mov    0xf017b958,%ax
f0106f4c:	66 83 f8 ff          	cmp    $0xffff,%ax
f0106f50:	74 15                	je     f0106f67 <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0106f52:	66 a1 58 b9 17 f0    	mov    0xf017b958,%ax
f0106f58:	0f b7 c0             	movzwl %ax,%eax
f0106f5b:	83 ec 0c             	sub    $0xc,%esp
f0106f5e:	50                   	push   %eax
f0106f5f:	e8 06 00 00 00       	call   f0106f6a <irq_setmask_8259A>
f0106f64:	83 c4 10             	add    $0x10,%esp
}
f0106f67:	90                   	nop
f0106f68:	c9                   	leave  
f0106f69:	c3                   	ret    

f0106f6a <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0106f6a:	55                   	push   %ebp
f0106f6b:	89 e5                	mov    %esp,%ebp
f0106f6d:	83 ec 14             	sub    $0x14,%esp
f0106f70:	8b 45 08             	mov    0x8(%ebp),%eax
f0106f73:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0106f77:	a1 6c 39 5c f0       	mov    0xf05c396c,%eax
f0106f7c:	85 c0                	test   %eax,%eax
f0106f7e:	74 34                	je     f0106fb4 <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0106f80:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f83:	0f b6 c0             	movzbl %al,%eax
f0106f86:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0106f8d:	88 45 f6             	mov    %al,-0xa(%ebp)
f0106f90:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106f93:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106f96:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0106f97:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106f9a:	66 c1 e8 08          	shr    $0x8,%ax
f0106f9e:	0f b6 c0             	movzbl %al,%eax
f0106fa1:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0106fa8:	88 45 f7             	mov    %al,-0x9(%ebp)
f0106fab:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106fae:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106fb1:	ee                   	out    %al,(%dx)
f0106fb2:	eb 01                	jmp    f0106fb5 <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0106fb4:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0106fb5:	c9                   	leave  
f0106fb6:	c3                   	ret    

f0106fb7 <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0106fb7:	55                   	push   %ebp
f0106fb8:	89 e5                	mov    %esp,%ebp
f0106fba:	53                   	push   %ebx
f0106fbb:	83 ec 14             	sub    $0x14,%esp
f0106fbe:	8b 45 08             	mov    0x8(%ebp),%eax
f0106fc1:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106fc4:	a1 6c 39 5c f0       	mov    0xf05c396c,%eax
f0106fc9:	85 c0                	test   %eax,%eax
f0106fcb:	74 58                	je     f0107025 <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106fcd:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106fd1:	77 08                	ja     f0106fdb <irq_set_mask+0x24>
		port = PIC1_DATA;
f0106fd3:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106fd9:	eb 0a                	jmp    f0106fe5 <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106fdb:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106fe1:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0106fe5:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106fe9:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106fec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fef:	89 c2                	mov    %eax,%edx
f0106ff1:	ec                   	in     (%dx),%al
f0106ff2:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106ff5:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106ff8:	88 c2                	mov    %al,%dl
f0106ffa:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106ffe:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107003:	88 c1                	mov    %al,%cl
f0107005:	d3 e3                	shl    %cl,%ebx
f0107007:	89 d8                	mov    %ebx,%eax
f0107009:	09 d0                	or     %edx,%eax
f010700b:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f010700e:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107012:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107016:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107019:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010701c:	8a 45 ef             	mov    -0x11(%ebp),%al
f010701f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107022:	ee                   	out    %al,(%dx)
f0107023:	eb 01                	jmp    f0107026 <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107025:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0107026:	83 c4 14             	add    $0x14,%esp
f0107029:	5b                   	pop    %ebx
f010702a:	5d                   	pop    %ebp
f010702b:	c3                   	ret    

f010702c <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f010702c:	55                   	push   %ebp
f010702d:	89 e5                	mov    %esp,%ebp
f010702f:	53                   	push   %ebx
f0107030:	83 ec 14             	sub    $0x14,%esp
f0107033:	8b 45 08             	mov    0x8(%ebp),%eax
f0107036:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107039:	a1 6c 39 5c f0       	mov    0xf05c396c,%eax
f010703e:	85 c0                	test   %eax,%eax
f0107040:	74 5a                	je     f010709c <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107042:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107046:	77 08                	ja     f0107050 <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0107048:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f010704e:	eb 0a                	jmp    f010705a <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107050:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107056:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f010705a:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f010705e:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107061:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107064:	89 c2                	mov    %eax,%edx
f0107066:	ec                   	in     (%dx),%al
f0107067:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f010706a:	8a 45 ee             	mov    -0x12(%ebp),%al
f010706d:	88 c2                	mov    %al,%dl
f010706f:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0107073:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107078:	88 c1                	mov    %al,%cl
f010707a:	d3 e3                	shl    %cl,%ebx
f010707c:	89 d8                	mov    %ebx,%eax
f010707e:	f7 d0                	not    %eax
f0107080:	21 d0                	and    %edx,%eax
f0107082:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0107085:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107089:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f010708d:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107090:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107093:	8a 45 ef             	mov    -0x11(%ebp),%al
f0107096:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107099:	ee                   	out    %al,(%dx)
f010709a:	eb 01                	jmp    f010709d <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f010709c:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f010709d:	83 c4 14             	add    $0x14,%esp
f01070a0:	5b                   	pop    %ebx
f01070a1:	5d                   	pop    %ebp
f01070a2:	c3                   	ret    

f01070a3 <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f01070a3:	55                   	push   %ebp
f01070a4:	89 e5                	mov    %esp,%ebp
f01070a6:	53                   	push   %ebx
f01070a7:	83 ec 14             	sub    $0x14,%esp
f01070aa:	8b 45 08             	mov    0x8(%ebp),%eax
f01070ad:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f01070b0:	a1 6c 39 5c f0       	mov    0xf05c396c,%eax
f01070b5:	85 c0                	test   %eax,%eax
f01070b7:	75 07                	jne    f01070c0 <irq_get_mask+0x1d>
		return -1;
f01070b9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01070be:	eb 45                	jmp    f0107105 <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f01070c0:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f01070c4:	77 08                	ja     f01070ce <irq_get_mask+0x2b>
		port = PIC1_DATA;
f01070c6:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f01070cc:	eb 0a                	jmp    f01070d8 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f01070ce:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f01070d4:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f01070d8:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f01070dc:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01070df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070e2:	89 c2                	mov    %eax,%edx
f01070e4:	ec                   	in     (%dx),%al
f01070e5:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f01070e8:	8a 45 f3             	mov    -0xd(%ebp),%al
f01070eb:	88 c2                	mov    %al,%dl
f01070ed:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f01070f1:	bb 01 00 00 00       	mov    $0x1,%ebx
f01070f6:	88 c1                	mov    %al,%cl
f01070f8:	d3 e3                	shl    %cl,%ebx
f01070fa:	89 d8                	mov    %ebx,%eax
f01070fc:	21 d0                	and    %edx,%eax
f01070fe:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f0107101:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f0107105:	83 c4 14             	add    $0x14,%esp
f0107108:	5b                   	pop    %ebx
f0107109:	5d                   	pop    %ebp
f010710a:	c3                   	ret    

f010710b <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f010710b:	55                   	push   %ebp
f010710c:	89 e5                	mov    %esp,%ebp
f010710e:	83 ec 14             	sub    $0x14,%esp
f0107111:	8b 45 08             	mov    0x8(%ebp),%eax
f0107114:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f0107117:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f010711b:	76 12                	jbe    f010712f <pic_sendEOI+0x24>
f010711d:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f0107124:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107128:	8a 45 f7             	mov    -0x9(%ebp),%al
f010712b:	8b 55 f8             	mov    -0x8(%ebp),%edx
f010712e:	ee                   	out    %al,(%dx)
f010712f:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f0107136:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f010713a:	8a 45 f6             	mov    -0xa(%ebp),%al
f010713d:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107140:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f0107141:	90                   	nop
f0107142:	c9                   	leave  
f0107143:	c3                   	ret    

f0107144 <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f0107144:	55                   	push   %ebp
f0107145:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f0107147:	b8 40 c6 5e f0       	mov    $0xf05ec640,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f010714c:	5d                   	pop    %ebp
f010714d:	c3                   	ret    

f010714e <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f010714e:	55                   	push   %ebp
f010714f:	89 e5                	mov    %esp,%ebp
f0107151:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f0107154:	e8 eb ff ff ff       	call   f0107144 <mycpu>
f0107159:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f010715c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010715f:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0107166:	00 00 00 
  c->ncli = 0;
f0107169:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010716c:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0107173:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107176:	9c                   	pushf  
f0107177:	58                   	pop    %eax
f0107178:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010717b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f010717e:	25 00 02 00 00       	and    $0x200,%eax
f0107183:	85 c0                	test   %eax,%eax
f0107185:	0f 95 c0             	setne  %al
f0107188:	0f b6 d0             	movzbl %al,%edx
f010718b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010718e:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f0107194:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107197:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f010719e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071a1:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f01071a8:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f01071ab:	8b 45 08             	mov    0x8(%ebp),%eax
f01071ae:	40                   	inc    %eax
f01071af:	c1 e0 0f             	shl    $0xf,%eax
f01071b2:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f01071b7:	29 c2                	sub    %eax,%edx
f01071b9:	89 d0                	mov    %edx,%eax
f01071bb:	89 c2                	mov    %eax,%edx
f01071bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071c0:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f01071c3:	e8 18 01 00 00       	call   f01072e0 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f01071c8:	e8 54 50 00 00       	call   f010c221 <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f01071cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071d0:	83 c0 0c             	add    $0xc,%eax
f01071d3:	83 ec 04             	sub    $0x4,%esp
f01071d6:	6a 68                	push   $0x68
f01071d8:	6a 00                	push   $0x0
f01071da:	50                   	push   %eax
f01071db:	e8 ed 7b 01 00       	call   f011edcd <memset>
f01071e0:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f01071e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071e6:	05 a4 00 00 00       	add    $0xa4,%eax
f01071eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01071ee:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f01071f5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01071f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01071fb:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f01071fe:	f0 87 02             	lock xchg %eax,(%edx)
f0107201:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f0107204:	90                   	nop
f0107205:	c9                   	leave  
f0107206:	c3                   	ret    

f0107207 <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f0107207:	55                   	push   %ebp
f0107208:	89 e5                	mov    %esp,%ebp
f010720a:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010720d:	9c                   	pushf  
f010720e:	58                   	pop    %eax
f010720f:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f0107212:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f0107215:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0107218:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f0107219:	e8 26 ff ff ff       	call   f0107144 <mycpu>
f010721e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f0107221:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107224:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010722a:	85 c0                	test   %eax,%eax
f010722c:	75 13                	jne    f0107241 <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f010722e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107231:	25 00 02 00 00       	and    $0x200,%eax
f0107236:	89 c2                	mov    %eax,%edx
f0107238:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010723b:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f0107241:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107244:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010724a:	8d 50 01             	lea    0x1(%eax),%edx
f010724d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107250:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f0107256:	90                   	nop
f0107257:	c9                   	leave  
f0107258:	c3                   	ret    

f0107259 <popcli>:

void popcli(void)
{
f0107259:	55                   	push   %ebp
f010725a:	89 e5                	mov    %esp,%ebp
f010725c:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010725f:	9c                   	pushf  
f0107260:	58                   	pop    %eax
f0107261:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107264:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f0107267:	25 00 02 00 00       	and    $0x200,%eax
f010726c:	85 c0                	test   %eax,%eax
f010726e:	74 14                	je     f0107284 <popcli+0x2b>
    panic("popcli - interruptible");
f0107270:	83 ec 04             	sub    $0x4,%esp
f0107273:	68 f5 41 12 f0       	push   $0xf01241f5
f0107278:	6a 5e                	push   $0x5e
f010727a:	68 0c 42 12 f0       	push   $0xf012420c
f010727f:	e8 b5 90 ff ff       	call   f0100339 <_panic>
  struct cpu* c = mycpu();
f0107284:	e8 bb fe ff ff       	call   f0107144 <mycpu>
f0107289:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f010728c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010728f:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0107295:	8d 50 ff             	lea    -0x1(%eax),%edx
f0107298:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010729b:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f01072a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072a4:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01072aa:	85 c0                	test   %eax,%eax
f01072ac:	79 14                	jns    f01072c2 <popcli+0x69>
    panic("popcli");
f01072ae:	83 ec 04             	sub    $0x4,%esp
f01072b1:	68 1b 42 12 f0       	push   $0xf012421b
f01072b6:	6a 61                	push   $0x61
f01072b8:	68 0c 42 12 f0       	push   $0xf012420c
f01072bd:	e8 77 90 ff ff       	call   f0100339 <_panic>
  if(c->ncli == 0 && c->intena)
f01072c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072c5:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01072cb:	85 c0                	test   %eax,%eax
f01072cd:	75 0e                	jne    f01072dd <popcli+0x84>
f01072cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072d2:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f01072d8:	85 c0                	test   %eax,%eax
f01072da:	74 01                	je     f01072dd <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01072dc:	fb                   	sti    
    sti();
}
f01072dd:	90                   	nop
f01072de:	c9                   	leave  
f01072df:	c3                   	ret    

f01072e0 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f01072e0:	55                   	push   %ebp
f01072e1:	89 e5                	mov    %esp,%ebp
f01072e3:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f01072e6:	e8 1c ff ff ff       	call   f0107207 <pushcli>

	c = mycpu();
f01072eb:	e8 54 fe ff ff       	call   f0107144 <mycpu>
f01072f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f01072f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072f6:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f01072fd:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f0107304:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107307:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f010730d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107310:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f0107316:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107319:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f0107320:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107323:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107329:	83 e2 f0             	and    $0xfffffff0,%edx
f010732c:	83 ca 0a             	or     $0xa,%edx
f010732f:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107335:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107338:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010733e:	83 ca 10             	or     $0x10,%edx
f0107341:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107347:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010734a:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107350:	83 e2 9f             	and    $0xffffff9f,%edx
f0107353:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107359:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010735c:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0107362:	83 ca 80             	or     $0xffffff80,%edx
f0107365:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010736b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010736e:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107374:	83 ca 0f             	or     $0xf,%edx
f0107377:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010737d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107380:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107386:	83 e2 ef             	and    $0xffffffef,%edx
f0107389:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010738f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107392:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107398:	83 e2 df             	and    $0xffffffdf,%edx
f010739b:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01073a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073a4:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01073aa:	83 ca 40             	or     $0x40,%edx
f01073ad:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01073b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073b6:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01073bc:	83 ca 80             	or     $0xffffff80,%edx
f01073bf:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01073c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073c8:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f01073cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073d2:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f01073d9:	ff ff 
f01073db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073de:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f01073e5:	00 00 
f01073e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073ea:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f01073f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073f4:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01073fa:	83 e2 f0             	and    $0xfffffff0,%edx
f01073fd:	83 ca 02             	or     $0x2,%edx
f0107400:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107406:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107409:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f010740f:	83 ca 10             	or     $0x10,%edx
f0107412:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0107418:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010741b:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107421:	83 e2 9f             	and    $0xffffff9f,%edx
f0107424:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f010742a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010742d:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0107433:	83 ca 80             	or     $0xffffff80,%edx
f0107436:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f010743c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010743f:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107445:	83 ca 0f             	or     $0xf,%edx
f0107448:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010744e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107451:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107457:	83 e2 ef             	and    $0xffffffef,%edx
f010745a:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107460:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107463:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107469:	83 e2 df             	and    $0xffffffdf,%edx
f010746c:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107472:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107475:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010747b:	83 ca 40             	or     $0x40,%edx
f010747e:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107484:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107487:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010748d:	83 ca 80             	or     $0xffffff80,%edx
f0107490:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107496:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107499:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f01074a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074a3:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f01074aa:	ff ff 
f01074ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074af:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f01074b6:	00 00 
f01074b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074bb:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f01074c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074c5:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074cb:	83 e2 f0             	and    $0xfffffff0,%edx
f01074ce:	83 ca 0a             	or     $0xa,%edx
f01074d1:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074da:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074e0:	83 ca 10             	or     $0x10,%edx
f01074e3:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074ec:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01074f2:	83 ca 60             	or     $0x60,%edx
f01074f5:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01074fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074fe:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107504:	83 ca 80             	or     $0xffffff80,%edx
f0107507:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f010750d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107510:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107516:	83 ca 0f             	or     $0xf,%edx
f0107519:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010751f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107522:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107528:	83 e2 ef             	and    $0xffffffef,%edx
f010752b:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107531:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107534:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f010753a:	83 e2 df             	and    $0xffffffdf,%edx
f010753d:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107543:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107546:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f010754c:	83 ca 40             	or     $0x40,%edx
f010754f:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107555:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107558:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f010755e:	83 ca 80             	or     $0xffffff80,%edx
f0107561:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107567:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010756a:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f0107571:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107574:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f010757b:	ff ff 
f010757d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107580:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f0107587:	00 00 
f0107589:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010758c:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f0107593:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107596:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010759c:	83 e2 f0             	and    $0xfffffff0,%edx
f010759f:	83 ca 02             	or     $0x2,%edx
f01075a2:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01075a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075ab:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01075b1:	83 ca 10             	or     $0x10,%edx
f01075b4:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01075ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075bd:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01075c3:	83 ca 60             	or     $0x60,%edx
f01075c6:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01075cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075cf:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01075d5:	83 ca 80             	or     $0xffffff80,%edx
f01075d8:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01075de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075e1:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075e7:	83 ca 0f             	or     $0xf,%edx
f01075ea:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01075f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075f3:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01075f9:	83 e2 ef             	and    $0xffffffef,%edx
f01075fc:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107602:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107605:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f010760b:	83 e2 df             	and    $0xffffffdf,%edx
f010760e:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107614:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107617:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f010761d:	83 ca 40             	or     $0x40,%edx
f0107620:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107626:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107629:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f010762f:	83 ca 80             	or     $0xffffff80,%edx
f0107632:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0107638:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010763b:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f0107642:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107645:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f010764c:	00 00 00 
f010764f:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f0107656:	00 00 00 

	popcli();	//enable interrupt
f0107659:	e8 fb fb ff ff       	call   f0107259 <popcli>


}
f010765e:	90                   	nop
f010765f:	c9                   	leave  
f0107660:	c3                   	ret    

f0107661 <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f0107661:	55                   	push   %ebp
f0107662:	89 e5                	mov    %esp,%ebp
f0107664:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f0107667:	83 ec 08             	sub    $0x8,%esp
f010766a:	68 00 10 00 00       	push   $0x1000
f010766f:	68 00 10 00 00       	push   $0x1000
f0107674:	e8 4a 02 00 00       	call   f01078c3 <boot_allocate_space>
f0107679:	83 c4 10             	add    $0x10,%esp
f010767c:	a3 1c cb 5e f0       	mov    %eax,0xf05ecb1c
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107681:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0107686:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107689:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107690:	77 14                	ja     f01076a6 <initialize_kernel_VM+0x45>
f0107692:	ff 75 e0             	pushl  -0x20(%ebp)
f0107695:	68 24 42 12 f0       	push   $0xf0124224
f010769a:	6a 57                	push   $0x57
f010769c:	68 58 42 12 f0       	push   $0xf0124258
f01076a1:	e8 93 8c ff ff       	call   f0100339 <_panic>
f01076a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01076a9:	05 00 00 00 10       	add    $0x10000000,%eax
f01076ae:	a3 24 cc 5e f0       	mov    %eax,0xf05ecc24
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f01076b3:	c7 45 dc 00 30 17 f0 	movl   $0xf0173000,-0x24(%ebp)
f01076ba:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f01076c1:	77 14                	ja     f01076d7 <initialize_kernel_VM+0x76>
f01076c3:	ff 75 dc             	pushl  -0x24(%ebp)
f01076c6:	68 24 42 12 f0       	push   $0xf0124224
f01076cb:	6a 63                	push   $0x63
f01076cd:	68 58 42 12 f0       	push   $0xf0124258
f01076d2:	e8 62 8c ff ff       	call   f0100339 <_panic>
f01076d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01076da:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01076e0:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f01076e5:	83 ec 0c             	sub    $0xc,%esp
f01076e8:	6a 02                	push   $0x2
f01076ea:	52                   	push   %edx
f01076eb:	68 00 80 00 00       	push   $0x8000
f01076f0:	68 00 80 bf ef       	push   $0xefbf8000
f01076f5:	50                   	push   %eax
f01076f6:	e8 3c 02 00 00       	call   f0107937 <boot_map_range>
f01076fb:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01076fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0107705:	eb 24                	jmp    f010772b <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f0107707:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010770a:	40                   	inc    %eax
f010770b:	c1 e0 0f             	shl    $0xf,%eax
f010770e:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0107713:	29 c2                	sub    %eax,%edx
f0107715:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f010771a:	6a 01                	push   $0x1
f010771c:	6a 00                	push   $0x0
f010771e:	52                   	push   %edx
f010771f:	50                   	push   %eax
f0107720:	e8 d9 19 00 00       	call   f01090fe <pt_set_page_permissions>
f0107725:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f0107728:	ff 45 f4             	incl   -0xc(%ebp)
f010772b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010772f:	7e d6                	jle    f0107707 <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f0107731:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0107738:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f010773f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f0107746:	eb 25                	jmp    f010776d <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0107748:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f010774b:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010774e:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0107753:	83 ec 04             	sub    $0x4,%esp
f0107756:	6a 01                	push   $0x1
f0107758:	52                   	push   %edx
f0107759:	50                   	push   %eax
f010775a:	e8 4c 02 00 00       	call   f01079ab <boot_get_page_table>
f010775f:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f0107762:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0107769:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f010776d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107771:	72 d5                	jb     f0107748 <initialize_kernel_VM+0xe7>
f0107773:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107777:	77 06                	ja     f010777f <initialize_kernel_VM+0x11e>
f0107779:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f010777d:	76 c9                	jbe    f0107748 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f010777f:	8b 15 f8 c6 5e f0    	mov    0xf05ec6f8,%edx
f0107785:	89 d0                	mov    %edx,%eax
f0107787:	01 c0                	add    %eax,%eax
f0107789:	01 d0                	add    %edx,%eax
f010778b:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f0107792:	01 c8                	add    %ecx,%eax
f0107794:	01 d0                	add    %edx,%eax
f0107796:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f0107799:	83 ec 08             	sub    $0x8,%esp
f010779c:	68 00 10 00 00       	push   $0x1000
f01077a1:	ff 75 d8             	pushl  -0x28(%ebp)
f01077a4:	e8 1a 01 00 00       	call   f01078c3 <boot_allocate_space>
f01077a9:	83 c4 10             	add    $0x10,%esp
f01077ac:	a3 68 c9 5e f0       	mov    %eax,0xf05ec968
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f01077b1:	c7 45 d4 00 e0 38 00 	movl   $0x38e000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f01077b8:	83 ec 08             	sub    $0x8,%esp
f01077bb:	68 00 10 00 00       	push   $0x1000
f01077c0:	ff 75 d4             	pushl  -0x2c(%ebp)
f01077c3:	e8 fb 00 00 00       	call   f01078c3 <boot_allocate_space>
f01077c8:	83 c4 10             	add    $0x10,%esp
f01077cb:	a3 24 c2 5e f0       	mov    %eax,0xf05ec224
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f01077d0:	e8 05 05 00 00       	call   f0107cda <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f01077d5:	83 ec 0c             	sub    $0xc,%esp
f01077d8:	68 d0 02 00 00       	push   $0x2d0
f01077dd:	e8 5b 59 01 00       	call   f011d13d <nearest_pow2_ceil>
f01077e2:	83 c4 10             	add    $0x10,%esp
f01077e5:	83 ec 04             	sub    $0x4,%esp
f01077e8:	50                   	push   %eax
f01077e9:	68 d0 02 00 00       	push   $0x2d0
f01077ee:	68 78 42 12 f0       	push   $0xf0124278
f01077f3:	e8 93 97 ff ff       	call   f0100f8b <cprintf>
f01077f8:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f01077fb:	c7 45 d0 00 ff 0f 00 	movl   $0xfff00,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f0107802:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107805:	83 ec 08             	sub    $0x8,%esp
f0107808:	68 00 10 00 00       	push   $0x1000
f010780d:	50                   	push   %eax
f010780e:	e8 b0 00 00 00       	call   f01078c3 <boot_allocate_space>
f0107813:	83 c4 10             	add    $0x10,%esp
f0107816:	a3 70 39 5c f0       	mov    %eax,0xf05c3970
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f010781b:	a1 70 39 5c f0       	mov    0xf05c3970,%eax
f0107820:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0107823:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f010782a:	77 17                	ja     f0107843 <initialize_kernel_VM+0x1e2>
f010782c:	ff 75 cc             	pushl  -0x34(%ebp)
f010782f:	68 24 42 12 f0       	push   $0xf0124224
f0107834:	68 b1 00 00 00       	push   $0xb1
f0107839:	68 58 42 12 f0       	push   $0xf0124258
f010783e:	e8 f6 8a ff ff       	call   f0100339 <_panic>
f0107843:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107846:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f010784c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010784f:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0107854:	83 ec 0c             	sub    $0xc,%esp
f0107857:	6a 04                	push   $0x4
f0107859:	51                   	push   %ecx
f010785a:	52                   	push   %edx
f010785b:	68 00 00 c0 ee       	push   $0xeec00000
f0107860:	50                   	push   %eax
f0107861:	e8 d1 00 00 00       	call   f0107937 <boot_map_range>
f0107866:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0107869:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f010786e:	05 ec 0e 00 00       	add    $0xeec,%eax
f0107873:	8b 15 1c cb 5e f0    	mov    0xf05ecb1c,%edx
f0107879:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f010787f:	8b 12                	mov    (%edx),%edx
f0107881:	83 ca 05             	or     $0x5,%edx
f0107884:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0107886:	a1 18 cb 5e f0       	mov    0xf05ecb18,%eax
f010788b:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107891:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0107896:	83 ec 0c             	sub    $0xc,%esp
f0107899:	6a 02                	push   $0x2
f010789b:	6a 00                	push   $0x0
f010789d:	52                   	push   %edx
f010789e:	68 00 00 00 f0       	push   $0xf0000000
f01078a3:	50                   	push   %eax
f01078a4:	e8 8e 00 00 00       	call   f0107937 <boot_map_range>
f01078a9:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f01078ac:	e8 5f 68 01 00       	call   f011e110 <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f01078b1:	c7 05 30 c6 5e f0 19 	movl   $0x19,0xf05ec630
f01078b8:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f01078bb:	e8 e6 02 00 00       	call   f0107ba6 <turn_on_paging>
}
f01078c0:	90                   	nop
f01078c1:	c9                   	leave  
f01078c2:	c3                   	ret    

f01078c3 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f01078c3:	55                   	push   %ebp
f01078c4:	89 e5                	mov    %esp,%ebp
f01078c6:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f01078c9:	a1 18 cb 5e f0       	mov    0xf05ecb18,%eax
f01078ce:	85 c0                	test   %eax,%eax
f01078d0:	75 0a                	jne    f01078dc <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f01078d2:	c7 05 18 cb 5e f0 f4 	movl   $0xf060f5f4,0xf05ecb18
f01078d9:	f5 60 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f01078dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01078df:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01078e2:	a1 18 cb 5e f0       	mov    0xf05ecb18,%eax
f01078e7:	89 c2                	mov    %eax,%edx
f01078e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078ec:	01 d0                	add    %edx,%eax
f01078ee:	48                   	dec    %eax
f01078ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01078f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01078f5:	ba 00 00 00 00       	mov    $0x0,%edx
f01078fa:	f7 75 f4             	divl   -0xc(%ebp)
f01078fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107900:	29 d0                	sub    %edx,%eax
f0107902:	a3 18 cb 5e f0       	mov    %eax,0xf05ecb18

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f0107907:	a1 18 cb 5e f0       	mov    0xf05ecb18,%eax
f010790c:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f010790f:	8b 15 18 cb 5e f0    	mov    0xf05ecb18,%edx
f0107915:	8b 45 08             	mov    0x8(%ebp),%eax
f0107918:	01 d0                	add    %edx,%eax
f010791a:	a3 18 cb 5e f0       	mov    %eax,0xf05ecb18

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f010791f:	83 ec 04             	sub    $0x4,%esp
f0107922:	ff 75 08             	pushl  0x8(%ebp)
f0107925:	6a 00                	push   $0x0
f0107927:	ff 75 ec             	pushl  -0x14(%ebp)
f010792a:	e8 9e 74 01 00       	call   f011edcd <memset>
f010792f:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f0107932:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f0107935:	c9                   	leave  
f0107936:	c3                   	ret    

f0107937 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f0107937:	55                   	push   %ebp
f0107938:	89 e5                	mov    %esp,%ebp
f010793a:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f010793d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107944:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010794b:	eb 53                	jmp    f01079a0 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f010794d:	83 ec 04             	sub    $0x4,%esp
f0107950:	6a 01                	push   $0x1
f0107952:	ff 75 0c             	pushl  0xc(%ebp)
f0107955:	ff 75 08             	pushl  0x8(%ebp)
f0107958:	e8 4e 00 00 00       	call   f01079ab <boot_get_page_table>
f010795d:	83 c4 10             	add    $0x10,%esp
f0107960:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0107963:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107966:	c1 e8 0c             	shr    $0xc,%eax
f0107969:	25 ff 03 00 00       	and    $0x3ff,%eax
f010796e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0107971:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107974:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010797b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010797e:	01 c2                	add    %eax,%edx
f0107980:	8b 45 18             	mov    0x18(%ebp),%eax
f0107983:	0b 45 14             	or     0x14(%ebp),%eax
f0107986:	83 c8 01             	or     $0x1,%eax
f0107989:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f010798b:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f0107992:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0107999:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f01079a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079a3:	3b 45 10             	cmp    0x10(%ebp),%eax
f01079a6:	72 a5                	jb     f010794d <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f01079a8:	90                   	nop
f01079a9:	c9                   	leave  
f01079aa:	c3                   	ret    

f01079ab <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f01079ab:	55                   	push   %ebp
f01079ac:	89 e5                	mov    %esp,%ebp
f01079ae:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f01079b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01079b4:	c1 e8 16             	shr    $0x16,%eax
f01079b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f01079ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079bd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01079c4:	8b 45 08             	mov    0x8(%ebp),%eax
f01079c7:	01 d0                	add    %edx,%eax
f01079c9:	8b 00                	mov    (%eax),%eax
f01079cb:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f01079ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01079d1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01079d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f01079d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01079dc:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01079df:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01079e2:	c1 e8 0c             	shr    $0xc,%eax
f01079e5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01079e8:	a1 f8 c6 5e f0       	mov    0xf05ec6f8,%eax
f01079ed:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01079f0:	72 17                	jb     f0107a09 <boot_get_page_table+0x5e>
f01079f2:	ff 75 e8             	pushl  -0x18(%ebp)
f01079f5:	68 a0 42 12 f0       	push   $0xf01242a0
f01079fa:	68 33 01 00 00       	push   $0x133
f01079ff:	68 58 42 12 f0       	push   $0xf0124258
f0107a04:	e8 30 89 ff ff       	call   f0100339 <_panic>
f0107a09:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107a0c:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0107a11:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f0107a14:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107a18:	75 72                	jne    f0107a8c <boot_get_page_table+0xe1>
	{
		if (create)
f0107a1a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0107a1e:	74 65                	je     f0107a85 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f0107a20:	83 ec 08             	sub    $0x8,%esp
f0107a23:	68 00 10 00 00       	push   $0x1000
f0107a28:	68 00 10 00 00       	push   $0x1000
f0107a2d:	e8 91 fe ff ff       	call   f01078c3 <boot_allocate_space>
f0107a32:	83 c4 10             	add    $0x10,%esp
f0107a35:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f0107a38:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107a3b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0107a3e:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0107a45:	77 17                	ja     f0107a5e <boot_get_page_table+0xb3>
f0107a47:	ff 75 dc             	pushl  -0x24(%ebp)
f0107a4a:	68 24 42 12 f0       	push   $0xf0124224
f0107a4f:	68 39 01 00 00       	push   $0x139
f0107a54:	68 58 42 12 f0       	push   $0xf0124258
f0107a59:	e8 db 88 ff ff       	call   f0100339 <_panic>
f0107a5e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107a61:	05 00 00 00 10       	add    $0x10000000,%eax
f0107a66:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f0107a69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107a6c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107a73:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a76:	01 d0                	add    %edx,%eax
f0107a78:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107a7b:	83 ca 03             	or     $0x3,%edx
f0107a7e:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f0107a80:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107a83:	eb 0a                	jmp    f0107a8f <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f0107a85:	b8 00 00 00 00       	mov    $0x0,%eax
f0107a8a:	eb 03                	jmp    f0107a8f <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0107a8c:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0107a8f:	c9                   	leave  
f0107a90:	c3                   	ret    

f0107a91 <nvram_read>:


int nvram_read(int r)
{
f0107a91:	55                   	push   %ebp
f0107a92:	89 e5                	mov    %esp,%ebp
f0107a94:	53                   	push   %ebx
f0107a95:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f0107a98:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a9b:	83 ec 0c             	sub    $0xc,%esp
f0107a9e:	50                   	push   %eax
f0107a9f:	e8 29 d1 ff ff       	call   f0104bcd <mc146818_read>
f0107aa4:	83 c4 10             	add    $0x10,%esp
f0107aa7:	89 c3                	mov    %eax,%ebx
f0107aa9:	8b 45 08             	mov    0x8(%ebp),%eax
f0107aac:	40                   	inc    %eax
f0107aad:	83 ec 0c             	sub    $0xc,%esp
f0107ab0:	50                   	push   %eax
f0107ab1:	e8 17 d1 ff ff       	call   f0104bcd <mc146818_read>
f0107ab6:	83 c4 10             	add    $0x10,%esp
f0107ab9:	c1 e0 08             	shl    $0x8,%eax
f0107abc:	09 d8                	or     %ebx,%eax
}
f0107abe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107ac1:	c9                   	leave  
f0107ac2:	c3                   	ret    

f0107ac3 <detect_memory>:

void detect_memory()
{
f0107ac3:	55                   	push   %ebp
f0107ac4:	89 e5                	mov    %esp,%ebp
f0107ac6:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f0107ac9:	83 ec 0c             	sub    $0xc,%esp
f0107acc:	6a 15                	push   $0x15
f0107ace:	e8 be ff ff ff       	call   f0107a91 <nvram_read>
f0107ad3:	83 c4 10             	add    $0x10,%esp
f0107ad6:	c1 e0 0a             	shl    $0xa,%eax
f0107ad9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107adc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107adf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107ae4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0107ae7:	83 ec 0c             	sub    $0xc,%esp
f0107aea:	6a 17                	push   $0x17
f0107aec:	e8 a0 ff ff ff       	call   f0107a91 <nvram_read>
f0107af1:	83 c4 10             	add    $0x10,%esp
f0107af4:	c1 e0 0a             	shl    $0xa,%eax
f0107af7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0107afa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107afd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107b02:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0107b05:	83 ec 0c             	sub    $0xc,%esp
f0107b08:	6a 34                	push   $0x34
f0107b0a:	e8 82 ff ff ff       	call   f0107a91 <nvram_read>
f0107b0f:	83 c4 10             	add    $0x10,%esp
f0107b12:	c1 e0 10             	shl    $0x10,%eax
f0107b15:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107b18:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107b1b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107b20:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0107b23:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0107b27:	74 18                	je     f0107b41 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0107b29:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107b2c:	05 00 00 00 01       	add    $0x1000000,%eax
f0107b31:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0107b34:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b37:	2d 00 00 10 00       	sub    $0x100000,%eax
f0107b3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107b3f:	eb 19                	jmp    f0107b5a <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0107b41:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107b45:	74 0d                	je     f0107b54 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0107b47:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b4a:	05 00 00 10 00       	add    $0x100000,%eax
f0107b4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107b52:	eb 06                	jmp    f0107b5a <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0107b54:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b57:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0107b5a:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107b61:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b64:	c1 e8 0c             	shr    $0xc,%eax
f0107b67:	a3 f8 c6 5e f0       	mov    %eax,0xf05ec6f8

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0107b6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b6f:	c1 e8 0a             	shr    $0xa,%eax
f0107b72:	83 ec 08             	sub    $0x8,%esp
f0107b75:	50                   	push   %eax
f0107b76:	68 d0 42 12 f0       	push   $0xf01242d0
f0107b7b:	e8 0b 94 ff ff       	call   f0100f8b <cprintf>
f0107b80:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107b83:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107b86:	c1 e8 0a             	shr    $0xa,%eax
f0107b89:	89 c2                	mov    %eax,%edx
f0107b8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107b8e:	c1 e8 0a             	shr    $0xa,%eax
f0107b91:	83 ec 04             	sub    $0x4,%esp
f0107b94:	52                   	push   %edx
f0107b95:	50                   	push   %eax
f0107b96:	68 f3 42 12 f0       	push   $0xf01242f3
f0107b9b:	e8 eb 93 ff ff       	call   f0100f8b <cprintf>
f0107ba0:	83 c4 10             	add    $0x10,%esp
}
f0107ba3:	90                   	nop
f0107ba4:	c9                   	leave  
f0107ba5:	c3                   	ret    

f0107ba6 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107ba6:	55                   	push   %ebp
f0107ba7:	89 e5                	mov    %esp,%ebp
f0107ba9:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0107bac:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107bb3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107bba:	eb 24                	jmp    f0107be0 <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0107bbc:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0107bc1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107bc4:	c1 e2 02             	shl    $0x2,%edx
f0107bc7:	01 c2                	add    %eax,%edx
f0107bc9:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0107bce:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107bd1:	c1 e1 02             	shl    $0x2,%ecx
f0107bd4:	01 c8                	add    %ecx,%eax
f0107bd6:	8b 00                	mov    (%eax),%eax
f0107bd8:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107bda:	ff 45 f4             	incl   -0xc(%ebp)
f0107bdd:	ff 45 f0             	incl   -0x10(%ebp)
f0107be0:	a1 18 cb 5e f0       	mov    0xf05ecb18,%eax
f0107be5:	c1 e8 16             	shr    $0x16,%eax
f0107be8:	89 c2                	mov    %eax,%edx
f0107bea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107bed:	39 c2                	cmp    %eax,%edx
f0107bef:	77 cb                	ja     f0107bbc <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0107bf1:	a1 24 cc 5e f0       	mov    0xf05ecc24,%eax
f0107bf6:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107bf9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107bfc:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0107bff:	0f 20 c0             	mov    %cr0,%eax
f0107c02:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0107c05:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0107c08:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0107c0b:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0107c12:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0107c16:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107c19:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0107c1c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0107c1f:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107c22:	e8 e0 f5 ff ff       	call   f0107207 <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107c27:	e8 18 f5 ff ff       	call   f0107144 <mycpu>
f0107c2c:	83 c0 74             	add    $0x74,%eax
f0107c2f:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107c32:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107c39:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0107c3c:	48                   	dec    %eax
f0107c3d:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107c41:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c44:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107c48:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107c4b:	c1 e8 10             	shr    $0x10,%eax
f0107c4e:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107c52:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107c55:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107c58:	e8 fc f5 ff ff       	call   f0107259 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0107c5d:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c62:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107c64:	b8 23 00 00 00       	mov    $0x23,%eax
f0107c69:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0107c6b:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c70:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107c72:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c77:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107c79:	b8 10 00 00 00       	mov    $0x10,%eax
f0107c7e:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0107c80:	ea 87 7c 10 f0 08 00 	ljmp   $0x8,$0xf0107c87
	asm volatile("lldt %%ax" :: "a" (0));
f0107c87:	b8 00 00 00 00       	mov    $0x0,%eax
f0107c8c:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0107c8f:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107c96:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107c9d:	eb 19                	jmp    f0107cb8 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0107c9f:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0107ca4:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107ca7:	c1 e2 02             	shl    $0x2,%edx
f0107caa:	01 d0                	add    %edx,%eax
f0107cac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107cb2:	ff 45 ec             	incl   -0x14(%ebp)
f0107cb5:	ff 45 e8             	incl   -0x18(%ebp)
f0107cb8:	a1 18 cb 5e f0       	mov    0xf05ecb18,%eax
f0107cbd:	c1 e8 16             	shr    $0x16,%eax
f0107cc0:	89 c2                	mov    %eax,%edx
f0107cc2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107cc5:	39 c2                	cmp    %eax,%edx
f0107cc7:	77 d6                	ja     f0107c9f <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0107cc9:	a1 24 cc 5e f0       	mov    0xf05ecc24,%eax
f0107cce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0107cd1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107cd4:	0f 22 d8             	mov    %eax,%cr3

}
f0107cd7:	90                   	nop
f0107cd8:	c9                   	leave  
f0107cd9:	c3                   	ret    

f0107cda <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0107cda:	55                   	push   %ebp
f0107cdb:	89 e5                	mov    %esp,%ebp
f0107cdd:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0107ce0:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0107ce5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107ce8:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0107cef:	77 17                	ja     f0107d08 <setup_listing_to_all_page_tables_entries+0x2e>
f0107cf1:	ff 75 f4             	pushl  -0xc(%ebp)
f0107cf4:	68 24 42 12 f0       	push   $0xf0124224
f0107cf9:	68 cf 01 00 00       	push   $0x1cf
f0107cfe:	68 58 42 12 f0       	push   $0xf0124258
f0107d03:	e8 31 86 ff ff       	call   f0100339 <_panic>
f0107d08:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107d0b:	05 00 00 00 10       	add    $0x10000000,%eax
f0107d10:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0107d13:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0107d18:	05 fc 0e 00 00       	add    $0xefc,%eax
f0107d1d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107d20:	83 ca 03             	or     $0x3,%edx
f0107d23:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0107d25:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0107d2a:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0107d30:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0107d35:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107d38:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0107d3f:	77 17                	ja     f0107d58 <setup_listing_to_all_page_tables_entries+0x7e>
f0107d41:	ff 75 ec             	pushl  -0x14(%ebp)
f0107d44:	68 24 42 12 f0       	push   $0xf0124224
f0107d49:	68 d4 01 00 00       	push   $0x1d4
f0107d4e:	68 58 42 12 f0       	push   $0xf0124258
f0107d53:	e8 e1 85 ff ff       	call   f0100339 <_panic>
f0107d58:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107d5b:	05 00 00 00 10       	add    $0x10000000,%eax
f0107d60:	83 c8 05             	or     $0x5,%eax
f0107d63:	89 02                	mov    %eax,(%edx)

}
f0107d65:	90                   	nop
f0107d66:	c9                   	leave  
f0107d67:	c3                   	ret    

f0107d68 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0107d68:	55                   	push   %ebp
f0107d69:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0107d6b:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d6e:	8b 15 68 c9 5e f0    	mov    0xf05ec968,%edx
f0107d74:	29 d0                	sub    %edx,%eax
f0107d76:	c1 f8 02             	sar    $0x2,%eax
f0107d79:	89 c2                	mov    %eax,%edx
f0107d7b:	89 d0                	mov    %edx,%eax
f0107d7d:	c1 e0 03             	shl    $0x3,%eax
f0107d80:	01 d0                	add    %edx,%eax
f0107d82:	c1 e0 03             	shl    $0x3,%eax
f0107d85:	01 d0                	add    %edx,%eax
f0107d87:	c1 e0 03             	shl    $0x3,%eax
f0107d8a:	01 d0                	add    %edx,%eax
f0107d8c:	c1 e0 03             	shl    $0x3,%eax
f0107d8f:	01 d0                	add    %edx,%eax
f0107d91:	89 c1                	mov    %eax,%ecx
f0107d93:	c1 e1 0f             	shl    $0xf,%ecx
f0107d96:	01 c8                	add    %ecx,%eax
f0107d98:	c1 e0 03             	shl    $0x3,%eax
f0107d9b:	01 d0                	add    %edx,%eax
f0107d9d:	f7 d8                	neg    %eax
}
f0107d9f:	5d                   	pop    %ebp
f0107da0:	c3                   	ret    

f0107da1 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0107da1:	55                   	push   %ebp
f0107da2:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0107da4:	ff 75 08             	pushl  0x8(%ebp)
f0107da7:	e8 bc ff ff ff       	call   f0107d68 <to_frame_number>
f0107dac:	83 c4 04             	add    $0x4,%esp
f0107daf:	c1 e0 0c             	shl    $0xc,%eax
}
f0107db2:	c9                   	leave  
f0107db3:	c3                   	ret    

f0107db4 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0107db4:	55                   	push   %ebp
f0107db5:	89 e5                	mov    %esp,%ebp
f0107db7:	53                   	push   %ebx
f0107db8:	83 ec 04             	sub    $0x4,%esp
	if (PPN(physical_address) >= number_of_frames)
f0107dbb:	8b 45 08             	mov    0x8(%ebp),%eax
f0107dbe:	c1 e8 0c             	shr    $0xc,%eax
f0107dc1:	89 c2                	mov    %eax,%edx
f0107dc3:	a1 f8 c6 5e f0       	mov    0xf05ec6f8,%eax
f0107dc8:	39 c2                	cmp    %eax,%edx
f0107dca:	72 14                	jb     f0107de0 <to_frame_info+0x2c>
		panic("to_frame_info called with invalid pa");
f0107dcc:	83 ec 04             	sub    $0x4,%esp
f0107dcf:	68 10 43 12 f0       	push   $0xf0124310
f0107dd4:	6a 55                	push   $0x55
f0107dd6:	68 35 43 12 f0       	push   $0xf0124335
f0107ddb:	e8 59 85 ff ff       	call   f0100339 <_panic>
	return &frames_info[PPN(physical_address)];
f0107de0:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f0107de6:	8b 45 08             	mov    0x8(%ebp),%eax
f0107de9:	c1 e8 0c             	shr    $0xc,%eax
f0107dec:	89 c2                	mov    %eax,%edx
f0107dee:	89 d0                	mov    %edx,%eax
f0107df0:	01 c0                	add    %eax,%eax
f0107df2:	01 d0                	add    %edx,%eax
f0107df4:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0107dfb:	01 d8                	add    %ebx,%eax
f0107dfd:	01 d0                	add    %edx,%eax
f0107dff:	01 c8                	add    %ecx,%eax
}
f0107e01:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107e04:	c9                   	leave  
f0107e05:	c3                   	ret    

f0107e06 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0107e06:	55                   	push   %ebp
f0107e07:	89 e5                	mov    %esp,%ebp
f0107e09:	83 ec 10             	sub    $0x10,%esp
f0107e0c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107e0f:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0107e12:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107e15:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f0107e18:	90                   	nop
f0107e19:	c9                   	leave  
f0107e1a:	c3                   	ret    

f0107e1b <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0107e1b:	55                   	push   %ebp
f0107e1c:	89 e5                	mov    %esp,%ebp
f0107e1e:	56                   	push   %esi
f0107e1f:	53                   	push   %ebx
f0107e20:	83 ec 20             	sub    $0x20,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0107e23:	c7 05 00 c5 5e f0 00 	movl   $0x0,0xf05ec500
f0107e2a:	00 00 00 
f0107e2d:	c7 05 04 c5 5e f0 00 	movl   $0x0,0xf05ec504
f0107e34:	00 00 00 
f0107e37:	c7 05 0c c5 5e f0 00 	movl   $0x0,0xf05ec50c
f0107e3e:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0107e41:	c7 05 10 c5 5e f0 00 	movl   $0x0,0xf05ec510
f0107e48:	00 00 00 
f0107e4b:	c7 05 14 c5 5e f0 00 	movl   $0x0,0xf05ec514
f0107e52:	00 00 00 
f0107e55:	c7 05 1c c5 5e f0 00 	movl   $0x0,0xf05ec51c
f0107e5c:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0107e5f:	83 ec 08             	sub    $0x8,%esp
f0107e62:	68 4f 43 12 f0       	push   $0xf012434f
f0107e67:	68 20 c5 5e f0       	push   $0xf05ec520
f0107e6c:	e8 1d 6d 00 00       	call   f010eb8e <init_spinlock>
f0107e71:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0107e74:	a1 68 c9 5e f0       	mov    0xf05ec968,%eax
f0107e79:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0107e7f:	a1 68 c9 5e f0       	mov    0xf05ec968,%eax
f0107e84:	83 c0 1c             	add    $0x1c,%eax
f0107e87:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0107e8d:	a1 68 c9 5e f0       	mov    0xf05ec968,%eax
f0107e92:	83 c0 38             	add    $0x38,%eax
f0107e95:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0107e9b:	c7 05 f4 c9 5e f0 00 	movl   $0xf0001000,0xf05ec9f4
f0107ea2:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0107ea5:	c7 05 a4 cb 5e f0 00 	movl   $0xf0002000,0xf05ecba4
f0107eac:	20 00 f0 
	i =0;
f0107eaf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0107eb6:	eb 1f                	jmp    f0107ed7 <initialize_paging+0xbc>
	{
		ptr_zero_page[i]=0;
f0107eb8:	8b 15 f4 c9 5e f0    	mov    0xf05ec9f4,%edx
f0107ebe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ec1:	01 d0                	add    %edx,%eax
f0107ec3:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0107ec6:	8b 15 a4 cb 5e f0    	mov    0xf05ecba4,%edx
f0107ecc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ecf:	01 d0                	add    %edx,%eax
f0107ed1:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0107ed4:	ff 45 f4             	incl   -0xc(%ebp)
f0107ed7:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0107ede:	7e d8                	jle    f0107eb8 <initialize_paging+0x9d>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0107ee0:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0107ee7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107eea:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0107eef:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107ef2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107ef5:	ba 00 00 00 00       	mov    $0x0,%edx
f0107efa:	f7 75 f0             	divl   -0x10(%ebp)
f0107efd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107f00:	29 d0                	sub    %edx,%eax
f0107f02:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107f05:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0107f0c:	e9 20 01 00 00       	jmp    f0108031 <initialize_paging+0x216>
	{

		initialize_frame_info(&(frames_info[i]));
f0107f11:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f0107f17:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f1a:	89 d0                	mov    %edx,%eax
f0107f1c:	01 c0                	add    %eax,%eax
f0107f1e:	01 d0                	add    %edx,%eax
f0107f20:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0107f27:	01 d8                	add    %ebx,%eax
f0107f29:	01 d0                	add    %edx,%eax
f0107f2b:	01 c8                	add    %ecx,%eax
f0107f2d:	83 ec 0c             	sub    $0xc,%esp
f0107f30:	50                   	push   %eax
f0107f31:	e8 31 03 00 00       	call   f0108267 <initialize_frame_info>
f0107f36:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107f39:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f0107f3f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f42:	89 d0                	mov    %edx,%eax
f0107f44:	01 c0                	add    %eax,%eax
f0107f46:	01 d0                	add    %edx,%eax
f0107f48:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0107f4f:	01 d8                	add    %ebx,%eax
f0107f51:	01 d0                	add    %edx,%eax
f0107f53:	01 c8                	add    %ecx,%eax
f0107f55:	85 c0                	test   %eax,%eax
f0107f57:	75 14                	jne    f0107f6d <initialize_paging+0x152>
f0107f59:	83 ec 04             	sub    $0x4,%esp
f0107f5c:	68 60 43 12 f0       	push   $0xf0124360
f0107f61:	6a 60                	push   $0x60
f0107f63:	68 83 43 12 f0       	push   $0xf0124383
f0107f68:	e8 cc 83 ff ff       	call   f0100339 <_panic>
f0107f6d:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f0107f73:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107f76:	89 d0                	mov    %edx,%eax
f0107f78:	01 c0                	add    %eax,%eax
f0107f7a:	01 d0                	add    %edx,%eax
f0107f7c:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0107f83:	01 d8                	add    %ebx,%eax
f0107f85:	01 d0                	add    %edx,%eax
f0107f87:	01 c8                	add    %ecx,%eax
f0107f89:	8b 15 00 c5 5e f0    	mov    0xf05ec500,%edx
f0107f8f:	89 10                	mov    %edx,(%eax)
f0107f91:	8b 00                	mov    (%eax),%eax
f0107f93:	85 c0                	test   %eax,%eax
f0107f95:	74 27                	je     f0107fbe <initialize_paging+0x1a3>
f0107f97:	8b 0d 00 c5 5e f0    	mov    0xf05ec500,%ecx
f0107f9d:	8b 1d 68 c9 5e f0    	mov    0xf05ec968,%ebx
f0107fa3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fa6:	89 d0                	mov    %edx,%eax
f0107fa8:	01 c0                	add    %eax,%eax
f0107faa:	01 d0                	add    %edx,%eax
f0107fac:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f0107fb3:	01 f0                	add    %esi,%eax
f0107fb5:	01 d0                	add    %edx,%eax
f0107fb7:	01 d8                	add    %ebx,%eax
f0107fb9:	89 41 04             	mov    %eax,0x4(%ecx)
f0107fbc:	eb 21                	jmp    f0107fdf <initialize_paging+0x1c4>
f0107fbe:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f0107fc4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fc7:	89 d0                	mov    %edx,%eax
f0107fc9:	01 c0                	add    %eax,%eax
f0107fcb:	01 d0                	add    %edx,%eax
f0107fcd:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0107fd4:	01 d8                	add    %ebx,%eax
f0107fd6:	01 d0                	add    %edx,%eax
f0107fd8:	01 c8                	add    %ecx,%eax
f0107fda:	a3 04 c5 5e f0       	mov    %eax,0xf05ec504
f0107fdf:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f0107fe5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107fe8:	89 d0                	mov    %edx,%eax
f0107fea:	01 c0                	add    %eax,%eax
f0107fec:	01 d0                	add    %edx,%eax
f0107fee:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0107ff5:	01 d8                	add    %ebx,%eax
f0107ff7:	01 d0                	add    %edx,%eax
f0107ff9:	01 c8                	add    %ecx,%eax
f0107ffb:	a3 00 c5 5e f0       	mov    %eax,0xf05ec500
f0108000:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f0108006:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108009:	89 d0                	mov    %edx,%eax
f010800b:	01 c0                	add    %eax,%eax
f010800d:	01 d0                	add    %edx,%eax
f010800f:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0108016:	01 d8                	add    %ebx,%eax
f0108018:	01 d0                	add    %edx,%eax
f010801a:	01 c8                	add    %ecx,%eax
f010801c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108023:	a1 0c c5 5e f0       	mov    0xf05ec50c,%eax
f0108028:	40                   	inc    %eax
f0108029:	a3 0c c5 5e f0       	mov    %eax,0xf05ec50c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f010802e:	ff 45 f4             	incl   -0xc(%ebp)
f0108031:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108034:	85 c0                	test   %eax,%eax
f0108036:	79 05                	jns    f010803d <initialize_paging+0x222>
f0108038:	05 ff 0f 00 00       	add    $0xfff,%eax
f010803d:	c1 f8 0c             	sar    $0xc,%eax
f0108040:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108043:	0f 8f c8 fe ff ff    	jg     f0107f11 <initialize_paging+0xf6>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0108049:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0108050:	eb 25                	jmp    f0108077 <initialize_paging+0x25c>
	{
		frames_info[i].references = 1;
f0108052:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f0108058:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010805b:	89 d0                	mov    %edx,%eax
f010805d:	01 c0                	add    %eax,%eax
f010805f:	01 d0                	add    %edx,%eax
f0108061:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0108068:	01 d8                	add    %ebx,%eax
f010806a:	01 d0                	add    %edx,%eax
f010806c:	01 c8                	add    %ecx,%eax
f010806e:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0108074:	ff 45 f4             	incl   -0xc(%ebp)
f0108077:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f010807e:	7e d2                	jle    f0108052 <initialize_paging+0x237>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0108080:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0108087:	a1 18 cb 5e f0       	mov    0xf05ecb18,%eax
f010808c:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010808f:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108096:	77 14                	ja     f01080ac <initialize_paging+0x291>
f0108098:	ff 75 e0             	pushl  -0x20(%ebp)
f010809b:	68 a0 43 12 f0       	push   $0xf01243a0
f01080a0:	6a 68                	push   $0x68
f01080a2:	68 83 43 12 f0       	push   $0xf0124383
f01080a7:	e8 8d 82 ff ff       	call   f0100339 <_panic>
f01080ac:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01080af:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01080b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01080b8:	01 d0                	add    %edx,%eax
f01080ba:	48                   	dec    %eax
f01080bb:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01080be:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01080c1:	ba 00 00 00 00       	mov    $0x0,%edx
f01080c6:	f7 75 e4             	divl   -0x1c(%ebp)
f01080c9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01080cc:	29 d0                	sub    %edx,%eax
f01080ce:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f01080d1:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f01080d8:	eb 25                	jmp    f01080ff <initialize_paging+0x2e4>
	{
		frames_info[i].references = 1;
f01080da:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f01080e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01080e3:	89 d0                	mov    %edx,%eax
f01080e5:	01 c0                	add    %eax,%eax
f01080e7:	01 d0                	add    %edx,%eax
f01080e9:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f01080f0:	01 d8                	add    %ebx,%eax
f01080f2:	01 d0                	add    %edx,%eax
f01080f4:	01 c8                	add    %ecx,%eax
f01080f6:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f01080fc:	ff 45 f4             	incl   -0xc(%ebp)
f01080ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108102:	85 c0                	test   %eax,%eax
f0108104:	79 05                	jns    f010810b <initialize_paging+0x2f0>
f0108106:	05 ff 0f 00 00       	add    $0xfff,%eax
f010810b:	c1 f8 0c             	sar    $0xc,%eax
f010810e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108111:	7f c7                	jg     f01080da <initialize_paging+0x2bf>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108113:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108116:	85 c0                	test   %eax,%eax
f0108118:	79 05                	jns    f010811f <initialize_paging+0x304>
f010811a:	05 ff 0f 00 00       	add    $0xfff,%eax
f010811f:	c1 f8 0c             	sar    $0xc,%eax
f0108122:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108125:	e9 20 01 00 00       	jmp    f010824a <initialize_paging+0x42f>
	{
		initialize_frame_info(&(frames_info[i]));
f010812a:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f0108130:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108133:	89 d0                	mov    %edx,%eax
f0108135:	01 c0                	add    %eax,%eax
f0108137:	01 d0                	add    %edx,%eax
f0108139:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0108140:	01 d8                	add    %ebx,%eax
f0108142:	01 d0                	add    %edx,%eax
f0108144:	01 c8                	add    %ecx,%eax
f0108146:	83 ec 0c             	sub    $0xc,%esp
f0108149:	50                   	push   %eax
f010814a:	e8 18 01 00 00       	call   f0108267 <initialize_frame_info>
f010814f:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0108152:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f0108158:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010815b:	89 d0                	mov    %edx,%eax
f010815d:	01 c0                	add    %eax,%eax
f010815f:	01 d0                	add    %edx,%eax
f0108161:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f0108168:	01 d8                	add    %ebx,%eax
f010816a:	01 d0                	add    %edx,%eax
f010816c:	01 c8                	add    %ecx,%eax
f010816e:	85 c0                	test   %eax,%eax
f0108170:	75 14                	jne    f0108186 <initialize_paging+0x36b>
f0108172:	83 ec 04             	sub    $0x4,%esp
f0108175:	68 60 43 12 f0       	push   $0xf0124360
f010817a:	6a 74                	push   $0x74
f010817c:	68 83 43 12 f0       	push   $0xf0124383
f0108181:	e8 b3 81 ff ff       	call   f0100339 <_panic>
f0108186:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f010818c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010818f:	89 d0                	mov    %edx,%eax
f0108191:	01 c0                	add    %eax,%eax
f0108193:	01 d0                	add    %edx,%eax
f0108195:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010819c:	01 d8                	add    %ebx,%eax
f010819e:	01 d0                	add    %edx,%eax
f01081a0:	01 c8                	add    %ecx,%eax
f01081a2:	8b 15 00 c5 5e f0    	mov    0xf05ec500,%edx
f01081a8:	89 10                	mov    %edx,(%eax)
f01081aa:	8b 00                	mov    (%eax),%eax
f01081ac:	85 c0                	test   %eax,%eax
f01081ae:	74 27                	je     f01081d7 <initialize_paging+0x3bc>
f01081b0:	8b 0d 00 c5 5e f0    	mov    0xf05ec500,%ecx
f01081b6:	8b 1d 68 c9 5e f0    	mov    0xf05ec968,%ebx
f01081bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01081bf:	89 d0                	mov    %edx,%eax
f01081c1:	01 c0                	add    %eax,%eax
f01081c3:	01 d0                	add    %edx,%eax
f01081c5:	8d 34 c5 00 00 00 00 	lea    0x0(,%eax,8),%esi
f01081cc:	01 f0                	add    %esi,%eax
f01081ce:	01 d0                	add    %edx,%eax
f01081d0:	01 d8                	add    %ebx,%eax
f01081d2:	89 41 04             	mov    %eax,0x4(%ecx)
f01081d5:	eb 21                	jmp    f01081f8 <initialize_paging+0x3dd>
f01081d7:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f01081dd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01081e0:	89 d0                	mov    %edx,%eax
f01081e2:	01 c0                	add    %eax,%eax
f01081e4:	01 d0                	add    %edx,%eax
f01081e6:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f01081ed:	01 d8                	add    %ebx,%eax
f01081ef:	01 d0                	add    %edx,%eax
f01081f1:	01 c8                	add    %ecx,%eax
f01081f3:	a3 04 c5 5e f0       	mov    %eax,0xf05ec504
f01081f8:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f01081fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108201:	89 d0                	mov    %edx,%eax
f0108203:	01 c0                	add    %eax,%eax
f0108205:	01 d0                	add    %edx,%eax
f0108207:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010820e:	01 d8                	add    %ebx,%eax
f0108210:	01 d0                	add    %edx,%eax
f0108212:	01 c8                	add    %ecx,%eax
f0108214:	a3 00 c5 5e f0       	mov    %eax,0xf05ec500
f0108219:	8b 0d 68 c9 5e f0    	mov    0xf05ec968,%ecx
f010821f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108222:	89 d0                	mov    %edx,%eax
f0108224:	01 c0                	add    %eax,%eax
f0108226:	01 d0                	add    %edx,%eax
f0108228:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
f010822f:	01 d8                	add    %ebx,%eax
f0108231:	01 d0                	add    %edx,%eax
f0108233:	01 c8                	add    %ecx,%eax
f0108235:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010823c:	a1 0c c5 5e f0       	mov    0xf05ec50c,%eax
f0108241:	40                   	inc    %eax
f0108242:	a3 0c c5 5e f0       	mov    %eax,0xf05ec50c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108247:	ff 45 f4             	incl   -0xc(%ebp)
f010824a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010824d:	a1 f8 c6 5e f0       	mov    0xf05ec6f8,%eax
f0108252:	39 c2                	cmp    %eax,%edx
f0108254:	0f 82 d0 fe ff ff    	jb     f010812a <initialize_paging+0x30f>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f010825a:	e8 69 ba ff ff       	call   f0103cc8 <initialize_disk_page_file>
}
f010825f:	90                   	nop
f0108260:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0108263:	5b                   	pop    %ebx
f0108264:	5e                   	pop    %esi
f0108265:	5d                   	pop    %ebp
f0108266:	c3                   	ret    

f0108267 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f0108267:	55                   	push   %ebp
f0108268:	89 e5                	mov    %esp,%ebp
f010826a:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f010826d:	83 ec 04             	sub    $0x4,%esp
f0108270:	6a 1c                	push   $0x1c
f0108272:	6a 00                	push   $0x0
f0108274:	ff 75 08             	pushl  0x8(%ebp)
f0108277:	e8 51 6b 01 00       	call   f011edcd <memset>
f010827c:	83 c4 10             	add    $0x10,%esp
}
f010827f:	90                   	nop
f0108280:	c9                   	leave  
f0108281:	c3                   	ret    

f0108282 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f0108282:	55                   	push   %ebp
f0108283:	89 e5                	mov    %esp,%ebp
f0108285:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f0108288:	83 ec 0c             	sub    $0xc,%esp
f010828b:	68 20 c5 5e f0       	push   $0xf05ec520
f0108290:	e8 43 6b 00 00       	call   f010edd8 <holding_spinlock>
f0108295:	83 c4 10             	add    $0x10,%esp
f0108298:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010829b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010829f:	75 10                	jne    f01082b1 <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01082a1:	83 ec 0c             	sub    $0xc,%esp
f01082a4:	68 20 c5 5e f0       	push   $0xf05ec520
f01082a9:	e8 11 69 00 00       	call   f010ebbf <acquire_spinlock>
f01082ae:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f01082b1:	8b 15 00 c5 5e f0    	mov    0xf05ec500,%edx
f01082b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01082ba:	89 10                	mov    %edx,(%eax)
	int c = 0;
f01082bc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f01082c3:	8b 45 08             	mov    0x8(%ebp),%eax
f01082c6:	8b 00                	mov    (%eax),%eax
f01082c8:	85 c0                	test   %eax,%eax
f01082ca:	75 17                	jne    f01082e3 <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f01082cc:	83 ec 04             	sub    $0x4,%esp
f01082cf:	68 d4 43 12 f0       	push   $0xf01243d4
f01082d4:	68 a2 00 00 00       	push   $0xa2
f01082d9:	68 83 43 12 f0       	push   $0xf0124383
f01082de:	e8 56 80 ff ff       	call   f0100339 <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f01082e3:	8b 45 08             	mov    0x8(%ebp),%eax
f01082e6:	8b 00                	mov    (%eax),%eax
f01082e8:	85 c0                	test   %eax,%eax
f01082ea:	75 17                	jne    f0108303 <allocate_frame+0x81>
f01082ec:	83 ec 04             	sub    $0x4,%esp
f01082ef:	68 21 44 12 f0       	push   $0xf0124421
f01082f4:	68 a8 00 00 00       	push   $0xa8
f01082f9:	68 83 43 12 f0       	push   $0xf0124383
f01082fe:	e8 36 80 ff ff       	call   f0100339 <_panic>
f0108303:	8b 45 08             	mov    0x8(%ebp),%eax
f0108306:	8b 00                	mov    (%eax),%eax
f0108308:	8b 00                	mov    (%eax),%eax
f010830a:	85 c0                	test   %eax,%eax
f010830c:	74 14                	je     f0108322 <allocate_frame+0xa0>
f010830e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108311:	8b 00                	mov    (%eax),%eax
f0108313:	8b 00                	mov    (%eax),%eax
f0108315:	8b 55 08             	mov    0x8(%ebp),%edx
f0108318:	8b 12                	mov    (%edx),%edx
f010831a:	8b 52 04             	mov    0x4(%edx),%edx
f010831d:	89 50 04             	mov    %edx,0x4(%eax)
f0108320:	eb 0d                	jmp    f010832f <allocate_frame+0xad>
f0108322:	8b 45 08             	mov    0x8(%ebp),%eax
f0108325:	8b 00                	mov    (%eax),%eax
f0108327:	8b 40 04             	mov    0x4(%eax),%eax
f010832a:	a3 04 c5 5e f0       	mov    %eax,0xf05ec504
f010832f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108332:	8b 00                	mov    (%eax),%eax
f0108334:	8b 40 04             	mov    0x4(%eax),%eax
f0108337:	85 c0                	test   %eax,%eax
f0108339:	74 13                	je     f010834e <allocate_frame+0xcc>
f010833b:	8b 45 08             	mov    0x8(%ebp),%eax
f010833e:	8b 00                	mov    (%eax),%eax
f0108340:	8b 40 04             	mov    0x4(%eax),%eax
f0108343:	8b 55 08             	mov    0x8(%ebp),%edx
f0108346:	8b 12                	mov    (%edx),%edx
f0108348:	8b 12                	mov    (%edx),%edx
f010834a:	89 10                	mov    %edx,(%eax)
f010834c:	eb 0c                	jmp    f010835a <allocate_frame+0xd8>
f010834e:	8b 45 08             	mov    0x8(%ebp),%eax
f0108351:	8b 00                	mov    (%eax),%eax
f0108353:	8b 00                	mov    (%eax),%eax
f0108355:	a3 00 c5 5e f0       	mov    %eax,0xf05ec500
f010835a:	8b 45 08             	mov    0x8(%ebp),%eax
f010835d:	8b 00                	mov    (%eax),%eax
f010835f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0108365:	8b 45 08             	mov    0x8(%ebp),%eax
f0108368:	8b 00                	mov    (%eax),%eax
f010836a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108371:	a1 0c c5 5e f0       	mov    0xf05ec50c,%eax
f0108376:	48                   	dec    %eax
f0108377:	a3 0c c5 5e f0       	mov    %eax,0xf05ec50c

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f010837c:	8b 45 08             	mov    0x8(%ebp),%eax
f010837f:	8b 00                	mov    (%eax),%eax
f0108381:	8a 40 18             	mov    0x18(%eax),%al
f0108384:	84 c0                	test   %al,%al
f0108386:	74 20                	je     f01083a8 <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f0108388:	8b 45 08             	mov    0x8(%ebp),%eax
f010838b:	8b 00                	mov    (%eax),%eax
f010838d:	8b 50 14             	mov    0x14(%eax),%edx
f0108390:	8b 45 08             	mov    0x8(%ebp),%eax
f0108393:	8b 00                	mov    (%eax),%eax
f0108395:	8b 40 10             	mov    0x10(%eax),%eax
f0108398:	8b 40 64             	mov    0x64(%eax),%eax
f010839b:	83 ec 08             	sub    $0x8,%esp
f010839e:	52                   	push   %edx
f010839f:	50                   	push   %eax
f01083a0:	e8 66 0e 00 00       	call   f010920b <pt_clear_page_table_entry>
f01083a5:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f01083a8:	8b 45 08             	mov    0x8(%ebp),%eax
f01083ab:	8b 00                	mov    (%eax),%eax
f01083ad:	83 ec 0c             	sub    $0xc,%esp
f01083b0:	50                   	push   %eax
f01083b1:	e8 b1 fe ff ff       	call   f0108267 <initialize_frame_info>
f01083b6:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f01083b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01083bd:	75 10                	jne    f01083cf <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01083bf:	83 ec 0c             	sub    $0xc,%esp
f01083c2:	68 20 c5 5e f0       	push   $0xf05ec520
f01083c7:	e8 7a 68 00 00       	call   f010ec46 <release_spinlock>
f01083cc:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f01083cf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01083d4:	c9                   	leave  
f01083d5:	c3                   	ret    

f01083d6 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f01083d6:	55                   	push   %ebp
f01083d7:	89 e5                	mov    %esp,%ebp
f01083d9:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f01083dc:	83 ec 0c             	sub    $0xc,%esp
f01083df:	68 20 c5 5e f0       	push   $0xf05ec520
f01083e4:	e8 ef 69 00 00       	call   f010edd8 <holding_spinlock>
f01083e9:	83 c4 10             	add    $0x10,%esp
f01083ec:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f01083ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01083f3:	75 10                	jne    f0108405 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01083f5:	83 ec 0c             	sub    $0xc,%esp
f01083f8:	68 20 c5 5e f0       	push   $0xf05ec520
f01083fd:	e8 bd 67 00 00       	call   f010ebbf <acquire_spinlock>
f0108402:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108405:	83 ec 0c             	sub    $0xc,%esp
f0108408:	ff 75 08             	pushl  0x8(%ebp)
f010840b:	e8 57 fe ff ff       	call   f0108267 <initialize_frame_info>
f0108410:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f0108413:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108417:	75 17                	jne    f0108430 <free_frame+0x5a>
f0108419:	83 ec 04             	sub    $0x4,%esp
f010841c:	68 60 43 12 f0       	push   $0xf0124360
f0108421:	68 cf 00 00 00       	push   $0xcf
f0108426:	68 83 43 12 f0       	push   $0xf0124383
f010842b:	e8 09 7f ff ff       	call   f0100339 <_panic>
f0108430:	8b 15 00 c5 5e f0    	mov    0xf05ec500,%edx
f0108436:	8b 45 08             	mov    0x8(%ebp),%eax
f0108439:	89 10                	mov    %edx,(%eax)
f010843b:	8b 45 08             	mov    0x8(%ebp),%eax
f010843e:	8b 00                	mov    (%eax),%eax
f0108440:	85 c0                	test   %eax,%eax
f0108442:	74 0d                	je     f0108451 <free_frame+0x7b>
f0108444:	a1 00 c5 5e f0       	mov    0xf05ec500,%eax
f0108449:	8b 55 08             	mov    0x8(%ebp),%edx
f010844c:	89 50 04             	mov    %edx,0x4(%eax)
f010844f:	eb 08                	jmp    f0108459 <free_frame+0x83>
f0108451:	8b 45 08             	mov    0x8(%ebp),%eax
f0108454:	a3 04 c5 5e f0       	mov    %eax,0xf05ec504
f0108459:	8b 45 08             	mov    0x8(%ebp),%eax
f010845c:	a3 00 c5 5e f0       	mov    %eax,0xf05ec500
f0108461:	8b 45 08             	mov    0x8(%ebp),%eax
f0108464:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010846b:	a1 0c c5 5e f0       	mov    0xf05ec50c,%eax
f0108470:	40                   	inc    %eax
f0108471:	a3 0c c5 5e f0       	mov    %eax,0xf05ec50c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f0108476:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010847a:	75 10                	jne    f010848c <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f010847c:	83 ec 0c             	sub    $0xc,%esp
f010847f:	68 20 c5 5e f0       	push   $0xf05ec520
f0108484:	e8 bd 67 00 00       	call   f010ec46 <release_spinlock>
f0108489:	83 c4 10             	add    $0x10,%esp
	}
}
f010848c:	90                   	nop
f010848d:	c9                   	leave  
f010848e:	c3                   	ret    

f010848f <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f010848f:	55                   	push   %ebp
f0108490:	89 e5                	mov    %esp,%ebp
f0108492:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f0108495:	8b 45 08             	mov    0x8(%ebp),%eax
f0108498:	8b 40 08             	mov    0x8(%eax),%eax
f010849b:	48                   	dec    %eax
f010849c:	8b 55 08             	mov    0x8(%ebp),%edx
f010849f:	66 89 42 08          	mov    %ax,0x8(%edx)
f01084a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01084a6:	8b 40 08             	mov    0x8(%eax),%eax
f01084a9:	66 85 c0             	test   %ax,%ax
f01084ac:	75 0e                	jne    f01084bc <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f01084ae:	83 ec 0c             	sub    $0xc,%esp
f01084b1:	ff 75 08             	pushl  0x8(%ebp)
f01084b4:	e8 1d ff ff ff       	call   f01083d6 <free_frame>
f01084b9:	83 c4 10             	add    $0x10,%esp
}
f01084bc:	90                   	nop
f01084bd:	c9                   	leave  
f01084be:	c3                   	ret    

f01084bf <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f01084bf:	55                   	push   %ebp
f01084c0:	89 e5                	mov    %esp,%ebp
f01084c2:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01084c5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01084c8:	c1 e8 16             	shr    $0x16,%eax
f01084cb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01084d2:	8b 45 08             	mov    0x8(%ebp),%eax
f01084d5:	01 d0                	add    %edx,%eax
f01084d7:	8b 00                	mov    (%eax),%eax
f01084d9:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f01084dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084df:	83 e0 01             	and    $0x1,%eax
f01084e2:	85 c0                	test   %eax,%eax
f01084e4:	74 74                	je     f010855a <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01084e6:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01084ed:	77 1d                	ja     f010850c <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f01084ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084f2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01084f7:	83 ec 0c             	sub    $0xc,%esp
f01084fa:	50                   	push   %eax
f01084fb:	e8 d7 0b 00 00       	call   f01090d7 <kheap_virtual_address>
f0108500:	83 c4 10             	add    $0x10,%esp
f0108503:	89 c2                	mov    %eax,%edx
f0108505:	8b 45 10             	mov    0x10(%ebp),%eax
f0108508:	89 10                	mov    %edx,(%eax)
f010850a:	eb 44                	jmp    f0108550 <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010850c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010850f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108514:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108517:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010851a:	c1 e8 0c             	shr    $0xc,%eax
f010851d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108520:	a1 f8 c6 5e f0       	mov    0xf05ec6f8,%eax
f0108525:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0108528:	72 17                	jb     f0108541 <get_page_table+0x82>
f010852a:	ff 75 f0             	pushl  -0x10(%ebp)
f010852d:	68 40 44 12 f0       	push   $0xf0124440
f0108532:	68 fb 00 00 00       	push   $0xfb
f0108537:	68 83 43 12 f0       	push   $0xf0124383
f010853c:	e8 f8 7d ff ff       	call   f0100339 <_panic>
f0108541:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108544:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108549:	89 c2                	mov    %eax,%edx
f010854b:	8b 45 10             	mov    0x10(%ebp),%eax
f010854e:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f0108550:	b8 00 00 00 00       	mov    $0x0,%eax
f0108555:	e9 b9 00 00 00       	jmp    f0108613 <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f010855a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010855e:	0f 84 a1 00 00 00    	je     f0108605 <get_page_table+0x146>
f0108564:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108567:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f010856a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010856d:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f0108570:	83 ec 0c             	sub    $0xc,%esp
f0108573:	6a 00                	push   $0x0
f0108575:	e8 c9 62 00 00       	call   f010e843 <fault_handler>
f010857a:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f010857d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108580:	c1 e8 16             	shr    $0x16,%eax
f0108583:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010858a:	8b 45 08             	mov    0x8(%ebp),%eax
f010858d:	01 d0                	add    %edx,%eax
f010858f:	8b 00                	mov    (%eax),%eax
f0108591:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0108594:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f010859b:	77 1d                	ja     f01085ba <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f010859d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01085a0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01085a5:	83 ec 0c             	sub    $0xc,%esp
f01085a8:	50                   	push   %eax
f01085a9:	e8 29 0b 00 00       	call   f01090d7 <kheap_virtual_address>
f01085ae:	83 c4 10             	add    $0x10,%esp
f01085b1:	89 c2                	mov    %eax,%edx
f01085b3:	8b 45 10             	mov    0x10(%ebp),%eax
f01085b6:	89 10                	mov    %edx,(%eax)
f01085b8:	eb 44                	jmp    f01085fe <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01085ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01085bd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01085c2:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01085c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01085c8:	c1 e8 0c             	shr    $0xc,%eax
f01085cb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01085ce:	a1 f8 c6 5e f0       	mov    0xf05ec6f8,%eax
f01085d3:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01085d6:	72 17                	jb     f01085ef <get_page_table+0x130>
f01085d8:	ff 75 e8             	pushl  -0x18(%ebp)
f01085db:	68 40 44 12 f0       	push   $0xf0124440
f01085e0:	68 13 01 00 00       	push   $0x113
f01085e5:	68 83 43 12 f0       	push   $0xf0124383
f01085ea:	e8 4a 7d ff ff       	call   f0100339 <_panic>
f01085ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01085f2:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01085f7:	89 c2                	mov    %eax,%edx
f01085f9:	8b 45 10             	mov    0x10(%ebp),%eax
f01085fc:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f01085fe:	b8 00 00 00 00       	mov    $0x0,%eax
f0108603:	eb 0e                	jmp    f0108613 <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0108605:	8b 45 10             	mov    0x10(%ebp),%eax
f0108608:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f010860e:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f0108613:	c9                   	leave  
f0108614:	c3                   	ret    

f0108615 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f0108615:	55                   	push   %ebp
f0108616:	89 e5                	mov    %esp,%ebp
f0108618:	53                   	push   %ebx
f0108619:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f010861c:	83 ec 0c             	sub    $0xc,%esp
f010861f:	68 00 10 00 00       	push   $0x1000
f0108624:	e8 07 08 00 00       	call   f0108e30 <kmalloc>
f0108629:	83 c4 10             	add    $0x10,%esp
f010862c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f010862f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108633:	75 17                	jne    f010864c <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f0108635:	83 ec 04             	sub    $0x4,%esp
f0108638:	68 6f 44 12 f0       	push   $0xf012446f
f010863d:	68 33 01 00 00       	push   $0x133
f0108642:	68 83 43 12 f0       	push   $0xf0124383
f0108647:	e8 ed 7c ff ff       	call   f0100339 <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f010864c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010864f:	c1 e8 16             	shr    $0x16,%eax
f0108652:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108659:	8b 45 08             	mov    0x8(%ebp),%eax
f010865c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f010865f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108662:	83 ec 0c             	sub    $0xc,%esp
f0108665:	50                   	push   %eax
f0108666:	e8 2b 0a 00 00       	call   f0109096 <kheap_physical_address>
f010866b:	83 c4 10             	add    $0x10,%esp
f010866e:	83 c8 07             	or     $0x7,%eax
f0108671:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f0108673:	83 ec 04             	sub    $0x4,%esp
f0108676:	68 00 10 00 00       	push   $0x1000
f010867b:	6a 00                	push   $0x0
f010867d:	ff 75 f4             	pushl  -0xc(%ebp)
f0108680:	e8 48 67 01 00       	call   f011edcd <memset>
f0108685:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108688:	0f 20 d8             	mov    %cr3,%eax
f010868b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010868e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108691:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f0108694:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108697:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010869a:	c9                   	leave  
f010869b:	c3                   	ret    

f010869c <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f010869c:	55                   	push   %ebp
f010869d:	89 e5                	mov    %esp,%ebp
f010869f:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f01086a2:	83 ec 0c             	sub    $0xc,%esp
f01086a5:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01086a8:	50                   	push   %eax
f01086a9:	e8 d4 fb ff ff       	call   f0108282 <allocate_frame>
f01086ae:	83 c4 10             	add    $0x10,%esp
f01086b1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f01086b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01086b7:	83 ec 0c             	sub    $0xc,%esp
f01086ba:	50                   	push   %eax
f01086bb:	e8 e1 f6 ff ff       	call   f0107da1 <to_physical_address>
f01086c0:	83 c4 10             	add    $0x10,%esp
f01086c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f01086c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01086c9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01086cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086cf:	c1 e8 0c             	shr    $0xc,%eax
f01086d2:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01086d5:	a1 f8 c6 5e f0       	mov    0xf05ec6f8,%eax
f01086da:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f01086dd:	72 17                	jb     f01086f6 <__static_cpt+0x5a>
f01086df:	ff 75 ec             	pushl  -0x14(%ebp)
f01086e2:	68 40 44 12 f0       	push   $0xf0124440
f01086e7:	68 4e 01 00 00       	push   $0x14e
f01086ec:	68 83 43 12 f0       	push   $0xf0124383
f01086f1:	e8 43 7c ff ff       	call   f0100339 <_panic>
f01086f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01086f9:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01086fe:	89 c2                	mov    %eax,%edx
f0108700:	8b 45 10             	mov    0x10(%ebp),%eax
f0108703:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0108705:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108708:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f010870e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108711:	c1 e8 16             	shr    $0x16,%eax
f0108714:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010871b:	8b 45 08             	mov    0x8(%ebp),%eax
f010871e:	01 d0                	add    %edx,%eax
f0108720:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108723:	83 ca 07             	or     $0x7,%edx
f0108726:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f0108728:	8b 45 10             	mov    0x10(%ebp),%eax
f010872b:	8b 00                	mov    (%eax),%eax
f010872d:	83 ec 04             	sub    $0x4,%esp
f0108730:	68 00 10 00 00       	push   $0x1000
f0108735:	6a 00                	push   $0x0
f0108737:	50                   	push   %eax
f0108738:	e8 90 66 01 00       	call   f011edcd <memset>
f010873d:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108740:	0f 20 d8             	mov    %cr3,%eax
f0108743:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108746:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108749:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f010874c:	90                   	nop
f010874d:	c9                   	leave  
f010874e:	c3                   	ret    

f010874f <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f010874f:	55                   	push   %ebp
f0108750:	89 e5                	mov    %esp,%ebp
f0108752:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108755:	ff 75 0c             	pushl  0xc(%ebp)
f0108758:	e8 44 f6 ff ff       	call   f0107da1 <to_physical_address>
f010875d:	83 c4 04             	add    $0x4,%esp
f0108760:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f0108763:	83 ec 04             	sub    $0x4,%esp
f0108766:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108769:	50                   	push   %eax
f010876a:	ff 75 10             	pushl  0x10(%ebp)
f010876d:	ff 75 08             	pushl  0x8(%ebp)
f0108770:	e8 4a fd ff ff       	call   f01084bf <get_page_table>
f0108775:	83 c4 10             	add    $0x10,%esp
f0108778:	83 f8 01             	cmp    $0x1,%eax
f010877b:	75 1b                	jne    f0108798 <map_frame+0x49>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f010877d:	83 ec 08             	sub    $0x8,%esp
f0108780:	ff 75 10             	pushl  0x10(%ebp)
f0108783:	ff 75 08             	pushl  0x8(%ebp)
f0108786:	e8 8a fe ff ff       	call   f0108615 <create_page_table>
f010878b:	83 c4 10             	add    $0x10,%esp
f010878e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f0108791:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f0108798:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010879b:	8b 55 10             	mov    0x10(%ebp),%edx
f010879e:	c1 ea 0c             	shr    $0xc,%edx
f01087a1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01087a7:	c1 e2 02             	shl    $0x2,%edx
f01087aa:	01 d0                	add    %edx,%eax
f01087ac:	8b 00                	mov    (%eax),%eax
f01087ae:	89 45 ec             	mov    %eax,-0x14(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f01087b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087b4:	83 e0 01             	and    $0x1,%eax
f01087b7:	85 c0                	test   %eax,%eax
f01087b9:	74 25                	je     f01087e0 <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f01087bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087be:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087c3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01087c6:	75 07                	jne    f01087cf <map_frame+0x80>
			return 0;
f01087c8:	b8 00 00 00 00       	mov    $0x0,%eax
f01087cd:	eb 68                	jmp    f0108837 <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f01087cf:	83 ec 08             	sub    $0x8,%esp
f01087d2:	ff 75 10             	pushl  0x10(%ebp)
f01087d5:	ff 75 08             	pushl  0x8(%ebp)
f01087d8:	e8 d2 00 00 00       	call   f01088af <unmap_frame>
f01087dd:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f01087e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01087e3:	8b 40 08             	mov    0x8(%eax),%eax
f01087e6:	40                   	inc    %eax
f01087e7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01087ea:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f01087ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01087f1:	8b 55 10             	mov    0x10(%ebp),%edx
f01087f4:	c1 ea 0c             	shr    $0xc,%edx
f01087f7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01087fd:	c1 e2 02             	shl    $0x2,%edx
f0108800:	01 d0                	add    %edx,%eax
f0108802:	8b 00                	mov    (%eax),%eax
f0108804:	25 00 0e 00 00       	and    $0xe00,%eax
f0108809:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f010880c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010880f:	8b 55 10             	mov    0x10(%ebp),%edx
f0108812:	c1 ea 0c             	shr    $0xc,%edx
f0108815:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010881b:	c1 e2 02             	shl    $0x2,%edx
f010881e:	01 c2                	add    %eax,%edx
f0108820:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108823:	0b 45 e8             	or     -0x18(%ebp),%eax
f0108826:	89 c1                	mov    %eax,%ecx
f0108828:	8b 45 14             	mov    0x14(%ebp),%eax
f010882b:	09 c8                	or     %ecx,%eax
f010882d:	83 c8 01             	or     $0x1,%eax
f0108830:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f0108832:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108837:	c9                   	leave  
f0108838:	c3                   	ret    

f0108839 <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f0108839:	55                   	push   %ebp
f010883a:	89 e5                	mov    %esp,%ebp
f010883c:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f010883f:	83 ec 04             	sub    $0x4,%esp
f0108842:	ff 75 10             	pushl  0x10(%ebp)
f0108845:	ff 75 0c             	pushl  0xc(%ebp)
f0108848:	ff 75 08             	pushl  0x8(%ebp)
f010884b:	e8 6f fc ff ff       	call   f01084bf <get_page_table>
f0108850:	83 c4 10             	add    $0x10,%esp
f0108853:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f0108856:	8b 45 10             	mov    0x10(%ebp),%eax
f0108859:	8b 00                	mov    (%eax),%eax
f010885b:	85 c0                	test   %eax,%eax
f010885d:	74 49                	je     f01088a8 <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f010885f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108862:	c1 e8 0c             	shr    $0xc,%eax
f0108865:	25 ff 03 00 00       	and    $0x3ff,%eax
f010886a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f010886d:	8b 45 10             	mov    0x10(%ebp),%eax
f0108870:	8b 00                	mov    (%eax),%eax
f0108872:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108875:	c1 e2 02             	shl    $0x2,%edx
f0108878:	01 d0                	add    %edx,%eax
f010887a:	8b 00                	mov    (%eax),%eax
f010887c:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f010887f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108882:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108887:	85 c0                	test   %eax,%eax
f0108889:	74 16                	je     f01088a1 <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f010888b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010888e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108893:	83 ec 0c             	sub    $0xc,%esp
f0108896:	50                   	push   %eax
f0108897:	e8 18 f5 ff ff       	call   f0107db4 <to_frame_info>
f010889c:	83 c4 10             	add    $0x10,%esp
f010889f:	eb 0c                	jmp    f01088ad <get_frame_info+0x74>
		}
		return 0;
f01088a1:	b8 00 00 00 00       	mov    $0x0,%eax
f01088a6:	eb 05                	jmp    f01088ad <get_frame_info+0x74>
	}
	return 0;
f01088a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01088ad:	c9                   	leave  
f01088ae:	c3                   	ret    

f01088af <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f01088af:	55                   	push   %ebp
f01088b0:	89 e5                	mov    %esp,%ebp
f01088b2:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f01088b5:	83 ec 04             	sub    $0x4,%esp
f01088b8:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01088bb:	50                   	push   %eax
f01088bc:	ff 75 0c             	pushl  0xc(%ebp)
f01088bf:	ff 75 08             	pushl  0x8(%ebp)
f01088c2:	e8 72 ff ff ff       	call   f0108839 <get_frame_info>
f01088c7:	83 c4 10             	add    $0x10,%esp
f01088ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f01088cd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01088d1:	74 7d                	je     f0108950 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f01088d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01088d6:	8a 40 18             	mov    0x18(%eax),%al
f01088d9:	84 c0                	test   %al,%al
f01088db:	74 1c                	je     f01088f9 <unmap_frame+0x4a>
f01088dd:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01088e4:	77 13                	ja     f01088f9 <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f01088e6:	83 ec 08             	sub    $0x8,%esp
f01088e9:	ff 75 0c             	pushl  0xc(%ebp)
f01088ec:	68 8c 44 12 f0       	push   $0xf012448c
f01088f1:	e8 95 86 ff ff       	call   f0100f8b <cprintf>
f01088f6:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f01088f9:	83 ec 0c             	sub    $0xc,%esp
f01088fc:	ff 75 f4             	pushl  -0xc(%ebp)
f01088ff:	e8 8b fb ff ff       	call   f010848f <decrement_references>
f0108904:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108907:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010890a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010890d:	c1 ea 0c             	shr    $0xc,%edx
f0108910:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108916:	c1 e2 02             	shl    $0x2,%edx
f0108919:	01 d0                	add    %edx,%eax
f010891b:	8b 00                	mov    (%eax),%eax
f010891d:	25 00 0e 00 00       	and    $0xe00,%eax
f0108922:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f0108925:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108928:	8b 55 0c             	mov    0xc(%ebp),%edx
f010892b:	c1 ea 0c             	shr    $0xc,%edx
f010892e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108934:	c1 e2 02             	shl    $0x2,%edx
f0108937:	01 c2                	add    %eax,%edx
f0108939:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010893c:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f010893e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108941:	83 ec 08             	sub    $0x8,%esp
f0108944:	50                   	push   %eax
f0108945:	ff 75 08             	pushl  0x8(%ebp)
f0108948:	e8 b9 f4 ff ff       	call   f0107e06 <tlb_invalidate>
f010894d:	83 c4 10             	add    $0x10,%esp
	}
}
f0108950:	90                   	nop
f0108951:	c9                   	leave  
f0108952:	c3                   	ret    

f0108953 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f0108953:	55                   	push   %ebp
f0108954:	89 e5                	mov    %esp,%ebp
f0108956:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f0108959:	ff 75 0c             	pushl  0xc(%ebp)
f010895c:	e8 40 f4 ff ff       	call   f0107da1 <to_physical_address>
f0108961:	83 c4 04             	add    $0x4,%esp
f0108964:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108967:	8b 45 10             	mov    0x10(%ebp),%eax
f010896a:	c1 e8 16             	shr    $0x16,%eax
f010896d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108974:	8b 45 08             	mov    0x8(%ebp),%eax
f0108977:	01 d0                	add    %edx,%eax
f0108979:	8b 00                	mov    (%eax),%eax
f010897b:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f010897e:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0108985:	77 19                	ja     f01089a0 <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108987:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010898a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010898f:	83 ec 0c             	sub    $0xc,%esp
f0108992:	50                   	push   %eax
f0108993:	e8 3f 07 00 00       	call   f01090d7 <kheap_virtual_address>
f0108998:	83 c4 10             	add    $0x10,%esp
f010899b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010899e:	eb 40                	jmp    f01089e0 <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01089a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01089a3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01089a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01089ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01089ae:	c1 e8 0c             	shr    $0xc,%eax
f01089b1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01089b4:	a1 f8 c6 5e f0       	mov    0xf05ec6f8,%eax
f01089b9:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01089bc:	72 17                	jb     f01089d5 <loadtime_map_frame+0x82>
f01089be:	ff 75 e8             	pushl  -0x18(%ebp)
f01089c1:	68 40 44 12 f0       	push   $0xf0124440
f01089c6:	68 f9 01 00 00       	push   $0x1f9
f01089cb:	68 83 43 12 f0       	push   $0xf0124383
f01089d0:	e8 64 79 ff ff       	call   f0100339 <_panic>
f01089d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01089d8:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01089dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f01089e0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01089e4:	75 14                	jne    f01089fa <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f01089e6:	83 ec 08             	sub    $0x8,%esp
f01089e9:	ff 75 10             	pushl  0x10(%ebp)
f01089ec:	ff 75 08             	pushl  0x8(%ebp)
f01089ef:	e8 21 fc ff ff       	call   f0108615 <create_page_table>
f01089f4:	83 c4 10             	add    $0x10,%esp
f01089f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f01089fa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01089fd:	8b 40 08             	mov    0x8(%eax),%eax
f0108a00:	40                   	inc    %eax
f0108a01:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108a04:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0108a08:	8b 45 10             	mov    0x10(%ebp),%eax
f0108a0b:	c1 e8 0c             	shr    $0xc,%eax
f0108a0e:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108a13:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108a1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a1d:	01 c2                	add    %eax,%edx
f0108a1f:	8b 45 14             	mov    0x14(%ebp),%eax
f0108a22:	0b 45 f0             	or     -0x10(%ebp),%eax
f0108a25:	83 c8 01             	or     $0x1,%eax
f0108a28:	89 02                	mov    %eax,(%edx)

	return 0;
f0108a2a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108a2f:	c9                   	leave  
f0108a30:	c3                   	ret    

f0108a31 <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f0108a31:	55                   	push   %ebp
f0108a32:	89 e5                	mov    %esp,%ebp
f0108a34:	57                   	push   %edi
f0108a35:	56                   	push   %esi
f0108a36:	53                   	push   %ebx
f0108a37:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f0108a3a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f0108a41:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f0108a48:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f0108a4f:	83 ec 0c             	sub    $0xc,%esp
f0108a52:	68 20 c5 5e f0       	push   $0xf05ec520
f0108a57:	e8 7c 63 00 00       	call   f010edd8 <holding_spinlock>
f0108a5c:	83 c4 10             	add    $0x10,%esp
f0108a5f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0108a62:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108a66:	75 10                	jne    f0108a78 <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108a68:	83 ec 0c             	sub    $0xc,%esp
f0108a6b:	68 20 c5 5e f0       	push   $0xf05ec520
f0108a70:	e8 4a 61 00 00       	call   f010ebbf <acquire_spinlock>
f0108a75:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0108a78:	a1 00 c5 5e f0       	mov    0xf05ec500,%eax
f0108a7d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108a80:	eb 1a                	jmp    f0108a9c <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f0108a82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108a85:	8a 40 18             	mov    0x18(%eax),%al
f0108a88:	84 c0                	test   %al,%al
f0108a8a:	74 05                	je     f0108a91 <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f0108a8c:	ff 45 dc             	incl   -0x24(%ebp)
f0108a8f:	eb 03                	jmp    f0108a94 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f0108a91:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0108a94:	a1 08 c5 5e f0       	mov    0xf05ec508,%eax
f0108a99:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108a9c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0108aa0:	74 07                	je     f0108aa9 <calculate_available_frames+0x78>
f0108aa2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108aa5:	8b 00                	mov    (%eax),%eax
f0108aa7:	eb 05                	jmp    f0108aae <calculate_available_frames+0x7d>
f0108aa9:	b8 00 00 00 00       	mov    $0x0,%eax
f0108aae:	a3 08 c5 5e f0       	mov    %eax,0xf05ec508
f0108ab3:	a1 08 c5 5e f0       	mov    0xf05ec508,%eax
f0108ab8:	85 c0                	test   %eax,%eax
f0108aba:	75 c6                	jne    f0108a82 <calculate_available_frames+0x51>
f0108abc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0108ac0:	75 c0                	jne    f0108a82 <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f0108ac2:	a1 1c c5 5e f0       	mov    0xf05ec51c,%eax
f0108ac7:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f0108aca:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0108ace:	75 10                	jne    f0108ae0 <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f0108ad0:	83 ec 0c             	sub    $0xc,%esp
f0108ad3:	68 20 c5 5e f0       	push   $0xf05ec520
f0108ad8:	e8 69 61 00 00       	call   f010ec46 <release_spinlock>
f0108add:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0108ae0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108ae3:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0108ae6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108ae9:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f0108aec:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0108aef:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0108af2:	8b 45 08             	mov    0x8(%ebp),%eax
f0108af5:	89 c3                	mov    %eax,%ebx
f0108af7:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0108afa:	ba 03 00 00 00       	mov    $0x3,%edx
f0108aff:	89 df                	mov    %ebx,%edi
f0108b01:	89 c6                	mov    %eax,%esi
f0108b03:	89 d1                	mov    %edx,%ecx
f0108b05:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0108b07:	8b 45 08             	mov    0x8(%ebp),%eax
f0108b0a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0108b0d:	5b                   	pop    %ebx
f0108b0e:	5e                   	pop    %esi
f0108b0f:	5f                   	pop    %edi
f0108b10:	5d                   	pop    %ebp
f0108b11:	c2 04 00             	ret    $0x4

f0108b14 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f0108b14:	55                   	push   %ebp
f0108b15:	89 e5                	mov    %esp,%ebp
f0108b17:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f0108b1a:	c7 05 c0 c3 5e f0 00 	movl   $0x0,0xf05ec3c0
f0108b21:	00 00 00 
f0108b24:	c7 05 c4 c3 5e f0 00 	movl   $0x0,0xf05ec3c4
f0108b2b:	00 00 00 
f0108b2e:	c7 05 cc c3 5e f0 00 	movl   $0x0,0xf05ec3cc
f0108b35:	00 00 00 
	init_spinlock(&AllShares.shareslock, "shares lock");
f0108b38:	83 ec 08             	sub    $0x8,%esp
f0108b3b:	68 bc 44 12 f0       	push   $0xf01244bc
f0108b40:	68 d0 c3 5e f0       	push   $0xf05ec3d0
f0108b45:	e8 44 60 00 00       	call   f010eb8e <init_spinlock>
f0108b4a:	83 c4 10             	add    $0x10,%esp
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0108b4d:	90                   	nop
f0108b4e:	c9                   	leave  
f0108b4f:	c3                   	ret    

f0108b50 <getSizeOfSharedObject>:

//==============================
// [2] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f0108b50:	55                   	push   %ebp
f0108b51:	89 e5                	mov    %esp,%ebp
f0108b53:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108b56:	83 ec 08             	sub    $0x8,%esp
f0108b59:	ff 75 0c             	pushl  0xc(%ebp)
f0108b5c:	ff 75 08             	pushl  0x8(%ebp)
f0108b5f:	e8 55 00 00 00       	call   f0108bb9 <get_share>
f0108b64:	83 c4 10             	add    $0x10,%esp
f0108b67:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108b6a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108b6e:	75 07                	jne    f0108b77 <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0108b70:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0108b75:	eb 06                	jmp    f0108b7d <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108b77:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b7a:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108b7d:	c9                   	leave  
f0108b7e:	c3                   	ret    

f0108b7f <create_frames_storage>:
//===========================
// [1] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f0108b7f:	55                   	push   %ebp
f0108b80:	89 e5                	mov    %esp,%ebp
f0108b82:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_frames_storage()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("create_frames_storage is not implemented yet");
f0108b85:	83 ec 04             	sub    $0x4,%esp
f0108b88:	68 c8 44 12 f0       	push   $0xf01244c8
f0108b8d:	6a 45                	push   $0x45
f0108b8f:	68 f8 44 12 f0       	push   $0xf01244f8
f0108b94:	e8 a0 77 ff ff       	call   f0100339 <_panic>

f0108b99 <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0108b99:	55                   	push   %ebp
f0108b9a:	89 e5                	mov    %esp,%ebp
f0108b9c:	83 ec 18             	sub    $0x18,%esp
f0108b9f:	8b 45 14             	mov    0x14(%ebp),%eax
f0108ba2:	88 45 f4             	mov    %al,-0xc(%ebp)
	//TODO: [PROJECT'24.MS2 - #16] [4] SHARED MEMORY - create_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("create_share is not implemented yet");
f0108ba5:	83 ec 04             	sub    $0x4,%esp
f0108ba8:	68 1c 45 12 f0       	push   $0xf012451c
f0108bad:	6a 54                	push   $0x54
f0108baf:	68 f8 44 12 f0       	push   $0xf01244f8
f0108bb4:	e8 80 77 ff ff       	call   f0100339 <_panic>

f0108bb9 <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f0108bb9:	55                   	push   %ebp
f0108bba:	89 e5                	mov    %esp,%ebp
f0108bbc:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #17] [4] SHARED MEMORY - get_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("get_share is not implemented yet");
f0108bbf:	83 ec 04             	sub    $0x4,%esp
f0108bc2:	68 40 45 12 f0       	push   $0xf0124540
f0108bc7:	6a 64                	push   $0x64
f0108bc9:	68 f8 44 12 f0       	push   $0xf01244f8
f0108bce:	e8 66 77 ff ff       	call   f0100339 <_panic>

f0108bd3 <createSharedObject>:

//=========================
// [4] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0108bd3:	55                   	push   %ebp
f0108bd4:	89 e5                	mov    %esp,%ebp
f0108bd6:	83 ec 18             	sub    $0x18,%esp
f0108bd9:	8b 45 14             	mov    0x14(%ebp),%eax
f0108bdc:	88 45 f4             	mov    %al,-0xc(%ebp)
	//TODO: [PROJECT'24.MS2 - #19] [4] SHARED MEMORY [KERNEL SIDE] - createSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("createSharedObject is not implemented yet");
f0108bdf:	83 ec 04             	sub    $0x4,%esp
f0108be2:	68 64 45 12 f0       	push   $0xf0124564
f0108be7:	6a 70                	push   $0x70
f0108be9:	68 f8 44 12 f0       	push   $0xf01244f8
f0108bee:	e8 46 77 ff ff       	call   f0100339 <_panic>

f0108bf3 <getSharedObject>:

//======================
// [5] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0108bf3:	55                   	push   %ebp
f0108bf4:	89 e5                	mov    %esp,%ebp
f0108bf6:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #21] [4] SHARED MEMORY [KERNEL SIDE] - getSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("getSharedObject is not implemented yet");
f0108bf9:	83 ec 04             	sub    $0x4,%esp
f0108bfc:	68 90 45 12 f0       	push   $0xf0124590
f0108c01:	6a 7e                	push   $0x7e
f0108c03:	68 f8 44 12 f0       	push   $0xf01244f8
f0108c08:	e8 2c 77 ff ff       	call   f0100339 <_panic>

f0108c0d <free_share>:
// [B1] Delete Share Object:
//==========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f0108c0d:	55                   	push   %ebp
f0108c0e:	89 e5                	mov    %esp,%ebp
f0108c10:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - free_share()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("free_share is not implemented yet");
f0108c13:	83 ec 04             	sub    $0x4,%esp
f0108c16:	68 b8 45 12 f0       	push   $0xf01245b8
f0108c1b:	68 91 00 00 00       	push   $0x91
f0108c20:	68 f8 44 12 f0       	push   $0xf01244f8
f0108c25:	e8 0f 77 ff ff       	call   f0100339 <_panic>

f0108c2a <freeSharedObject>:
}
//========================
// [B2] Free Share Object:
//========================
int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f0108c2a:	55                   	push   %ebp
f0108c2b:	89 e5                	mov    %esp,%ebp
f0108c2d:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - BONUS#4] [4] SHARED MEMORY [KERNEL SIDE] - freeSharedObject()
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("freeSharedObject is not implemented yet");
f0108c30:	83 ec 04             	sub    $0x4,%esp
f0108c33:	68 dc 45 12 f0       	push   $0xf01245dc
f0108c38:	68 9c 00 00 00       	push   $0x9c
f0108c3d:	68 f8 44 12 f0       	push   $0xf01244f8
f0108c42:	e8 f2 76 ff ff       	call   f0100339 <_panic>

f0108c47 <initialize_kheap_dynamic_allocator>:
//Remember: call the initialize_dynamic_allocator(..) to complete the initialization
//Return:
//	On success: 0
//	Otherwise (if no memory OR initial size exceed the given limit): PANIC

int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit) {
f0108c47:	55                   	push   %ebp
f0108c48:	89 e5                	mov    %esp,%ebp
f0108c4a:	83 ec 28             	sub    $0x28,%esp
	//TODO: [PROJECT'24.MS2 - #01] [1] KERNEL HEAP - initialize_kheap_dynamic_allocator
		// Write your code here, remove the panic and write your code
	//panic("initial size exceeds the given limit!");
    if (initSizeToAllocate > daLimit - daStart) {
f0108c4d:	8b 45 10             	mov    0x10(%ebp),%eax
f0108c50:	2b 45 08             	sub    0x8(%ebp),%eax
f0108c53:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108c56:	73 14                	jae    f0108c6c <initialize_kheap_dynamic_allocator+0x25>
        panic("initial size exceeds the given limit!");
f0108c58:	83 ec 04             	sub    $0x4,%esp
f0108c5b:	68 04 46 12 f0       	push   $0xf0124604
f0108c60:	6a 13                	push   $0x13
f0108c62:	68 2a 46 12 f0       	push   $0xf012462a
f0108c67:	e8 cd 76 ff ff       	call   f0100339 <_panic>
    }

    kstart = daStart;
f0108c6c:	8b 45 08             	mov    0x8(%ebp),%eax
f0108c6f:	a3 58 c9 5e f0       	mov    %eax,0xf05ec958
    kbrk = daStart + initSizeToAllocate;
f0108c74:	8b 55 08             	mov    0x8(%ebp),%edx
f0108c77:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108c7a:	01 d0                	add    %edx,%eax
f0108c7c:	a3 4c c9 5e f0       	mov    %eax,0xf05ec94c
    khardlimit = daLimit;
f0108c81:	8b 45 10             	mov    0x10(%ebp),%eax
f0108c84:	a3 20 c2 5e f0       	mov    %eax,0xf05ec220
    //cprintf("zzzzzzzzzzzzzzzzzzzzzzzzzzz%x",daLimit);


    for (uint32 i = kstart; i < kbrk; i += PAGE_SIZE) {
f0108c89:	a1 58 c9 5e f0       	mov    0xf05ec958,%eax
f0108c8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c91:	eb 7c                	jmp    f0108d0f <initialize_kheap_dynamic_allocator+0xc8>



        uint32 *ptr_page_table = NULL;
f0108c93:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
        struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, i, &ptr_page_table);
f0108c9a:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0108c9f:	83 ec 04             	sub    $0x4,%esp
f0108ca2:	8d 55 e8             	lea    -0x18(%ebp),%edx
f0108ca5:	52                   	push   %edx
f0108ca6:	ff 75 f4             	pushl  -0xc(%ebp)
f0108ca9:	50                   	push   %eax
f0108caa:	e8 8a fb ff ff       	call   f0108839 <get_frame_info>
f0108caf:	83 c4 10             	add    $0x10,%esp
f0108cb2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if (ptr_frame_info == NULL) {
f0108cb5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108cb8:	85 c0                	test   %eax,%eax
f0108cba:	75 4c                	jne    f0108d08 <initialize_kheap_dynamic_allocator+0xc1>
            int allocResult = allocate_frame(&ptr_frame_info);
f0108cbc:	83 ec 0c             	sub    $0xc,%esp
f0108cbf:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0108cc2:	50                   	push   %eax
f0108cc3:	e8 ba f5 ff ff       	call   f0108282 <allocate_frame>
f0108cc8:	83 c4 10             	add    $0x10,%esp
f0108ccb:	89 45 f0             	mov    %eax,-0x10(%ebp)
            if (allocResult != E_NO_MEM) {
f0108cce:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f0108cd2:	74 34                	je     f0108d08 <initialize_kheap_dynamic_allocator+0xc1>

                int mapResult = map_frame(ptr_page_directory, ptr_frame_info, i, PERM_WRITEABLE | PERM_PRESENT);
f0108cd4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0108cd7:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0108cdc:	6a 03                	push   $0x3
f0108cde:	ff 75 f4             	pushl  -0xc(%ebp)
f0108ce1:	52                   	push   %edx
f0108ce2:	50                   	push   %eax
f0108ce3:	e8 67 fa ff ff       	call   f010874f <map_frame>
f0108ce8:	83 c4 10             	add    $0x10,%esp
f0108ceb:	89 45 ec             	mov    %eax,-0x14(%ebp)
                if (mapResult == E_NO_MEM) {
f0108cee:	83 7d ec fc          	cmpl   $0xfffffffc,-0x14(%ebp)
f0108cf2:	75 14                	jne    f0108d08 <initialize_kheap_dynamic_allocator+0xc1>
                    panic("failed to map frame to virtual address");
f0108cf4:	83 ec 04             	sub    $0x4,%esp
f0108cf7:	68 3c 46 12 f0       	push   $0xf012463c
f0108cfc:	6a 29                	push   $0x29
f0108cfe:	68 2a 46 12 f0       	push   $0xf012462a
f0108d03:	e8 31 76 ff ff       	call   f0100339 <_panic>
    kbrk = daStart + initSizeToAllocate;
    khardlimit = daLimit;
    //cprintf("zzzzzzzzzzzzzzzzzzzzzzzzzzz%x",daLimit);


    for (uint32 i = kstart; i < kbrk; i += PAGE_SIZE) {
f0108d08:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0108d0f:	a1 4c c9 5e f0       	mov    0xf05ec94c,%eax
f0108d14:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0108d17:	0f 82 76 ff ff ff    	jb     f0108c93 <initialize_kheap_dynamic_allocator+0x4c>
            }
        }
    }


    initialize_dynamic_allocator(daStart, initSizeToAllocate);
f0108d1d:	83 ec 08             	sub    $0x8,%esp
f0108d20:	ff 75 0c             	pushl  0xc(%ebp)
f0108d23:	ff 75 08             	pushl  0x8(%ebp)
f0108d26:	e8 83 6a 01 00       	call   f011f7ae <initialize_dynamic_allocator>
f0108d2b:	83 c4 10             	add    $0x10,%esp

    return 0;
f0108d2e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108d33:	c9                   	leave  
f0108d34:	c3                   	ret    

f0108d35 <sbrk>:
	// cprintf("kbrk: %p, khardlimit: %p, numOfPages: %d\n", kbrk, khardlimit, numOfPages);




void* sbrk(int numOfPages) {
f0108d35:	55                   	push   %ebp
f0108d36:	89 e5                	mov    %esp,%ebp
f0108d38:	83 ec 38             	sub    $0x38,%esp

  //  cprintf("kbrk: %p, khardlimit: %p, numOfPages: %d\n", kbrk, khardlimit, numOfPages);


    if (numOfPages == 0) {
f0108d3b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108d3f:	75 0a                	jne    f0108d4b <sbrk+0x16>
      //  cprintf("returning current break: %p\n", kbrk);
        return (void*)(kbrk);
f0108d41:	a1 4c c9 5e f0       	mov    0xf05ec94c,%eax
f0108d46:	e9 e3 00 00 00       	jmp    f0108e2e <sbrk+0xf9>
    }


    if (numOfPages < 0) {
f0108d4b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108d4f:	79 0a                	jns    f0108d5b <sbrk+0x26>

        return (void*)-1;
f0108d51:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0108d56:	e9 d3 00 00 00       	jmp    f0108e2e <sbrk+0xf9>
    }


    uint32 size = numOfPages * PAGE_SIZE;
f0108d5b:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d5e:	c1 e0 0c             	shl    $0xc,%eax
f0108d61:	89 45 ec             	mov    %eax,-0x14(%ebp)
   // cprintf(" size: %u bytes\n", size);


    unsigned int new_break = kbrk + size;
f0108d64:	8b 15 4c c9 5e f0    	mov    0xf05ec94c,%edx
f0108d6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108d6d:	01 d0                	add    %edx,%eax
f0108d6f:	89 45 e8             	mov    %eax,-0x18(%ebp)
   // cprintf("calculated new_break: %p\n", (void*)new_break);


    if (new_break > khardlimit) {
f0108d72:	a1 20 c2 5e f0       	mov    0xf05ec220,%eax
f0108d77:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0108d7a:	76 0a                	jbe    f0108d86 <sbrk+0x51>

        return (void*)-1;
f0108d7c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0108d81:	e9 a8 00 00 00       	jmp    f0108e2e <sbrk+0xf9>
    }
    uint32 *ptr_page_table = NULL;
f0108d86:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
      struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, kbrk, &ptr_page_table);
f0108d8d:	8b 15 4c c9 5e f0    	mov    0xf05ec94c,%edx
f0108d93:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0108d98:	83 ec 04             	sub    $0x4,%esp
f0108d9b:	8d 4d d8             	lea    -0x28(%ebp),%ecx
f0108d9e:	51                   	push   %ecx
f0108d9f:	52                   	push   %edx
f0108da0:	50                   	push   %eax
f0108da1:	e8 93 fa ff ff       	call   f0108839 <get_frame_info>
f0108da6:	83 c4 10             	add    $0x10,%esp
f0108da9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      uint32 brk_tmp=kbrk;
f0108dac:	a1 4c c9 5e f0       	mov    0xf05ec94c,%eax
f0108db1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(int i=0;i<numOfPages;i++){
f0108db4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0108dbb:	eb 56                	jmp    f0108e13 <sbrk+0xde>


               int allocResult = allocate_frame(&ptr_frame_info);
f0108dbd:	83 ec 0c             	sub    $0xc,%esp
f0108dc0:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f0108dc3:	50                   	push   %eax
f0108dc4:	e8 b9 f4 ff ff       	call   f0108282 <allocate_frame>
f0108dc9:	83 c4 10             	add    $0x10,%esp
f0108dcc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
               if (allocResult != E_NO_MEM) {
f0108dcf:	83 7d e4 fc          	cmpl   $0xfffffffc,-0x1c(%ebp)
f0108dd3:	74 3b                	je     f0108e10 <sbrk+0xdb>
                   int mapResult = map_frame(ptr_page_directory, ptr_frame_info, brk_tmp, PERM_WRITEABLE |PERM_PRESENT);
f0108dd5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0108dd8:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0108ddd:	6a 03                	push   $0x3
f0108ddf:	ff 75 f4             	pushl  -0xc(%ebp)
f0108de2:	52                   	push   %edx
f0108de3:	50                   	push   %eax
f0108de4:	e8 66 f9 ff ff       	call   f010874f <map_frame>
f0108de9:	83 c4 10             	add    $0x10,%esp
f0108dec:	89 45 e0             	mov    %eax,-0x20(%ebp)
                   brk_tmp+=PAGE_SIZE;
f0108def:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
                   if (mapResult == E_NO_MEM) {
f0108df6:	83 7d e0 fc          	cmpl   $0xfffffffc,-0x20(%ebp)
f0108dfa:	75 14                	jne    f0108e10 <sbrk+0xdb>

                       panic("sssssssssssssssssssssssssssssssssssssssssss");
f0108dfc:	83 ec 04             	sub    $0x4,%esp
f0108dff:	68 64 46 12 f0       	push   $0xf0124664
f0108e04:	6a 76                	push   $0x76
f0108e06:	68 2a 46 12 f0       	push   $0xf012462a
f0108e0b:	e8 29 75 ff ff       	call   f0100339 <_panic>
        return (void*)-1;
    }
    uint32 *ptr_page_table = NULL;
      struct FrameInfo *ptr_frame_info = get_frame_info(ptr_page_directory, kbrk, &ptr_page_table);
      uint32 brk_tmp=kbrk;
    for(int i=0;i<numOfPages;i++){
f0108e10:	ff 45 f0             	incl   -0x10(%ebp)
f0108e13:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108e16:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108e19:	7c a2                	jl     f0108dbd <sbrk+0x88>

               }


         }
         unsigned int old_break = kbrk;
f0108e1b:	a1 4c c9 5e f0       	mov    0xf05ec94c,%eax
f0108e20:	89 45 dc             	mov    %eax,-0x24(%ebp)
         kbrk = new_break;
f0108e23:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e26:	a3 4c c9 5e f0       	mov    %eax,0xf05ec94c


       //  cprintf("updated kbrk: %p\n", (void*)kbrk);
         //cprintf("returning old break: %p\n", (void*)old_break);
         return (void*)old_break;
f0108e2b:	8b 45 dc             	mov    -0x24(%ebp),%eax
}
f0108e2e:	c9                   	leave  
f0108e2f:	c3                   	ret    

f0108e30 <kmalloc>:

//TODO: [PROJECT'24.MS2 - BONUS#2] [1] KERNEL HEAP - Fast Page Allocator

void* kmalloc(unsigned int size)
{
f0108e30:	55                   	push   %ebp
f0108e31:	89 e5                	mov    %esp,%ebp
f0108e33:	83 ec 48             	sub    $0x48,%esp
	//TODO: [PROJECT'24.MS2 - #03] [1] KERNEL HEAP - kmalloc
	// Write your code here, remove the panic and write your code
//_into_prompt("kmalloc() is not implemented yet...!!");

	//use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy
uint32 pageadd=0;
f0108e36:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  if (size<=2048){
f0108e3d:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f0108e44:	77 13                	ja     f0108e59 <kmalloc+0x29>



	 // cprintf("here block \n");
	return(void*) alloc_block_FF(size);
f0108e46:	83 ec 0c             	sub    $0xc,%esp
f0108e49:	ff 75 08             	pushl  0x8(%ebp)
f0108e4c:	e8 c7 6a 01 00       	call   f011f918 <alloc_block_FF>
f0108e51:	83 c4 10             	add    $0x10,%esp
f0108e54:	e9 42 01 00 00       	jmp    f0108f9b <kmalloc+0x16b>
 }
  else{


	uint32 num_wanted_pages =ROUNDUP(size,4*1024)/(4*1024);
f0108e59:	c7 45 e0 00 10 00 00 	movl   $0x1000,-0x20(%ebp)
f0108e60:	8b 55 08             	mov    0x8(%ebp),%edx
f0108e63:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108e66:	01 d0                	add    %edx,%eax
f0108e68:	48                   	dec    %eax
f0108e69:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108e6c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108e6f:	ba 00 00 00 00       	mov    $0x0,%edx
f0108e74:	f7 75 e0             	divl   -0x20(%ebp)
f0108e77:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108e7a:	29 d0                	sub    %edx,%eax
f0108e7c:	c1 e8 0c             	shr    $0xc,%eax
f0108e7f:	89 45 d8             	mov    %eax,-0x28(%ebp)
	 // cprintf("iam here mothere%d ",num_wanted_pages);
	  uint32 *ptr_pagetable = NULL;
f0108e82:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
int count=0;
f0108e89:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
struct FrameInfo *ptr_frameinfo;
uint32*page_table;
//cprintf("here y3m %x\n",khardlimit+(4*1024));
	  for (uint32 i = khardlimit+(4*1024); i <= KERNEL_HEAP_MAX-(4*1024); i += PAGE_SIZE) {
f0108e90:	a1 20 c2 5e f0       	mov    0xf05ec220,%eax
f0108e95:	05 00 10 00 00       	add    $0x1000,%eax
f0108e9a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108e9d:	eb 68                	jmp    f0108f07 <kmalloc+0xd7>
		get_page_table(ptr_page_directory,i,&page_table);
f0108e9f:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0108ea4:	83 ec 04             	sub    $0x4,%esp
f0108ea7:	8d 55 c0             	lea    -0x40(%ebp),%edx
f0108eaa:	52                   	push   %edx
f0108eab:	ff 75 ec             	pushl  -0x14(%ebp)
f0108eae:	50                   	push   %eax
f0108eaf:	e8 0b f6 ff ff       	call   f01084bf <get_page_table>
f0108eb4:	83 c4 10             	add    $0x10,%esp
		uint32 presbit=page_table[PTX(i)]&1;
f0108eb7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0108eba:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108ebd:	c1 ea 0c             	shr    $0xc,%edx
f0108ec0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108ec6:	c1 e2 02             	shl    $0x2,%edx
f0108ec9:	01 d0                	add    %edx,%eax
f0108ecb:	8b 00                	mov    (%eax),%eax
f0108ecd:	83 e0 01             	and    $0x1,%eax
f0108ed0:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (presbit==0){
f0108ed3:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0108ed7:	75 19                	jne    f0108ef2 <kmalloc+0xc2>

		  count++;
f0108ed9:	ff 45 f0             	incl   -0x10(%ebp)
		  if(pageadd==0)
f0108edc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108ee0:	75 06                	jne    f0108ee8 <kmalloc+0xb8>
			pageadd=i;
f0108ee2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ee5:	89 45 f4             	mov    %eax,-0xc(%ebp)
			if (count==num_wanted_pages)break;
f0108ee8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108eeb:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0108eee:	75 10                	jne    f0108f00 <kmalloc+0xd0>
f0108ef0:	eb 1e                	jmp    f0108f10 <kmalloc+0xe0>
		}

		  else{ count =0;
f0108ef2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		  pageadd=0;
f0108ef9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	  uint32 *ptr_pagetable = NULL;
int count=0;
struct FrameInfo *ptr_frameinfo;
uint32*page_table;
//cprintf("here y3m %x\n",khardlimit+(4*1024));
	  for (uint32 i = khardlimit+(4*1024); i <= KERNEL_HEAP_MAX-(4*1024); i += PAGE_SIZE) {
f0108f00:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f0108f07:	81 7d ec 00 e0 ff ff 	cmpl   $0xffffe000,-0x14(%ebp)
f0108f0e:	76 8f                	jbe    f0108e9f <kmalloc+0x6f>
		//cprintf("herefor %d/n",pageadd);
		  }


	  }
      if (count<num_wanted_pages)return NULL;
f0108f10:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108f13:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0108f16:	73 07                	jae    f0108f1f <kmalloc+0xef>
f0108f18:	b8 00 00 00 00       	mov    $0x0,%eax
f0108f1d:	eb 7c                	jmp    f0108f9b <kmalloc+0x16b>
      //cprintf("First here %d/n", pageadd =((num_wanted_pages-1)*PAGE_SIZE));

    //  cprintf("numof pageee%d/n", num_wanted_pages);

uint32 pagetemp=pageadd;
f0108f1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108f22:	89 45 e8             	mov    %eax,-0x18(%ebp)
     for(int i=0;i<num_wanted_pages;i++){
f0108f25:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0108f2c:	eb 62                	jmp    f0108f90 <kmalloc+0x160>
          int allocResult = allocate_frame(&ptr_frameinfo);
f0108f2e:	83 ec 0c             	sub    $0xc,%esp
f0108f31:	8d 45 c4             	lea    -0x3c(%ebp),%eax
f0108f34:	50                   	push   %eax
f0108f35:	e8 48 f3 ff ff       	call   f0108282 <allocate_frame>
f0108f3a:	83 c4 10             	add    $0x10,%esp
f0108f3d:	89 45 cc             	mov    %eax,-0x34(%ebp)




          if (allocResult != E_NO_MEM) {
f0108f40:	83 7d cc fc          	cmpl   $0xfffffffc,-0x34(%ebp)
f0108f44:	74 47                	je     f0108f8d <kmalloc+0x15d>

              int mapResult = map_frame(ptr_page_directory, ptr_frameinfo, pagetemp,PERM_PRESENT|PERM_WRITEABLE);
f0108f46:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0108f49:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0108f4e:	6a 03                	push   $0x3
f0108f50:	ff 75 e8             	pushl  -0x18(%ebp)
f0108f53:	52                   	push   %edx
f0108f54:	50                   	push   %eax
f0108f55:	e8 f5 f7 ff ff       	call   f010874f <map_frame>
f0108f5a:	83 c4 10             	add    $0x10,%esp
f0108f5d:	89 45 c8             	mov    %eax,-0x38(%ebp)
              //get_page_table(ptr_page_directory,pagetemp,&page_table);
              		//uint32 presbit=page_table[PTX(pagetemp)]&1;
              	  	  	  //cprintf("iam here\n%d",presbit);
              ptr_frameinfo->size=num_wanted_pages;
f0108f60:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0108f63:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0108f66:	89 50 0c             	mov    %edx,0xc(%eax)
              	  pagetemp+=PAGE_SIZE;
f0108f69:	81 45 e8 00 10 00 00 	addl   $0x1000,-0x18(%ebp)
              if (mapResult == E_NO_MEM) {
f0108f70:	83 7d c8 fc          	cmpl   $0xfffffffc,-0x38(%ebp)
f0108f74:	75 17                	jne    f0108f8d <kmalloc+0x15d>
                 panic("failed to map frame to virtual address");
f0108f76:	83 ec 04             	sub    $0x4,%esp
f0108f79:	68 3c 46 12 f0       	push   $0xf012463c
f0108f7e:	68 d1 00 00 00       	push   $0xd1
f0108f83:	68 2a 46 12 f0       	push   $0xf012462a
f0108f88:	e8 ac 73 ff ff       	call   f0100339 <_panic>
      //cprintf("First here %d/n", pageadd =((num_wanted_pages-1)*PAGE_SIZE));

    //  cprintf("numof pageee%d/n", num_wanted_pages);

uint32 pagetemp=pageadd;
     for(int i=0;i<num_wanted_pages;i++){
f0108f8d:	ff 45 e4             	incl   -0x1c(%ebp)
f0108f90:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108f93:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0108f96:	72 96                	jb     f0108f2e <kmalloc+0xfe>
          }
          	  	  	  	  	  	  	  	}

 //cprintf("last%x/n",pageadd);

  return (void*)pageadd;
f0108f98:	8b 45 f4             	mov    -0xc(%ebp),%eax
  }



}
f0108f9b:	c9                   	leave  
f0108f9c:	c3                   	ret    

f0108f9d <kfree>:



void kfree(void* virtual_address)
{
f0108f9d:	55                   	push   %ebp
f0108f9e:	89 e5                	mov    %esp,%ebp
f0108fa0:	83 ec 18             	sub    $0x18,%esp
	// Write your code here, remove the panic and write your code
	//panic("kfree() is not implemented yet...!!");

	//you need to get the size of the given allocation using its address
	//refer to the project presentation and documentation for details
	cprintf("vm--%x---kstart--%x--hard--%x\n",virtual_address,kbrk);
f0108fa3:	a1 4c c9 5e f0       	mov    0xf05ec94c,%eax
f0108fa8:	83 ec 04             	sub    $0x4,%esp
f0108fab:	50                   	push   %eax
f0108fac:	ff 75 08             	pushl  0x8(%ebp)
f0108faf:	68 90 46 12 f0       	push   $0xf0124690
f0108fb4:	e8 d2 7f ff ff       	call   f0100f8b <cprintf>
f0108fb9:	83 c4 10             	add    $0x10,%esp
if((uint32)virtual_address>=(uint32)kstart&&(uint32)virtual_address<(uint32)kbrk){
f0108fbc:	8b 55 08             	mov    0x8(%ebp),%edx
f0108fbf:	a1 58 c9 5e f0       	mov    0xf05ec958,%eax
f0108fc4:	39 c2                	cmp    %eax,%edx
f0108fc6:	72 3f                	jb     f0109007 <kfree+0x6a>
f0108fc8:	8b 55 08             	mov    0x8(%ebp),%edx
f0108fcb:	a1 4c c9 5e f0       	mov    0xf05ec94c,%eax
f0108fd0:	39 c2                	cmp    %eax,%edx
f0108fd2:	73 33                	jae    f0109007 <kfree+0x6a>
	cprintf("hereee before block\n");
f0108fd4:	83 ec 0c             	sub    $0xc,%esp
f0108fd7:	68 af 46 12 f0       	push   $0xf01246af
f0108fdc:	e8 aa 7f ff ff       	call   f0100f8b <cprintf>
f0108fe1:	83 c4 10             	add    $0x10,%esp
	free_block(virtual_address);
f0108fe4:	83 ec 0c             	sub    $0xc,%esp
f0108fe7:	ff 75 08             	pushl  0x8(%ebp)
f0108fea:	e8 34 72 01 00       	call   f0120223 <free_block>
f0108fef:	83 c4 10             	add    $0x10,%esp
	cprintf("hereee block freeeeeee doneeee\n");
f0108ff2:	83 ec 0c             	sub    $0xc,%esp
f0108ff5:	68 c4 46 12 f0       	push   $0xf01246c4
f0108ffa:	e8 8c 7f ff ff       	call   f0100f8b <cprintf>
f0108fff:	83 c4 10             	add    $0x10,%esp
f0109002:	e9 8c 00 00 00       	jmp    f0109093 <kfree+0xf6>

}
else if((uint32)virtual_address<KERNEL_HEAP_MAX&&(uint32)virtual_address>=(khardlimit+(4*1024))){
f0109007:	8b 45 08             	mov    0x8(%ebp),%eax
f010900a:	3d ff ef ff ff       	cmp    $0xffffefff,%eax
f010900f:	77 6b                	ja     f010907c <kfree+0xdf>
f0109011:	a1 20 c2 5e f0       	mov    0xf05ec220,%eax
f0109016:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
f010901c:	8b 45 08             	mov    0x8(%ebp),%eax
f010901f:	39 c2                	cmp    %eax,%edx
f0109021:	77 59                	ja     f010907c <kfree+0xdf>
	uint32* page_table;
	uint32 xx=pf_calculate_free_frames();
f0109023:	e8 e1 b8 ff ff       	call   f0104909 <pf_calculate_free_frames>
f0109028:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//cprintf("freee%d\n",xx);
	uint32 num_of_free_pages=get_frame_info(ptr_page_directory,(uint32)virtual_address,&page_table)->size;
f010902b:	8b 55 08             	mov    0x8(%ebp),%edx
f010902e:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0109033:	83 ec 04             	sub    $0x4,%esp
f0109036:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f0109039:	51                   	push   %ecx
f010903a:	52                   	push   %edx
f010903b:	50                   	push   %eax
f010903c:	e8 f8 f7 ff ff       	call   f0108839 <get_frame_info>
f0109041:	83 c4 10             	add    $0x10,%esp
f0109044:	8b 40 0c             	mov    0xc(%eax),%eax
f0109047:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//get_page_table(ptr_page_directory,(uint32)virtual_address,&page_table);
//	cprintf("hereee%d",num_of_free_pages,"\n");
	for(uint32 i=0;i<num_of_free_pages;i++){
f010904a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109051:	eb 1f                	jmp    f0109072 <kfree+0xd5>

	unmap_frame(ptr_page_directory,(uint32) virtual_address);
f0109053:	8b 55 08             	mov    0x8(%ebp),%edx
f0109056:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f010905b:	83 ec 08             	sub    $0x8,%esp
f010905e:	52                   	push   %edx
f010905f:	50                   	push   %eax
f0109060:	e8 4a f8 ff ff       	call   f01088af <unmap_frame>
f0109065:	83 c4 10             	add    $0x10,%esp
	virtual_address+=PAGE_SIZE;
f0109068:	81 45 08 00 10 00 00 	addl   $0x1000,0x8(%ebp)
	uint32 xx=pf_calculate_free_frames();
	//cprintf("freee%d\n",xx);
	uint32 num_of_free_pages=get_frame_info(ptr_page_directory,(uint32)virtual_address,&page_table)->size;
	//get_page_table(ptr_page_directory,(uint32)virtual_address,&page_table);
//	cprintf("hereee%d",num_of_free_pages,"\n");
	for(uint32 i=0;i<num_of_free_pages;i++){
f010906f:	ff 45 f4             	incl   -0xc(%ebp)
f0109072:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109075:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109078:	72 d9                	jb     f0109053 <kfree+0xb6>
	cprintf("hereee before block\n");
	free_block(virtual_address);
	cprintf("hereee block freeeeeee doneeee\n");

}
else if((uint32)virtual_address<KERNEL_HEAP_MAX&&(uint32)virtual_address>=(khardlimit+(4*1024))){
f010907a:	eb 17                	jmp    f0109093 <kfree+0xf6>
	unmap_frame(ptr_page_directory,(uint32) virtual_address);
	virtual_address+=PAGE_SIZE;
	}

}
else panic("painccc");
f010907c:	83 ec 04             	sub    $0x4,%esp
f010907f:	68 e4 46 12 f0       	push   $0xf01246e4
f0109084:	68 fe 00 00 00       	push   $0xfe
f0109089:	68 2a 46 12 f0       	push   $0xf012462a
f010908e:	e8 a6 72 ff ff       	call   f0100339 <_panic>
}
f0109093:	90                   	nop
f0109094:	c9                   	leave  
f0109095:	c3                   	ret    

f0109096 <kheap_physical_address>:

unsigned int kheap_physical_address(unsigned int virtual_address)
{
f0109096:	55                   	push   %ebp
f0109097:	89 e5                	mov    %esp,%ebp
f0109099:	83 ec 18             	sub    $0x18,%esp
	//return the physical address corresponding to given virtual_address
	//refer to the project presentation and documentation for details

	//EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
	uint32 *page_table;
	get_page_table(ptr_page_directory,virtual_address,&page_table);
f010909c:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f01090a1:	83 ec 04             	sub    $0x4,%esp
f01090a4:	8d 55 f4             	lea    -0xc(%ebp),%edx
f01090a7:	52                   	push   %edx
f01090a8:	ff 75 08             	pushl  0x8(%ebp)
f01090ab:	50                   	push   %eax
f01090ac:	e8 0e f4 ff ff       	call   f01084bf <get_page_table>
f01090b1:	83 c4 10             	add    $0x10,%esp


	return page_table[PTX(virtual_address)]+( virtual_address & 0xFFF);
f01090b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01090b7:	8b 55 08             	mov    0x8(%ebp),%edx
f01090ba:	c1 ea 0c             	shr    $0xc,%edx
f01090bd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01090c3:	c1 e2 02             	shl    $0x2,%edx
f01090c6:	01 d0                	add    %edx,%eax
f01090c8:	8b 00                	mov    (%eax),%eax
f01090ca:	8b 55 08             	mov    0x8(%ebp),%edx
f01090cd:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
f01090d3:	01 d0                	add    %edx,%eax
}
f01090d5:	c9                   	leave  
f01090d6:	c3                   	ret    

f01090d7 <kheap_virtual_address>:

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f01090d7:	55                   	push   %ebp
f01090d8:	89 e5                	mov    %esp,%ebp
f01090da:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #06] [1] KERNEL HEAP - kheap_virtual_address
	// Write your code here, remove the panic and write your code
	panic("kheap_virtual_address() is not implemented yet...!!");
f01090dd:	83 ec 04             	sub    $0x4,%esp
f01090e0:	68 ec 46 12 f0       	push   $0xf01246ec
f01090e5:	68 17 01 00 00       	push   $0x117
f01090ea:	68 2a 46 12 f0       	push   $0xf012462a
f01090ef:	e8 45 72 ff ff       	call   f0100339 <_panic>

f01090f4 <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *virtual_address, uint32 new_size)
{
f01090f4:	55                   	push   %ebp
f01090f5:	89 e5                	mov    %esp,%ebp
	//TODO: [PROJECT'24.MS2 - BONUS#1] [1] KERNEL HEAP - krealloc
	// Write your code here, remove the panic and write your code
	return NULL;
f01090f7:	b8 00 00 00 00       	mov    $0x0,%eax
	panic("krealloc() is not implemented yet...!!");
}
f01090fc:	5d                   	pop    %ebp
f01090fd:	c3                   	ret    

f01090fe <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f01090fe:	55                   	push   %ebp
f01090ff:	89 e5                	mov    %esp,%ebp
f0109101:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109104:	83 ec 04             	sub    $0x4,%esp
f0109107:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010910a:	50                   	push   %eax
f010910b:	ff 75 0c             	pushl  0xc(%ebp)
f010910e:	ff 75 08             	pushl  0x8(%ebp)
f0109111:	e8 a9 f3 ff ff       	call   f01084bf <get_page_table>
f0109116:	83 c4 10             	add    $0x10,%esp
f0109119:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f010911c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010911f:	85 c0                	test   %eax,%eax
f0109121:	74 64                	je     f0109187 <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f0109123:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109126:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109129:	c1 ea 0c             	shr    $0xc,%edx
f010912c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109132:	c1 e2 02             	shl    $0x2,%edx
f0109135:	01 c2                	add    %eax,%edx
f0109137:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010913a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010913d:	c1 e9 0c             	shr    $0xc,%ecx
f0109140:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109146:	c1 e1 02             	shl    $0x2,%ecx
f0109149:	01 c8                	add    %ecx,%eax
f010914b:	8b 00                	mov    (%eax),%eax
f010914d:	0b 45 10             	or     0x10(%ebp),%eax
f0109150:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0109152:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109155:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109158:	c1 ea 0c             	shr    $0xc,%edx
f010915b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109161:	c1 e2 02             	shl    $0x2,%edx
f0109164:	01 d0                	add    %edx,%eax
f0109166:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109169:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010916c:	c1 e9 0c             	shr    $0xc,%ecx
f010916f:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109175:	c1 e1 02             	shl    $0x2,%ecx
f0109178:	01 ca                	add    %ecx,%edx
f010917a:	8b 12                	mov    (%edx),%edx
f010917c:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010917f:	f7 d1                	not    %ecx
f0109181:	21 ca                	and    %ecx,%edx
f0109183:	89 10                	mov    %edx,(%eax)
f0109185:	eb 27                	jmp    f01091ae <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f0109187:	83 ec 08             	sub    $0x8,%esp
f010918a:	ff 75 0c             	pushl  0xc(%ebp)
f010918d:	68 20 47 12 f0       	push   $0xf0124720
f0109192:	e8 f4 7d ff ff       	call   f0100f8b <cprintf>
f0109197:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f010919a:	83 ec 04             	sub    $0x4,%esp
f010919d:	68 48 47 12 f0       	push   $0xf0124748
f01091a2:	6a 1c                	push   $0x1c
f01091a4:	68 bc 47 12 f0       	push   $0xf01247bc
f01091a9:	e8 8b 71 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f01091ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f01091b1:	83 ec 08             	sub    $0x8,%esp
f01091b4:	50                   	push   %eax
f01091b5:	6a 00                	push   $0x0
f01091b7:	e8 4a ec ff ff       	call   f0107e06 <tlb_invalidate>
f01091bc:	83 c4 10             	add    $0x10,%esp
}
f01091bf:	90                   	nop
f01091c0:	c9                   	leave  
f01091c1:	c3                   	ret    

f01091c2 <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f01091c2:	55                   	push   %ebp
f01091c3:	89 e5                	mov    %esp,%ebp
f01091c5:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f01091c8:	83 ec 04             	sub    $0x4,%esp
f01091cb:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01091ce:	50                   	push   %eax
f01091cf:	ff 75 0c             	pushl  0xc(%ebp)
f01091d2:	ff 75 08             	pushl  0x8(%ebp)
f01091d5:	e8 e5 f2 ff ff       	call   f01084bf <get_page_table>
f01091da:	83 c4 10             	add    $0x10,%esp
f01091dd:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f01091e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01091e3:	85 c0                	test   %eax,%eax
f01091e5:	74 1d                	je     f0109204 <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f01091e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01091ea:	8b 55 0c             	mov    0xc(%ebp),%edx
f01091ed:	c1 ea 0c             	shr    $0xc,%edx
f01091f0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01091f6:	c1 e2 02             	shl    $0x2,%edx
f01091f9:	01 d0                	add    %edx,%eax
f01091fb:	8b 00                	mov    (%eax),%eax
f01091fd:	25 ff 0f 00 00       	and    $0xfff,%eax
f0109202:	eb 05                	jmp    f0109209 <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f0109204:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f0109209:	c9                   	leave  
f010920a:	c3                   	ret    

f010920b <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f010920b:	55                   	push   %ebp
f010920c:	89 e5                	mov    %esp,%ebp
f010920e:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f0109211:	83 ec 04             	sub    $0x4,%esp
f0109214:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109217:	50                   	push   %eax
f0109218:	ff 75 0c             	pushl  0xc(%ebp)
f010921b:	ff 75 08             	pushl  0x8(%ebp)
f010921e:	e8 9c f2 ff ff       	call   f01084bf <get_page_table>
f0109223:	83 c4 10             	add    $0x10,%esp
f0109226:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109229:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010922c:	85 c0                	test   %eax,%eax
f010922e:	74 46                	je     f0109276 <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f0109230:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109233:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109236:	c1 ea 0c             	shr    $0xc,%edx
f0109239:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010923f:	c1 e2 02             	shl    $0x2,%edx
f0109242:	01 d0                	add    %edx,%eax
f0109244:	8b 00                	mov    (%eax),%eax
f0109246:	83 ec 04             	sub    $0x4,%esp
f0109249:	50                   	push   %eax
f010924a:	ff 75 0c             	pushl  0xc(%ebp)
f010924d:	68 d8 47 12 f0       	push   $0xf01247d8
f0109252:	e8 34 7d ff ff       	call   f0100f8b <cprintf>
f0109257:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f010925a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010925d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109260:	c1 ea 0c             	shr    $0xc,%edx
f0109263:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109269:	c1 e2 02             	shl    $0x2,%edx
f010926c:	01 d0                	add    %edx,%eax
f010926e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0109274:	eb 14                	jmp    f010928a <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109276:	83 ec 04             	sub    $0x4,%esp
f0109279:	68 00 48 12 f0       	push   $0xf0124800
f010927e:	6a 47                	push   $0x47
f0109280:	68 bc 47 12 f0       	push   $0xf01247bc
f0109285:	e8 af 70 ff ff       	call   f0100339 <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f010928a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010928d:	83 ec 08             	sub    $0x8,%esp
f0109290:	50                   	push   %eax
f0109291:	6a 00                	push   $0x0
f0109293:	e8 6e eb ff ff       	call   f0107e06 <tlb_invalidate>
f0109298:	83 c4 10             	add    $0x10,%esp
}
f010929b:	90                   	nop
f010929c:	c9                   	leave  
f010929d:	c3                   	ret    

f010929e <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f010929e:	55                   	push   %ebp
f010929f:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f01092a1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01092a4:	c1 e8 16             	shr    $0x16,%eax
f01092a7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01092ae:	8b 45 08             	mov    0x8(%ebp),%eax
f01092b1:	01 d0                	add    %edx,%eax
f01092b3:	8b 00                	mov    (%eax),%eax
f01092b5:	83 e0 20             	and    $0x20,%eax
f01092b8:	85 c0                	test   %eax,%eax
f01092ba:	0f 95 c0             	setne  %al
f01092bd:	0f b6 c0             	movzbl %al,%eax
}
f01092c0:	5d                   	pop    %ebp
f01092c1:	c3                   	ret    

f01092c2 <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f01092c2:	55                   	push   %ebp
f01092c3:	89 e5                	mov    %esp,%ebp
f01092c5:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f01092c8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01092cb:	c1 e8 16             	shr    $0x16,%eax
f01092ce:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01092d5:	8b 45 08             	mov    0x8(%ebp),%eax
f01092d8:	01 d0                	add    %edx,%eax
f01092da:	8b 55 0c             	mov    0xc(%ebp),%edx
f01092dd:	c1 ea 16             	shr    $0x16,%edx
f01092e0:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f01092e7:	8b 55 08             	mov    0x8(%ebp),%edx
f01092ea:	01 ca                	add    %ecx,%edx
f01092ec:	8b 12                	mov    (%edx),%edx
f01092ee:	83 e2 df             	and    $0xffffffdf,%edx
f01092f1:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f01092f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01092f6:	83 ec 08             	sub    $0x8,%esp
f01092f9:	50                   	push   %eax
f01092fa:	6a 00                	push   $0x0
f01092fc:	e8 05 eb ff ff       	call   f0107e06 <tlb_invalidate>
f0109301:	83 c4 10             	add    $0x10,%esp
}
f0109304:	90                   	nop
f0109305:	c9                   	leave  
f0109306:	c3                   	ret    

f0109307 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f0109307:	55                   	push   %ebp
f0109308:	89 e5                	mov    %esp,%ebp
f010930a:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f010930d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109310:	c1 e8 16             	shr    $0x16,%eax
f0109313:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010931a:	8b 45 08             	mov    0x8(%ebp),%eax
f010931d:	01 d0                	add    %edx,%eax
f010931f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0109325:	0f 20 d8             	mov    %cr3,%eax
f0109328:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010932b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010932e:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0109331:	90                   	nop
f0109332:	c9                   	leave  
f0109333:	c3                   	ret    

f0109334 <env_page_ws_list_create_element>:
///============================================================================================
/// Dealing with environment working set
#if USE_KHEAP

inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f0109334:	55                   	push   %ebp
f0109335:	89 e5                	mov    %esp,%ebp
f0109337:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - Create a new WS element
	//If failed to create a new one, kernel should panic()!
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("env_page_ws_list_create_element is not implemented yet");
f010933a:	83 ec 04             	sub    $0x4,%esp
f010933d:	68 78 48 12 f0       	push   $0xf0124878
f0109342:	6a 16                	push   $0x16
f0109344:	68 b0 48 12 f0       	push   $0xf01248b0
f0109349:	e8 eb 6f ff ff       	call   f0100339 <_panic>

f010934e <env_page_ws_invalidate>:
	//Your Code is Here...

}
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010934e:	55                   	push   %ebp
f010934f:	89 e5                	mov    %esp,%ebp
f0109351:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109354:	83 ec 0c             	sub    $0xc,%esp
f0109357:	6a 02                	push   $0x2
f0109359:	e8 00 54 00 00       	call   f010e75e <isPageReplacmentAlgorithmLRU>
f010935e:	83 c4 10             	add    $0x10,%esp
f0109361:	85 c0                	test   %eax,%eax
f0109363:	0f 84 e5 03 00 00    	je     f010974e <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f0109369:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f0109370:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109377:	8b 45 08             	mov    0x8(%ebp),%eax
f010937a:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f0109380:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109383:	e9 3b 02 00 00       	jmp    f01095c3 <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0109388:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010938b:	8b 00                	mov    (%eax),%eax
f010938d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109390:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109393:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109398:	89 c2                	mov    %eax,%edx
f010939a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010939d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01093a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01093a3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01093a8:	39 c2                	cmp    %eax,%edx
f01093aa:	0f 85 07 02 00 00    	jne    f01095b7 <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f01093b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01093b3:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f01093b9:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f01093bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093bf:	8b 10                	mov    (%eax),%edx
f01093c1:	8b 45 08             	mov    0x8(%ebp),%eax
f01093c4:	8b 40 64             	mov    0x64(%eax),%eax
f01093c7:	83 ec 08             	sub    $0x8,%esp
f01093ca:	52                   	push   %edx
f01093cb:	50                   	push   %eax
f01093cc:	e8 de f4 ff ff       	call   f01088af <unmap_frame>
f01093d1:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f01093d4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01093d8:	75 14                	jne    f01093ee <env_page_ws_invalidate+0xa0>
f01093da:	83 ec 04             	sub    $0x4,%esp
f01093dd:	68 cf 48 12 f0       	push   $0xf01248cf
f01093e2:	6a 27                	push   $0x27
f01093e4:	68 b0 48 12 f0       	push   $0xf01248b0
f01093e9:	e8 4b 6f ff ff       	call   f0100339 <_panic>
f01093ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093f1:	8b 40 10             	mov    0x10(%eax),%eax
f01093f4:	85 c0                	test   %eax,%eax
f01093f6:	74 11                	je     f0109409 <env_page_ws_invalidate+0xbb>
f01093f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093fb:	8b 40 10             	mov    0x10(%eax),%eax
f01093fe:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109401:	8b 52 14             	mov    0x14(%edx),%edx
f0109404:	89 50 14             	mov    %edx,0x14(%eax)
f0109407:	eb 0f                	jmp    f0109418 <env_page_ws_invalidate+0xca>
f0109409:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010940c:	8b 50 14             	mov    0x14(%eax),%edx
f010940f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109412:	89 90 58 05 00 00    	mov    %edx,0x558(%eax)
f0109418:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010941b:	8b 40 14             	mov    0x14(%eax),%eax
f010941e:	85 c0                	test   %eax,%eax
f0109420:	74 11                	je     f0109433 <env_page_ws_invalidate+0xe5>
f0109422:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109425:	8b 40 14             	mov    0x14(%eax),%eax
f0109428:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010942b:	8b 52 10             	mov    0x10(%edx),%edx
f010942e:	89 50 10             	mov    %edx,0x10(%eax)
f0109431:	eb 0f                	jmp    f0109442 <env_page_ws_invalidate+0xf4>
f0109433:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109436:	8b 50 10             	mov    0x10(%eax),%edx
f0109439:	8b 45 08             	mov    0x8(%ebp),%eax
f010943c:	89 90 54 05 00 00    	mov    %edx,0x554(%eax)
f0109442:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109445:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010944c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010944f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109456:	8b 45 08             	mov    0x8(%ebp),%eax
f0109459:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010945f:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109462:	8b 45 08             	mov    0x8(%ebp),%eax
f0109465:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f010946b:	83 ec 0c             	sub    $0xc,%esp
f010946e:	ff 75 f0             	pushl  -0x10(%ebp)
f0109471:	e8 27 fb ff ff       	call   f0108f9d <kfree>
f0109476:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f0109479:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010947d:	0f 84 2b 01 00 00    	je     f01095ae <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f0109483:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0109487:	75 14                	jne    f010949d <env_page_ws_invalidate+0x14f>
f0109489:	83 ec 04             	sub    $0x4,%esp
f010948c:	68 cf 48 12 f0       	push   $0xf01248cf
f0109491:	6a 2d                	push   $0x2d
f0109493:	68 b0 48 12 f0       	push   $0xf01248b0
f0109498:	e8 9c 6e ff ff       	call   f0100339 <_panic>
f010949d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01094a0:	8b 40 10             	mov    0x10(%eax),%eax
f01094a3:	85 c0                	test   %eax,%eax
f01094a5:	74 11                	je     f01094b8 <env_page_ws_invalidate+0x16a>
f01094a7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01094aa:	8b 40 10             	mov    0x10(%eax),%eax
f01094ad:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01094b0:	8b 52 14             	mov    0x14(%edx),%edx
f01094b3:	89 50 14             	mov    %edx,0x14(%eax)
f01094b6:	eb 0f                	jmp    f01094c7 <env_page_ws_invalidate+0x179>
f01094b8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01094bb:	8b 50 14             	mov    0x14(%eax),%edx
f01094be:	8b 45 08             	mov    0x8(%ebp),%eax
f01094c1:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f01094c7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01094ca:	8b 40 14             	mov    0x14(%eax),%eax
f01094cd:	85 c0                	test   %eax,%eax
f01094cf:	74 11                	je     f01094e2 <env_page_ws_invalidate+0x194>
f01094d1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01094d4:	8b 40 14             	mov    0x14(%eax),%eax
f01094d7:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01094da:	8b 52 10             	mov    0x10(%edx),%edx
f01094dd:	89 50 10             	mov    %edx,0x10(%eax)
f01094e0:	eb 0f                	jmp    f01094f1 <env_page_ws_invalidate+0x1a3>
f01094e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01094e5:	8b 50 10             	mov    0x10(%eax),%edx
f01094e8:	8b 45 08             	mov    0x8(%ebp),%eax
f01094eb:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f01094f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01094f4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f01094fb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01094fe:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f0109505:	8b 45 08             	mov    0x8(%ebp),%eax
f0109508:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010950e:	8d 50 ff             	lea    -0x1(%eax),%edx
f0109511:	8b 45 08             	mov    0x8(%ebp),%eax
f0109514:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f010951a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010951e:	75 14                	jne    f0109534 <env_page_ws_invalidate+0x1e6>
f0109520:	83 ec 04             	sub    $0x4,%esp
f0109523:	68 f0 48 12 f0       	push   $0xf01248f0
f0109528:	6a 2e                	push   $0x2e
f010952a:	68 b0 48 12 f0       	push   $0xf01248b0
f010952f:	e8 05 6e ff ff       	call   f0100339 <_panic>
f0109534:	8b 45 08             	mov    0x8(%ebp),%eax
f0109537:	8b 90 58 05 00 00    	mov    0x558(%eax),%edx
f010953d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109540:	89 50 14             	mov    %edx,0x14(%eax)
f0109543:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109546:	8b 40 14             	mov    0x14(%eax),%eax
f0109549:	85 c0                	test   %eax,%eax
f010954b:	74 11                	je     f010955e <env_page_ws_invalidate+0x210>
f010954d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109550:	8b 80 58 05 00 00    	mov    0x558(%eax),%eax
f0109556:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109559:	89 50 10             	mov    %edx,0x10(%eax)
f010955c:	eb 0c                	jmp    f010956a <env_page_ws_invalidate+0x21c>
f010955e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109561:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109564:	89 90 54 05 00 00    	mov    %edx,0x554(%eax)
f010956a:	8b 45 08             	mov    0x8(%ebp),%eax
f010956d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0109570:	89 90 58 05 00 00    	mov    %edx,0x558(%eax)
f0109576:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109579:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109580:	8b 45 08             	mov    0x8(%ebp),%eax
f0109583:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f0109589:	8d 50 01             	lea    0x1(%eax),%edx
f010958c:	8b 45 08             	mov    0x8(%ebp),%eax
f010958f:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f0109595:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109598:	8b 10                	mov    (%eax),%edx
f010959a:	8b 45 08             	mov    0x8(%ebp),%eax
f010959d:	8b 40 64             	mov    0x64(%eax),%eax
f01095a0:	6a 00                	push   $0x0
f01095a2:	6a 01                	push   $0x1
f01095a4:	52                   	push   %edx
f01095a5:	50                   	push   %eax
f01095a6:	e8 53 fb ff ff       	call   f01090fe <pt_set_page_permissions>
f01095ab:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f01095ae:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f01095b5:	eb 43                	jmp    f01095fa <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f01095b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01095ba:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f01095c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01095c3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01095c7:	74 08                	je     f01095d1 <env_page_ws_invalidate+0x283>
f01095c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01095cc:	8b 40 10             	mov    0x10(%eax),%eax
f01095cf:	eb 05                	jmp    f01095d6 <env_page_ws_invalidate+0x288>
f01095d1:	b8 00 00 00 00       	mov    $0x0,%eax
f01095d6:	8b 55 08             	mov    0x8(%ebp),%edx
f01095d9:	89 82 5c 05 00 00    	mov    %eax,0x55c(%edx)
f01095df:	8b 45 08             	mov    0x8(%ebp),%eax
f01095e2:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f01095e8:	85 c0                	test   %eax,%eax
f01095ea:	0f 85 98 fd ff ff    	jne    f0109388 <env_page_ws_invalidate+0x3a>
f01095f0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01095f4:	0f 85 8e fd ff ff    	jne    f0109388 <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f01095fa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01095fe:	0f 85 a4 02 00 00    	jne    f01098a8 <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f0109604:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010960b:	8b 45 08             	mov    0x8(%ebp),%eax
f010960e:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f0109614:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109617:	e9 f6 00 00 00       	jmp    f0109712 <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010961c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010961f:	8b 00                	mov    (%eax),%eax
f0109621:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0109624:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109627:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010962c:	89 c2                	mov    %eax,%edx
f010962e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109631:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0109634:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0109637:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010963c:	39 c2                	cmp    %eax,%edx
f010963e:	0f 85 c2 00 00 00    	jne    f0109706 <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f0109644:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109647:	8b 10                	mov    (%eax),%edx
f0109649:	8b 45 08             	mov    0x8(%ebp),%eax
f010964c:	8b 40 64             	mov    0x64(%eax),%eax
f010964f:	83 ec 08             	sub    $0x8,%esp
f0109652:	52                   	push   %edx
f0109653:	50                   	push   %eax
f0109654:	e8 56 f2 ff ff       	call   f01088af <unmap_frame>
f0109659:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f010965c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109660:	75 14                	jne    f0109676 <env_page_ws_invalidate+0x328>
f0109662:	83 ec 04             	sub    $0x4,%esp
f0109665:	68 cf 48 12 f0       	push   $0xf01248cf
f010966a:	6a 3e                	push   $0x3e
f010966c:	68 b0 48 12 f0       	push   $0xf01248b0
f0109671:	e8 c3 6c ff ff       	call   f0100339 <_panic>
f0109676:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109679:	8b 40 10             	mov    0x10(%eax),%eax
f010967c:	85 c0                	test   %eax,%eax
f010967e:	74 11                	je     f0109691 <env_page_ws_invalidate+0x343>
f0109680:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109683:	8b 40 10             	mov    0x10(%eax),%eax
f0109686:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109689:	8b 52 14             	mov    0x14(%edx),%edx
f010968c:	89 50 14             	mov    %edx,0x14(%eax)
f010968f:	eb 0f                	jmp    f01096a0 <env_page_ws_invalidate+0x352>
f0109691:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109694:	8b 50 14             	mov    0x14(%eax),%edx
f0109697:	8b 45 08             	mov    0x8(%ebp),%eax
f010969a:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f01096a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096a3:	8b 40 14             	mov    0x14(%eax),%eax
f01096a6:	85 c0                	test   %eax,%eax
f01096a8:	74 11                	je     f01096bb <env_page_ws_invalidate+0x36d>
f01096aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096ad:	8b 40 14             	mov    0x14(%eax),%eax
f01096b0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01096b3:	8b 52 10             	mov    0x10(%edx),%edx
f01096b6:	89 50 10             	mov    %edx,0x10(%eax)
f01096b9:	eb 0f                	jmp    f01096ca <env_page_ws_invalidate+0x37c>
f01096bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096be:	8b 50 10             	mov    0x10(%eax),%edx
f01096c1:	8b 45 08             	mov    0x8(%ebp),%eax
f01096c4:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f01096ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096cd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f01096d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096d7:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f01096de:	8b 45 08             	mov    0x8(%ebp),%eax
f01096e1:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f01096e7:	8d 50 ff             	lea    -0x1(%eax),%edx
f01096ea:	8b 45 08             	mov    0x8(%ebp),%eax
f01096ed:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)

					kfree(ptr_WS_element);
f01096f3:	83 ec 0c             	sub    $0xc,%esp
f01096f6:	ff 75 f0             	pushl  -0x10(%ebp)
f01096f9:	e8 9f f8 ff ff       	call   f0108f9d <kfree>
f01096fe:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f0109701:	e9 a2 01 00 00       	jmp    f01098a8 <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109706:	8b 45 08             	mov    0x8(%ebp),%eax
f0109709:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010970f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109712:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109716:	74 08                	je     f0109720 <env_page_ws_invalidate+0x3d2>
f0109718:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010971b:	8b 40 10             	mov    0x10(%eax),%eax
f010971e:	eb 05                	jmp    f0109725 <env_page_ws_invalidate+0x3d7>
f0109720:	b8 00 00 00 00       	mov    $0x0,%eax
f0109725:	8b 55 08             	mov    0x8(%ebp),%edx
f0109728:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f010972e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109731:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0109737:	85 c0                	test   %eax,%eax
f0109739:	0f 85 dd fe ff ff    	jne    f010961c <env_page_ws_invalidate+0x2ce>
f010973f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109743:	0f 85 d3 fe ff ff    	jne    f010961c <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f0109749:	e9 5a 01 00 00       	jmp    f01098a8 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010974e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109751:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0109757:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010975a:	e9 10 01 00 00       	jmp    f010986f <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010975f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109762:	8b 00                	mov    (%eax),%eax
f0109764:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0109767:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010976a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010976f:	89 c2                	mov    %eax,%edx
f0109771:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109774:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0109777:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010977a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010977f:	39 c2                	cmp    %eax,%edx
f0109781:	0f 85 dc 00 00 00    	jne    f0109863 <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f0109787:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010978a:	8b 10                	mov    (%eax),%edx
f010978c:	8b 45 08             	mov    0x8(%ebp),%eax
f010978f:	8b 40 64             	mov    0x64(%eax),%eax
f0109792:	83 ec 08             	sub    $0x8,%esp
f0109795:	52                   	push   %edx
f0109796:	50                   	push   %eax
f0109797:	e8 13 f1 ff ff       	call   f01088af <unmap_frame>
f010979c:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f010979f:	8b 45 08             	mov    0x8(%ebp),%eax
f01097a2:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f01097a8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01097ab:	75 0f                	jne    f01097bc <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f01097ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01097b0:	8b 50 10             	mov    0x10(%eax),%edx
f01097b3:	8b 45 08             	mov    0x8(%ebp),%eax
f01097b6:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f01097bc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01097c0:	75 14                	jne    f01097d6 <env_page_ws_invalidate+0x488>
f01097c2:	83 ec 04             	sub    $0x4,%esp
f01097c5:	68 cf 48 12 f0       	push   $0xf01248cf
f01097ca:	6a 54                	push   $0x54
f01097cc:	68 b0 48 12 f0       	push   $0xf01248b0
f01097d1:	e8 63 6b ff ff       	call   f0100339 <_panic>
f01097d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01097d9:	8b 40 10             	mov    0x10(%eax),%eax
f01097dc:	85 c0                	test   %eax,%eax
f01097de:	74 11                	je     f01097f1 <env_page_ws_invalidate+0x4a3>
f01097e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01097e3:	8b 40 10             	mov    0x10(%eax),%eax
f01097e6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01097e9:	8b 52 14             	mov    0x14(%edx),%edx
f01097ec:	89 50 14             	mov    %edx,0x14(%eax)
f01097ef:	eb 0f                	jmp    f0109800 <env_page_ws_invalidate+0x4b2>
f01097f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01097f4:	8b 50 14             	mov    0x14(%eax),%edx
f01097f7:	8b 45 08             	mov    0x8(%ebp),%eax
f01097fa:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f0109800:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109803:	8b 40 14             	mov    0x14(%eax),%eax
f0109806:	85 c0                	test   %eax,%eax
f0109808:	74 11                	je     f010981b <env_page_ws_invalidate+0x4cd>
f010980a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010980d:	8b 40 14             	mov    0x14(%eax),%eax
f0109810:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0109813:	8b 52 10             	mov    0x10(%edx),%edx
f0109816:	89 50 10             	mov    %edx,0x10(%eax)
f0109819:	eb 0f                	jmp    f010982a <env_page_ws_invalidate+0x4dc>
f010981b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010981e:	8b 50 10             	mov    0x10(%eax),%edx
f0109821:	8b 45 08             	mov    0x8(%ebp),%eax
f0109824:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010982a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010982d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f0109834:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109837:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010983e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109841:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0109847:	8d 50 ff             	lea    -0x1(%eax),%edx
f010984a:	8b 45 08             	mov    0x8(%ebp),%eax
f010984d:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)

				kfree(wse);
f0109853:	83 ec 0c             	sub    $0xc,%esp
f0109856:	ff 75 ec             	pushl  -0x14(%ebp)
f0109859:	e8 3f f7 ff ff       	call   f0108f9d <kfree>
f010985e:	83 c4 10             	add    $0x10,%esp

				break;
f0109861:	eb 45                	jmp    f01098a8 <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109863:	8b 45 08             	mov    0x8(%ebp),%eax
f0109866:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010986c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010986f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109873:	74 08                	je     f010987d <env_page_ws_invalidate+0x52f>
f0109875:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109878:	8b 40 10             	mov    0x10(%eax),%eax
f010987b:	eb 05                	jmp    f0109882 <env_page_ws_invalidate+0x534>
f010987d:	b8 00 00 00 00       	mov    $0x0,%eax
f0109882:	8b 55 08             	mov    0x8(%ebp),%edx
f0109885:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f010988b:	8b 45 08             	mov    0x8(%ebp),%eax
f010988e:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0109894:	85 c0                	test   %eax,%eax
f0109896:	0f 85 c3 fe ff ff    	jne    f010975f <env_page_ws_invalidate+0x411>
f010989c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01098a0:	0f 85 b9 fe ff ff    	jne    f010975f <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f01098a6:	eb 00                	jmp    f01098a8 <env_page_ws_invalidate+0x55a>
f01098a8:	90                   	nop
f01098a9:	c9                   	leave  
f01098aa:	c3                   	ret    

f01098ab <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f01098ab:	55                   	push   %ebp
f01098ac:	89 e5                	mov    %esp,%ebp
f01098ae:	53                   	push   %ebx
f01098af:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f01098b2:	83 ec 0c             	sub    $0xc,%esp
f01098b5:	6a 02                	push   $0x2
f01098b7:	e8 a2 4e 00 00       	call   f010e75e <isPageReplacmentAlgorithmLRU>
f01098bc:	83 c4 10             	add    $0x10,%esp
f01098bf:	85 c0                	test   %eax,%eax
f01098c1:	0f 84 fe 00 00 00    	je     f01099c5 <env_page_ws_print+0x11a>
	{
		int i = 0;
f01098c7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f01098ce:	83 ec 0c             	sub    $0xc,%esp
f01098d1:	68 13 49 12 f0       	push   $0xf0124913
f01098d6:	e8 b0 76 ff ff       	call   f0100f8b <cprintf>
f01098db:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f01098de:	8b 45 08             	mov    0x8(%ebp),%eax
f01098e1:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f01098e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01098ea:	eb 2c                	jmp    f0109918 <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f01098ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01098ef:	8b 10                	mov    (%eax),%edx
f01098f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01098f4:	8d 48 01             	lea    0x1(%eax),%ecx
f01098f7:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f01098fa:	83 ec 04             	sub    $0x4,%esp
f01098fd:	52                   	push   %edx
f01098fe:	50                   	push   %eax
f01098ff:	68 2d 49 12 f0       	push   $0xf012492d
f0109904:	e8 82 76 ff ff       	call   f0100f8b <cprintf>
f0109909:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010990c:	8b 45 08             	mov    0x8(%ebp),%eax
f010990f:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f0109915:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109918:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010991c:	74 08                	je     f0109926 <env_page_ws_print+0x7b>
f010991e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109921:	8b 40 10             	mov    0x10(%eax),%eax
f0109924:	eb 05                	jmp    f010992b <env_page_ws_print+0x80>
f0109926:	b8 00 00 00 00       	mov    $0x0,%eax
f010992b:	8b 55 08             	mov    0x8(%ebp),%edx
f010992e:	89 82 5c 05 00 00    	mov    %eax,0x55c(%edx)
f0109934:	8b 45 08             	mov    0x8(%ebp),%eax
f0109937:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010993d:	85 c0                	test   %eax,%eax
f010993f:	75 ab                	jne    f01098ec <env_page_ws_print+0x41>
f0109941:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109945:	75 a5                	jne    f01098ec <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f0109947:	83 ec 0c             	sub    $0xc,%esp
f010994a:	68 35 49 12 f0       	push   $0xf0124935
f010994f:	e8 37 76 ff ff       	call   f0100f8b <cprintf>
f0109954:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109957:	8b 45 08             	mov    0x8(%ebp),%eax
f010995a:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f0109960:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109963:	eb 2c                	jmp    f0109991 <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f0109965:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109968:	8b 10                	mov    (%eax),%edx
f010996a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010996d:	8d 48 01             	lea    0x1(%eax),%ecx
f0109970:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0109973:	83 ec 04             	sub    $0x4,%esp
f0109976:	52                   	push   %edx
f0109977:	50                   	push   %eax
f0109978:	68 2d 49 12 f0       	push   $0xf012492d
f010997d:	e8 09 76 ff ff       	call   f0100f8b <cprintf>
f0109982:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0109985:	8b 45 08             	mov    0x8(%ebp),%eax
f0109988:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010998e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109991:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109995:	74 08                	je     f010999f <env_page_ws_print+0xf4>
f0109997:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010999a:	8b 40 10             	mov    0x10(%eax),%eax
f010999d:	eb 05                	jmp    f01099a4 <env_page_ws_print+0xf9>
f010999f:	b8 00 00 00 00       	mov    $0x0,%eax
f01099a4:	8b 55 08             	mov    0x8(%ebp),%edx
f01099a7:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f01099ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01099b0:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f01099b6:	85 c0                	test   %eax,%eax
f01099b8:	75 ab                	jne    f0109965 <env_page_ws_print+0xba>
f01099ba:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01099be:	75 a5                	jne    f0109965 <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f01099c0:	e9 5a 01 00 00       	jmp    f0109b1f <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f01099c5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f01099cc:	83 ec 0c             	sub    $0xc,%esp
f01099cf:	68 50 49 12 f0       	push   $0xf0124950
f01099d4:	e8 b2 75 ff ff       	call   f0100f8b <cprintf>
f01099d9:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f01099dc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f01099e3:	8b 45 08             	mov    0x8(%ebp),%eax
f01099e6:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01099ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01099ef:	e9 d1 00 00 00       	jmp    f0109ac5 <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f01099f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01099f7:	8b 00                	mov    (%eax),%eax
f01099f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f01099fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01099ff:	8b 40 08             	mov    0x8(%eax),%eax
f0109a02:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f0109a05:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a08:	8b 40 64             	mov    0x64(%eax),%eax
f0109a0b:	83 ec 08             	sub    $0x8,%esp
f0109a0e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109a11:	50                   	push   %eax
f0109a12:	e8 ab f7 ff ff       	call   f01091c2 <pt_get_page_permissions>
f0109a17:	83 c4 10             	add    $0x10,%esp
f0109a1a:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f0109a1d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109a20:	83 e0 40             	and    $0x40,%eax
f0109a23:	85 c0                	test   %eax,%eax
f0109a25:	0f 95 c0             	setne  %al
f0109a28:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f0109a2b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109a2e:	83 e0 20             	and    $0x20,%eax
f0109a31:	85 c0                	test   %eax,%eax
f0109a33:	0f 95 c0             	setne  %al
f0109a36:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f0109a39:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109a3c:	25 00 02 00 00       	and    $0x200,%eax
f0109a41:	85 c0                	test   %eax,%eax
f0109a43:	0f 95 c0             	setne  %al
f0109a46:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f0109a49:	83 ec 04             	sub    $0x4,%esp
f0109a4c:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109a4f:	ff 75 ec             	pushl  -0x14(%ebp)
f0109a52:	68 5a 49 12 f0       	push   $0xf012495a
f0109a57:	e8 2f 75 ff ff       	call   f0100f8b <cprintf>
f0109a5c:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f0109a5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109a62:	8b 58 0c             	mov    0xc(%eax),%ebx
f0109a65:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f0109a69:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f0109a6d:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f0109a71:	83 ec 08             	sub    $0x8,%esp
f0109a74:	53                   	push   %ebx
f0109a75:	ff 75 e0             	pushl  -0x20(%ebp)
f0109a78:	51                   	push   %ecx
f0109a79:	52                   	push   %edx
f0109a7a:	50                   	push   %eax
f0109a7b:	68 64 49 12 f0       	push   $0xf0124964
f0109a80:	e8 06 75 ff ff       	call   f0100f8b <cprintf>
f0109a85:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f0109a88:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a8b:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f0109a91:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0109a94:	75 10                	jne    f0109aa6 <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f0109a96:	83 ec 0c             	sub    $0xc,%esp
f0109a99:	68 ab 49 12 f0       	push   $0xf01249ab
f0109a9e:	e8 e8 74 ff ff       	call   f0100f8b <cprintf>
f0109aa3:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0109aa6:	83 ec 0c             	sub    $0xc,%esp
f0109aa9:	68 b0 49 12 f0       	push   $0xf01249b0
f0109aae:	e8 d8 74 ff ff       	call   f0100f8b <cprintf>
f0109ab3:	83 c4 10             	add    $0x10,%esp
			i++;
f0109ab6:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f0109ab9:	8b 45 08             	mov    0x8(%ebp),%eax
f0109abc:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0109ac2:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109ac5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0109ac9:	74 08                	je     f0109ad3 <env_page_ws_print+0x228>
f0109acb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109ace:	8b 40 10             	mov    0x10(%eax),%eax
f0109ad1:	eb 05                	jmp    f0109ad8 <env_page_ws_print+0x22d>
f0109ad3:	b8 00 00 00 00       	mov    $0x0,%eax
f0109ad8:	8b 55 08             	mov    0x8(%ebp),%edx
f0109adb:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f0109ae1:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ae4:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0109aea:	85 c0                	test   %eax,%eax
f0109aec:	0f 85 02 ff ff ff    	jne    f01099f4 <env_page_ws_print+0x149>
f0109af2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0109af6:	0f 85 f8 fe ff ff    	jne    f01099f4 <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f0109afc:	eb 13                	jmp    f0109b11 <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f0109afe:	83 ec 0c             	sub    $0xc,%esp
f0109b01:	68 b2 49 12 f0       	push   $0xf01249b2
f0109b06:	e8 80 74 ff ff       	call   f0100f8b <cprintf>
f0109b0b:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f0109b0e:	ff 45 ec             	incl   -0x14(%ebp)
f0109b11:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b14:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0109b1a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0109b1d:	77 df                	ja     f0109afe <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f0109b1f:	90                   	nop
f0109b20:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109b23:	c9                   	leave  
f0109b24:	c3                   	ret    

f0109b25 <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f0109b25:	55                   	push   %ebp
f0109b26:	89 e5                	mov    %esp,%ebp
f0109b28:	53                   	push   %ebx
f0109b29:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f0109b2c:	83 ec 0c             	sub    $0xc,%esp
f0109b2f:	68 c4 49 12 f0       	push   $0xf01249c4
f0109b34:	e8 52 74 ff ff       	call   f0100f8b <cprintf>
f0109b39:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f0109b3c:	83 ec 0c             	sub    $0xc,%esp
f0109b3f:	68 f9 49 12 f0       	push   $0xf01249f9
f0109b44:	e8 42 74 ff ff       	call   f0100f8b <cprintf>
f0109b49:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f0109b4c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0109b53:	e9 16 01 00 00       	jmp    f0109c6e <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f0109b58:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109b5b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109b5e:	89 d0                	mov    %edx,%eax
f0109b60:	01 c0                	add    %eax,%eax
f0109b62:	01 d0                	add    %edx,%eax
f0109b64:	c1 e0 03             	shl    $0x3,%eax
f0109b67:	01 c8                	add    %ecx,%eax
f0109b69:	05 a4 00 00 00       	add    $0xa4,%eax
f0109b6e:	8a 00                	mov    (%eax),%al
f0109b70:	84 c0                	test   %al,%al
f0109b72:	74 43                	je     f0109bb7 <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f0109b74:	83 ec 0c             	sub    $0xc,%esp
f0109b77:	68 04 4a 12 f0       	push   $0xf0124a04
f0109b7c:	e8 0a 74 ff ff       	call   f0100f8b <cprintf>
f0109b81:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f0109b84:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b87:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
f0109b8d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0109b90:	75 10                	jne    f0109ba2 <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f0109b92:	83 ec 0c             	sub    $0xc,%esp
f0109b95:	68 13 4a 12 f0       	push   $0xf0124a13
f0109b9a:	e8 ec 73 ff ff       	call   f0100f8b <cprintf>
f0109b9f:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0109ba2:	83 ec 0c             	sub    $0xc,%esp
f0109ba5:	68 b0 49 12 f0       	push   $0xf01249b0
f0109baa:	e8 dc 73 ff ff       	call   f0100f8b <cprintf>
f0109baf:	83 c4 10             	add    $0x10,%esp
			continue;
f0109bb2:	e9 b4 00 00 00       	jmp    f0109c6b <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f0109bb7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109bba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109bbd:	89 d0                	mov    %edx,%eax
f0109bbf:	01 c0                	add    %eax,%eax
f0109bc1:	01 d0                	add    %edx,%eax
f0109bc3:	c1 e0 03             	shl    $0x3,%eax
f0109bc6:	01 c8                	add    %ecx,%eax
f0109bc8:	05 a0 00 00 00       	add    $0xa0,%eax
f0109bcd:	8b 00                	mov    (%eax),%eax
f0109bcf:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f0109bd2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109bd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109bd8:	89 d0                	mov    %edx,%eax
f0109bda:	01 c0                	add    %eax,%eax
f0109bdc:	01 d0                	add    %edx,%eax
f0109bde:	c1 e0 03             	shl    $0x3,%eax
f0109be1:	01 c8                	add    %ecx,%eax
f0109be3:	05 a0 00 00 00       	add    $0xa0,%eax
f0109be8:	8b 00                	mov    (%eax),%eax
f0109bea:	83 ec 04             	sub    $0x4,%esp
f0109bed:	50                   	push   %eax
f0109bee:	ff 75 f4             	pushl  -0xc(%ebp)
f0109bf1:	68 19 4a 12 f0       	push   $0xf0124a19
f0109bf6:	e8 90 73 ff ff       	call   f0100f8b <cprintf>
f0109bfb:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f0109bfe:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109c01:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109c04:	89 d0                	mov    %edx,%eax
f0109c06:	01 c0                	add    %eax,%eax
f0109c08:	01 d0                	add    %edx,%eax
f0109c0a:	c1 e0 03             	shl    $0x3,%eax
f0109c0d:	01 c8                	add    %ecx,%eax
f0109c0f:	05 a8 00 00 00       	add    $0xa8,%eax
f0109c14:	8b 18                	mov    (%eax),%ebx
f0109c16:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c19:	8b 40 64             	mov    0x64(%eax),%eax
f0109c1c:	83 ec 08             	sub    $0x8,%esp
f0109c1f:	ff 75 f0             	pushl  -0x10(%ebp)
f0109c22:	50                   	push   %eax
f0109c23:	e8 76 f6 ff ff       	call   f010929e <pd_is_table_used>
f0109c28:	83 c4 10             	add    $0x10,%esp
f0109c2b:	83 ec 04             	sub    $0x4,%esp
f0109c2e:	53                   	push   %ebx
f0109c2f:	50                   	push   %eax
f0109c30:	68 30 4a 12 f0       	push   $0xf0124a30
f0109c35:	e8 51 73 ff ff       	call   f0100f8b <cprintf>
f0109c3a:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f0109c3d:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c40:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
f0109c46:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0109c49:	75 10                	jne    f0109c5b <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f0109c4b:	83 ec 0c             	sub    $0xc,%esp
f0109c4e:	68 ab 49 12 f0       	push   $0xf01249ab
f0109c53:	e8 33 73 ff ff       	call   f0100f8b <cprintf>
f0109c58:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f0109c5b:	83 ec 0c             	sub    $0xc,%esp
f0109c5e:	68 b0 49 12 f0       	push   $0xf01249b0
f0109c63:	e8 23 73 ff ff       	call   f0100f8b <cprintf>
f0109c68:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f0109c6b:	ff 45 f4             	incl   -0xc(%ebp)
f0109c6e:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f0109c72:	0f 86 e0 fe ff ff    	jbe    f0109b58 <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f0109c78:	90                   	nop
f0109c79:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109c7c:	c9                   	leave  
f0109c7d:	c3                   	ret    

f0109c7e <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f0109c7e:	55                   	push   %ebp
f0109c7f:	89 e5                	mov    %esp,%ebp
f0109c81:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f0109c84:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0109c8b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f0109c92:	eb 22                	jmp    f0109cb6 <env_table_ws_get_size+0x38>
f0109c94:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109c97:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0109c9a:	89 d0                	mov    %edx,%eax
f0109c9c:	01 c0                	add    %eax,%eax
f0109c9e:	01 d0                	add    %edx,%eax
f0109ca0:	c1 e0 03             	shl    $0x3,%eax
f0109ca3:	01 c8                	add    %ecx,%eax
f0109ca5:	05 a4 00 00 00       	add    $0xa4,%eax
f0109caa:	8a 00                	mov    (%eax),%al
f0109cac:	84 c0                	test   %al,%al
f0109cae:	75 03                	jne    f0109cb3 <env_table_ws_get_size+0x35>
f0109cb0:	ff 45 f8             	incl   -0x8(%ebp)
f0109cb3:	ff 45 fc             	incl   -0x4(%ebp)
f0109cb6:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f0109cba:	7e d8                	jle    f0109c94 <env_table_ws_get_size+0x16>
	return counter;
f0109cbc:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0109cbf:	c9                   	leave  
f0109cc0:	c3                   	ret    

f0109cc1 <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0109cc1:	55                   	push   %ebp
f0109cc2:	89 e5                	mov    %esp,%ebp
f0109cc4:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f0109cc7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f0109cce:	eb 4e                	jmp    f0109d1e <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f0109cd0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109cd3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109cd6:	89 d0                	mov    %edx,%eax
f0109cd8:	01 c0                	add    %eax,%eax
f0109cda:	01 d0                	add    %edx,%eax
f0109cdc:	c1 e0 03             	shl    $0x3,%eax
f0109cdf:	01 c8                	add    %ecx,%eax
f0109ce1:	05 a0 00 00 00       	add    $0xa0,%eax
f0109ce6:	8b 00                	mov    (%eax),%eax
f0109ce8:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109ceb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109cee:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f0109cf3:	89 c2                	mov    %eax,%edx
f0109cf5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109cf8:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109cfb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109cfe:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f0109d03:	39 c2                	cmp    %eax,%edx
f0109d05:	75 14                	jne    f0109d1b <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f0109d07:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109d0a:	83 ec 08             	sub    $0x8,%esp
f0109d0d:	50                   	push   %eax
f0109d0e:	ff 75 08             	pushl  0x8(%ebp)
f0109d11:	e8 bc 00 00 00       	call   f0109dd2 <env_table_ws_clear_entry>
f0109d16:	83 c4 10             	add    $0x10,%esp
			break;
f0109d19:	eb 09                	jmp    f0109d24 <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f0109d1b:	ff 45 f4             	incl   -0xc(%ebp)
f0109d1e:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f0109d22:	7e ac                	jle    f0109cd0 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f0109d24:	90                   	nop
f0109d25:	c9                   	leave  
f0109d26:	c3                   	ret    

f0109d27 <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f0109d27:	55                   	push   %ebp
f0109d28:	89 e5                	mov    %esp,%ebp
f0109d2a:	53                   	push   %ebx
f0109d2b:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0109d2e:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109d32:	76 19                	jbe    f0109d4d <env_table_ws_set_entry+0x26>
f0109d34:	68 54 4a 12 f0       	push   $0xf0124a54
f0109d39:	68 85 4a 12 f0       	push   $0xf0124a85
f0109d3e:	68 37 01 00 00       	push   $0x137
f0109d43:	68 b0 48 12 f0       	push   $0xf01248b0
f0109d48:	e8 ec 65 ff ff       	call   f0100339 <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f0109d4d:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0109d54:	76 19                	jbe    f0109d6f <env_table_ws_set_entry+0x48>
f0109d56:	68 9c 4a 12 f0       	push   $0xf0124a9c
f0109d5b:	68 85 4a 12 f0       	push   $0xf0124a85
f0109d60:	68 38 01 00 00       	push   $0x138
f0109d65:	68 b0 48 12 f0       	push   $0xf01248b0
f0109d6a:	e8 ca 65 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f0109d6f:	8b 45 10             	mov    0x10(%ebp),%eax
f0109d72:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109d75:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109d78:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f0109d7d:	89 c1                	mov    %eax,%ecx
f0109d7f:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0109d82:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d85:	89 d0                	mov    %edx,%eax
f0109d87:	01 c0                	add    %eax,%eax
f0109d89:	01 d0                	add    %edx,%eax
f0109d8b:	c1 e0 03             	shl    $0x3,%eax
f0109d8e:	01 d8                	add    %ebx,%eax
f0109d90:	05 a0 00 00 00       	add    $0xa0,%eax
f0109d95:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f0109d97:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109d9a:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d9d:	89 d0                	mov    %edx,%eax
f0109d9f:	01 c0                	add    %eax,%eax
f0109da1:	01 d0                	add    %edx,%eax
f0109da3:	c1 e0 03             	shl    $0x3,%eax
f0109da6:	01 c8                	add    %ecx,%eax
f0109da8:	05 a4 00 00 00       	add    $0xa4,%eax
f0109dad:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f0109db0:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109db3:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109db6:	89 d0                	mov    %edx,%eax
f0109db8:	01 c0                	add    %eax,%eax
f0109dba:	01 d0                	add    %edx,%eax
f0109dbc:	c1 e0 03             	shl    $0x3,%eax
f0109dbf:	01 c8                	add    %ecx,%eax
f0109dc1:	05 a8 00 00 00       	add    $0xa8,%eax
f0109dc6:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f0109dcc:	90                   	nop
}
f0109dcd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109dd0:	c9                   	leave  
f0109dd1:	c3                   	ret    

f0109dd2 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f0109dd2:	55                   	push   %ebp
f0109dd3:	89 e5                	mov    %esp,%ebp
f0109dd5:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0109dd8:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109ddc:	76 19                	jbe    f0109df7 <env_table_ws_clear_entry+0x25>
f0109dde:	68 54 4a 12 f0       	push   $0xf0124a54
f0109de3:	68 85 4a 12 f0       	push   $0xf0124a85
f0109de8:	68 43 01 00 00       	push   $0x143
f0109ded:	68 b0 48 12 f0       	push   $0xf01248b0
f0109df2:	e8 42 65 ff ff       	call   f0100339 <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f0109df7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109dfa:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109dfd:	89 d0                	mov    %edx,%eax
f0109dff:	01 c0                	add    %eax,%eax
f0109e01:	01 d0                	add    %edx,%eax
f0109e03:	c1 e0 03             	shl    $0x3,%eax
f0109e06:	01 c8                	add    %ecx,%eax
f0109e08:	05 a0 00 00 00       	add    $0xa0,%eax
f0109e0d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f0109e13:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109e16:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109e19:	89 d0                	mov    %edx,%eax
f0109e1b:	01 c0                	add    %eax,%eax
f0109e1d:	01 d0                	add    %edx,%eax
f0109e1f:	c1 e0 03             	shl    $0x3,%eax
f0109e22:	01 c8                	add    %ecx,%eax
f0109e24:	05 a4 00 00 00       	add    $0xa4,%eax
f0109e29:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f0109e2c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109e2f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109e32:	89 d0                	mov    %edx,%eax
f0109e34:	01 c0                	add    %eax,%eax
f0109e36:	01 d0                	add    %edx,%eax
f0109e38:	c1 e0 03             	shl    $0x3,%eax
f0109e3b:	01 c8                	add    %ecx,%eax
f0109e3d:	05 a8 00 00 00       	add    $0xa8,%eax
f0109e42:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f0109e48:	90                   	nop
f0109e49:	c9                   	leave  
f0109e4a:	c3                   	ret    

f0109e4b <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f0109e4b:	55                   	push   %ebp
f0109e4c:	89 e5                	mov    %esp,%ebp
f0109e4e:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0109e51:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109e55:	76 19                	jbe    f0109e70 <env_table_ws_get_virtual_address+0x25>
f0109e57:	68 54 4a 12 f0       	push   $0xf0124a54
f0109e5c:	68 85 4a 12 f0       	push   $0xf0124a85
f0109e61:	68 4b 01 00 00       	push   $0x14b
f0109e66:	68 b0 48 12 f0       	push   $0xf01248b0
f0109e6b:	e8 c9 64 ff ff       	call   f0100339 <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f0109e70:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109e73:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109e76:	89 d0                	mov    %edx,%eax
f0109e78:	01 c0                	add    %eax,%eax
f0109e7a:	01 d0                	add    %edx,%eax
f0109e7c:	c1 e0 03             	shl    $0x3,%eax
f0109e7f:	01 c8                	add    %ecx,%eax
f0109e81:	05 a0 00 00 00       	add    $0xa0,%eax
f0109e86:	8b 00                	mov    (%eax),%eax
f0109e88:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109e8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109e8e:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f0109e93:	c9                   	leave  
f0109e94:	c3                   	ret    

f0109e95 <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f0109e95:	55                   	push   %ebp
f0109e96:	89 e5                	mov    %esp,%ebp
f0109e98:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f0109e9b:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109e9f:	76 19                	jbe    f0109eba <env_table_ws_get_time_stamp+0x25>
f0109ea1:	68 54 4a 12 f0       	push   $0xf0124a54
f0109ea6:	68 85 4a 12 f0       	push   $0xf0124a85
f0109eab:	68 52 01 00 00       	push   $0x152
f0109eb0:	68 b0 48 12 f0       	push   $0xf01248b0
f0109eb5:	e8 7f 64 ff ff       	call   f0100339 <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f0109eba:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109ebd:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109ec0:	89 d0                	mov    %edx,%eax
f0109ec2:	01 c0                	add    %eax,%eax
f0109ec4:	01 d0                	add    %edx,%eax
f0109ec6:	c1 e0 03             	shl    $0x3,%eax
f0109ec9:	01 c8                	add    %ecx,%eax
f0109ecb:	05 a8 00 00 00       	add    $0xa8,%eax
f0109ed0:	8b 00                	mov    (%eax),%eax
}
f0109ed2:	c9                   	leave  
f0109ed3:	c3                   	ret    

f0109ed4 <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f0109ed4:	55                   	push   %ebp
f0109ed5:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f0109ed7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109eda:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109edd:	89 d0                	mov    %edx,%eax
f0109edf:	01 c0                	add    %eax,%eax
f0109ee1:	01 d0                	add    %edx,%eax
f0109ee3:	c1 e0 03             	shl    $0x3,%eax
f0109ee6:	01 c8                	add    %ecx,%eax
f0109ee8:	05 a4 00 00 00       	add    $0xa4,%eax
f0109eed:	8a 00                	mov    (%eax),%al
f0109eef:	0f b6 c0             	movzbl %al,%eax
}
f0109ef2:	5d                   	pop    %ebp
f0109ef3:	c3                   	ret    

f0109ef4 <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f0109ef4:	55                   	push   %ebp
f0109ef5:	89 e5                	mov    %esp,%ebp
f0109ef7:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f0109efa:	83 ec 04             	sub    $0x4,%esp
f0109efd:	68 cf 4a 12 f0       	push   $0xf0124acf
f0109f02:	68 62 01 00 00       	push   $0x162
f0109f07:	68 b0 48 12 f0       	push   $0xf01248b0
f0109f0c:	e8 28 64 ff ff       	call   f0100339 <_panic>

f0109f11 <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f0109f11:	55                   	push   %ebp
f0109f12:	89 e5                	mov    %esp,%ebp
f0109f14:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f0109f17:	83 ec 04             	sub    $0x4,%esp
f0109f1a:	68 cf 4a 12 f0       	push   $0xf0124acf
f0109f1f:	68 67 01 00 00       	push   $0x167
f0109f24:	68 b0 48 12 f0       	push   $0xf01248b0
f0109f29:	e8 0b 64 ff ff       	call   f0100339 <_panic>

f0109f2e <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f0109f2e:	55                   	push   %ebp
f0109f2f:	89 e5                	mov    %esp,%ebp
f0109f31:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f0109f34:	83 ec 04             	sub    $0x4,%esp
f0109f37:	68 e0 4a 12 f0       	push   $0xf0124ae0
f0109f3c:	6a 21                	push   $0x21
f0109f3e:	68 0e 4b 12 f0       	push   $0xf0124b0e
f0109f43:	e8 f1 63 ff ff       	call   f0100339 <_panic>

f0109f48 <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f0109f48:	55                   	push   %ebp
f0109f49:	89 e5                	mov    %esp,%ebp
f0109f4b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f0109f4e:	83 ec 04             	sub    $0x4,%esp
f0109f51:	68 2c 4b 12 f0       	push   $0xf0124b2c
f0109f56:	6a 34                	push   $0x34
f0109f58:	68 0e 4b 12 f0       	push   $0xf0124b0e
f0109f5d:	e8 d7 63 ff ff       	call   f0100339 <_panic>

f0109f62 <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f0109f62:	55                   	push   %ebp
f0109f63:	89 e5                	mov    %esp,%ebp
f0109f65:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f0109f68:	83 ec 04             	sub    $0x4,%esp
f0109f6b:	68 5c 4b 12 f0       	push   $0xf0124b5c
f0109f70:	6a 44                	push   $0x44
f0109f72:	68 0e 4b 12 f0       	push   $0xf0124b0e
f0109f77:	e8 bd 63 ff ff       	call   f0100339 <_panic>

f0109f7c <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f0109f7c:	55                   	push   %ebp
f0109f7d:	89 e5                	mov    %esp,%ebp
f0109f7f:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f0109f82:	83 ec 04             	sub    $0x4,%esp
f0109f85:	68 88 4b 12 f0       	push   $0xf0124b88
f0109f8a:	6a 52                	push   $0x52
f0109f8c:	68 0e 4b 12 f0       	push   $0xf0124b0e
f0109f91:	e8 a3 63 ff ff       	call   f0100339 <_panic>

f0109f96 <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f0109f96:	55                   	push   %ebp
f0109f97:	89 e5                	mov    %esp,%ebp
f0109f99:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f0109f9c:	83 ec 04             	sub    $0x4,%esp
f0109f9f:	68 b8 4b 12 f0       	push   $0xf0124bb8
f0109fa4:	6a 5c                	push   $0x5c
f0109fa6:	68 0e 4b 12 f0       	push   $0xf0124b0e
f0109fab:	e8 89 63 ff ff       	call   f0100339 <_panic>

f0109fb0 <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f0109fb0:	55                   	push   %ebp
f0109fb1:	89 e5                	mov    %esp,%ebp
f0109fb3:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f0109fb6:	83 ec 04             	sub    $0x4,%esp
f0109fb9:	68 f0 4b 12 f0       	push   $0xf0124bf0
f0109fbe:	6a 69                	push   $0x69
f0109fc0:	68 0e 4b 12 f0       	push   $0xf0124b0e
f0109fc5:	e8 6f 63 ff ff       	call   f0100339 <_panic>

f0109fca <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f0109fca:	55                   	push   %ebp
f0109fcb:	89 e5                	mov    %esp,%ebp
	 */

	//TODO: [PROJECT'24.MS2 - #11] [3] USER HEAP - sys_sbrk
	/*====================================*/
	/*Remove this line before start coding*/
	return (void*)-1 ;
f0109fcd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	/*====================================*/
	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit


}
f0109fd2:	5d                   	pop    %ebp
f0109fd3:	c3                   	ret    

f0109fd4 <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f0109fd4:	55                   	push   %ebp
f0109fd5:	89 e5                	mov    %esp,%ebp
f0109fd7:	83 ec 08             	sub    $0x8,%esp
//	return;
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #13] [3] USER HEAP [KERNEL SIDE] - allocate_user_mem()
	// Write your code here, remove the panic and write your code
	panic("allocate_user_mem() is not implemented yet...!!");
f0109fda:	83 ec 04             	sub    $0x4,%esp
f0109fdd:	68 28 4c 12 f0       	push   $0xf0124c28
f0109fe2:	68 a2 00 00 00       	push   $0xa2
f0109fe7:	68 0e 4b 12 f0       	push   $0xf0124b0e
f0109fec:	e8 48 63 ff ff       	call   f0100339 <_panic>

f0109ff1 <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f0109ff1:	55                   	push   %ebp
f0109ff2:	89 e5                	mov    %esp,%ebp
f0109ff4:	83 ec 08             	sub    $0x8,%esp
//	return;
	/*====================================*/

	//TODO: [PROJECT'24.MS2 - #15] [3] USER HEAP [KERNEL SIDE] - free_user_mem
	// Write your code here, remove the panic and write your code
	panic("free_user_mem() is not implemented yet...!!");
f0109ff7:	83 ec 04             	sub    $0x4,%esp
f0109ffa:	68 58 4c 12 f0       	push   $0xf0124c58
f0109fff:	68 b2 00 00 00       	push   $0xb2
f010a004:	68 0e 4b 12 f0       	push   $0xf0124b0e
f010a009:	e8 2b 63 ff ff       	call   f0100339 <_panic>

f010a00e <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010a00e:	55                   	push   %ebp
f010a00f:	89 e5                	mov    %esp,%ebp
f010a011:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010a014:	83 ec 04             	sub    $0x4,%esp
f010a017:	68 84 4c 12 f0       	push   $0xf0124c84
f010a01c:	68 be 00 00 00       	push   $0xbe
f010a021:	68 0e 4b 12 f0       	push   $0xf0124b0e
f010a026:	e8 0e 63 ff ff       	call   f0100339 <_panic>

f010a02b <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010a02b:	55                   	push   %ebp
f010a02c:	89 e5                	mov    %esp,%ebp
f010a02e:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f010a031:	83 ec 04             	sub    $0x4,%esp
f010a034:	68 c4 4c 12 f0       	push   $0xf0124cc4
f010a039:	68 c8 00 00 00       	push   $0xc8
f010a03e:	68 0e 4b 12 f0       	push   $0xf0124b0e
f010a043:	e8 f1 62 ff ff       	call   f0100339 <_panic>

f010a048 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010a048:	55                   	push   %ebp
f010a049:	89 e5                	mov    %esp,%ebp
f010a04b:	53                   	push   %ebx
f010a04c:	83 ec 14             	sub    $0x14,%esp
	int iEnv = NENV-1;
f010a04f:	c7 45 f4 cf 02 00 00 	movl   $0x2cf,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010a056:	e9 70 01 00 00       	jmp    f010a1cb <env_init+0x183>
	{
		envs[iEnv].env_status = ENV_FREE;
f010a05b:	8b 0d 70 39 5c f0    	mov    0xf05c3970,%ecx
f010a061:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a064:	89 d0                	mov    %edx,%eax
f010a066:	c1 e0 02             	shl    $0x2,%eax
f010a069:	01 d0                	add    %edx,%eax
f010a06b:	01 c0                	add    %eax,%eax
f010a06d:	01 d0                	add    %edx,%eax
f010a06f:	c1 e0 02             	shl    $0x2,%eax
f010a072:	01 d0                	add    %edx,%eax
f010a074:	01 c0                	add    %eax,%eax
f010a076:	01 d0                	add    %edx,%eax
f010a078:	c1 e0 04             	shl    $0x4,%eax
f010a07b:	01 c8                	add    %ecx,%eax
f010a07d:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010a084:	8b 0d 70 39 5c f0    	mov    0xf05c3970,%ecx
f010a08a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a08d:	89 d0                	mov    %edx,%eax
f010a08f:	c1 e0 02             	shl    $0x2,%eax
f010a092:	01 d0                	add    %edx,%eax
f010a094:	01 c0                	add    %eax,%eax
f010a096:	01 d0                	add    %edx,%eax
f010a098:	c1 e0 02             	shl    $0x2,%eax
f010a09b:	01 d0                	add    %edx,%eax
f010a09d:	01 c0                	add    %eax,%eax
f010a09f:	01 d0                	add    %edx,%eax
f010a0a1:	c1 e0 04             	shl    $0x4,%eax
f010a0a4:	01 c8                	add    %ecx,%eax
f010a0a6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010a0ad:	8b 0d 70 39 5c f0    	mov    0xf05c3970,%ecx
f010a0b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a0b6:	89 d0                	mov    %edx,%eax
f010a0b8:	c1 e0 02             	shl    $0x2,%eax
f010a0bb:	01 d0                	add    %edx,%eax
f010a0bd:	01 c0                	add    %eax,%eax
f010a0bf:	01 d0                	add    %edx,%eax
f010a0c1:	c1 e0 02             	shl    $0x2,%eax
f010a0c4:	01 d0                	add    %edx,%eax
f010a0c6:	01 c0                	add    %eax,%eax
f010a0c8:	01 d0                	add    %edx,%eax
f010a0ca:	c1 e0 04             	shl    $0x4,%eax
f010a0cd:	01 c8                	add    %ecx,%eax
f010a0cf:	85 c0                	test   %eax,%eax
f010a0d1:	75 14                	jne    f010a0e7 <env_init+0x9f>
f010a0d3:	83 ec 04             	sub    $0x4,%esp
f010a0d6:	68 f0 4c 12 f0       	push   $0xf0124cf0
f010a0db:	6a 64                	push   $0x64
f010a0dd:	68 13 4d 12 f0       	push   $0xf0124d13
f010a0e2:	e8 52 62 ff ff       	call   f0100339 <_panic>
f010a0e7:	8b 0d 70 39 5c f0    	mov    0xf05c3970,%ecx
f010a0ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a0f0:	89 d0                	mov    %edx,%eax
f010a0f2:	c1 e0 02             	shl    $0x2,%eax
f010a0f5:	01 d0                	add    %edx,%eax
f010a0f7:	01 c0                	add    %eax,%eax
f010a0f9:	01 d0                	add    %edx,%eax
f010a0fb:	c1 e0 02             	shl    $0x2,%eax
f010a0fe:	01 d0                	add    %edx,%eax
f010a100:	01 c0                	add    %eax,%eax
f010a102:	01 d0                	add    %edx,%eax
f010a104:	c1 e0 04             	shl    $0x4,%eax
f010a107:	01 c8                	add    %ecx,%eax
f010a109:	8b 15 74 39 5c f0    	mov    0xf05c3974,%edx
f010a10f:	89 50 08             	mov    %edx,0x8(%eax)
f010a112:	8b 40 08             	mov    0x8(%eax),%eax
f010a115:	85 c0                	test   %eax,%eax
f010a117:	74 2d                	je     f010a146 <env_init+0xfe>
f010a119:	8b 0d 74 39 5c f0    	mov    0xf05c3974,%ecx
f010a11f:	8b 1d 70 39 5c f0    	mov    0xf05c3970,%ebx
f010a125:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a128:	89 d0                	mov    %edx,%eax
f010a12a:	c1 e0 02             	shl    $0x2,%eax
f010a12d:	01 d0                	add    %edx,%eax
f010a12f:	01 c0                	add    %eax,%eax
f010a131:	01 d0                	add    %edx,%eax
f010a133:	c1 e0 02             	shl    $0x2,%eax
f010a136:	01 d0                	add    %edx,%eax
f010a138:	01 c0                	add    %eax,%eax
f010a13a:	01 d0                	add    %edx,%eax
f010a13c:	c1 e0 04             	shl    $0x4,%eax
f010a13f:	01 d8                	add    %ebx,%eax
f010a141:	89 41 0c             	mov    %eax,0xc(%ecx)
f010a144:	eb 27                	jmp    f010a16d <env_init+0x125>
f010a146:	8b 0d 70 39 5c f0    	mov    0xf05c3970,%ecx
f010a14c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a14f:	89 d0                	mov    %edx,%eax
f010a151:	c1 e0 02             	shl    $0x2,%eax
f010a154:	01 d0                	add    %edx,%eax
f010a156:	01 c0                	add    %eax,%eax
f010a158:	01 d0                	add    %edx,%eax
f010a15a:	c1 e0 02             	shl    $0x2,%eax
f010a15d:	01 d0                	add    %edx,%eax
f010a15f:	01 c0                	add    %eax,%eax
f010a161:	01 d0                	add    %edx,%eax
f010a163:	c1 e0 04             	shl    $0x4,%eax
f010a166:	01 c8                	add    %ecx,%eax
f010a168:	a3 78 39 5c f0       	mov    %eax,0xf05c3978
f010a16d:	8b 0d 70 39 5c f0    	mov    0xf05c3970,%ecx
f010a173:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a176:	89 d0                	mov    %edx,%eax
f010a178:	c1 e0 02             	shl    $0x2,%eax
f010a17b:	01 d0                	add    %edx,%eax
f010a17d:	01 c0                	add    %eax,%eax
f010a17f:	01 d0                	add    %edx,%eax
f010a181:	c1 e0 02             	shl    $0x2,%eax
f010a184:	01 d0                	add    %edx,%eax
f010a186:	01 c0                	add    %eax,%eax
f010a188:	01 d0                	add    %edx,%eax
f010a18a:	c1 e0 04             	shl    $0x4,%eax
f010a18d:	01 c8                	add    %ecx,%eax
f010a18f:	a3 74 39 5c f0       	mov    %eax,0xf05c3974
f010a194:	8b 0d 70 39 5c f0    	mov    0xf05c3970,%ecx
f010a19a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a19d:	89 d0                	mov    %edx,%eax
f010a19f:	c1 e0 02             	shl    $0x2,%eax
f010a1a2:	01 d0                	add    %edx,%eax
f010a1a4:	01 c0                	add    %eax,%eax
f010a1a6:	01 d0                	add    %edx,%eax
f010a1a8:	c1 e0 02             	shl    $0x2,%eax
f010a1ab:	01 d0                	add    %edx,%eax
f010a1ad:	01 c0                	add    %eax,%eax
f010a1af:	01 d0                	add    %edx,%eax
f010a1b1:	c1 e0 04             	shl    $0x4,%eax
f010a1b4:	01 c8                	add    %ecx,%eax
f010a1b6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010a1bd:	a1 80 39 5c f0       	mov    0xf05c3980,%eax
f010a1c2:	40                   	inc    %eax
f010a1c3:	a3 80 39 5c f0       	mov    %eax,0xf05c3980
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010a1c8:	ff 4d f4             	decl   -0xc(%ebp)
f010a1cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a1cf:	0f 89 86 fe ff ff    	jns    f010a05b <env_init+0x13>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010a1d5:	90                   	nop
f010a1d6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a1d9:	c9                   	leave  
f010a1da:	c3                   	ret    

f010a1db <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010a1db:	55                   	push   %ebp
f010a1dc:	89 e5                	mov    %esp,%ebp
f010a1de:	57                   	push   %edi
f010a1df:	56                   	push   %esi
f010a1e0:	81 ec e0 00 00 00    	sub    $0xe0,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f010a1e6:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010a1ed:	83 ec 0c             	sub    $0xc,%esp
f010a1f0:	ff 75 08             	pushl  0x8(%ebp)
f010a1f3:	e8 b0 1d 00 00       	call   f010bfa8 <get_user_program_info>
f010a1f8:	83 c4 10             	add    $0x10,%esp
f010a1fb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(ptr_user_program_info == 0)
f010a1fe:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010a202:	75 0a                	jne    f010a20e <env_create+0x33>
	{
		return NULL;
f010a204:	b8 00 00 00 00       	mov    $0x0,%eax
f010a209:	e9 aa 09 00 00       	jmp    f010abb8 <env_create+0x9dd>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f010a20e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a211:	8b 40 08             	mov    0x8(%eax),%eax
f010a214:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f010a217:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
f010a21e:	00 00 00 
	if(allocate_environment(&e) < 0)
f010a221:	83 ec 0c             	sub    $0xc,%esp
f010a224:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
f010a22a:	50                   	push   %eax
f010a22b:	e8 8e 0e 00 00       	call   f010b0be <allocate_environment>
f010a230:	83 c4 10             	add    $0x10,%esp
f010a233:	85 c0                	test   %eax,%eax
f010a235:	79 0a                	jns    f010a241 <env_create+0x66>
	{
		return NULL;
f010a237:	b8 00 00 00 00       	mov    $0x0,%eax
f010a23c:	e9 77 09 00 00       	jmp    f010abb8 <env_create+0x9dd>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010a241:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a244:	8b 00                	mov    (%eax),%eax
f010a246:	83 ec 0c             	sub    $0xc,%esp
f010a249:	50                   	push   %eax
f010a24a:	e8 90 49 01 00       	call   f011ebdf <strlen>
f010a24f:	83 c4 10             	add    $0x10,%esp
f010a252:	83 f8 3f             	cmp    $0x3f,%eax
f010a255:	7f 1d                	jg     f010a274 <env_create+0x99>
		strcpy(e->prog_name, ptr_user_program_info->name);
f010a257:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a25a:	8b 00                	mov    (%eax),%eax
f010a25c:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010a262:	83 c2 20             	add    $0x20,%edx
f010a265:	83 ec 08             	sub    $0x8,%esp
f010a268:	50                   	push   %eax
f010a269:	52                   	push   %edx
f010a26a:	e8 bf 49 01 00       	call   f011ec2e <strcpy>
f010a26f:	83 c4 10             	add    $0x10,%esp
f010a272:	eb 1d                	jmp    f010a291 <env_create+0xb6>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010a274:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a277:	8b 00                	mov    (%eax),%eax
f010a279:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010a27f:	83 c2 20             	add    $0x20,%edx
f010a282:	83 ec 04             	sub    $0x4,%esp
f010a285:	6a 3f                	push   $0x3f
f010a287:	50                   	push   %eax
f010a288:	52                   	push   %edx
f010a289:	e8 ce 49 01 00       	call   f011ec5c <strncpy>
f010a28e:	83 c4 10             	add    $0x10,%esp
	//REMEMBER: "allocate_frame" should always return a free frame
	uint32* ptr_user_page_directory;
	unsigned int phys_user_page_directory;
#if USE_KHEAP
	{
		ptr_user_page_directory = create_user_directory();
f010a291:	e8 f4 13 00 00       	call   f010b68a <create_user_directory>
f010a296:	89 45 c0             	mov    %eax,-0x40(%ebp)
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010a299:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010a29c:	83 ec 0c             	sub    $0xc,%esp
f010a29f:	50                   	push   %eax
f010a2a0:	e8 f1 ed ff ff       	call   f0109096 <kheap_physical_address>
f010a2a5:	83 c4 10             	add    $0x10,%esp
f010a2a8:	89 45 bc             	mov    %eax,-0x44(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f010a2ab:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a2b1:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a2b4:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a2ba:	83 ec 0c             	sub    $0xc,%esp
f010a2bd:	6a 02                	push   $0x2
f010a2bf:	e8 9a 44 00 00       	call   f010e75e <isPageReplacmentAlgorithmLRU>
f010a2c4:	83 c4 10             	add    $0x10,%esp
f010a2c7:	85 c0                	test   %eax,%eax
f010a2c9:	74 21                	je     f010a2ec <env_create+0x111>
	{
		e->SecondListSize = LRU_second_list_size;
f010a2cb:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a2d1:	8b 55 10             	mov    0x10(%ebp),%edx
f010a2d4:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010a2da:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a2e0:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a2e3:	2b 55 10             	sub    0x10(%ebp),%edx
f010a2e6:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010a2ec:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010a2f0:	75 12                	jne    f010a304 <env_create+0x129>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010a2f2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a2f8:	c7 80 80 05 00 00 0a 	movl   $0xa,0x580(%eax)
f010a2ff:	00 00 00 
f010a302:	eb 0f                	jmp    f010a313 <env_create+0x138>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010a304:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a30a:	8b 55 14             	mov    0x14(%ebp),%edx
f010a30d:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010a313:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a319:	83 ec 04             	sub    $0x4,%esp
f010a31c:	ff 75 bc             	pushl  -0x44(%ebp)
f010a31f:	ff 75 c0             	pushl  -0x40(%ebp)
f010a322:	50                   	push   %eax
f010a323:	e8 dd 13 00 00       	call   f010b705 <initialize_environment>
f010a328:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f010a32b:	e8 d7 ce ff ff       	call   f0107207 <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010a330:	0f 20 d8             	mov    %cr3,%eax
f010a333:	89 45 b0             	mov    %eax,-0x50(%ebp)
	return val;
f010a336:	8b 45 b0             	mov    -0x50(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010a339:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		lcr3(e->env_cr3) ;
f010a33c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a342:	8b 40 68             	mov    0x68(%eax),%eax
f010a345:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010a34b:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f010a351:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010a354:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int segment_counter=0;
f010a35b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010a362:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a368:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010a36e:	48                   	dec    %eax
f010a36f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010a372:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
f010a379:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010a37c:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f010a382:	83 ec 08             	sub    $0x8,%esp
f010a385:	ff 75 c8             	pushl  -0x38(%ebp)
f010a388:	50                   	push   %eax
f010a389:	e8 2c 19 00 00       	call   f010bcba <PROGRAM_SEGMENT_FIRST>
f010a38e:	83 c4 0c             	add    $0xc,%esp
f010a391:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010a397:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f010a39d:	b9 05 00 00 00       	mov    $0x5,%ecx
f010a3a2:	89 c7                	mov    %eax,%edi
f010a3a4:	89 d6                	mov    %edx,%esi
f010a3a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010a3a8:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010a3ae:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a3b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a3b4:	8b 40 10             	mov    0x10(%eax),%eax
f010a3b7:	83 f8 ff             	cmp    $0xffffffff,%eax
f010a3ba:	75 07                	jne    f010a3c3 <env_create+0x1e8>
f010a3bc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010a3c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a3c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a3c9:	e9 fa 02 00 00       	jmp    f010a6c8 <env_create+0x4ed>
		{
			segment_counter++;
f010a3ce:	ff 45 f0             	incl   -0x10(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010a3d1:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f010a3d8:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010a3db:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a3e1:	83 ec 0c             	sub    $0xc,%esp
f010a3e4:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
f010a3ea:	52                   	push   %edx
f010a3eb:	ff 75 ec             	pushl  -0x14(%ebp)
f010a3ee:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010a3f4:	52                   	push   %edx
f010a3f5:	ff 75 f4             	pushl  -0xc(%ebp)
f010a3f8:	50                   	push   %eax
f010a3f9:	e8 7e 0d 00 00       	call   f010b17c <program_segment_alloc_map_copy_workingset>
f010a3fe:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010a401:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a407:	29 45 ec             	sub    %eax,-0x14(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010a40a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a40d:	8b 00                	mov    (%eax),%eax
f010a40f:	89 45 ac             	mov    %eax,-0x54(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010a412:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a415:	8b 40 0c             	mov    0xc(%eax),%eax
f010a418:	89 45 a8             	mov    %eax,-0x58(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010a41b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a41e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010a421:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f010a424:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a429:	89 45 a0             	mov    %eax,-0x60(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010a42c:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
f010a433:	8b 55 a8             	mov    -0x58(%ebp),%edx
f010a436:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010a439:	01 d0                	add    %edx,%eax
f010a43b:	48                   	dec    %eax
f010a43c:	89 45 98             	mov    %eax,-0x68(%ebp)
f010a43f:	8b 45 98             	mov    -0x68(%ebp),%eax
f010a442:	ba 00 00 00 00       	mov    $0x0,%edx
f010a447:	f7 75 9c             	divl   -0x64(%ebp)
f010a44a:	8b 45 98             	mov    -0x68(%ebp),%eax
f010a44d:	29 d0                	sub    %edx,%eax
f010a44f:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010a452:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a455:	2b 45 a0             	sub    -0x60(%ebp),%eax
f010a458:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010a45b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010a45e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010a461:	8b 15 a4 cb 5e f0    	mov    0xf05ecba4,%edx
f010a467:	8b 45 90             	mov    -0x70(%ebp),%eax
f010a46a:	01 d0                	add    %edx,%eax
f010a46c:	89 45 e0             	mov    %eax,-0x20(%ebp)
			int i;
			if (offset_first_page)
f010a46f:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
f010a473:	74 73                	je     f010a4e8 <env_create+0x30d>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010a475:	a1 a4 cb 5e f0       	mov    0xf05ecba4,%eax
f010a47a:	83 ec 04             	sub    $0x4,%esp
f010a47d:	68 00 10 00 00       	push   $0x1000
f010a482:	6a 00                	push   $0x0
f010a484:	50                   	push   %eax
f010a485:	e8 43 49 01 00       	call   f011edcd <memset>
f010a48a:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010a48d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a490:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a493:	eb 13                	jmp    f010a4a8 <env_create+0x2cd>
				{
					*dst_ptr = *src_ptr ;
f010a495:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a498:	8a 10                	mov    (%eax),%dl
f010a49a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a49d:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010a49f:	ff 45 dc             	incl   -0x24(%ebp)
f010a4a2:	ff 45 e4             	incl   -0x1c(%ebp)
f010a4a5:	ff 45 e0             	incl   -0x20(%ebp)
f010a4a8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a4ab:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f010a4ae:	72 e5                	jb     f010a495 <env_create+0x2ba>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010a4b0:	8b 15 a4 cb 5e f0    	mov    0xf05ecba4,%edx
f010a4b6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a4bc:	83 ec 04             	sub    $0x4,%esp
f010a4bf:	52                   	push   %edx
f010a4c0:	ff 75 a0             	pushl  -0x60(%ebp)
f010a4c3:	50                   	push   %eax
f010a4c4:	e8 08 9e ff ff       	call   f01042d1 <pf_add_env_page>
f010a4c9:	83 c4 10             	add    $0x10,%esp
f010a4cc:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010a4cf:	75 17                	jne    f010a4e8 <env_create+0x30d>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010a4d1:	83 ec 04             	sub    $0x4,%esp
f010a4d4:	68 30 4d 12 f0       	push   $0xf0124d30
f010a4d9:	68 f4 00 00 00       	push   $0xf4
f010a4de:	68 13 4d 12 f0       	push   $0xf0124d13
f010a4e3:	e8 51 5e ff ff       	call   f0100339 <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010a4e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a4eb:	8b 50 04             	mov    0x4(%eax),%edx
f010a4ee:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a4f1:	01 d0                	add    %edx,%eax
f010a4f3:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010a4f6:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010a4f9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a4fe:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010a501:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a504:	8b 50 04             	mov    0x4(%eax),%edx
f010a507:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a50a:	01 d0                	add    %edx,%eax
f010a50c:	89 45 84             	mov    %eax,-0x7c(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010a50f:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010a512:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a515:	eb 43                	jmp    f010a55a <env_create+0x37f>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010a517:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010a51a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a520:	83 ec 04             	sub    $0x4,%esp
f010a523:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a526:	52                   	push   %edx
f010a527:	50                   	push   %eax
f010a528:	e8 a4 9d ff ff       	call   f01042d1 <pf_add_env_page>
f010a52d:	83 c4 10             	add    $0x10,%esp
f010a530:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010a533:	75 17                	jne    f010a54c <env_create+0x371>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010a535:	83 ec 04             	sub    $0x4,%esp
f010a538:	68 30 4d 12 f0       	push   $0xf0124d30
f010a53d:	68 01 01 00 00       	push   $0x101
f010a542:	68 13 4d 12 f0       	push   $0xf0124d13
f010a547:	e8 ed 5d ff ff       	call   f0100339 <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010a54c:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010a553:	81 45 e4 00 10 00 00 	addl   $0x1000,-0x1c(%ebp)
f010a55a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a55d:	3b 45 88             	cmp    -0x78(%ebp),%eax
f010a560:	72 b5                	jb     f010a517 <env_create+0x33c>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010a562:	a1 a4 cb 5e f0       	mov    0xf05ecba4,%eax
f010a567:	89 45 e0             	mov    %eax,-0x20(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010a56a:	83 ec 04             	sub    $0x4,%esp
f010a56d:	68 00 10 00 00       	push   $0x1000
f010a572:	6a 00                	push   $0x0
f010a574:	ff 75 e0             	pushl  -0x20(%ebp)
f010a577:	e8 51 48 01 00       	call   f011edcd <memset>
f010a57c:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010a57f:	8b 45 88             	mov    -0x78(%ebp),%eax
f010a582:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a585:	eb 13                	jmp    f010a59a <env_create+0x3bf>
			{
				*dst_ptr = *src_ptr;
f010a587:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a58a:	8a 10                	mov    (%eax),%dl
f010a58c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a58f:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010a591:	ff 45 dc             	incl   -0x24(%ebp)
f010a594:	ff 45 e4             	incl   -0x1c(%ebp)
f010a597:	ff 45 e0             	incl   -0x20(%ebp)
f010a59a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a59d:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f010a5a0:	72 e5                	jb     f010a587 <env_create+0x3ac>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010a5a2:	8b 15 a4 cb 5e f0    	mov    0xf05ecba4,%edx
f010a5a8:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a5ae:	83 ec 04             	sub    $0x4,%esp
f010a5b1:	52                   	push   %edx
f010a5b2:	ff 75 88             	pushl  -0x78(%ebp)
f010a5b5:	50                   	push   %eax
f010a5b6:	e8 16 9d ff ff       	call   f01042d1 <pf_add_env_page>
f010a5bb:	83 c4 10             	add    $0x10,%esp
f010a5be:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010a5c1:	75 17                	jne    f010a5da <env_create+0x3ff>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010a5c3:	83 ec 04             	sub    $0x4,%esp
f010a5c6:	68 30 4d 12 f0       	push   $0xf0124d30
f010a5cb:	68 10 01 00 00       	push   $0x110
f010a5d0:	68 13 4d 12 f0       	push   $0xf0124d13
f010a5d5:	e8 5f 5d ff ff       	call   f0100339 <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010a5da:	c7 45 80 00 10 00 00 	movl   $0x1000,-0x80(%ebp)
f010a5e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a5e4:	8b 50 04             	mov    0x4(%eax),%edx
f010a5e7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a5ea:	01 c2                	add    %eax,%edx
f010a5ec:	8b 45 80             	mov    -0x80(%ebp),%eax
f010a5ef:	01 d0                	add    %edx,%eax
f010a5f1:	48                   	dec    %eax
f010a5f2:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
f010a5f8:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010a5fe:	ba 00 00 00 00       	mov    $0x0,%edx
f010a603:	f7 75 80             	divl   -0x80(%ebp)
f010a606:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010a60c:	29 d0                	sub    %edx,%eax
f010a60e:	89 45 d8             	mov    %eax,-0x28(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010a611:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a614:	8b 50 08             	mov    0x8(%eax),%edx
f010a617:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010a61a:	01 d0                	add    %edx,%eax
f010a61c:	2b 45 d8             	sub    -0x28(%ebp),%eax
f010a61f:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010a625:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010a62c:	eb 41                	jmp    f010a66f <env_create+0x494>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010a62e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a634:	83 ec 04             	sub    $0x4,%esp
f010a637:	6a 01                	push   $0x1
f010a639:	ff 75 d8             	pushl  -0x28(%ebp)
f010a63c:	50                   	push   %eax
f010a63d:	e8 61 9b ff ff       	call   f01041a3 <pf_add_empty_env_page>
f010a642:	83 c4 10             	add    $0x10,%esp
f010a645:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010a648:	75 17                	jne    f010a661 <env_create+0x486>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010a64a:	83 ec 04             	sub    $0x4,%esp
f010a64d:	68 30 4d 12 f0       	push   $0xf0124d30
f010a652:	68 1d 01 00 00       	push   $0x11d
f010a657:	68 13 4d 12 f0       	push   $0xf0124d13
f010a65c:	e8 d8 5c ff ff       	call   f0100339 <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010a661:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f010a668:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f010a66f:	c7 85 74 ff ff ff 00 	movl   $0x1000,-0x8c(%ebp)
f010a676:	10 00 00 
f010a679:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f010a67f:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010a685:	01 d0                	add    %edx,%eax
f010a687:	48                   	dec    %eax
f010a688:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
f010a68e:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010a694:	ba 00 00 00 00       	mov    $0x0,%edx
f010a699:	f7 b5 74 ff ff ff    	divl   -0x8c(%ebp)
f010a69f:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010a6a5:	29 d0                	sub    %edx,%eax
f010a6a7:	89 c2                	mov    %eax,%edx
f010a6a9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a6ac:	39 c2                	cmp    %eax,%edx
f010a6ae:	0f 87 7a ff ff ff    	ja     f010a62e <env_create+0x453>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010a6b4:	83 ec 08             	sub    $0x8,%esp
f010a6b7:	ff 75 c8             	pushl  -0x38(%ebp)
f010a6ba:	ff 75 f4             	pushl  -0xc(%ebp)
f010a6bd:	e8 ed 14 00 00       	call   f010bbaf <PROGRAM_SEGMENT_NEXT>
f010a6c2:	83 c4 10             	add    $0x10,%esp
f010a6c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a6c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a6cc:	0f 85 fc fc ff ff    	jne    f010a3ce <env_create+0x1f3>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a6d2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a6d8:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010a6de:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a6e1:	eb 77                	jmp    f010a75a <env_create+0x57f>
		{
			uint32 virtual_address = wse->virtual_address;
f010a6e3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a6e6:	8b 00                	mov    (%eax),%eax
f010a6e8:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010a6ee:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a6f4:	8b 40 64             	mov    0x64(%eax),%eax
f010a6f7:	83 ec 04             	sub    $0x4,%esp
f010a6fa:	8d 95 3c ff ff ff    	lea    -0xc4(%ebp),%edx
f010a700:	52                   	push   %edx
f010a701:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
f010a707:	50                   	push   %eax
f010a708:	e8 b2 dd ff ff       	call   f01084bf <get_page_table>
f010a70d:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010a710:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f010a716:	8b 95 6c ff ff ff    	mov    -0x94(%ebp),%edx
f010a71c:	c1 ea 0c             	shr    $0xc,%edx
f010a71f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010a725:	c1 e2 02             	shl    $0x2,%edx
f010a728:	01 d0                	add    %edx,%eax
f010a72a:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f010a730:	8b 8d 6c ff ff ff    	mov    -0x94(%ebp),%ecx
f010a736:	c1 e9 0c             	shr    $0xc,%ecx
f010a739:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010a73f:	c1 e1 02             	shl    $0x2,%ecx
f010a742:	01 ca                	add    %ecx,%edx
f010a744:	8b 12                	mov    (%edx),%edx
f010a746:	83 e2 bf             	and    $0xffffffbf,%edx
f010a749:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a74b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a751:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a757:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a75a:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a760:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a764:	74 08                	je     f010a76e <env_create+0x593>
f010a766:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a769:	8b 52 10             	mov    0x10(%edx),%edx
f010a76c:	eb 05                	jmp    f010a773 <env_create+0x598>
f010a76e:	ba 00 00 00 00       	mov    $0x0,%edx
f010a773:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
f010a779:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a77f:	85 c0                	test   %eax,%eax
f010a781:	0f 85 5c ff ff ff    	jne    f010a6e3 <env_create+0x508>
f010a787:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a78b:	0f 85 52 ff ff ff    	jne    f010a6e3 <env_create+0x508>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010a791:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010a794:	8b 50 08             	mov    0x8(%eax),%edx
f010a797:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a79d:	83 ec 08             	sub    $0x8,%esp
f010a7a0:	52                   	push   %edx
f010a7a1:	50                   	push   %eax
f010a7a2:	e8 c8 13 00 00       	call   f010bb6f <set_environment_entry_point>
f010a7a7:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010a7aa:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a7b0:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010a7b7:	c7 85 68 ff ff ff 00 	movl   $0xeebfd000,-0x98(%ebp)
f010a7be:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010a7c1:	c7 45 d0 00 d0 bf ee 	movl   $0xeebfd000,-0x30(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010a7c8:	e9 42 03 00 00       	jmp    f010ab0f <env_create+0x934>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010a7cd:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
f010a7d4:	00 00 00 
			allocate_frame(&pp);
f010a7d7:	83 ec 0c             	sub    $0xc,%esp
f010a7da:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f010a7e0:	50                   	push   %eax
f010a7e1:	e8 9c da ff ff       	call   f0108282 <allocate_frame>
f010a7e6:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010a7e9:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f010a7ef:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a7f5:	8b 40 64             	mov    0x64(%eax),%eax
f010a7f8:	6a 06                	push   $0x6
f010a7fa:	ff 75 d0             	pushl  -0x30(%ebp)
f010a7fd:	52                   	push   %edx
f010a7fe:	50                   	push   %eax
f010a7ff:	e8 4f e1 ff ff       	call   f0108953 <loadtime_map_frame>
f010a804:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010a807:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a80a:	83 ec 04             	sub    $0x4,%esp
f010a80d:	68 00 10 00 00       	push   $0x1000
f010a812:	6a 00                	push   $0x0
f010a814:	50                   	push   %eax
f010a815:	e8 b3 45 01 00       	call   f011edcd <memset>
f010a81a:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010a81d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a823:	83 ec 08             	sub    $0x8,%esp
f010a826:	ff 75 d0             	pushl  -0x30(%ebp)
f010a829:	50                   	push   %eax
f010a82a:	e8 05 eb ff ff       	call   f0109334 <env_page_ws_list_create_element>
f010a82f:	83 c4 10             	add    $0x10,%esp
f010a832:	89 45 d4             	mov    %eax,-0x2c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010a835:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a839:	75 17                	jne    f010a852 <env_create+0x677>
f010a83b:	83 ec 04             	sub    $0x4,%esp
f010a83e:	68 78 4d 12 f0       	push   $0xf0124d78
f010a843:	68 5c 01 00 00       	push   $0x15c
f010a848:	68 13 4d 12 f0       	push   $0xf0124d13
f010a84d:	e8 e7 5a ff ff       	call   f0100339 <_panic>
f010a852:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a858:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f010a85e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a861:	89 50 14             	mov    %edx,0x14(%eax)
f010a864:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a867:	8b 40 14             	mov    0x14(%eax),%eax
f010a86a:	85 c0                	test   %eax,%eax
f010a86c:	74 14                	je     f010a882 <env_create+0x6a7>
f010a86e:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a874:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f010a87a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a87d:	89 50 10             	mov    %edx,0x10(%eax)
f010a880:	eb 0f                	jmp    f010a891 <env_create+0x6b6>
f010a882:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a888:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a88b:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010a891:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a897:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a89a:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010a8a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a8a3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a8aa:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a8b0:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010a8b6:	42                   	inc    %edx
f010a8b7:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010a8bd:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a8c3:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010a8c9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a8cf:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010a8d5:	39 c2                	cmp    %eax,%edx
f010a8d7:	75 1a                	jne    f010a8f3 <env_create+0x718>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010a8d9:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a8df:	8b 95 5c ff ff ff    	mov    -0xa4(%ebp),%edx
f010a8e5:	8b 92 88 00 00 00    	mov    0x88(%edx),%edx
f010a8eb:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010a8f1:	eb 10                	jmp    f010a903 <env_create+0x728>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010a8f3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a8f9:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010a900:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a903:	83 ec 0c             	sub    $0xc,%esp
f010a906:	6a 02                	push   $0x2
f010a908:	e8 51 3e 00 00       	call   f010e75e <isPageReplacmentAlgorithmLRU>
f010a90d:	83 c4 10             	add    $0x10,%esp
f010a910:	85 c0                	test   %eax,%eax
f010a912:	0f 84 d3 01 00 00    	je     f010aaeb <env_create+0x910>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010a918:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a91c:	75 17                	jne    f010a935 <env_create+0x75a>
f010a91e:	83 ec 04             	sub    $0x4,%esp
f010a921:	68 9b 4d 12 f0       	push   $0xf0124d9b
f010a926:	68 69 01 00 00       	push   $0x169
f010a92b:	68 13 4d 12 f0       	push   $0xf0124d13
f010a930:	e8 04 5a ff ff       	call   f0100339 <_panic>
f010a935:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a938:	8b 40 10             	mov    0x10(%eax),%eax
f010a93b:	85 c0                	test   %eax,%eax
f010a93d:	74 11                	je     f010a950 <env_create+0x775>
f010a93f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a942:	8b 40 10             	mov    0x10(%eax),%eax
f010a945:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a948:	8b 52 14             	mov    0x14(%edx),%edx
f010a94b:	89 50 14             	mov    %edx,0x14(%eax)
f010a94e:	eb 12                	jmp    f010a962 <env_create+0x787>
f010a950:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a956:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a959:	8b 52 14             	mov    0x14(%edx),%edx
f010a95c:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010a962:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a965:	8b 40 14             	mov    0x14(%eax),%eax
f010a968:	85 c0                	test   %eax,%eax
f010a96a:	74 11                	je     f010a97d <env_create+0x7a2>
f010a96c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a96f:	8b 40 14             	mov    0x14(%eax),%eax
f010a972:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a975:	8b 52 10             	mov    0x10(%edx),%edx
f010a978:	89 50 10             	mov    %edx,0x10(%eax)
f010a97b:	eb 12                	jmp    f010a98f <env_create+0x7b4>
f010a97d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a983:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010a986:	8b 52 10             	mov    0x10(%edx),%edx
f010a989:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010a98f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a992:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a999:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a99c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a9a3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a9a9:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010a9af:	4a                   	dec    %edx
f010a9b0:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010a9b6:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a9bc:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010a9c2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a9c8:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010a9ce:	39 c2                	cmp    %eax,%edx
f010a9d0:	0f 83 8d 00 00 00    	jae    f010aa63 <env_create+0x888>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010a9d6:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010a9da:	75 17                	jne    f010a9f3 <env_create+0x818>
f010a9dc:	83 ec 04             	sub    $0x4,%esp
f010a9df:	68 f0 4c 12 f0       	push   $0xf0124cf0
f010a9e4:	68 6e 01 00 00       	push   $0x16e
f010a9e9:	68 13 4d 12 f0       	push   $0xf0124d13
f010a9ee:	e8 46 59 ff ff       	call   f0100339 <_panic>
f010a9f3:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010a9f9:	8b 90 54 05 00 00    	mov    0x554(%eax),%edx
f010a9ff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010aa02:	89 50 10             	mov    %edx,0x10(%eax)
f010aa05:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010aa08:	8b 40 10             	mov    0x10(%eax),%eax
f010aa0b:	85 c0                	test   %eax,%eax
f010aa0d:	74 14                	je     f010aa23 <env_create+0x848>
f010aa0f:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa15:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f010aa1b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010aa1e:	89 50 14             	mov    %edx,0x14(%eax)
f010aa21:	eb 0f                	jmp    f010aa32 <env_create+0x857>
f010aa23:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa29:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010aa2c:	89 90 58 05 00 00    	mov    %edx,0x558(%eax)
f010aa32:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa38:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010aa3b:	89 90 54 05 00 00    	mov    %edx,0x554(%eax)
f010aa41:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010aa44:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010aa4b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa51:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010aa57:	42                   	inc    %edx
f010aa58:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010aa5e:	e9 88 00 00 00       	jmp    f010aaeb <env_create+0x910>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010aa63:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010aa67:	75 17                	jne    f010aa80 <env_create+0x8a5>
f010aa69:	83 ec 04             	sub    $0x4,%esp
f010aa6c:	68 f0 4c 12 f0       	push   $0xf0124cf0
f010aa71:	68 72 01 00 00       	push   $0x172
f010aa76:	68 13 4d 12 f0       	push   $0xf0124d13
f010aa7b:	e8 b9 58 ff ff       	call   f0100339 <_panic>
f010aa80:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aa86:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010aa8c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010aa8f:	89 50 10             	mov    %edx,0x10(%eax)
f010aa92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010aa95:	8b 40 10             	mov    0x10(%eax),%eax
f010aa98:	85 c0                	test   %eax,%eax
f010aa9a:	74 14                	je     f010aab0 <env_create+0x8d5>
f010aa9c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aaa2:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010aaa8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010aaab:	89 50 14             	mov    %edx,0x14(%eax)
f010aaae:	eb 0f                	jmp    f010aabf <env_create+0x8e4>
f010aab0:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aab6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010aab9:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010aabf:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aac5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010aac8:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010aace:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010aad1:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010aad8:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aade:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010aae4:	42                   	inc    %edx
f010aae5:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010aaeb:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010aaf1:	83 ec 04             	sub    $0x4,%esp
f010aaf4:	6a 01                	push   $0x1
f010aaf6:	ff 75 d0             	pushl  -0x30(%ebp)
f010aaf9:	50                   	push   %eax
f010aafa:	e8 a4 96 ff ff       	call   f01041a3 <pf_add_empty_env_page>
f010aaff:	83 c4 10             	add    $0x10,%esp
f010ab02:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010ab08:	81 6d d0 00 10 00 00 	subl   $0x1000,-0x30(%ebp)
f010ab0f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ab12:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f010ab18:	0f 83 af fc ff ff    	jae    f010a7cd <env_create+0x5f2>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010ab1e:	83 ec 0c             	sub    $0xc,%esp
f010ab21:	6a 02                	push   $0x2
f010ab23:	e8 36 3c 00 00       	call   f010e75e <isPageReplacmentAlgorithmLRU>
f010ab28:	83 c4 10             	add    $0x10,%esp
f010ab2b:	85 c0                	test   %eax,%eax
f010ab2d:	74 72                	je     f010aba1 <env_create+0x9c6>
		{
			struct WorkingSetElement * elm = NULL;
f010ab2f:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010ab36:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ab3c:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010ab42:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010ab45:	eb 2b                	jmp    f010ab72 <env_create+0x997>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010ab47:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ab4a:	8b 10                	mov    (%eax),%edx
f010ab4c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ab52:	8b 40 64             	mov    0x64(%eax),%eax
f010ab55:	6a 01                	push   $0x1
f010ab57:	6a 00                	push   $0x0
f010ab59:	52                   	push   %edx
f010ab5a:	50                   	push   %eax
f010ab5b:	e8 9e e5 ff ff       	call   f01090fe <pt_set_page_permissions>
f010ab60:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010ab63:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ab69:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010ab6f:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010ab72:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010ab78:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010ab7c:	74 08                	je     f010ab86 <env_create+0x9ab>
f010ab7e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010ab81:	8b 52 10             	mov    0x10(%edx),%edx
f010ab84:	eb 05                	jmp    f010ab8b <env_create+0x9b0>
f010ab86:	ba 00 00 00 00       	mov    $0x0,%edx
f010ab8b:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010ab91:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010ab97:	85 c0                	test   %eax,%eax
f010ab99:	75 ac                	jne    f010ab47 <env_create+0x96c>
f010ab9b:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010ab9f:	75 a6                	jne    f010ab47 <env_create+0x96c>
f010aba1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010aba4:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010aba7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010abaa:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010abad:	e8 a7 c6 ff ff       	call   f0107259 <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010abb2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
}
f010abb8:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010abbb:	5e                   	pop    %esi
f010abbc:	5f                   	pop    %edi
f010abbd:	5d                   	pop    %ebp
f010abbe:	c3                   	ret    

f010abbf <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010abbf:	55                   	push   %ebp
f010abc0:	89 e5                	mov    %esp,%ebp
f010abc2:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010abc5:	83 ec 0c             	sub    $0xc,%esp
f010abc8:	68 60 c4 5e f0       	push   $0xf05ec460
f010abcd:	e8 74 40 00 00       	call   f010ec46 <release_spinlock>
f010abd2:	83 c4 10             	add    $0x10,%esp

	if (first)
f010abd5:	a1 60 b9 17 f0       	mov    0xf017b960,%eax
f010abda:	85 c0                	test   %eax,%eax
f010abdc:	74 30                	je     f010ac0e <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010abde:	e8 76 00 00 00       	call   f010ac59 <get_cpu_proc>
f010abe3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010abe6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abe9:	8b 40 10             	mov    0x10(%eax),%eax
f010abec:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010abef:	83 c2 20             	add    $0x20,%edx
f010abf2:	83 ec 04             	sub    $0x4,%esp
f010abf5:	50                   	push   %eax
f010abf6:	52                   	push   %edx
f010abf7:	68 b9 4d 12 f0       	push   $0xf0124db9
f010abfc:	e8 8a 63 ff ff       	call   f0100f8b <cprintf>
f010ac01:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010ac04:	c7 05 60 b9 17 f0 00 	movl   $0x0,0xf017b960
f010ac0b:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010ac0e:	90                   	nop
f010ac0f:	c9                   	leave  
f010ac10:	c3                   	ret    

f010ac11 <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010ac11:	55                   	push   %ebp
f010ac12:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010ac14:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010ac15:	5d                   	pop    %ebp
f010ac16:	c3                   	ret    

f010ac17 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010ac17:	55                   	push   %ebp
f010ac18:	89 e5                	mov    %esp,%ebp
f010ac1a:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ac1d:	e8 37 00 00 00       	call   f010ac59 <get_cpu_proc>
f010ac22:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ac25:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ac29:	75 19                	jne    f010ac44 <env_exit+0x2d>
f010ac2b:	68 cf 4d 12 f0       	push   $0xf0124dcf
f010ac30:	68 df 4d 12 f0       	push   $0xf0124ddf
f010ac35:	68 ec 01 00 00       	push   $0x1ec
f010ac3a:	68 13 4d 12 f0       	push   $0xf0124d13
f010ac3f:	e8 f5 56 ff ff       	call   f0100339 <_panic>
	sched_exit_env(cur_env->env_id);
f010ac44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac47:	8b 40 10             	mov    0x10(%eax),%eax
f010ac4a:	83 ec 0c             	sub    $0xc,%esp
f010ac4d:	50                   	push   %eax
f010ac4e:	e8 17 ac ff ff       	call   f010586a <sched_exit_env>
f010ac53:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010ac56:	90                   	nop
f010ac57:	c9                   	leave  
f010ac58:	c3                   	ret    

f010ac59 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010ac59:	55                   	push   %ebp
f010ac5a:	89 e5                	mov    %esp,%ebp
f010ac5c:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010ac5f:	e8 a3 c5 ff ff       	call   f0107207 <pushcli>
	c = mycpu();
f010ac64:	e8 db c4 ff ff       	call   f0107144 <mycpu>
f010ac69:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010ac6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac6f:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010ac75:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010ac78:	e8 dc c5 ff ff       	call   f0107259 <popcli>
	return p;
f010ac7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010ac80:	c9                   	leave  
f010ac81:	c3                   	ret    

f010ac82 <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010ac82:	55                   	push   %ebp
f010ac83:	89 e5                	mov    %esp,%ebp
f010ac85:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010ac88:	e8 7a c5 ff ff       	call   f0107207 <pushcli>
	c = mycpu();
f010ac8d:	e8 b2 c4 ff ff       	call   f0107144 <mycpu>
f010ac92:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010ac95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ac98:	8b 55 08             	mov    0x8(%ebp),%edx
f010ac9b:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010aca1:	e8 b3 c5 ff ff       	call   f0107259 <popcli>
}
f010aca6:	90                   	nop
f010aca7:	c9                   	leave  
f010aca8:	c3                   	ret    

f010aca9 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010aca9:	55                   	push   %ebp
f010acaa:	89 e5                	mov    %esp,%ebp
f010acac:	53                   	push   %ebx
f010acad:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010acb0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010acb4:	75 16                	jne    f010accc <envid2env+0x23>
		*env_store = get_cpu_proc();
f010acb6:	e8 9e ff ff ff       	call   f010ac59 <get_cpu_proc>
f010acbb:	89 c2                	mov    %eax,%edx
f010acbd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010acc0:	89 10                	mov    %edx,(%eax)
		return 0;
f010acc2:	b8 00 00 00 00       	mov    $0x0,%eax
f010acc7:	e9 a2 00 00 00       	jmp    f010ad6e <envid2env+0xc5>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010accc:	8b 1d 70 39 5c f0    	mov    0xf05c3970,%ebx
f010acd2:	83 ec 0c             	sub    $0xc,%esp
f010acd5:	68 d0 02 00 00       	push   $0x2d0
f010acda:	e8 5e 24 01 00       	call   f011d13d <nearest_pow2_ceil>
f010acdf:	83 c4 10             	add    $0x10,%esp
f010ace2:	8d 50 ff             	lea    -0x1(%eax),%edx
f010ace5:	8b 45 08             	mov    0x8(%ebp),%eax
f010ace8:	21 c2                	and    %eax,%edx
f010acea:	89 d0                	mov    %edx,%eax
f010acec:	c1 e0 02             	shl    $0x2,%eax
f010acef:	01 d0                	add    %edx,%eax
f010acf1:	01 c0                	add    %eax,%eax
f010acf3:	01 d0                	add    %edx,%eax
f010acf5:	c1 e0 02             	shl    $0x2,%eax
f010acf8:	01 d0                	add    %edx,%eax
f010acfa:	01 c0                	add    %eax,%eax
f010acfc:	01 d0                	add    %edx,%eax
f010acfe:	c1 e0 04             	shl    $0x4,%eax
f010ad01:	01 d8                	add    %ebx,%eax
f010ad03:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010ad06:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad09:	8b 40 18             	mov    0x18(%eax),%eax
f010ad0c:	85 c0                	test   %eax,%eax
f010ad0e:	74 0b                	je     f010ad1b <envid2env+0x72>
f010ad10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad13:	8b 40 10             	mov    0x10(%eax),%eax
f010ad16:	3b 45 08             	cmp    0x8(%ebp),%eax
f010ad19:	74 10                	je     f010ad2b <envid2env+0x82>
		*env_store = 0;
f010ad1b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ad1e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010ad24:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010ad29:	eb 43                	jmp    f010ad6e <envid2env+0xc5>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010ad2b:	e8 29 ff ff ff       	call   f010ac59 <get_cpu_proc>
f010ad30:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010ad33:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010ad37:	74 28                	je     f010ad61 <envid2env+0xb8>
f010ad39:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad3c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ad3f:	74 20                	je     f010ad61 <envid2env+0xb8>
f010ad41:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ad44:	8b 50 14             	mov    0x14(%eax),%edx
f010ad47:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ad4a:	8b 40 10             	mov    0x10(%eax),%eax
f010ad4d:	39 c2                	cmp    %eax,%edx
f010ad4f:	74 10                	je     f010ad61 <envid2env+0xb8>
		*env_store = 0;
f010ad51:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ad54:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010ad5a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010ad5f:	eb 0d                	jmp    f010ad6e <envid2env+0xc5>
	}

	*env_store = e;
f010ad61:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ad64:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ad67:	89 10                	mov    %edx,(%eax)
	return 0;
f010ad69:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ad6e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ad71:	c9                   	leave  
f010ad72:	c3                   	ret    

f010ad73 <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010ad73:	55                   	push   %ebp
f010ad74:	89 e5                	mov    %esp,%ebp
f010ad76:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010ad79:	83 ec 0c             	sub    $0xc,%esp
f010ad7c:	68 60 c4 5e f0       	push   $0xf05ec460
f010ad81:	e8 39 3e 00 00       	call   f010ebbf <acquire_spinlock>
f010ad86:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010ad89:	e8 cb fe ff ff       	call   f010ac59 <get_cpu_proc>
f010ad8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010ad91:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ad95:	75 19                	jne    f010adb0 <yield+0x3d>
f010ad97:	68 f4 4d 12 f0       	push   $0xf0124df4
f010ad9c:	68 df 4d 12 f0       	push   $0xf0124ddf
f010ada1:	68 4b 02 00 00       	push   $0x24b
f010ada6:	68 13 4d 12 f0       	push   $0xf0124d13
f010adab:	e8 89 55 ff ff       	call   f0100339 <_panic>
		p->env_status = ENV_READY;
f010adb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010adb3:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010adba:	e8 13 00 00 00       	call   f010add2 <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010adbf:	83 ec 0c             	sub    $0xc,%esp
f010adc2:	68 60 c4 5e f0       	push   $0xf05ec460
f010adc7:	e8 7a 3e 00 00       	call   f010ec46 <release_spinlock>
f010adcc:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010adcf:	90                   	nop
f010add0:	c9                   	leave  
f010add1:	c3                   	ret    

f010add2 <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010add2:	55                   	push   %ebp
f010add3:	89 e5                	mov    %esp,%ebp
f010add5:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010add8:	e8 7c fe ff ff       	call   f010ac59 <get_cpu_proc>
f010addd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010ade0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ade4:	75 19                	jne    f010adff <sched+0x2d>
f010ade6:	68 f4 4d 12 f0       	push   $0xf0124df4
f010adeb:	68 df 4d 12 f0       	push   $0xf0124ddf
f010adf0:	68 5f 02 00 00       	push   $0x25f
f010adf5:	68 13 4d 12 f0       	push   $0xf0124d13
f010adfa:	e8 3a 55 ff ff       	call   f0100339 <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010adff:	83 ec 0c             	sub    $0xc,%esp
f010ae02:	68 60 c4 5e f0       	push   $0xf05ec460
f010ae07:	e8 cc 3f 00 00       	call   f010edd8 <holding_spinlock>
f010ae0c:	83 c4 10             	add    $0x10,%esp
f010ae0f:	85 c0                	test   %eax,%eax
f010ae11:	75 17                	jne    f010ae2a <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010ae13:	83 ec 04             	sub    $0x4,%esp
f010ae16:	68 00 4e 12 f0       	push   $0xf0124e00
f010ae1b:	68 63 02 00 00       	push   $0x263
f010ae20:	68 13 4d 12 f0       	push   $0xf0124d13
f010ae25:	e8 0f 55 ff ff       	call   f0100339 <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010ae2a:	e8 15 c3 ff ff       	call   f0107144 <mycpu>
f010ae2f:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010ae35:	83 f8 01             	cmp    $0x1,%eax
f010ae38:	74 20                	je     f010ae5a <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010ae3a:	e8 05 c3 ff ff       	call   f0107144 <mycpu>
f010ae3f:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010ae45:	50                   	push   %eax
f010ae46:	68 42 4e 12 f0       	push   $0xf0124e42
f010ae4b:	68 66 02 00 00       	push   $0x266
f010ae50:	68 13 4d 12 f0       	push   $0xf0124d13
f010ae55:	e8 df 54 ff ff       	call   f0100339 <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010ae5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ae5d:	8b 40 18             	mov    0x18(%eax),%eax
f010ae60:	83 f8 02             	cmp    $0x2,%eax
f010ae63:	75 17                	jne    f010ae7c <sched+0xaa>
		panic("sched a running process");
f010ae65:	83 ec 04             	sub    $0x4,%esp
f010ae68:	68 59 4e 12 f0       	push   $0xf0124e59
f010ae6d:	68 69 02 00 00       	push   $0x269
f010ae72:	68 13 4d 12 f0       	push   $0xf0124d13
f010ae77:	e8 bd 54 ff ff       	call   f0100339 <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010ae7c:	9c                   	pushf  
f010ae7d:	58                   	pop    %eax
f010ae7e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010ae81:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010ae84:	25 00 02 00 00       	and    $0x200,%eax
f010ae89:	85 c0                	test   %eax,%eax
f010ae8b:	74 17                	je     f010aea4 <sched+0xd2>
		panic("sched is interruptible!");
f010ae8d:	83 ec 04             	sub    $0x4,%esp
f010ae90:	68 71 4e 12 f0       	push   $0xf0124e71
f010ae95:	68 6b 02 00 00       	push   $0x26b
f010ae9a:	68 13 4d 12 f0       	push   $0xf0124d13
f010ae9f:	e8 95 54 ff ff       	call   f0100339 <_panic>
	intena = mycpu()->intena;
f010aea4:	e8 9b c2 ff ff       	call   f0107144 <mycpu>
f010aea9:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010aeaf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010aeb2:	e8 8d c2 ff ff       	call   f0107144 <mycpu>
f010aeb7:	8b 40 04             	mov    0x4(%eax),%eax
f010aeba:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aebd:	83 c2 04             	add    $0x4,%edx
f010aec0:	83 ec 08             	sub    $0x8,%esp
f010aec3:	50                   	push   %eax
f010aec4:	52                   	push   %edx
f010aec5:	e8 e8 9c ff ff       	call   f0104bb2 <context_switch>
f010aeca:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010aecd:	e8 72 c2 ff ff       	call   f0107144 <mycpu>
f010aed2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010aed5:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010aedb:	90                   	nop
f010aedc:	c9                   	leave  
f010aedd:	c3                   	ret    

f010aede <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010aede:	55                   	push   %ebp
f010aedf:	89 e5                	mov    %esp,%ebp
f010aee1:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010aee4:	a1 24 cc 5e f0       	mov    0xf05ecc24,%eax
f010aee9:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010aeec:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010aeef:	0f 22 d8             	mov    %eax,%cr3
}
f010aef2:	90                   	nop
f010aef3:	c9                   	leave  
f010aef4:	c3                   	ret    

f010aef5 <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010aef5:	55                   	push   %ebp
f010aef6:	89 e5                	mov    %esp,%ebp
f010aef8:	53                   	push   %ebx
f010aef9:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010aefc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010af00:	75 17                	jne    f010af19 <switchuvm+0x24>
		panic("switchuvm: no process");
f010af02:	83 ec 04             	sub    $0x4,%esp
f010af05:	68 89 4e 12 f0       	push   $0xf0124e89
f010af0a:	68 80 02 00 00       	push   $0x280
f010af0f:	68 13 4d 12 f0       	push   $0xf0124d13
f010af14:	e8 20 54 ff ff       	call   f0100339 <_panic>
	if(proc->kstack == 0)
f010af19:	8b 45 08             	mov    0x8(%ebp),%eax
f010af1c:	8b 40 70             	mov    0x70(%eax),%eax
f010af1f:	85 c0                	test   %eax,%eax
f010af21:	75 17                	jne    f010af3a <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010af23:	83 ec 04             	sub    $0x4,%esp
f010af26:	68 9f 4e 12 f0       	push   $0xf0124e9f
f010af2b:	68 82 02 00 00       	push   $0x282
f010af30:	68 13 4d 12 f0       	push   $0xf0124d13
f010af35:	e8 ff 53 ff ff       	call   f0100339 <_panic>
	if(proc->env_page_directory == 0)
f010af3a:	8b 45 08             	mov    0x8(%ebp),%eax
f010af3d:	8b 40 64             	mov    0x64(%eax),%eax
f010af40:	85 c0                	test   %eax,%eax
f010af42:	75 17                	jne    f010af5b <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010af44:	83 ec 04             	sub    $0x4,%esp
f010af47:	68 b4 4e 12 f0       	push   $0xf0124eb4
f010af4c:	68 84 02 00 00       	push   $0x284
f010af51:	68 13 4d 12 f0       	push   $0xf0124d13
f010af56:	e8 de 53 ff ff       	call   f0100339 <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010af5b:	e8 a7 c2 ff ff       	call   f0107207 <pushcli>
	struct cpu* c = mycpu();
f010af60:	e8 df c1 ff ff       	call   f0107144 <mycpu>
f010af65:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010af68:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af6b:	8b 55 08             	mov    0x8(%ebp),%edx
f010af6e:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010af74:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af77:	83 c0 0c             	add    $0xc,%eax
f010af7a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af7d:	83 c2 0c             	add    $0xc,%edx
f010af80:	c1 ea 10             	shr    $0x10,%edx
f010af83:	88 d3                	mov    %dl,%bl
f010af85:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af88:	83 c2 0c             	add    $0xc,%edx
f010af8b:	c1 ea 18             	shr    $0x18,%edx
f010af8e:	88 d1                	mov    %dl,%cl
f010af90:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af93:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010af9a:	68 00 
f010af9c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af9f:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010afa6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010afa9:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010afaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010afb2:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010afb8:	83 e2 f0             	and    $0xfffffff0,%edx
f010afbb:	83 ca 09             	or     $0x9,%edx
f010afbe:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010afc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010afc7:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010afcd:	83 ca 10             	or     $0x10,%edx
f010afd0:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010afd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010afd9:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010afdf:	83 e2 9f             	and    $0xffffff9f,%edx
f010afe2:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010afe8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010afeb:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010aff1:	83 ca 80             	or     $0xffffff80,%edx
f010aff4:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010affa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010affd:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b003:	83 e2 f0             	and    $0xfffffff0,%edx
f010b006:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b00c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b00f:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b015:	83 e2 ef             	and    $0xffffffef,%edx
f010b018:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b01e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b021:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b027:	83 e2 df             	and    $0xffffffdf,%edx
f010b02a:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b030:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b033:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b039:	83 ca 40             	or     $0x40,%edx
f010b03c:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b042:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b045:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010b04b:	83 e2 7f             	and    $0x7f,%edx
f010b04e:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010b054:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b057:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010b05d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b060:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010b066:	83 e2 ef             	and    $0xffffffef,%edx
f010b069:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010b06f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b072:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b078:	8b 40 70             	mov    0x70(%eax),%eax
f010b07b:	05 00 80 00 00       	add    $0x8000,%eax
f010b080:	89 c2                	mov    %eax,%edx
f010b082:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b085:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010b088:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b08b:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010b091:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010b097:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010b09b:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010b09e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b0a1:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b0a7:	8b 40 68             	mov    0x68(%eax),%eax
f010b0aa:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b0ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b0b0:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010b0b3:	e8 a1 c1 ff ff       	call   f0107259 <popcli>
}
f010b0b8:	90                   	nop
f010b0b9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b0bc:	c9                   	leave  
f010b0bd:	c3                   	ret    

f010b0be <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010b0be:	55                   	push   %ebp
f010b0bf:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010b0c1:	8b 15 74 39 5c f0    	mov    0xf05c3974,%edx
f010b0c7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0ca:	89 10                	mov    %edx,(%eax)
f010b0cc:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0cf:	8b 00                	mov    (%eax),%eax
f010b0d1:	85 c0                	test   %eax,%eax
f010b0d3:	75 07                	jne    f010b0dc <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010b0d5:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010b0da:	eb 11                	jmp    f010b0ed <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010b0dc:	8b 45 08             	mov    0x8(%ebp),%eax
f010b0df:	8b 00                	mov    (%eax),%eax
f010b0e1:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010b0e8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b0ed:	5d                   	pop    %ebp
f010b0ee:	c3                   	ret    

f010b0ef <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010b0ef:	55                   	push   %ebp
f010b0f0:	89 e5                	mov    %esp,%ebp
f010b0f2:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010b0f5:	83 ec 04             	sub    $0x4,%esp
f010b0f8:	68 b0 05 00 00       	push   $0x5b0
f010b0fd:	6a 00                	push   $0x0
f010b0ff:	ff 75 08             	pushl  0x8(%ebp)
f010b102:	e8 c6 3c 01 00       	call   f011edcd <memset>
f010b107:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010b10a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b10d:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010b114:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b118:	75 17                	jne    f010b131 <free_environment+0x42>
f010b11a:	83 ec 04             	sub    $0x4,%esp
f010b11d:	68 f0 4c 12 f0       	push   $0xf0124cf0
f010b122:	68 bf 02 00 00       	push   $0x2bf
f010b127:	68 13 4d 12 f0       	push   $0xf0124d13
f010b12c:	e8 08 52 ff ff       	call   f0100339 <_panic>
f010b131:	8b 15 74 39 5c f0    	mov    0xf05c3974,%edx
f010b137:	8b 45 08             	mov    0x8(%ebp),%eax
f010b13a:	89 50 08             	mov    %edx,0x8(%eax)
f010b13d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b140:	8b 40 08             	mov    0x8(%eax),%eax
f010b143:	85 c0                	test   %eax,%eax
f010b145:	74 0d                	je     f010b154 <free_environment+0x65>
f010b147:	a1 74 39 5c f0       	mov    0xf05c3974,%eax
f010b14c:	8b 55 08             	mov    0x8(%ebp),%edx
f010b14f:	89 50 0c             	mov    %edx,0xc(%eax)
f010b152:	eb 08                	jmp    f010b15c <free_environment+0x6d>
f010b154:	8b 45 08             	mov    0x8(%ebp),%eax
f010b157:	a3 78 39 5c f0       	mov    %eax,0xf05c3978
f010b15c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b15f:	a3 74 39 5c f0       	mov    %eax,0xf05c3974
f010b164:	8b 45 08             	mov    0x8(%ebp),%eax
f010b167:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010b16e:	a1 80 39 5c f0       	mov    0xf05c3980,%eax
f010b173:	40                   	inc    %eax
f010b174:	a3 80 39 5c f0       	mov    %eax,0xf05c3980
}
f010b179:	90                   	nop
f010b17a:	c9                   	leave  
f010b17b:	c3                   	ret    

f010b17c <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010b17c:	55                   	push   %ebp
f010b17d:	89 e5                	mov    %esp,%ebp
f010b17f:	53                   	push   %ebx
f010b180:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010b183:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b186:	8b 40 0c             	mov    0xc(%eax),%eax
f010b189:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010b18c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b18f:	8b 40 08             	mov    0x8(%eax),%eax
f010b192:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010b195:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010b19c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010b19f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b1a2:	01 c2                	add    %eax,%edx
f010b1a4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b1a7:	01 d0                	add    %edx,%eax
f010b1a9:	48                   	dec    %eax
f010b1aa:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010b1ad:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b1b0:	ba 00 00 00 00       	mov    $0x0,%edx
f010b1b5:	f7 75 dc             	divl   -0x24(%ebp)
f010b1b8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b1bb:	29 d0                	sub    %edx,%eax
f010b1bd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010b1c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b1c3:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010b1c6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b1c9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b1ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010b1d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010b1d8:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010b1df:	8b 45 10             	mov    0x10(%ebp),%eax
f010b1e2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010b1e8:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010b1ef:	0f 85 f5 03 00 00    	jne    f010b5ea <program_segment_alloc_map_copy_workingset+0x46e>
f010b1f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1f8:	83 c0 20             	add    $0x20,%eax
f010b1fb:	83 ec 08             	sub    $0x8,%esp
f010b1fe:	68 c8 4e 12 f0       	push   $0xf0124ec8
f010b203:	50                   	push   %eax
f010b204:	e8 e2 3a 01 00       	call   f011eceb <strcmp>
f010b209:	83 c4 10             	add    $0x10,%esp
f010b20c:	85 c0                	test   %eax,%eax
f010b20e:	0f 84 d6 03 00 00    	je     f010b5ea <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010b214:	8b 45 14             	mov    0x14(%ebp),%eax
f010b217:	83 f8 06             	cmp    $0x6,%eax
f010b21a:	76 05                	jbe    f010b221 <program_segment_alloc_map_copy_workingset+0xa5>
f010b21c:	b8 06 00 00 00       	mov    $0x6,%eax
f010b221:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010b224:	e9 c1 03 00 00       	jmp    f010b5ea <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010b229:	83 ec 0c             	sub    $0xc,%esp
f010b22c:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010b22f:	50                   	push   %eax
f010b230:	e8 4d d0 ff ff       	call   f0108282 <allocate_frame>
f010b235:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010b238:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010b23b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b23e:	8b 40 64             	mov    0x64(%eax),%eax
f010b241:	6a 06                	push   $0x6
f010b243:	ff 75 f4             	pushl  -0xc(%ebp)
f010b246:	52                   	push   %edx
f010b247:	50                   	push   %eax
f010b248:	e8 06 d7 ff ff       	call   f0108953 <loadtime_map_frame>
f010b24d:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010b250:	83 ec 08             	sub    $0x8,%esp
f010b253:	ff 75 f4             	pushl  -0xc(%ebp)
f010b256:	ff 75 08             	pushl  0x8(%ebp)
f010b259:	e8 d6 e0 ff ff       	call   f0109334 <env_page_ws_list_create_element>
f010b25e:	83 c4 10             	add    $0x10,%esp
f010b261:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010b264:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b267:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010b26e:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b272:	75 17                	jne    f010b28b <program_segment_alloc_map_copy_workingset+0x10f>
f010b274:	83 ec 04             	sub    $0x4,%esp
f010b277:	68 78 4d 12 f0       	push   $0xf0124d78
f010b27c:	68 e9 02 00 00       	push   $0x2e9
f010b281:	68 13 4d 12 f0       	push   $0xf0124d13
f010b286:	e8 ae 50 ff ff       	call   f0100339 <_panic>
f010b28b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b28e:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f010b294:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b297:	89 50 14             	mov    %edx,0x14(%eax)
f010b29a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b29d:	8b 40 14             	mov    0x14(%eax),%eax
f010b2a0:	85 c0                	test   %eax,%eax
f010b2a2:	74 11                	je     f010b2b5 <program_segment_alloc_map_copy_workingset+0x139>
f010b2a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2a7:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f010b2ad:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b2b0:	89 50 10             	mov    %edx,0x10(%eax)
f010b2b3:	eb 0c                	jmp    f010b2c1 <program_segment_alloc_map_copy_workingset+0x145>
f010b2b5:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2b8:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b2bb:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010b2c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2c4:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b2c7:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010b2cd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b2d0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b2d7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2da:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010b2e0:	8d 50 01             	lea    0x1(%eax),%edx
f010b2e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010b2e6:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b2ec:	83 ec 0c             	sub    $0xc,%esp
f010b2ef:	6a 02                	push   $0x2
f010b2f1:	e8 68 34 00 00       	call   f010e75e <isPageReplacmentAlgorithmLRU>
f010b2f6:	83 c4 10             	add    $0x10,%esp
f010b2f9:	85 c0                	test   %eax,%eax
f010b2fb:	0f 84 b3 01 00 00    	je     f010b4b4 <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			LIST_REMOVE(&(e->page_WS_list), wse);
f010b301:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b305:	75 17                	jne    f010b31e <program_segment_alloc_map_copy_workingset+0x1a2>
f010b307:	83 ec 04             	sub    $0x4,%esp
f010b30a:	68 9b 4d 12 f0       	push   $0xf0124d9b
f010b30f:	68 f5 02 00 00       	push   $0x2f5
f010b314:	68 13 4d 12 f0       	push   $0xf0124d13
f010b319:	e8 1b 50 ff ff       	call   f0100339 <_panic>
f010b31e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b321:	8b 40 10             	mov    0x10(%eax),%eax
f010b324:	85 c0                	test   %eax,%eax
f010b326:	74 11                	je     f010b339 <program_segment_alloc_map_copy_workingset+0x1bd>
f010b328:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b32b:	8b 40 10             	mov    0x10(%eax),%eax
f010b32e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b331:	8b 52 14             	mov    0x14(%edx),%edx
f010b334:	89 50 14             	mov    %edx,0x14(%eax)
f010b337:	eb 0f                	jmp    f010b348 <program_segment_alloc_map_copy_workingset+0x1cc>
f010b339:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b33c:	8b 50 14             	mov    0x14(%eax),%edx
f010b33f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b342:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010b348:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b34b:	8b 40 14             	mov    0x14(%eax),%eax
f010b34e:	85 c0                	test   %eax,%eax
f010b350:	74 11                	je     f010b363 <program_segment_alloc_map_copy_workingset+0x1e7>
f010b352:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b355:	8b 40 14             	mov    0x14(%eax),%eax
f010b358:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b35b:	8b 52 10             	mov    0x10(%edx),%edx
f010b35e:	89 50 10             	mov    %edx,0x10(%eax)
f010b361:	eb 0f                	jmp    f010b372 <program_segment_alloc_map_copy_workingset+0x1f6>
f010b363:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b366:	8b 50 10             	mov    0x10(%eax),%edx
f010b369:	8b 45 08             	mov    0x8(%ebp),%eax
f010b36c:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010b372:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b375:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b37c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b37f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b386:	8b 45 08             	mov    0x8(%ebp),%eax
f010b389:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010b38f:	8d 50 ff             	lea    -0x1(%eax),%edx
f010b392:	8b 45 08             	mov    0x8(%ebp),%eax
f010b395:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010b39b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b39e:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010b3a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3a7:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010b3ad:	48                   	dec    %eax
f010b3ae:	39 c2                	cmp    %eax,%edx
f010b3b0:	0f 83 80 00 00 00    	jae    f010b436 <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010b3b6:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b3ba:	75 17                	jne    f010b3d3 <program_segment_alloc_map_copy_workingset+0x257>
f010b3bc:	83 ec 04             	sub    $0x4,%esp
f010b3bf:	68 f0 4c 12 f0       	push   $0xf0124cf0
f010b3c4:	68 f9 02 00 00       	push   $0x2f9
f010b3c9:	68 13 4d 12 f0       	push   $0xf0124d13
f010b3ce:	e8 66 4f ff ff       	call   f0100339 <_panic>
f010b3d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3d6:	8b 90 54 05 00 00    	mov    0x554(%eax),%edx
f010b3dc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b3df:	89 50 10             	mov    %edx,0x10(%eax)
f010b3e2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b3e5:	8b 40 10             	mov    0x10(%eax),%eax
f010b3e8:	85 c0                	test   %eax,%eax
f010b3ea:	74 11                	je     f010b3fd <program_segment_alloc_map_copy_workingset+0x281>
f010b3ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3ef:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f010b3f5:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b3f8:	89 50 14             	mov    %edx,0x14(%eax)
f010b3fb:	eb 0c                	jmp    f010b409 <program_segment_alloc_map_copy_workingset+0x28d>
f010b3fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b400:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b403:	89 90 58 05 00 00    	mov    %edx,0x558(%eax)
f010b409:	8b 45 08             	mov    0x8(%ebp),%eax
f010b40c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b40f:	89 90 54 05 00 00    	mov    %edx,0x554(%eax)
f010b415:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b418:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b41f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b422:	8b 80 60 05 00 00    	mov    0x560(%eax),%eax
f010b428:	8d 50 01             	lea    0x1(%eax),%edx
f010b42b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b42e:	89 90 60 05 00 00    	mov    %edx,0x560(%eax)
f010b434:	eb 7e                	jmp    f010b4b4 <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010b436:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010b43a:	75 17                	jne    f010b453 <program_segment_alloc_map_copy_workingset+0x2d7>
f010b43c:	83 ec 04             	sub    $0x4,%esp
f010b43f:	68 f0 4c 12 f0       	push   $0xf0124cf0
f010b444:	68 fe 02 00 00       	push   $0x2fe
f010b449:	68 13 4d 12 f0       	push   $0xf0124d13
f010b44e:	e8 e6 4e ff ff       	call   f0100339 <_panic>
f010b453:	8b 45 08             	mov    0x8(%ebp),%eax
f010b456:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010b45c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b45f:	89 50 10             	mov    %edx,0x10(%eax)
f010b462:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b465:	8b 40 10             	mov    0x10(%eax),%eax
f010b468:	85 c0                	test   %eax,%eax
f010b46a:	74 11                	je     f010b47d <program_segment_alloc_map_copy_workingset+0x301>
f010b46c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b46f:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010b475:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b478:	89 50 14             	mov    %edx,0x14(%eax)
f010b47b:	eb 0c                	jmp    f010b489 <program_segment_alloc_map_copy_workingset+0x30d>
f010b47d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b480:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b483:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010b489:	8b 45 08             	mov    0x8(%ebp),%eax
f010b48c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b48f:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
f010b495:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b498:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b49f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4a2:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010b4a8:	8d 50 01             	lea    0x1(%eax),%edx
f010b4ab:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4ae:	89 90 70 05 00 00    	mov    %edx,0x570(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010b4b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4b7:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010b4bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4c0:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010b4c6:	39 c2                	cmp    %eax,%edx
f010b4c8:	75 14                	jne    f010b4de <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010b4ca:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4cd:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f010b4d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4d6:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b4dc:	eb 0d                	jmp    f010b4eb <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010b4de:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4e1:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010b4e8:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010b4eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b4ee:	c1 e8 16             	shr    $0x16,%eax
f010b4f1:	89 c2                	mov    %eax,%edx
f010b4f3:	8b 45 18             	mov    0x18(%ebp),%eax
f010b4f6:	8b 00                	mov    (%eax),%eax
f010b4f8:	39 c2                	cmp    %eax,%edx
f010b4fa:	0f 84 d3 00 00 00    	je     f010b5d3 <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010b500:	8b 45 08             	mov    0x8(%ebp),%eax
f010b503:	8b 90 50 05 00 00    	mov    0x550(%eax),%edx
f010b509:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b50c:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010b50f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010b512:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010b517:	89 c1                	mov    %eax,%ecx
f010b519:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010b51c:	89 d0                	mov    %edx,%eax
f010b51e:	01 c0                	add    %eax,%eax
f010b520:	01 d0                	add    %edx,%eax
f010b522:	c1 e0 03             	shl    $0x3,%eax
f010b525:	01 d8                	add    %ebx,%eax
f010b527:	05 a0 00 00 00       	add    $0xa0,%eax
f010b52c:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010b52e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b531:	8b 90 50 05 00 00    	mov    0x550(%eax),%edx
f010b537:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b53a:	89 d0                	mov    %edx,%eax
f010b53c:	01 c0                	add    %eax,%eax
f010b53e:	01 d0                	add    %edx,%eax
f010b540:	c1 e0 03             	shl    $0x3,%eax
f010b543:	01 c8                	add    %ecx,%eax
f010b545:	05 a4 00 00 00       	add    $0xa4,%eax
f010b54a:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010b54d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b550:	8b 90 50 05 00 00    	mov    0x550(%eax),%edx
f010b556:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b559:	89 d0                	mov    %edx,%eax
f010b55b:	01 c0                	add    %eax,%eax
f010b55d:	01 d0                	add    %edx,%eax
f010b55f:	c1 e0 03             	shl    $0x3,%eax
f010b562:	01 c8                	add    %ecx,%eax
f010b564:	05 a8 00 00 00       	add    $0xa8,%eax
f010b569:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010b56f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b572:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
f010b578:	8d 50 01             	lea    0x1(%eax),%edx
f010b57b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b57e:	89 90 50 05 00 00    	mov    %edx,0x550(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010b584:	8b 45 08             	mov    0x8(%ebp),%eax
f010b587:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
f010b58d:	b9 32 00 00 00       	mov    $0x32,%ecx
f010b592:	ba 00 00 00 00       	mov    $0x0,%edx
f010b597:	f7 f1                	div    %ecx
f010b599:	8b 45 08             	mov    0x8(%ebp),%eax
f010b59c:	89 90 50 05 00 00    	mov    %edx,0x550(%eax)
			if (e->table_last_WS_index == 0)
f010b5a2:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5a5:	8b 80 50 05 00 00    	mov    0x550(%eax),%eax
f010b5ab:	85 c0                	test   %eax,%eax
f010b5ad:	75 17                	jne    f010b5c6 <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010b5af:	83 ec 04             	sub    $0x4,%esp
f010b5b2:	68 cc 4e 12 f0       	push   $0xf0124ecc
f010b5b7:	68 26 03 00 00       	push   $0x326
f010b5bc:	68 13 4d 12 f0       	push   $0xf0124d13
f010b5c1:	e8 73 4d ff ff       	call   f0100339 <_panic>
			(*lastTableNumber) = PDX(iVA);
f010b5c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b5c9:	c1 e8 16             	shr    $0x16,%eax
f010b5cc:	89 c2                	mov    %eax,%edx
f010b5ce:	8b 45 18             	mov    0x18(%ebp),%eax
f010b5d1:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010b5d3:	8b 45 10             	mov    0x10(%ebp),%eax
f010b5d6:	8b 00                	mov    (%eax),%eax
f010b5d8:	8d 50 01             	lea    0x1(%eax),%edx
f010b5db:	8b 45 10             	mov    0x10(%ebp),%eax
f010b5de:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010b5e0:	ff 45 f0             	incl   -0x10(%ebp)
f010b5e3:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010b5ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b5ed:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010b5f0:	73 0c                	jae    f010b5fe <program_segment_alloc_map_copy_workingset+0x482>
f010b5f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b5f5:	3b 45 14             	cmp    0x14(%ebp),%eax
f010b5f8:	0f 82 2b fc ff ff    	jb     f010b229 <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010b5fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b601:	8b 00                	mov    (%eax),%eax
f010b603:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010b606:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b609:	8b 40 0c             	mov    0xc(%eax),%eax
f010b60c:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b60f:	eb 10                	jmp    f010b621 <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010b611:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b614:	8a 10                	mov    (%eax),%dl
f010b616:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b619:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010b61b:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010b61e:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b621:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b624:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010b627:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b62a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b62f:	89 c2                	mov    %eax,%edx
f010b631:	8b 45 10             	mov    0x10(%ebp),%eax
f010b634:	8b 00                	mov    (%eax),%eax
f010b636:	c1 e0 0c             	shl    $0xc,%eax
f010b639:	01 c2                	add    %eax,%edx
f010b63b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b63e:	39 c2                	cmp    %eax,%edx
f010b640:	76 1d                	jbe    f010b65f <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010b642:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b645:	8b 50 04             	mov    0x4(%eax),%edx
f010b648:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b64b:	01 c2                	add    %eax,%edx
f010b64d:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b650:	39 c2                	cmp    %eax,%edx
f010b652:	77 bd                	ja     f010b611 <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010b654:	eb 09                	jmp    f010b65f <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010b656:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b659:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010b65c:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010b65f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b662:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010b665:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b668:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b66d:	89 c2                	mov    %eax,%edx
f010b66f:	8b 45 10             	mov    0x10(%ebp),%eax
f010b672:	8b 00                	mov    (%eax),%eax
f010b674:	c1 e0 0c             	shl    $0xc,%eax
f010b677:	01 c2                	add    %eax,%edx
f010b679:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b67c:	39 c2                	cmp    %eax,%edx
f010b67e:	77 d6                	ja     f010b656 <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010b680:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b685:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b688:	c9                   	leave  
f010b689:	c3                   	ret    

f010b68a <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010b68a:	55                   	push   %ebp
f010b68b:	89 e5                	mov    %esp,%ebp
f010b68d:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010b690:	83 ec 0c             	sub    $0xc,%esp
f010b693:	68 00 10 00 00       	push   $0x1000
f010b698:	e8 93 d7 ff ff       	call   f0108e30 <kmalloc>
f010b69d:	83 c4 10             	add    $0x10,%esp
f010b6a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010b6a3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b6a7:	75 17                	jne    f010b6c0 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010b6a9:	83 ec 04             	sub    $0x4,%esp
f010b6ac:	68 6f 4f 12 f0       	push   $0xf0124f6f
f010b6b1:	68 56 03 00 00       	push   $0x356
f010b6b6:	68 13 4d 12 f0       	push   $0xf0124d13
f010b6bb:	e8 79 4c ff ff       	call   f0100339 <_panic>
	}
	return ptr_user_page_directory;
f010b6c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010b6c3:	c9                   	leave  
f010b6c4:	c3                   	ret    

f010b6c5 <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010b6c5:	55                   	push   %ebp
f010b6c6:	89 e5                	mov    %esp,%ebp
f010b6c8:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//TODO: [PROJECT'24.MS2 - #07] [2] FAULT HANDLER I - create_user_kern_stack
	// Write your code here, remove the panic and write your code
	panic("create_user_kern_stack() is not implemented yet...!!");
f010b6cb:	83 ec 04             	sub    $0x4,%esp
f010b6ce:	68 8c 4f 12 f0       	push   $0xf0124f8c
f010b6d3:	68 66 03 00 00       	push   $0x366
f010b6d8:	68 13 4d 12 f0       	push   $0xf0124d13
f010b6dd:	e8 57 4c ff ff       	call   f0100339 <_panic>

f010b6e2 <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010b6e2:	55                   	push   %ebp
f010b6e3:	89 e5                	mov    %esp,%ebp
f010b6e5:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//[PROJECT'24.MS3] BONUS
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010b6e8:	83 ec 04             	sub    $0x4,%esp
f010b6eb:	68 c4 4f 12 f0       	push   $0xf0124fc4
f010b6f0:	68 81 03 00 00       	push   $0x381
f010b6f5:	68 13 4d 12 f0       	push   $0xf0124d13
f010b6fa:	e8 3a 4c ff ff       	call   f0100339 <_panic>

f010b6ff <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010b6ff:	55                   	push   %ebp
f010b700:	89 e5                	mov    %esp,%ebp
	//TODO: [PROJECT'24.MS2 - #10] [3] USER HEAP - initialize_uheap_dynamic_allocator
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
}
f010b702:	90                   	nop
f010b703:	5d                   	pop    %ebp
f010b704:	c3                   	ret    

f010b705 <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010b705:	55                   	push   %ebp
f010b706:	89 e5                	mov    %esp,%ebp
f010b708:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010b70b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b70e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b711:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010b714:	8b 45 08             	mov    0x8(%ebp),%eax
f010b717:	8b 55 10             	mov    0x10(%ebp),%edx
f010b71a:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010b71d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b724:	eb 17                	jmp    f010b73d <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010b726:	8b 45 08             	mov    0x8(%ebp),%eax
f010b729:	8b 40 64             	mov    0x64(%eax),%eax
f010b72c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b72f:	c1 e2 02             	shl    $0x2,%edx
f010b732:	01 d0                	add    %edx,%eax
f010b734:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010b73a:	ff 45 f4             	incl   -0xc(%ebp)
f010b73d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b740:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010b745:	76 df                	jbe    f010b726 <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010b747:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010b74e:	eb 22                	jmp    f010b772 <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010b750:	8b 45 08             	mov    0x8(%ebp),%eax
f010b753:	8b 40 64             	mov    0x64(%eax),%eax
f010b756:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b759:	c1 e2 02             	shl    $0x2,%edx
f010b75c:	01 c2                	add    %eax,%edx
f010b75e:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f010b763:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010b766:	c1 e1 02             	shl    $0x2,%ecx
f010b769:	01 c8                	add    %ecx,%eax
f010b76b:	8b 00                	mov    (%eax),%eax
f010b76d:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010b76f:	ff 45 f4             	incl   -0xc(%ebp)
f010b772:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010b779:	7e d5                	jle    f010b750 <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010b77b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b77e:	8b 40 64             	mov    0x64(%eax),%eax
f010b781:	83 ec 0c             	sub    $0xc,%esp
f010b784:	50                   	push   %eax
f010b785:	e8 3b ff ff ff       	call   f010b6c5 <create_user_kern_stack>
f010b78a:	83 c4 10             	add    $0x10,%esp
f010b78d:	89 c2                	mov    %eax,%edx
f010b78f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b792:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010b795:	8b 45 08             	mov    0x8(%ebp),%eax
f010b798:	8b 40 70             	mov    0x70(%eax),%eax
f010b79b:	05 00 80 00 00       	add    $0x8000,%eax
f010b7a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010b7a3:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010b7a7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7aa:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b7ad:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010b7af:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010b7b3:	ba d6 d7 10 f0       	mov    $0xf010d7d6,%edx
f010b7b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b7bb:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010b7bd:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010b7c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7c4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b7c7:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010b7ca:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7cd:	8b 40 04             	mov    0x4(%eax),%eax
f010b7d0:	83 ec 04             	sub    $0x4,%esp
f010b7d3:	6a 20                	push   $0x20
f010b7d5:	6a 00                	push   $0x0
f010b7d7:	50                   	push   %eax
f010b7d8:	e8 f0 35 01 00       	call   f011edcd <memset>
f010b7dd:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010b7e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7e3:	8b 40 04             	mov    0x4(%eax),%eax
f010b7e6:	ba bf ab 10 f0       	mov    $0xf010abbf,%edx
f010b7eb:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010b7ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7f1:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010b7f8:	00 00 00 
f010b7fb:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7fe:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010b805:	00 00 00 
f010b808:	8b 45 08             	mov    0x8(%ebp),%eax
f010b80b:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010b812:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b815:	83 ec 0c             	sub    $0xc,%esp
f010b818:	6a 02                	push   $0x2
f010b81a:	e8 3f 2f 00 00       	call   f010e75e <isPageReplacmentAlgorithmLRU>
f010b81f:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010b822:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b829:	eb 54                	jmp    f010b87f <initialize_environment+0x17a>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010b82b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b82e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b831:	89 d0                	mov    %edx,%eax
f010b833:	01 c0                	add    %eax,%eax
f010b835:	01 d0                	add    %edx,%eax
f010b837:	c1 e0 03             	shl    $0x3,%eax
f010b83a:	01 c8                	add    %ecx,%eax
f010b83c:	05 a0 00 00 00       	add    $0xa0,%eax
f010b841:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010b847:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b84a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b84d:	89 d0                	mov    %edx,%eax
f010b84f:	01 c0                	add    %eax,%eax
f010b851:	01 d0                	add    %edx,%eax
f010b853:	c1 e0 03             	shl    $0x3,%eax
f010b856:	01 c8                	add    %ecx,%eax
f010b858:	05 a4 00 00 00       	add    $0xa4,%eax
f010b85d:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010b860:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b863:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b866:	89 d0                	mov    %edx,%eax
f010b868:	01 c0                	add    %eax,%eax
f010b86a:	01 d0                	add    %edx,%eax
f010b86c:	c1 e0 03             	shl    $0x3,%eax
f010b86f:	01 c8                	add    %ecx,%eax
f010b871:	05 a8 00 00 00       	add    $0xa8,%eax
f010b876:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010b87c:	ff 45 f4             	incl   -0xc(%ebp)
f010b87f:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010b883:	7e a6                	jle    f010b82b <initialize_environment+0x126>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010b885:	8b 45 08             	mov    0x8(%ebp),%eax
f010b888:	c7 80 50 05 00 00 00 	movl   $0x0,0x550(%eax)
f010b88f:	00 00 00 

	e->pageFaultsCounter=0;
f010b892:	8b 45 08             	mov    0x8(%ebp),%eax
f010b895:	c7 80 84 05 00 00 00 	movl   $0x0,0x584(%eax)
f010b89c:	00 00 00 
	e->tableFaultsCounter=0;
f010b89f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8a2:	c7 80 88 05 00 00 00 	movl   $0x0,0x588(%eax)
f010b8a9:	00 00 00 

	e->freeingFullWSCounter = 0;
f010b8ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8af:	c7 80 8c 05 00 00 00 	movl   $0x0,0x58c(%eax)
f010b8b6:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010b8b9:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8bc:	c7 80 90 05 00 00 00 	movl   $0x0,0x590(%eax)
f010b8c3:	00 00 00 

	e->nModifiedPages=0;
f010b8c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8c9:	c7 80 94 05 00 00 00 	movl   $0x0,0x594(%eax)
f010b8d0:	00 00 00 
	e->nNotModifiedPages=0;
f010b8d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8d6:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010b8dd:	00 00 00 
	e->nClocks = 0;
f010b8e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8e3:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010b8ea:	00 00 00 

	//2020
	e->nPageIn = 0;
f010b8ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8f0:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010b8f7:	00 00 00 
	e->nPageOut = 0;
f010b8fa:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8fd:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010b904:	00 00 00 
	e->nNewPageAdded = 0;
f010b907:	8b 45 08             	mov    0x8(%ebp),%eax
f010b90a:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010b911:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010b914:	83 ec 04             	sub    $0x4,%esp
f010b917:	68 00 00 00 82       	push   $0x82000000
f010b91c:	68 00 00 00 80       	push   $0x80000000
f010b921:	ff 75 08             	pushl  0x8(%ebp)
f010b924:	e8 d6 fd ff ff       	call   f010b6ff <initialize_uheap_dynamic_allocator>
f010b929:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010b92c:	83 ec 0c             	sub    $0xc,%esp
f010b92f:	ff 75 08             	pushl  0x8(%ebp)
f010b932:	e8 06 00 00 00       	call   f010b93d <complete_environment_initialization>
f010b937:	83 c4 10             	add    $0x10,%esp
}
f010b93a:	90                   	nop
f010b93b:	c9                   	leave  
f010b93c:	c3                   	ret    

f010b93d <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010b93d:	55                   	push   %ebp
f010b93e:	89 e5                	mov    %esp,%ebp
f010b940:	53                   	push   %ebx
f010b941:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010b944:	8b 45 08             	mov    0x8(%ebp),%eax
f010b947:	8b 40 64             	mov    0x64(%eax),%eax
f010b94a:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010b950:	8b 45 08             	mov    0x8(%ebp),%eax
f010b953:	8b 40 68             	mov    0x68(%eax),%eax
f010b956:	83 c8 03             	or     $0x3,%eax
f010b959:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010b95b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b95e:	8b 40 64             	mov    0x64(%eax),%eax
f010b961:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010b967:	8b 45 08             	mov    0x8(%ebp),%eax
f010b96a:	8b 40 68             	mov    0x68(%eax),%eax
f010b96d:	83 c8 05             	or     $0x5,%eax
f010b970:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010b972:	8b 45 08             	mov    0x8(%ebp),%eax
f010b975:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	e->disk_env_pgdir_PA= 0;
f010b97c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b97f:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	e->disk_env_tabledir = 0;
f010b986:	8b 45 08             	mov    0x8(%ebp),%eax
f010b989:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	e->disk_env_tabledir_PA = 0;
f010b990:	8b 45 08             	mov    0x8(%ebp),%eax
f010b993:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010b99a:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010b99d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b9a0:	8b 58 10             	mov    0x10(%eax),%ebx
f010b9a3:	83 ec 0c             	sub    $0xc,%esp
f010b9a6:	68 d0 02 00 00       	push   $0x2d0
f010b9ab:	e8 c2 17 01 00       	call   f011d172 <log2_ceil>
f010b9b0:	83 c4 10             	add    $0x10,%esp
f010b9b3:	ba 01 00 00 00       	mov    $0x1,%edx
f010b9b8:	88 c1                	mov    %al,%cl
f010b9ba:	d3 e2                	shl    %cl,%edx
f010b9bc:	89 d0                	mov    %edx,%eax
f010b9be:	01 d8                	add    %ebx,%eax
f010b9c0:	89 c3                	mov    %eax,%ebx
f010b9c2:	83 ec 0c             	sub    $0xc,%esp
f010b9c5:	68 d0 02 00 00       	push   $0x2d0
f010b9ca:	e8 6e 17 01 00       	call   f011d13d <nearest_pow2_ceil>
f010b9cf:	83 c4 10             	add    $0x10,%esp
f010b9d2:	f7 d8                	neg    %eax
f010b9d4:	21 d8                	and    %ebx,%eax
f010b9d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010b9d9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b9dd:	7f 1e                	jg     f010b9fd <complete_environment_initialization+0xc0>
		generation = 1 << ENVGENSHIFT;
f010b9df:	83 ec 0c             	sub    $0xc,%esp
f010b9e2:	68 d0 02 00 00       	push   $0x2d0
f010b9e7:	e8 86 17 01 00       	call   f011d172 <log2_ceil>
f010b9ec:	83 c4 10             	add    $0x10,%esp
f010b9ef:	ba 01 00 00 00       	mov    $0x1,%edx
f010b9f4:	88 c1                	mov    %al,%cl
f010b9f6:	d3 e2                	shl    %cl,%edx
f010b9f8:	89 d0                	mov    %edx,%eax
f010b9fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010b9fd:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba00:	8b 15 70 39 5c f0    	mov    0xf05c3970,%edx
f010ba06:	29 d0                	sub    %edx,%eax
f010ba08:	c1 f8 04             	sar    $0x4,%eax
f010ba0b:	89 c2                	mov    %eax,%edx
f010ba0d:	89 d0                	mov    %edx,%eax
f010ba0f:	c1 e0 09             	shl    $0x9,%eax
f010ba12:	29 d0                	sub    %edx,%eax
f010ba14:	c1 e0 03             	shl    $0x3,%eax
f010ba17:	01 d0                	add    %edx,%eax
f010ba19:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010ba20:	01 c8                	add    %ecx,%eax
f010ba22:	c1 e0 03             	shl    $0x3,%eax
f010ba25:	01 d0                	add    %edx,%eax
f010ba27:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ba2e:	01 d0                	add    %edx,%eax
f010ba30:	89 c2                	mov    %eax,%edx
f010ba32:	c1 e2 09             	shl    $0x9,%edx
f010ba35:	01 d0                	add    %edx,%eax
f010ba37:	f7 d8                	neg    %eax
f010ba39:	0b 45 f4             	or     -0xc(%ebp),%eax
f010ba3c:	89 c2                	mov    %eax,%edx
f010ba3e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba41:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010ba44:	e8 10 f2 ff ff       	call   f010ac59 <get_cpu_proc>
f010ba49:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010ba4c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ba50:	75 0c                	jne    f010ba5e <complete_environment_initialization+0x121>
		e->env_parent_id = 0;//no parent;
f010ba52:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba55:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010ba5c:	eb 0c                	jmp    f010ba6a <complete_environment_initialization+0x12d>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010ba5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ba61:	8b 50 10             	mov    0x10(%eax),%edx
f010ba64:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba67:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010ba6a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba6d:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010ba74:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba77:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010ba7e:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010ba81:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba84:	8b 00                	mov    (%eax),%eax
f010ba86:	83 ec 04             	sub    $0x4,%esp
f010ba89:	6a 44                	push   $0x44
f010ba8b:	6a 00                	push   $0x0
f010ba8d:	50                   	push   %eax
f010ba8e:	e8 3a 33 01 00       	call   f011edcd <memset>
f010ba93:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010ba96:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba99:	8b 00                	mov    (%eax),%eax
f010ba9b:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010baa1:	8b 45 08             	mov    0x8(%ebp),%eax
f010baa4:	8b 00                	mov    (%eax),%eax
f010baa6:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010baac:	8b 45 08             	mov    0x8(%ebp),%eax
f010baaf:	8b 00                	mov    (%eax),%eax
f010bab1:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010bab7:	8b 45 08             	mov    0x8(%ebp),%eax
f010baba:	8b 00                	mov    (%eax),%eax
f010babc:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010bac3:	8b 45 08             	mov    0x8(%ebp),%eax
f010bac6:	8b 00                	mov    (%eax),%eax
f010bac8:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010bace:	8b 45 08             	mov    0x8(%ebp),%eax
f010bad1:	8b 00                	mov    (%eax),%eax
f010bad3:	8b 55 08             	mov    0x8(%ebp),%edx
f010bad6:	8b 12                	mov    (%edx),%edx
f010bad8:	8b 52 38             	mov    0x38(%edx),%edx
f010badb:	80 ce 02             	or     $0x2,%dh
f010bade:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010bae1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bae5:	75 17                	jne    f010bafe <complete_environment_initialization+0x1c1>
f010bae7:	83 ec 04             	sub    $0x4,%esp
f010baea:	68 9b 4d 12 f0       	push   $0xf0124d9b
f010baef:	68 55 04 00 00       	push   $0x455
f010baf4:	68 13 4d 12 f0       	push   $0xf0124d13
f010baf9:	e8 3b 48 ff ff       	call   f0100339 <_panic>
f010bafe:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb01:	8b 40 08             	mov    0x8(%eax),%eax
f010bb04:	85 c0                	test   %eax,%eax
f010bb06:	74 11                	je     f010bb19 <complete_environment_initialization+0x1dc>
f010bb08:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb0b:	8b 40 08             	mov    0x8(%eax),%eax
f010bb0e:	8b 55 08             	mov    0x8(%ebp),%edx
f010bb11:	8b 52 0c             	mov    0xc(%edx),%edx
f010bb14:	89 50 0c             	mov    %edx,0xc(%eax)
f010bb17:	eb 0b                	jmp    f010bb24 <complete_environment_initialization+0x1e7>
f010bb19:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb1c:	8b 40 0c             	mov    0xc(%eax),%eax
f010bb1f:	a3 78 39 5c f0       	mov    %eax,0xf05c3978
f010bb24:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb27:	8b 40 0c             	mov    0xc(%eax),%eax
f010bb2a:	85 c0                	test   %eax,%eax
f010bb2c:	74 11                	je     f010bb3f <complete_environment_initialization+0x202>
f010bb2e:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb31:	8b 40 0c             	mov    0xc(%eax),%eax
f010bb34:	8b 55 08             	mov    0x8(%ebp),%edx
f010bb37:	8b 52 08             	mov    0x8(%edx),%edx
f010bb3a:	89 50 08             	mov    %edx,0x8(%eax)
f010bb3d:	eb 0b                	jmp    f010bb4a <complete_environment_initialization+0x20d>
f010bb3f:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb42:	8b 40 08             	mov    0x8(%eax),%eax
f010bb45:	a3 74 39 5c f0       	mov    %eax,0xf05c3974
f010bb4a:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb4d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010bb54:	8b 45 08             	mov    0x8(%ebp),%eax
f010bb57:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010bb5e:	a1 80 39 5c f0       	mov    0xf05c3980,%eax
f010bb63:	48                   	dec    %eax
f010bb64:	a3 80 39 5c f0       	mov    %eax,0xf05c3980
	return ;
f010bb69:	90                   	nop
}
f010bb6a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bb6d:	c9                   	leave  
f010bb6e:	c3                   	ret    

f010bb6f <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010bb6f:	55                   	push   %ebp
f010bb70:	89 e5                	mov    %esp,%ebp
f010bb72:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010bb75:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb78:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010bb7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb7e:	8b 00                	mov    (%eax),%eax
f010bb80:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010bb85:	74 17                	je     f010bb9e <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010bb87:	83 ec 04             	sub    $0x4,%esp
f010bb8a:	68 f9 4f 12 f0       	push   $0xf0124ff9
f010bb8f:	68 61 04 00 00       	push   $0x461
f010bb94:	68 13 4d 12 f0       	push   $0xf0124d13
f010bb99:	e8 9b 47 ff ff       	call   f0100339 <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010bb9e:	8b 45 08             	mov    0x8(%ebp),%eax
f010bba1:	8b 00                	mov    (%eax),%eax
f010bba3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bba6:	8b 52 18             	mov    0x18(%edx),%edx
f010bba9:	89 50 30             	mov    %edx,0x30(%eax)
}
f010bbac:	90                   	nop
f010bbad:	c9                   	leave  
f010bbae:	c3                   	ret    

f010bbaf <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010bbaf:	55                   	push   %ebp
f010bbb0:	89 e5                	mov    %esp,%ebp
f010bbb2:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010bbb5:	8b 45 08             	mov    0x8(%ebp),%eax
f010bbb8:	8b 40 10             	mov    0x10(%eax),%eax
f010bbbb:	8d 48 01             	lea    0x1(%eax),%ecx
f010bbbe:	8b 55 08             	mov    0x8(%ebp),%edx
f010bbc1:	89 4a 10             	mov    %ecx,0x10(%edx)
f010bbc4:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010bbc7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bbca:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010bbcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bbd0:	8b 00                	mov    (%eax),%eax
f010bbd2:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010bbd7:	74 17                	je     f010bbf0 <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010bbd9:	83 ec 04             	sub    $0x4,%esp
f010bbdc:	68 f9 4f 12 f0       	push   $0xf0124ff9
f010bbe1:	68 6f 04 00 00       	push   $0x46f
f010bbe6:	68 13 4d 12 f0       	push   $0xf0124d13
f010bbeb:	e8 49 47 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010bbf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bbf3:	8b 50 1c             	mov    0x1c(%eax),%edx
f010bbf6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bbf9:	01 d0                	add    %edx,%eax
f010bbfb:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010bbfe:	eb 0f                	jmp    f010bc0f <PROGRAM_SEGMENT_NEXT+0x60>
f010bc00:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc03:	8b 40 10             	mov    0x10(%eax),%eax
f010bc06:	8d 50 01             	lea    0x1(%eax),%edx
f010bc09:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc0c:	89 50 10             	mov    %edx,0x10(%eax)
f010bc0f:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc12:	8b 40 10             	mov    0x10(%eax),%eax
f010bc15:	c1 e0 05             	shl    $0x5,%eax
f010bc18:	89 c2                	mov    %eax,%edx
f010bc1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bc1d:	01 d0                	add    %edx,%eax
f010bc1f:	8b 00                	mov    (%eax),%eax
f010bc21:	83 f8 01             	cmp    $0x1,%eax
f010bc24:	74 13                	je     f010bc39 <PROGRAM_SEGMENT_NEXT+0x8a>
f010bc26:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc29:	8b 50 10             	mov    0x10(%eax),%edx
f010bc2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bc2f:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bc32:	0f b7 c0             	movzwl %ax,%eax
f010bc35:	39 c2                	cmp    %eax,%edx
f010bc37:	72 c7                	jb     f010bc00 <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010bc39:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc3c:	8b 40 10             	mov    0x10(%eax),%eax
f010bc3f:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010bc42:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bc45:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bc48:	0f b7 c0             	movzwl %ax,%eax
f010bc4b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010bc4e:	7e 63                	jle    f010bcb3 <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010bc50:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc53:	c1 e0 05             	shl    $0x5,%eax
f010bc56:	89 c2                	mov    %eax,%edx
f010bc58:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bc5b:	01 d0                	add    %edx,%eax
f010bc5d:	8b 50 04             	mov    0x4(%eax),%edx
f010bc60:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bc63:	01 c2                	add    %eax,%edx
f010bc65:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc68:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010bc6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc6d:	c1 e0 05             	shl    $0x5,%eax
f010bc70:	89 c2                	mov    %eax,%edx
f010bc72:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bc75:	01 d0                	add    %edx,%eax
f010bc77:	8b 50 14             	mov    0x14(%eax),%edx
f010bc7a:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc7d:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010bc80:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc83:	c1 e0 05             	shl    $0x5,%eax
f010bc86:	89 c2                	mov    %eax,%edx
f010bc88:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bc8b:	01 d0                	add    %edx,%eax
f010bc8d:	8b 50 10             	mov    0x10(%eax),%edx
f010bc90:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc93:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010bc96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc99:	c1 e0 05             	shl    $0x5,%eax
f010bc9c:	89 c2                	mov    %eax,%edx
f010bc9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bca1:	01 d0                	add    %edx,%eax
f010bca3:	8b 40 08             	mov    0x8(%eax),%eax
f010bca6:	89 c2                	mov    %eax,%edx
f010bca8:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcab:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010bcae:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcb1:	eb 05                	jmp    f010bcb8 <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010bcb3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bcb8:	c9                   	leave  
f010bcb9:	c3                   	ret    

f010bcba <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010bcba:	55                   	push   %ebp
f010bcbb:	89 e5                	mov    %esp,%ebp
f010bcbd:	57                   	push   %edi
f010bcbe:	56                   	push   %esi
f010bcbf:	53                   	push   %ebx
f010bcc0:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010bcc3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010bcca:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bccd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010bcd0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bcd3:	8b 00                	mov    (%eax),%eax
f010bcd5:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010bcda:	74 17                	je     f010bcf3 <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010bcdc:	83 ec 04             	sub    $0x4,%esp
f010bcdf:	68 f9 4f 12 f0       	push   $0xf0124ff9
f010bce4:	68 8b 04 00 00       	push   $0x48b
f010bce9:	68 13 4d 12 f0       	push   $0xf0124d13
f010bcee:	e8 46 46 ff ff       	call   f0100339 <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010bcf3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bcf6:	8b 50 1c             	mov    0x1c(%eax),%edx
f010bcf9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bcfc:	01 d0                	add    %edx,%eax
f010bcfe:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010bd01:	eb 07                	jmp    f010bd0a <PROGRAM_SEGMENT_FIRST+0x50>
f010bd03:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bd06:	40                   	inc    %eax
f010bd07:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010bd0a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bd0d:	c1 e0 05             	shl    $0x5,%eax
f010bd10:	89 c2                	mov    %eax,%edx
f010bd12:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bd15:	01 d0                	add    %edx,%eax
f010bd17:	8b 00                	mov    (%eax),%eax
f010bd19:	83 f8 01             	cmp    $0x1,%eax
f010bd1c:	74 10                	je     f010bd2e <PROGRAM_SEGMENT_FIRST+0x74>
f010bd1e:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010bd21:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bd24:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bd27:	0f b7 c0             	movzwl %ax,%eax
f010bd2a:	39 c2                	cmp    %eax,%edx
f010bd2c:	72 d5                	jb     f010bd03 <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010bd2e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bd31:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010bd34:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bd37:	8b 40 2c             	mov    0x2c(%eax),%eax
f010bd3a:	0f b7 c0             	movzwl %ax,%eax
f010bd3d:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010bd40:	7e 68                	jle    f010bdaa <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010bd42:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bd45:	c1 e0 05             	shl    $0x5,%eax
f010bd48:	89 c2                	mov    %eax,%edx
f010bd4a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bd4d:	01 d0                	add    %edx,%eax
f010bd4f:	8b 50 04             	mov    0x4(%eax),%edx
f010bd52:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bd55:	01 d0                	add    %edx,%eax
f010bd57:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010bd5a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bd5d:	c1 e0 05             	shl    $0x5,%eax
f010bd60:	89 c2                	mov    %eax,%edx
f010bd62:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bd65:	01 d0                	add    %edx,%eax
f010bd67:	8b 40 14             	mov    0x14(%eax),%eax
f010bd6a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010bd6d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bd70:	c1 e0 05             	shl    $0x5,%eax
f010bd73:	89 c2                	mov    %eax,%edx
f010bd75:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bd78:	01 d0                	add    %edx,%eax
f010bd7a:	8b 40 10             	mov    0x10(%eax),%eax
f010bd7d:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010bd80:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bd83:	c1 e0 05             	shl    $0x5,%eax
f010bd86:	89 c2                	mov    %eax,%edx
f010bd88:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bd8b:	01 d0                	add    %edx,%eax
f010bd8d:	8b 40 08             	mov    0x8(%eax),%eax
f010bd90:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010bd93:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd96:	89 c3                	mov    %eax,%ebx
f010bd98:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010bd9b:	ba 05 00 00 00       	mov    $0x5,%edx
f010bda0:	89 df                	mov    %ebx,%edi
f010bda2:	89 c6                	mov    %eax,%esi
f010bda4:	89 d1                	mov    %edx,%ecx
f010bda6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010bda8:	eb 1c                	jmp    f010bdc6 <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010bdaa:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010bdb1:	8b 45 08             	mov    0x8(%ebp),%eax
f010bdb4:	89 c3                	mov    %eax,%ebx
f010bdb6:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010bdb9:	ba 05 00 00 00       	mov    $0x5,%edx
f010bdbe:	89 df                	mov    %ebx,%edi
f010bdc0:	89 c6                	mov    %eax,%esi
f010bdc2:	89 d1                	mov    %edx,%ecx
f010bdc4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010bdc6:	8b 45 08             	mov    0x8(%ebp),%eax
f010bdc9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010bdcc:	5b                   	pop    %ebx
f010bdcd:	5e                   	pop    %esi
f010bdce:	5f                   	pop    %edi
f010bdcf:	5d                   	pop    %ebp
f010bdd0:	c2 04 00             	ret    $0x4

f010bdd3 <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010bdd3:	55                   	push   %ebp
f010bdd4:	89 e5                	mov    %esp,%ebp
f010bdd6:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010bdd9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010bde0:	83 ec 0c             	sub    $0xc,%esp
f010bde3:	68 20 c5 5e f0       	push   $0xf05ec520
f010bde8:	e8 d2 2d 00 00       	call   f010ebbf <acquire_spinlock>
f010bded:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010bdf0:	a1 10 c5 5e f0       	mov    0xf05ec510,%eax
f010bdf5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010bdf8:	e9 c3 00 00 00       	jmp    f010bec0 <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010bdfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be00:	8b 40 10             	mov    0x10(%eax),%eax
f010be03:	3b 45 08             	cmp    0x8(%ebp),%eax
f010be06:	0f 85 ac 00 00 00    	jne    f010beb8 <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010be0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be0f:	8b 50 14             	mov    0x14(%eax),%edx
f010be12:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be15:	8b 40 10             	mov    0x10(%eax),%eax
f010be18:	8b 40 64             	mov    0x64(%eax),%eax
f010be1b:	83 ec 08             	sub    $0x8,%esp
f010be1e:	52                   	push   %edx
f010be1f:	50                   	push   %eax
f010be20:	e8 e6 d3 ff ff       	call   f010920b <pt_clear_page_table_entry>
f010be25:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010be28:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010be2c:	75 17                	jne    f010be45 <cleanup_buffers+0x72>
f010be2e:	83 ec 04             	sub    $0x4,%esp
f010be31:	68 9b 4d 12 f0       	push   $0xf0124d9b
f010be36:	68 b4 04 00 00       	push   $0x4b4
f010be3b:	68 13 4d 12 f0       	push   $0xf0124d13
f010be40:	e8 f4 44 ff ff       	call   f0100339 <_panic>
f010be45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be48:	8b 00                	mov    (%eax),%eax
f010be4a:	85 c0                	test   %eax,%eax
f010be4c:	74 10                	je     f010be5e <cleanup_buffers+0x8b>
f010be4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be51:	8b 00                	mov    (%eax),%eax
f010be53:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010be56:	8b 52 04             	mov    0x4(%edx),%edx
f010be59:	89 50 04             	mov    %edx,0x4(%eax)
f010be5c:	eb 0b                	jmp    f010be69 <cleanup_buffers+0x96>
f010be5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be61:	8b 40 04             	mov    0x4(%eax),%eax
f010be64:	a3 14 c5 5e f0       	mov    %eax,0xf05ec514
f010be69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be6c:	8b 40 04             	mov    0x4(%eax),%eax
f010be6f:	85 c0                	test   %eax,%eax
f010be71:	74 0f                	je     f010be82 <cleanup_buffers+0xaf>
f010be73:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be76:	8b 40 04             	mov    0x4(%eax),%eax
f010be79:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010be7c:	8b 12                	mov    (%edx),%edx
f010be7e:	89 10                	mov    %edx,(%eax)
f010be80:	eb 0a                	jmp    f010be8c <cleanup_buffers+0xb9>
f010be82:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be85:	8b 00                	mov    (%eax),%eax
f010be87:	a3 10 c5 5e f0       	mov    %eax,0xf05ec510
f010be8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be8f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010be95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be98:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010be9f:	a1 1c c5 5e f0       	mov    0xf05ec51c,%eax
f010bea4:	48                   	dec    %eax
f010bea5:	a3 1c c5 5e f0       	mov    %eax,0xf05ec51c

				free_frame(ptr_fi);
f010beaa:	83 ec 0c             	sub    $0xc,%esp
f010bead:	ff 75 f4             	pushl  -0xc(%ebp)
f010beb0:	e8 21 c5 ff ff       	call   f01083d6 <free_frame>
f010beb5:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010beb8:	a1 18 c5 5e f0       	mov    0xf05ec518,%eax
f010bebd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010bec0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bec4:	74 07                	je     f010becd <cleanup_buffers+0xfa>
f010bec6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bec9:	8b 00                	mov    (%eax),%eax
f010becb:	eb 05                	jmp    f010bed2 <cleanup_buffers+0xff>
f010becd:	b8 00 00 00 00       	mov    $0x0,%eax
f010bed2:	a3 18 c5 5e f0       	mov    %eax,0xf05ec518
f010bed7:	a1 18 c5 5e f0       	mov    0xf05ec518,%eax
f010bedc:	85 c0                	test   %eax,%eax
f010bede:	0f 85 19 ff ff ff    	jne    f010bdfd <cleanup_buffers+0x2a>
f010bee4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bee8:	0f 85 0f ff ff ff    	jne    f010bdfd <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010beee:	83 ec 0c             	sub    $0xc,%esp
f010bef1:	68 20 c5 5e f0       	push   $0xf05ec520
f010bef6:	e8 4b 2d 00 00       	call   f010ec46 <release_spinlock>
f010befb:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010befe:	90                   	nop
f010beff:	c9                   	leave  
f010bf00:	c3                   	ret    

f010bf01 <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010bf01:	55                   	push   %ebp
f010bf02:	89 e5                	mov    %esp,%ebp
f010bf04:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010bf07:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010bf0b:	7e 06                	jle    f010bf13 <set_program_priority+0x12>
f010bf0d:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010bf11:	7e 14                	jle    f010bf27 <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010bf13:	83 ec 04             	sub    $0x4,%esp
f010bf16:	68 10 50 12 f0       	push   $0xf0125010
f010bf1b:	6a 10                	push   $0x10
f010bf1d:	68 34 50 12 f0       	push   $0xf0125034
f010bf22:	e8 12 44 ff ff       	call   f0100339 <_panic>
		return;
	}
	if(env == NULL)
f010bf27:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bf2b:	74 78                	je     f010bfa5 <set_program_priority+0xa4>
		return;
	switch(priority)
f010bf2d:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010bf31:	77 56                	ja     f010bf89 <set_program_priority+0x88>
f010bf33:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bf36:	c1 e0 02             	shl    $0x2,%eax
f010bf39:	05 70 50 12 f0       	add    $0xf0125070,%eax
f010bf3e:	8b 00                	mov    (%eax),%eax
f010bf40:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010bf42:	83 ec 08             	sub    $0x8,%esp
f010bf45:	6a 01                	push   $0x1
f010bf47:	ff 75 08             	pushl  0x8(%ebp)
f010bf4a:	e8 c2 df ff ff       	call   f0109f11 <half_WS_Size>
f010bf4f:	83 c4 10             	add    $0x10,%esp
			break;
f010bf52:	eb 35                	jmp    f010bf89 <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010bf54:	83 ec 08             	sub    $0x8,%esp
f010bf57:	6a 00                	push   $0x0
f010bf59:	ff 75 08             	pushl  0x8(%ebp)
f010bf5c:	e8 b0 df ff ff       	call   f0109f11 <half_WS_Size>
f010bf61:	83 c4 10             	add    $0x10,%esp
			break;
f010bf64:	eb 23                	jmp    f010bf89 <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010bf66:	83 ec 08             	sub    $0x8,%esp
f010bf69:	6a 01                	push   $0x1
f010bf6b:	ff 75 08             	pushl  0x8(%ebp)
f010bf6e:	e8 81 df ff ff       	call   f0109ef4 <double_WS_Size>
f010bf73:	83 c4 10             	add    $0x10,%esp
			break;
f010bf76:	eb 11                	jmp    f010bf89 <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010bf78:	83 ec 08             	sub    $0x8,%esp
f010bf7b:	6a 00                	push   $0x0
f010bf7d:	ff 75 08             	pushl  0x8(%ebp)
f010bf80:	e8 6f df ff ff       	call   f0109ef4 <double_WS_Size>
f010bf85:	83 c4 10             	add    $0x10,%esp
			break;
f010bf88:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010bf89:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf8c:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010bf92:	83 ec 08             	sub    $0x8,%esp
f010bf95:	50                   	push   %eax
f010bf96:	68 51 50 12 f0       	push   $0xf0125051
f010bf9b:	e8 eb 4f ff ff       	call   f0100f8b <cprintf>
f010bfa0:	83 c4 10             	add    $0x10,%esp
f010bfa3:	eb 01                	jmp    f010bfa6 <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010bfa5:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010bfa6:	c9                   	leave  
f010bfa7:	c3                   	ret    

f010bfa8 <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010bfa8:	55                   	push   %ebp
f010bfa9:	89 e5                	mov    %esp,%ebp
f010bfab:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bfae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bfb5:	eb 29                	jmp    f010bfe0 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010bfb7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bfba:	89 d0                	mov    %edx,%eax
f010bfbc:	01 c0                	add    %eax,%eax
f010bfbe:	01 d0                	add    %edx,%eax
f010bfc0:	c1 e0 02             	shl    $0x2,%eax
f010bfc3:	05 80 b9 17 f0       	add    $0xf017b980,%eax
f010bfc8:	8b 00                	mov    (%eax),%eax
f010bfca:	83 ec 08             	sub    $0x8,%esp
f010bfcd:	50                   	push   %eax
f010bfce:	ff 75 08             	pushl  0x8(%ebp)
f010bfd1:	e8 15 2d 01 00       	call   f011eceb <strcmp>
f010bfd6:	83 c4 10             	add    $0x10,%esp
f010bfd9:	85 c0                	test   %eax,%eax
f010bfdb:	74 0f                	je     f010bfec <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bfdd:	ff 45 f4             	incl   -0xc(%ebp)
f010bfe0:	a1 e4 bc 17 f0       	mov    0xf017bce4,%eax
f010bfe5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bfe8:	7c cd                	jl     f010bfb7 <get_user_program_info+0xf>
f010bfea:	eb 01                	jmp    f010bfed <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010bfec:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010bfed:	a1 e4 bc 17 f0       	mov    0xf017bce4,%eax
f010bff2:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bff5:	75 1a                	jne    f010c011 <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010bff7:	83 ec 08             	sub    $0x8,%esp
f010bffa:	ff 75 08             	pushl  0x8(%ebp)
f010bffd:	68 d5 5d 12 f0       	push   $0xf0125dd5
f010c002:	e8 84 4f ff ff       	call   f0100f8b <cprintf>
f010c007:	83 c4 10             	add    $0x10,%esp
		return 0;
f010c00a:	b8 00 00 00 00       	mov    $0x0,%eax
f010c00f:	eb 11                	jmp    f010c022 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010c011:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c014:	89 d0                	mov    %edx,%eax
f010c016:	01 c0                	add    %eax,%eax
f010c018:	01 d0                	add    %edx,%eax
f010c01a:	c1 e0 02             	shl    $0x2,%eax
f010c01d:	05 80 b9 17 f0       	add    $0xf017b980,%eax
}
f010c022:	c9                   	leave  
f010c023:	c3                   	ret    

f010c024 <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010c024:	55                   	push   %ebp
f010c025:	89 e5                	mov    %esp,%ebp
f010c027:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c02a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c031:	eb 2d                	jmp    f010c060 <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010c033:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c036:	89 d0                	mov    %edx,%eax
f010c038:	01 c0                	add    %eax,%eax
f010c03a:	01 d0                	add    %edx,%eax
f010c03c:	c1 e0 02             	shl    $0x2,%eax
f010c03f:	05 80 b9 17 f0       	add    $0xf017b980,%eax
f010c044:	8b 00                	mov    (%eax),%eax
f010c046:	8b 55 08             	mov    0x8(%ebp),%edx
f010c049:	83 c2 20             	add    $0x20,%edx
f010c04c:	83 ec 08             	sub    $0x8,%esp
f010c04f:	50                   	push   %eax
f010c050:	52                   	push   %edx
f010c051:	e8 95 2c 01 00       	call   f011eceb <strcmp>
f010c056:	83 c4 10             	add    $0x10,%esp
f010c059:	85 c0                	test   %eax,%eax
f010c05b:	74 0f                	je     f010c06c <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010c05d:	ff 45 f4             	incl   -0xc(%ebp)
f010c060:	a1 e4 bc 17 f0       	mov    0xf017bce4,%eax
f010c065:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c068:	7c c9                	jl     f010c033 <get_user_program_info_by_env+0xf>
f010c06a:	eb 01                	jmp    f010c06d <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010c06c:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010c06d:	a1 e4 bc 17 f0       	mov    0xf017bce4,%eax
f010c072:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010c075:	75 17                	jne    f010c08e <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010c077:	83 ec 0c             	sub    $0xc,%esp
f010c07a:	68 f0 5d 12 f0       	push   $0xf0125df0
f010c07f:	e8 07 4f ff ff       	call   f0100f8b <cprintf>
f010c084:	83 c4 10             	add    $0x10,%esp
		return 0;
f010c087:	b8 00 00 00 00       	mov    $0x0,%eax
f010c08c:	eb 11                	jmp    f010c09f <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010c08e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c091:	89 d0                	mov    %edx,%eax
f010c093:	01 c0                	add    %eax,%eax
f010c095:	01 d0                	add    %edx,%eax
f010c097:	c1 e0 02             	shl    $0x2,%eax
f010c09a:	05 80 b9 17 f0       	add    $0xf017b980,%eax
}
f010c09f:	c9                   	leave  
f010c0a0:	c3                   	ret    

f010c0a1 <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010c0a1:	55                   	push   %ebp
f010c0a2:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010c0a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0a7:	83 f8 13             	cmp    $0x13,%eax
f010c0aa:	77 0c                	ja     f010c0b8 <trapname+0x17>
		return excnames[trapno];
f010c0ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0af:	8b 04 85 e0 61 12 f0 	mov    -0xfed9e20(,%eax,4),%eax
f010c0b6:	eb 2c                	jmp    f010c0e4 <trapname+0x43>
	if (trapno == T_SYSCALL)
f010c0b8:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010c0bc:	75 07                	jne    f010c0c5 <trapname+0x24>
		return "System call";
f010c0be:	b8 20 5e 12 f0       	mov    $0xf0125e20,%eax
f010c0c3:	eb 1f                	jmp    f010c0e4 <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010c0c5:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010c0c9:	75 07                	jne    f010c0d2 <trapname+0x31>
		return "Clock Interrupt";
f010c0cb:	b8 2c 5e 12 f0       	mov    $0xf0125e2c,%eax
f010c0d0:	eb 12                	jmp    f010c0e4 <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010c0d2:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010c0d6:	75 07                	jne    f010c0df <trapname+0x3e>
		return "Keyboard Interrupt";
f010c0d8:	b8 3c 5e 12 f0       	mov    $0xf0125e3c,%eax
f010c0dd:	eb 05                	jmp    f010c0e4 <trapname+0x43>
	return "(unknown trap)";
f010c0df:	b8 4f 5e 12 f0       	mov    $0xf0125e4f,%eax
}
f010c0e4:	5d                   	pop    %ebp
f010c0e5:	c3                   	ret    

f010c0e6 <ts_init>:


void ts_init(void)
{
f010c0e6:	55                   	push   %ebp
f010c0e7:	89 e5                	mov    %esp,%ebp
f010c0e9:	53                   	push   %ebx
f010c0ea:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010c0ed:	e8 15 b1 ff ff       	call   f0107207 <pushcli>

	struct cpu* c = mycpu();
f010c0f2:	e8 4d b0 ff ff       	call   f0107144 <mycpu>
f010c0f7:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010c0fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c0fd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010c104:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c107:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010c10d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c110:	83 c0 0c             	add    $0xc,%eax
f010c113:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c116:	83 c2 0c             	add    $0xc,%edx
f010c119:	c1 ea 10             	shr    $0x10,%edx
f010c11c:	88 d3                	mov    %dl,%bl
f010c11e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c121:	83 c2 0c             	add    $0xc,%edx
f010c124:	c1 ea 18             	shr    $0x18,%edx
f010c127:	88 d1                	mov    %dl,%cl
f010c129:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c12c:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010c133:	68 00 
f010c135:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c138:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010c13f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c142:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010c148:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c14b:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c151:	83 e2 f0             	and    $0xfffffff0,%edx
f010c154:	83 ca 09             	or     $0x9,%edx
f010c157:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c15d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c160:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c166:	83 ca 10             	or     $0x10,%edx
f010c169:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c16f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c172:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c178:	83 e2 9f             	and    $0xffffff9f,%edx
f010c17b:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c181:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c184:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c18a:	83 ca 80             	or     $0xffffff80,%edx
f010c18d:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010c193:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c196:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c19c:	83 e2 f0             	and    $0xfffffff0,%edx
f010c19f:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c1a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c1a8:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c1ae:	83 e2 ef             	and    $0xffffffef,%edx
f010c1b1:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c1b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c1ba:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c1c0:	83 e2 df             	and    $0xffffffdf,%edx
f010c1c3:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c1c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c1cc:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c1d2:	83 ca 40             	or     $0x40,%edx
f010c1d5:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c1db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c1de:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010c1e4:	83 e2 7f             	and    $0x7f,%edx
f010c1e7:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010c1ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c1f0:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010c1f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c1f9:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010c1ff:	83 e2 ef             	and    $0xffffffef,%edx
f010c202:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010c208:	e8 4c b0 ff ff       	call   f0107259 <popcli>
f010c20d:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010c213:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010c217:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010c21a:	90                   	nop
f010c21b:	83 c4 14             	add    $0x14,%esp
f010c21e:	5b                   	pop    %ebx
f010c21f:	5d                   	pop    %ebp
f010c220:	c3                   	ret    

f010c221 <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010c221:	55                   	push   %ebp
f010c222:	89 e5                	mov    %esp,%ebp
f010c224:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010c227:	b8 d0 d6 10 f0       	mov    $0xf010d6d0,%eax
f010c22c:	66 a3 e0 39 5c f0    	mov    %ax,0xf05c39e0
f010c232:	66 c7 05 e2 39 5c f0 	movw   $0x8,0xf05c39e2
f010c239:	08 00 
f010c23b:	a0 e4 39 5c f0       	mov    0xf05c39e4,%al
f010c240:	83 e0 e0             	and    $0xffffffe0,%eax
f010c243:	a2 e4 39 5c f0       	mov    %al,0xf05c39e4
f010c248:	a0 e4 39 5c f0       	mov    0xf05c39e4,%al
f010c24d:	83 e0 1f             	and    $0x1f,%eax
f010c250:	a2 e4 39 5c f0       	mov    %al,0xf05c39e4
f010c255:	a0 e5 39 5c f0       	mov    0xf05c39e5,%al
f010c25a:	83 e0 f0             	and    $0xfffffff0,%eax
f010c25d:	83 c8 0e             	or     $0xe,%eax
f010c260:	a2 e5 39 5c f0       	mov    %al,0xf05c39e5
f010c265:	a0 e5 39 5c f0       	mov    0xf05c39e5,%al
f010c26a:	83 e0 ef             	and    $0xffffffef,%eax
f010c26d:	a2 e5 39 5c f0       	mov    %al,0xf05c39e5
f010c272:	a0 e5 39 5c f0       	mov    0xf05c39e5,%al
f010c277:	83 e0 9f             	and    $0xffffff9f,%eax
f010c27a:	a2 e5 39 5c f0       	mov    %al,0xf05c39e5
f010c27f:	a0 e5 39 5c f0       	mov    0xf05c39e5,%al
f010c284:	83 c8 80             	or     $0xffffff80,%eax
f010c287:	a2 e5 39 5c f0       	mov    %al,0xf05c39e5
f010c28c:	b8 d0 d6 10 f0       	mov    $0xf010d6d0,%eax
f010c291:	c1 e8 10             	shr    $0x10,%eax
f010c294:	66 a3 e6 39 5c f0    	mov    %ax,0xf05c39e6
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010c29a:	b8 d8 d6 10 f0       	mov    $0xf010d6d8,%eax
f010c29f:	66 a3 10 3a 5c f0    	mov    %ax,0xf05c3a10
f010c2a5:	66 c7 05 12 3a 5c f0 	movw   $0x8,0xf05c3a12
f010c2ac:	08 00 
f010c2ae:	a0 14 3a 5c f0       	mov    0xf05c3a14,%al
f010c2b3:	83 e0 e0             	and    $0xffffffe0,%eax
f010c2b6:	a2 14 3a 5c f0       	mov    %al,0xf05c3a14
f010c2bb:	a0 14 3a 5c f0       	mov    0xf05c3a14,%al
f010c2c0:	83 e0 1f             	and    $0x1f,%eax
f010c2c3:	a2 14 3a 5c f0       	mov    %al,0xf05c3a14
f010c2c8:	a0 15 3a 5c f0       	mov    0xf05c3a15,%al
f010c2cd:	83 e0 f0             	and    $0xfffffff0,%eax
f010c2d0:	83 c8 0e             	or     $0xe,%eax
f010c2d3:	a2 15 3a 5c f0       	mov    %al,0xf05c3a15
f010c2d8:	a0 15 3a 5c f0       	mov    0xf05c3a15,%al
f010c2dd:	83 e0 ef             	and    $0xffffffef,%eax
f010c2e0:	a2 15 3a 5c f0       	mov    %al,0xf05c3a15
f010c2e5:	a0 15 3a 5c f0       	mov    0xf05c3a15,%al
f010c2ea:	83 e0 9f             	and    $0xffffff9f,%eax
f010c2ed:	a2 15 3a 5c f0       	mov    %al,0xf05c3a15
f010c2f2:	a0 15 3a 5c f0       	mov    0xf05c3a15,%al
f010c2f7:	83 c8 80             	or     $0xffffff80,%eax
f010c2fa:	a2 15 3a 5c f0       	mov    %al,0xf05c3a15
f010c2ff:	b8 d8 d6 10 f0       	mov    $0xf010d6d8,%eax
f010c304:	c1 e8 10             	shr    $0x10,%eax
f010c307:	66 a3 16 3a 5c f0    	mov    %ax,0xf05c3a16
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010c30d:	b8 e0 d6 10 f0       	mov    $0xf010d6e0,%eax
f010c312:	66 a3 a0 3a 5c f0    	mov    %ax,0xf05c3aa0
f010c318:	66 c7 05 a2 3a 5c f0 	movw   $0x8,0xf05c3aa2
f010c31f:	08 00 
f010c321:	a0 a4 3a 5c f0       	mov    0xf05c3aa4,%al
f010c326:	83 e0 e0             	and    $0xffffffe0,%eax
f010c329:	a2 a4 3a 5c f0       	mov    %al,0xf05c3aa4
f010c32e:	a0 a4 3a 5c f0       	mov    0xf05c3aa4,%al
f010c333:	83 e0 1f             	and    $0x1f,%eax
f010c336:	a2 a4 3a 5c f0       	mov    %al,0xf05c3aa4
f010c33b:	a0 a5 3a 5c f0       	mov    0xf05c3aa5,%al
f010c340:	83 e0 f0             	and    $0xfffffff0,%eax
f010c343:	83 c8 0e             	or     $0xe,%eax
f010c346:	a2 a5 3a 5c f0       	mov    %al,0xf05c3aa5
f010c34b:	a0 a5 3a 5c f0       	mov    0xf05c3aa5,%al
f010c350:	83 e0 ef             	and    $0xffffffef,%eax
f010c353:	a2 a5 3a 5c f0       	mov    %al,0xf05c3aa5
f010c358:	a0 a5 3a 5c f0       	mov    0xf05c3aa5,%al
f010c35d:	83 c8 60             	or     $0x60,%eax
f010c360:	a2 a5 3a 5c f0       	mov    %al,0xf05c3aa5
f010c365:	a0 a5 3a 5c f0       	mov    0xf05c3aa5,%al
f010c36a:	83 c8 80             	or     $0xffffff80,%eax
f010c36d:	a2 a5 3a 5c f0       	mov    %al,0xf05c3aa5
f010c372:	b8 e0 d6 10 f0       	mov    $0xf010d6e0,%eax
f010c377:	c1 e8 10             	shr    $0x10,%eax
f010c37a:	66 a3 a6 3a 5c f0    	mov    %ax,0xf05c3aa6
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010c380:	b8 ea d6 10 f0       	mov    $0xf010d6ea,%eax
f010c385:	66 a3 a8 3a 5c f0    	mov    %ax,0xf05c3aa8
f010c38b:	66 c7 05 aa 3a 5c f0 	movw   $0x8,0xf05c3aaa
f010c392:	08 00 
f010c394:	a0 ac 3a 5c f0       	mov    0xf05c3aac,%al
f010c399:	83 e0 e0             	and    $0xffffffe0,%eax
f010c39c:	a2 ac 3a 5c f0       	mov    %al,0xf05c3aac
f010c3a1:	a0 ac 3a 5c f0       	mov    0xf05c3aac,%al
f010c3a6:	83 e0 1f             	and    $0x1f,%eax
f010c3a9:	a2 ac 3a 5c f0       	mov    %al,0xf05c3aac
f010c3ae:	a0 ad 3a 5c f0       	mov    0xf05c3aad,%al
f010c3b3:	83 e0 f0             	and    $0xfffffff0,%eax
f010c3b6:	83 c8 0e             	or     $0xe,%eax
f010c3b9:	a2 ad 3a 5c f0       	mov    %al,0xf05c3aad
f010c3be:	a0 ad 3a 5c f0       	mov    0xf05c3aad,%al
f010c3c3:	83 e0 ef             	and    $0xffffffef,%eax
f010c3c6:	a2 ad 3a 5c f0       	mov    %al,0xf05c3aad
f010c3cb:	a0 ad 3a 5c f0       	mov    0xf05c3aad,%al
f010c3d0:	83 c8 60             	or     $0x60,%eax
f010c3d3:	a2 ad 3a 5c f0       	mov    %al,0xf05c3aad
f010c3d8:	a0 ad 3a 5c f0       	mov    0xf05c3aad,%al
f010c3dd:	83 c8 80             	or     $0xffffff80,%eax
f010c3e0:	a2 ad 3a 5c f0       	mov    %al,0xf05c3aad
f010c3e5:	b8 ea d6 10 f0       	mov    $0xf010d6ea,%eax
f010c3ea:	c1 e8 10             	shr    $0x10,%eax
f010c3ed:	66 a3 ae 3a 5c f0    	mov    %ax,0xf05c3aae
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010c3f3:	b8 f4 d6 10 f0       	mov    $0xf010d6f4,%eax
f010c3f8:	66 a3 20 3b 5c f0    	mov    %ax,0xf05c3b20
f010c3fe:	66 c7 05 22 3b 5c f0 	movw   $0x8,0xf05c3b22
f010c405:	08 00 
f010c407:	a0 24 3b 5c f0       	mov    0xf05c3b24,%al
f010c40c:	83 e0 e0             	and    $0xffffffe0,%eax
f010c40f:	a2 24 3b 5c f0       	mov    %al,0xf05c3b24
f010c414:	a0 24 3b 5c f0       	mov    0xf05c3b24,%al
f010c419:	83 e0 1f             	and    $0x1f,%eax
f010c41c:	a2 24 3b 5c f0       	mov    %al,0xf05c3b24
f010c421:	a0 25 3b 5c f0       	mov    0xf05c3b25,%al
f010c426:	83 e0 f0             	and    $0xfffffff0,%eax
f010c429:	83 c8 0e             	or     $0xe,%eax
f010c42c:	a2 25 3b 5c f0       	mov    %al,0xf05c3b25
f010c431:	a0 25 3b 5c f0       	mov    0xf05c3b25,%al
f010c436:	83 e0 ef             	and    $0xffffffef,%eax
f010c439:	a2 25 3b 5c f0       	mov    %al,0xf05c3b25
f010c43e:	a0 25 3b 5c f0       	mov    0xf05c3b25,%al
f010c443:	83 c8 60             	or     $0x60,%eax
f010c446:	a2 25 3b 5c f0       	mov    %al,0xf05c3b25
f010c44b:	a0 25 3b 5c f0       	mov    0xf05c3b25,%al
f010c450:	83 c8 80             	or     $0xffffff80,%eax
f010c453:	a2 25 3b 5c f0       	mov    %al,0xf05c3b25
f010c458:	b8 f4 d6 10 f0       	mov    $0xf010d6f4,%eax
f010c45d:	c1 e8 10             	shr    $0x10,%eax
f010c460:	66 a3 26 3b 5c f0    	mov    %ax,0xf05c3b26

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010c466:	b8 fe d6 10 f0       	mov    $0xf010d6fe,%eax
f010c46b:	66 a3 a0 39 5c f0    	mov    %ax,0xf05c39a0
f010c471:	66 c7 05 a2 39 5c f0 	movw   $0x8,0xf05c39a2
f010c478:	08 00 
f010c47a:	a0 a4 39 5c f0       	mov    0xf05c39a4,%al
f010c47f:	83 e0 e0             	and    $0xffffffe0,%eax
f010c482:	a2 a4 39 5c f0       	mov    %al,0xf05c39a4
f010c487:	a0 a4 39 5c f0       	mov    0xf05c39a4,%al
f010c48c:	83 e0 1f             	and    $0x1f,%eax
f010c48f:	a2 a4 39 5c f0       	mov    %al,0xf05c39a4
f010c494:	a0 a5 39 5c f0       	mov    0xf05c39a5,%al
f010c499:	83 e0 f0             	and    $0xfffffff0,%eax
f010c49c:	83 c8 0e             	or     $0xe,%eax
f010c49f:	a2 a5 39 5c f0       	mov    %al,0xf05c39a5
f010c4a4:	a0 a5 39 5c f0       	mov    0xf05c39a5,%al
f010c4a9:	83 e0 ef             	and    $0xffffffef,%eax
f010c4ac:	a2 a5 39 5c f0       	mov    %al,0xf05c39a5
f010c4b1:	a0 a5 39 5c f0       	mov    0xf05c39a5,%al
f010c4b6:	83 c8 60             	or     $0x60,%eax
f010c4b9:	a2 a5 39 5c f0       	mov    %al,0xf05c39a5
f010c4be:	a0 a5 39 5c f0       	mov    0xf05c39a5,%al
f010c4c3:	83 c8 80             	or     $0xffffff80,%eax
f010c4c6:	a2 a5 39 5c f0       	mov    %al,0xf05c39a5
f010c4cb:	b8 fe d6 10 f0       	mov    $0xf010d6fe,%eax
f010c4d0:	c1 e8 10             	shr    $0x10,%eax
f010c4d3:	66 a3 a6 39 5c f0    	mov    %ax,0xf05c39a6
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010c4d9:	b8 08 d7 10 f0       	mov    $0xf010d708,%eax
f010c4de:	66 a3 a8 39 5c f0    	mov    %ax,0xf05c39a8
f010c4e4:	66 c7 05 aa 39 5c f0 	movw   $0x8,0xf05c39aa
f010c4eb:	08 00 
f010c4ed:	a0 ac 39 5c f0       	mov    0xf05c39ac,%al
f010c4f2:	83 e0 e0             	and    $0xffffffe0,%eax
f010c4f5:	a2 ac 39 5c f0       	mov    %al,0xf05c39ac
f010c4fa:	a0 ac 39 5c f0       	mov    0xf05c39ac,%al
f010c4ff:	83 e0 1f             	and    $0x1f,%eax
f010c502:	a2 ac 39 5c f0       	mov    %al,0xf05c39ac
f010c507:	a0 ad 39 5c f0       	mov    0xf05c39ad,%al
f010c50c:	83 c8 0f             	or     $0xf,%eax
f010c50f:	a2 ad 39 5c f0       	mov    %al,0xf05c39ad
f010c514:	a0 ad 39 5c f0       	mov    0xf05c39ad,%al
f010c519:	83 e0 ef             	and    $0xffffffef,%eax
f010c51c:	a2 ad 39 5c f0       	mov    %al,0xf05c39ad
f010c521:	a0 ad 39 5c f0       	mov    0xf05c39ad,%al
f010c526:	83 c8 60             	or     $0x60,%eax
f010c529:	a2 ad 39 5c f0       	mov    %al,0xf05c39ad
f010c52e:	a0 ad 39 5c f0       	mov    0xf05c39ad,%al
f010c533:	83 c8 80             	or     $0xffffff80,%eax
f010c536:	a2 ad 39 5c f0       	mov    %al,0xf05c39ad
f010c53b:	b8 08 d7 10 f0       	mov    $0xf010d708,%eax
f010c540:	c1 e8 10             	shr    $0x10,%eax
f010c543:	66 a3 ae 39 5c f0    	mov    %ax,0xf05c39ae
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010c549:	b8 12 d7 10 f0       	mov    $0xf010d712,%eax
f010c54e:	66 a3 b0 39 5c f0    	mov    %ax,0xf05c39b0
f010c554:	66 c7 05 b2 39 5c f0 	movw   $0x8,0xf05c39b2
f010c55b:	08 00 
f010c55d:	a0 b4 39 5c f0       	mov    0xf05c39b4,%al
f010c562:	83 e0 e0             	and    $0xffffffe0,%eax
f010c565:	a2 b4 39 5c f0       	mov    %al,0xf05c39b4
f010c56a:	a0 b4 39 5c f0       	mov    0xf05c39b4,%al
f010c56f:	83 e0 1f             	and    $0x1f,%eax
f010c572:	a2 b4 39 5c f0       	mov    %al,0xf05c39b4
f010c577:	a0 b5 39 5c f0       	mov    0xf05c39b5,%al
f010c57c:	83 e0 f0             	and    $0xfffffff0,%eax
f010c57f:	83 c8 0e             	or     $0xe,%eax
f010c582:	a2 b5 39 5c f0       	mov    %al,0xf05c39b5
f010c587:	a0 b5 39 5c f0       	mov    0xf05c39b5,%al
f010c58c:	83 e0 ef             	and    $0xffffffef,%eax
f010c58f:	a2 b5 39 5c f0       	mov    %al,0xf05c39b5
f010c594:	a0 b5 39 5c f0       	mov    0xf05c39b5,%al
f010c599:	83 c8 60             	or     $0x60,%eax
f010c59c:	a2 b5 39 5c f0       	mov    %al,0xf05c39b5
f010c5a1:	a0 b5 39 5c f0       	mov    0xf05c39b5,%al
f010c5a6:	83 c8 80             	or     $0xffffff80,%eax
f010c5a9:	a2 b5 39 5c f0       	mov    %al,0xf05c39b5
f010c5ae:	b8 12 d7 10 f0       	mov    $0xf010d712,%eax
f010c5b3:	c1 e8 10             	shr    $0x10,%eax
f010c5b6:	66 a3 b6 39 5c f0    	mov    %ax,0xf05c39b6
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010c5bc:	b8 1c d7 10 f0       	mov    $0xf010d71c,%eax
f010c5c1:	66 a3 b8 39 5c f0    	mov    %ax,0xf05c39b8
f010c5c7:	66 c7 05 ba 39 5c f0 	movw   $0x8,0xf05c39ba
f010c5ce:	08 00 
f010c5d0:	a0 bc 39 5c f0       	mov    0xf05c39bc,%al
f010c5d5:	83 e0 e0             	and    $0xffffffe0,%eax
f010c5d8:	a2 bc 39 5c f0       	mov    %al,0xf05c39bc
f010c5dd:	a0 bc 39 5c f0       	mov    0xf05c39bc,%al
f010c5e2:	83 e0 1f             	and    $0x1f,%eax
f010c5e5:	a2 bc 39 5c f0       	mov    %al,0xf05c39bc
f010c5ea:	a0 bd 39 5c f0       	mov    0xf05c39bd,%al
f010c5ef:	83 c8 0f             	or     $0xf,%eax
f010c5f2:	a2 bd 39 5c f0       	mov    %al,0xf05c39bd
f010c5f7:	a0 bd 39 5c f0       	mov    0xf05c39bd,%al
f010c5fc:	83 e0 ef             	and    $0xffffffef,%eax
f010c5ff:	a2 bd 39 5c f0       	mov    %al,0xf05c39bd
f010c604:	a0 bd 39 5c f0       	mov    0xf05c39bd,%al
f010c609:	83 c8 60             	or     $0x60,%eax
f010c60c:	a2 bd 39 5c f0       	mov    %al,0xf05c39bd
f010c611:	a0 bd 39 5c f0       	mov    0xf05c39bd,%al
f010c616:	83 c8 80             	or     $0xffffff80,%eax
f010c619:	a2 bd 39 5c f0       	mov    %al,0xf05c39bd
f010c61e:	b8 1c d7 10 f0       	mov    $0xf010d71c,%eax
f010c623:	c1 e8 10             	shr    $0x10,%eax
f010c626:	66 a3 be 39 5c f0    	mov    %ax,0xf05c39be
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010c62c:	b8 26 d7 10 f0       	mov    $0xf010d726,%eax
f010c631:	66 a3 c0 39 5c f0    	mov    %ax,0xf05c39c0
f010c637:	66 c7 05 c2 39 5c f0 	movw   $0x8,0xf05c39c2
f010c63e:	08 00 
f010c640:	a0 c4 39 5c f0       	mov    0xf05c39c4,%al
f010c645:	83 e0 e0             	and    $0xffffffe0,%eax
f010c648:	a2 c4 39 5c f0       	mov    %al,0xf05c39c4
f010c64d:	a0 c4 39 5c f0       	mov    0xf05c39c4,%al
f010c652:	83 e0 1f             	and    $0x1f,%eax
f010c655:	a2 c4 39 5c f0       	mov    %al,0xf05c39c4
f010c65a:	a0 c5 39 5c f0       	mov    0xf05c39c5,%al
f010c65f:	83 c8 0f             	or     $0xf,%eax
f010c662:	a2 c5 39 5c f0       	mov    %al,0xf05c39c5
f010c667:	a0 c5 39 5c f0       	mov    0xf05c39c5,%al
f010c66c:	83 e0 ef             	and    $0xffffffef,%eax
f010c66f:	a2 c5 39 5c f0       	mov    %al,0xf05c39c5
f010c674:	a0 c5 39 5c f0       	mov    0xf05c39c5,%al
f010c679:	83 c8 60             	or     $0x60,%eax
f010c67c:	a2 c5 39 5c f0       	mov    %al,0xf05c39c5
f010c681:	a0 c5 39 5c f0       	mov    0xf05c39c5,%al
f010c686:	83 c8 80             	or     $0xffffff80,%eax
f010c689:	a2 c5 39 5c f0       	mov    %al,0xf05c39c5
f010c68e:	b8 26 d7 10 f0       	mov    $0xf010d726,%eax
f010c693:	c1 e8 10             	shr    $0x10,%eax
f010c696:	66 a3 c6 39 5c f0    	mov    %ax,0xf05c39c6
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010c69c:	b8 30 d7 10 f0       	mov    $0xf010d730,%eax
f010c6a1:	66 a3 c8 39 5c f0    	mov    %ax,0xf05c39c8
f010c6a7:	66 c7 05 ca 39 5c f0 	movw   $0x8,0xf05c39ca
f010c6ae:	08 00 
f010c6b0:	a0 cc 39 5c f0       	mov    0xf05c39cc,%al
f010c6b5:	83 e0 e0             	and    $0xffffffe0,%eax
f010c6b8:	a2 cc 39 5c f0       	mov    %al,0xf05c39cc
f010c6bd:	a0 cc 39 5c f0       	mov    0xf05c39cc,%al
f010c6c2:	83 e0 1f             	and    $0x1f,%eax
f010c6c5:	a2 cc 39 5c f0       	mov    %al,0xf05c39cc
f010c6ca:	a0 cd 39 5c f0       	mov    0xf05c39cd,%al
f010c6cf:	83 e0 f0             	and    $0xfffffff0,%eax
f010c6d2:	83 c8 0e             	or     $0xe,%eax
f010c6d5:	a2 cd 39 5c f0       	mov    %al,0xf05c39cd
f010c6da:	a0 cd 39 5c f0       	mov    0xf05c39cd,%al
f010c6df:	83 e0 ef             	and    $0xffffffef,%eax
f010c6e2:	a2 cd 39 5c f0       	mov    %al,0xf05c39cd
f010c6e7:	a0 cd 39 5c f0       	mov    0xf05c39cd,%al
f010c6ec:	83 c8 60             	or     $0x60,%eax
f010c6ef:	a2 cd 39 5c f0       	mov    %al,0xf05c39cd
f010c6f4:	a0 cd 39 5c f0       	mov    0xf05c39cd,%al
f010c6f9:	83 c8 80             	or     $0xffffff80,%eax
f010c6fc:	a2 cd 39 5c f0       	mov    %al,0xf05c39cd
f010c701:	b8 30 d7 10 f0       	mov    $0xf010d730,%eax
f010c706:	c1 e8 10             	shr    $0x10,%eax
f010c709:	66 a3 ce 39 5c f0    	mov    %ax,0xf05c39ce
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010c70f:	b8 3a d7 10 f0       	mov    $0xf010d73a,%eax
f010c714:	66 a3 d0 39 5c f0    	mov    %ax,0xf05c39d0
f010c71a:	66 c7 05 d2 39 5c f0 	movw   $0x8,0xf05c39d2
f010c721:	08 00 
f010c723:	a0 d4 39 5c f0       	mov    0xf05c39d4,%al
f010c728:	83 e0 e0             	and    $0xffffffe0,%eax
f010c72b:	a2 d4 39 5c f0       	mov    %al,0xf05c39d4
f010c730:	a0 d4 39 5c f0       	mov    0xf05c39d4,%al
f010c735:	83 e0 1f             	and    $0x1f,%eax
f010c738:	a2 d4 39 5c f0       	mov    %al,0xf05c39d4
f010c73d:	a0 d5 39 5c f0       	mov    0xf05c39d5,%al
f010c742:	83 e0 f0             	and    $0xfffffff0,%eax
f010c745:	83 c8 0e             	or     $0xe,%eax
f010c748:	a2 d5 39 5c f0       	mov    %al,0xf05c39d5
f010c74d:	a0 d5 39 5c f0       	mov    0xf05c39d5,%al
f010c752:	83 e0 ef             	and    $0xffffffef,%eax
f010c755:	a2 d5 39 5c f0       	mov    %al,0xf05c39d5
f010c75a:	a0 d5 39 5c f0       	mov    0xf05c39d5,%al
f010c75f:	83 c8 60             	or     $0x60,%eax
f010c762:	a2 d5 39 5c f0       	mov    %al,0xf05c39d5
f010c767:	a0 d5 39 5c f0       	mov    0xf05c39d5,%al
f010c76c:	83 c8 80             	or     $0xffffff80,%eax
f010c76f:	a2 d5 39 5c f0       	mov    %al,0xf05c39d5
f010c774:	b8 3a d7 10 f0       	mov    $0xf010d73a,%eax
f010c779:	c1 e8 10             	shr    $0x10,%eax
f010c77c:	66 a3 d6 39 5c f0    	mov    %ax,0xf05c39d6
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010c782:	b8 44 d7 10 f0       	mov    $0xf010d744,%eax
f010c787:	66 a3 d8 39 5c f0    	mov    %ax,0xf05c39d8
f010c78d:	66 c7 05 da 39 5c f0 	movw   $0x8,0xf05c39da
f010c794:	08 00 
f010c796:	a0 dc 39 5c f0       	mov    0xf05c39dc,%al
f010c79b:	83 e0 e0             	and    $0xffffffe0,%eax
f010c79e:	a2 dc 39 5c f0       	mov    %al,0xf05c39dc
f010c7a3:	a0 dc 39 5c f0       	mov    0xf05c39dc,%al
f010c7a8:	83 e0 1f             	and    $0x1f,%eax
f010c7ab:	a2 dc 39 5c f0       	mov    %al,0xf05c39dc
f010c7b0:	a0 dd 39 5c f0       	mov    0xf05c39dd,%al
f010c7b5:	83 e0 f0             	and    $0xfffffff0,%eax
f010c7b8:	83 c8 0e             	or     $0xe,%eax
f010c7bb:	a2 dd 39 5c f0       	mov    %al,0xf05c39dd
f010c7c0:	a0 dd 39 5c f0       	mov    0xf05c39dd,%al
f010c7c5:	83 e0 ef             	and    $0xffffffef,%eax
f010c7c8:	a2 dd 39 5c f0       	mov    %al,0xf05c39dd
f010c7cd:	a0 dd 39 5c f0       	mov    0xf05c39dd,%al
f010c7d2:	83 c8 60             	or     $0x60,%eax
f010c7d5:	a2 dd 39 5c f0       	mov    %al,0xf05c39dd
f010c7da:	a0 dd 39 5c f0       	mov    0xf05c39dd,%al
f010c7df:	83 c8 80             	or     $0xffffff80,%eax
f010c7e2:	a2 dd 39 5c f0       	mov    %al,0xf05c39dd
f010c7e7:	b8 44 d7 10 f0       	mov    $0xf010d744,%eax
f010c7ec:	c1 e8 10             	shr    $0x10,%eax
f010c7ef:	66 a3 de 39 5c f0    	mov    %ax,0xf05c39de
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010c7f5:	b8 4a d7 10 f0       	mov    $0xf010d74a,%eax
f010c7fa:	66 a3 f0 39 5c f0    	mov    %ax,0xf05c39f0
f010c800:	66 c7 05 f2 39 5c f0 	movw   $0x8,0xf05c39f2
f010c807:	08 00 
f010c809:	a0 f4 39 5c f0       	mov    0xf05c39f4,%al
f010c80e:	83 e0 e0             	and    $0xffffffe0,%eax
f010c811:	a2 f4 39 5c f0       	mov    %al,0xf05c39f4
f010c816:	a0 f4 39 5c f0       	mov    0xf05c39f4,%al
f010c81b:	83 e0 1f             	and    $0x1f,%eax
f010c81e:	a2 f4 39 5c f0       	mov    %al,0xf05c39f4
f010c823:	a0 f5 39 5c f0       	mov    0xf05c39f5,%al
f010c828:	83 e0 f0             	and    $0xfffffff0,%eax
f010c82b:	83 c8 0e             	or     $0xe,%eax
f010c82e:	a2 f5 39 5c f0       	mov    %al,0xf05c39f5
f010c833:	a0 f5 39 5c f0       	mov    0xf05c39f5,%al
f010c838:	83 e0 ef             	and    $0xffffffef,%eax
f010c83b:	a2 f5 39 5c f0       	mov    %al,0xf05c39f5
f010c840:	a0 f5 39 5c f0       	mov    0xf05c39f5,%al
f010c845:	83 c8 60             	or     $0x60,%eax
f010c848:	a2 f5 39 5c f0       	mov    %al,0xf05c39f5
f010c84d:	a0 f5 39 5c f0       	mov    0xf05c39f5,%al
f010c852:	83 c8 80             	or     $0xffffff80,%eax
f010c855:	a2 f5 39 5c f0       	mov    %al,0xf05c39f5
f010c85a:	b8 4a d7 10 f0       	mov    $0xf010d74a,%eax
f010c85f:	c1 e8 10             	shr    $0x10,%eax
f010c862:	66 a3 f6 39 5c f0    	mov    %ax,0xf05c39f6
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010c868:	b8 4e d7 10 f0       	mov    $0xf010d74e,%eax
f010c86d:	66 a3 f8 39 5c f0    	mov    %ax,0xf05c39f8
f010c873:	66 c7 05 fa 39 5c f0 	movw   $0x8,0xf05c39fa
f010c87a:	08 00 
f010c87c:	a0 fc 39 5c f0       	mov    0xf05c39fc,%al
f010c881:	83 e0 e0             	and    $0xffffffe0,%eax
f010c884:	a2 fc 39 5c f0       	mov    %al,0xf05c39fc
f010c889:	a0 fc 39 5c f0       	mov    0xf05c39fc,%al
f010c88e:	83 e0 1f             	and    $0x1f,%eax
f010c891:	a2 fc 39 5c f0       	mov    %al,0xf05c39fc
f010c896:	a0 fd 39 5c f0       	mov    0xf05c39fd,%al
f010c89b:	83 e0 f0             	and    $0xfffffff0,%eax
f010c89e:	83 c8 0e             	or     $0xe,%eax
f010c8a1:	a2 fd 39 5c f0       	mov    %al,0xf05c39fd
f010c8a6:	a0 fd 39 5c f0       	mov    0xf05c39fd,%al
f010c8ab:	83 e0 ef             	and    $0xffffffef,%eax
f010c8ae:	a2 fd 39 5c f0       	mov    %al,0xf05c39fd
f010c8b3:	a0 fd 39 5c f0       	mov    0xf05c39fd,%al
f010c8b8:	83 c8 60             	or     $0x60,%eax
f010c8bb:	a2 fd 39 5c f0       	mov    %al,0xf05c39fd
f010c8c0:	a0 fd 39 5c f0       	mov    0xf05c39fd,%al
f010c8c5:	83 c8 80             	or     $0xffffff80,%eax
f010c8c8:	a2 fd 39 5c f0       	mov    %al,0xf05c39fd
f010c8cd:	b8 4e d7 10 f0       	mov    $0xf010d74e,%eax
f010c8d2:	c1 e8 10             	shr    $0x10,%eax
f010c8d5:	66 a3 fe 39 5c f0    	mov    %ax,0xf05c39fe
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010c8db:	b8 52 d7 10 f0       	mov    $0xf010d752,%eax
f010c8e0:	66 a3 00 3a 5c f0    	mov    %ax,0xf05c3a00
f010c8e6:	66 c7 05 02 3a 5c f0 	movw   $0x8,0xf05c3a02
f010c8ed:	08 00 
f010c8ef:	a0 04 3a 5c f0       	mov    0xf05c3a04,%al
f010c8f4:	83 e0 e0             	and    $0xffffffe0,%eax
f010c8f7:	a2 04 3a 5c f0       	mov    %al,0xf05c3a04
f010c8fc:	a0 04 3a 5c f0       	mov    0xf05c3a04,%al
f010c901:	83 e0 1f             	and    $0x1f,%eax
f010c904:	a2 04 3a 5c f0       	mov    %al,0xf05c3a04
f010c909:	a0 05 3a 5c f0       	mov    0xf05c3a05,%al
f010c90e:	83 e0 f0             	and    $0xfffffff0,%eax
f010c911:	83 c8 0e             	or     $0xe,%eax
f010c914:	a2 05 3a 5c f0       	mov    %al,0xf05c3a05
f010c919:	a0 05 3a 5c f0       	mov    0xf05c3a05,%al
f010c91e:	83 e0 ef             	and    $0xffffffef,%eax
f010c921:	a2 05 3a 5c f0       	mov    %al,0xf05c3a05
f010c926:	a0 05 3a 5c f0       	mov    0xf05c3a05,%al
f010c92b:	83 c8 60             	or     $0x60,%eax
f010c92e:	a2 05 3a 5c f0       	mov    %al,0xf05c3a05
f010c933:	a0 05 3a 5c f0       	mov    0xf05c3a05,%al
f010c938:	83 c8 80             	or     $0xffffff80,%eax
f010c93b:	a2 05 3a 5c f0       	mov    %al,0xf05c3a05
f010c940:	b8 52 d7 10 f0       	mov    $0xf010d752,%eax
f010c945:	c1 e8 10             	shr    $0x10,%eax
f010c948:	66 a3 06 3a 5c f0    	mov    %ax,0xf05c3a06
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010c94e:	b8 56 d7 10 f0       	mov    $0xf010d756,%eax
f010c953:	66 a3 08 3a 5c f0    	mov    %ax,0xf05c3a08
f010c959:	66 c7 05 0a 3a 5c f0 	movw   $0x8,0xf05c3a0a
f010c960:	08 00 
f010c962:	a0 0c 3a 5c f0       	mov    0xf05c3a0c,%al
f010c967:	83 e0 e0             	and    $0xffffffe0,%eax
f010c96a:	a2 0c 3a 5c f0       	mov    %al,0xf05c3a0c
f010c96f:	a0 0c 3a 5c f0       	mov    0xf05c3a0c,%al
f010c974:	83 e0 1f             	and    $0x1f,%eax
f010c977:	a2 0c 3a 5c f0       	mov    %al,0xf05c3a0c
f010c97c:	a0 0d 3a 5c f0       	mov    0xf05c3a0d,%al
f010c981:	83 e0 f0             	and    $0xfffffff0,%eax
f010c984:	83 c8 0e             	or     $0xe,%eax
f010c987:	a2 0d 3a 5c f0       	mov    %al,0xf05c3a0d
f010c98c:	a0 0d 3a 5c f0       	mov    0xf05c3a0d,%al
f010c991:	83 e0 ef             	and    $0xffffffef,%eax
f010c994:	a2 0d 3a 5c f0       	mov    %al,0xf05c3a0d
f010c999:	a0 0d 3a 5c f0       	mov    0xf05c3a0d,%al
f010c99e:	83 c8 60             	or     $0x60,%eax
f010c9a1:	a2 0d 3a 5c f0       	mov    %al,0xf05c3a0d
f010c9a6:	a0 0d 3a 5c f0       	mov    0xf05c3a0d,%al
f010c9ab:	83 c8 80             	or     $0xffffff80,%eax
f010c9ae:	a2 0d 3a 5c f0       	mov    %al,0xf05c3a0d
f010c9b3:	b8 56 d7 10 f0       	mov    $0xf010d756,%eax
f010c9b8:	c1 e8 10             	shr    $0x10,%eax
f010c9bb:	66 a3 0e 3a 5c f0    	mov    %ax,0xf05c3a0e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010c9c1:	b8 5a d7 10 f0       	mov    $0xf010d75a,%eax
f010c9c6:	66 a3 20 3a 5c f0    	mov    %ax,0xf05c3a20
f010c9cc:	66 c7 05 22 3a 5c f0 	movw   $0x8,0xf05c3a22
f010c9d3:	08 00 
f010c9d5:	a0 24 3a 5c f0       	mov    0xf05c3a24,%al
f010c9da:	83 e0 e0             	and    $0xffffffe0,%eax
f010c9dd:	a2 24 3a 5c f0       	mov    %al,0xf05c3a24
f010c9e2:	a0 24 3a 5c f0       	mov    0xf05c3a24,%al
f010c9e7:	83 e0 1f             	and    $0x1f,%eax
f010c9ea:	a2 24 3a 5c f0       	mov    %al,0xf05c3a24
f010c9ef:	a0 25 3a 5c f0       	mov    0xf05c3a25,%al
f010c9f4:	83 e0 f0             	and    $0xfffffff0,%eax
f010c9f7:	83 c8 0e             	or     $0xe,%eax
f010c9fa:	a2 25 3a 5c f0       	mov    %al,0xf05c3a25
f010c9ff:	a0 25 3a 5c f0       	mov    0xf05c3a25,%al
f010ca04:	83 e0 ef             	and    $0xffffffef,%eax
f010ca07:	a2 25 3a 5c f0       	mov    %al,0xf05c3a25
f010ca0c:	a0 25 3a 5c f0       	mov    0xf05c3a25,%al
f010ca11:	83 c8 60             	or     $0x60,%eax
f010ca14:	a2 25 3a 5c f0       	mov    %al,0xf05c3a25
f010ca19:	a0 25 3a 5c f0       	mov    0xf05c3a25,%al
f010ca1e:	83 c8 80             	or     $0xffffff80,%eax
f010ca21:	a2 25 3a 5c f0       	mov    %al,0xf05c3a25
f010ca26:	b8 5a d7 10 f0       	mov    $0xf010d75a,%eax
f010ca2b:	c1 e8 10             	shr    $0x10,%eax
f010ca2e:	66 a3 26 3a 5c f0    	mov    %ax,0xf05c3a26
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010ca34:	b8 60 d7 10 f0       	mov    $0xf010d760,%eax
f010ca39:	66 a3 28 3a 5c f0    	mov    %ax,0xf05c3a28
f010ca3f:	66 c7 05 2a 3a 5c f0 	movw   $0x8,0xf05c3a2a
f010ca46:	08 00 
f010ca48:	a0 2c 3a 5c f0       	mov    0xf05c3a2c,%al
f010ca4d:	83 e0 e0             	and    $0xffffffe0,%eax
f010ca50:	a2 2c 3a 5c f0       	mov    %al,0xf05c3a2c
f010ca55:	a0 2c 3a 5c f0       	mov    0xf05c3a2c,%al
f010ca5a:	83 e0 1f             	and    $0x1f,%eax
f010ca5d:	a2 2c 3a 5c f0       	mov    %al,0xf05c3a2c
f010ca62:	a0 2d 3a 5c f0       	mov    0xf05c3a2d,%al
f010ca67:	83 e0 f0             	and    $0xfffffff0,%eax
f010ca6a:	83 c8 0e             	or     $0xe,%eax
f010ca6d:	a2 2d 3a 5c f0       	mov    %al,0xf05c3a2d
f010ca72:	a0 2d 3a 5c f0       	mov    0xf05c3a2d,%al
f010ca77:	83 e0 ef             	and    $0xffffffef,%eax
f010ca7a:	a2 2d 3a 5c f0       	mov    %al,0xf05c3a2d
f010ca7f:	a0 2d 3a 5c f0       	mov    0xf05c3a2d,%al
f010ca84:	83 c8 60             	or     $0x60,%eax
f010ca87:	a2 2d 3a 5c f0       	mov    %al,0xf05c3a2d
f010ca8c:	a0 2d 3a 5c f0       	mov    0xf05c3a2d,%al
f010ca91:	83 c8 80             	or     $0xffffff80,%eax
f010ca94:	a2 2d 3a 5c f0       	mov    %al,0xf05c3a2d
f010ca99:	b8 60 d7 10 f0       	mov    $0xf010d760,%eax
f010ca9e:	c1 e8 10             	shr    $0x10,%eax
f010caa1:	66 a3 2e 3a 5c f0    	mov    %ax,0xf05c3a2e
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010caa7:	b8 64 d7 10 f0       	mov    $0xf010d764,%eax
f010caac:	66 a3 30 3a 5c f0    	mov    %ax,0xf05c3a30
f010cab2:	66 c7 05 32 3a 5c f0 	movw   $0x8,0xf05c3a32
f010cab9:	08 00 
f010cabb:	a0 34 3a 5c f0       	mov    0xf05c3a34,%al
f010cac0:	83 e0 e0             	and    $0xffffffe0,%eax
f010cac3:	a2 34 3a 5c f0       	mov    %al,0xf05c3a34
f010cac8:	a0 34 3a 5c f0       	mov    0xf05c3a34,%al
f010cacd:	83 e0 1f             	and    $0x1f,%eax
f010cad0:	a2 34 3a 5c f0       	mov    %al,0xf05c3a34
f010cad5:	a0 35 3a 5c f0       	mov    0xf05c3a35,%al
f010cada:	83 e0 f0             	and    $0xfffffff0,%eax
f010cadd:	83 c8 0e             	or     $0xe,%eax
f010cae0:	a2 35 3a 5c f0       	mov    %al,0xf05c3a35
f010cae5:	a0 35 3a 5c f0       	mov    0xf05c3a35,%al
f010caea:	83 e0 ef             	and    $0xffffffef,%eax
f010caed:	a2 35 3a 5c f0       	mov    %al,0xf05c3a35
f010caf2:	a0 35 3a 5c f0       	mov    0xf05c3a35,%al
f010caf7:	83 c8 60             	or     $0x60,%eax
f010cafa:	a2 35 3a 5c f0       	mov    %al,0xf05c3a35
f010caff:	a0 35 3a 5c f0       	mov    0xf05c3a35,%al
f010cb04:	83 c8 80             	or     $0xffffff80,%eax
f010cb07:	a2 35 3a 5c f0       	mov    %al,0xf05c3a35
f010cb0c:	b8 64 d7 10 f0       	mov    $0xf010d764,%eax
f010cb11:	c1 e8 10             	shr    $0x10,%eax
f010cb14:	66 a3 36 3a 5c f0    	mov    %ax,0xf05c3a36
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010cb1a:	b8 6a d7 10 f0       	mov    $0xf010d76a,%eax
f010cb1f:	66 a3 38 3a 5c f0    	mov    %ax,0xf05c3a38
f010cb25:	66 c7 05 3a 3a 5c f0 	movw   $0x8,0xf05c3a3a
f010cb2c:	08 00 
f010cb2e:	a0 3c 3a 5c f0       	mov    0xf05c3a3c,%al
f010cb33:	83 e0 e0             	and    $0xffffffe0,%eax
f010cb36:	a2 3c 3a 5c f0       	mov    %al,0xf05c3a3c
f010cb3b:	a0 3c 3a 5c f0       	mov    0xf05c3a3c,%al
f010cb40:	83 e0 1f             	and    $0x1f,%eax
f010cb43:	a2 3c 3a 5c f0       	mov    %al,0xf05c3a3c
f010cb48:	a0 3d 3a 5c f0       	mov    0xf05c3a3d,%al
f010cb4d:	83 e0 f0             	and    $0xfffffff0,%eax
f010cb50:	83 c8 0e             	or     $0xe,%eax
f010cb53:	a2 3d 3a 5c f0       	mov    %al,0xf05c3a3d
f010cb58:	a0 3d 3a 5c f0       	mov    0xf05c3a3d,%al
f010cb5d:	83 e0 ef             	and    $0xffffffef,%eax
f010cb60:	a2 3d 3a 5c f0       	mov    %al,0xf05c3a3d
f010cb65:	a0 3d 3a 5c f0       	mov    0xf05c3a3d,%al
f010cb6a:	83 c8 60             	or     $0x60,%eax
f010cb6d:	a2 3d 3a 5c f0       	mov    %al,0xf05c3a3d
f010cb72:	a0 3d 3a 5c f0       	mov    0xf05c3a3d,%al
f010cb77:	83 c8 80             	or     $0xffffff80,%eax
f010cb7a:	a2 3d 3a 5c f0       	mov    %al,0xf05c3a3d
f010cb7f:	b8 6a d7 10 f0       	mov    $0xf010d76a,%eax
f010cb84:	c1 e8 10             	shr    $0x10,%eax
f010cb87:	66 a3 3e 3a 5c f0    	mov    %ax,0xf05c3a3e

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010cb8d:	b8 70 d7 10 f0       	mov    $0xf010d770,%eax
f010cb92:	66 a3 b0 3a 5c f0    	mov    %ax,0xf05c3ab0
f010cb98:	66 c7 05 b2 3a 5c f0 	movw   $0x8,0xf05c3ab2
f010cb9f:	08 00 
f010cba1:	a0 b4 3a 5c f0       	mov    0xf05c3ab4,%al
f010cba6:	83 e0 e0             	and    $0xffffffe0,%eax
f010cba9:	a2 b4 3a 5c f0       	mov    %al,0xf05c3ab4
f010cbae:	a0 b4 3a 5c f0       	mov    0xf05c3ab4,%al
f010cbb3:	83 e0 1f             	and    $0x1f,%eax
f010cbb6:	a2 b4 3a 5c f0       	mov    %al,0xf05c3ab4
f010cbbb:	a0 b5 3a 5c f0       	mov    0xf05c3ab5,%al
f010cbc0:	83 e0 f0             	and    $0xfffffff0,%eax
f010cbc3:	83 c8 0e             	or     $0xe,%eax
f010cbc6:	a2 b5 3a 5c f0       	mov    %al,0xf05c3ab5
f010cbcb:	a0 b5 3a 5c f0       	mov    0xf05c3ab5,%al
f010cbd0:	83 e0 ef             	and    $0xffffffef,%eax
f010cbd3:	a2 b5 3a 5c f0       	mov    %al,0xf05c3ab5
f010cbd8:	a0 b5 3a 5c f0       	mov    0xf05c3ab5,%al
f010cbdd:	83 c8 60             	or     $0x60,%eax
f010cbe0:	a2 b5 3a 5c f0       	mov    %al,0xf05c3ab5
f010cbe5:	a0 b5 3a 5c f0       	mov    0xf05c3ab5,%al
f010cbea:	83 c8 80             	or     $0xffffff80,%eax
f010cbed:	a2 b5 3a 5c f0       	mov    %al,0xf05c3ab5
f010cbf2:	b8 70 d7 10 f0       	mov    $0xf010d770,%eax
f010cbf7:	c1 e8 10             	shr    $0x10,%eax
f010cbfa:	66 a3 b6 3a 5c f0    	mov    %ax,0xf05c3ab6
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010cc00:	b8 76 d7 10 f0       	mov    $0xf010d776,%eax
f010cc05:	66 a3 b8 3a 5c f0    	mov    %ax,0xf05c3ab8
f010cc0b:	66 c7 05 ba 3a 5c f0 	movw   $0x8,0xf05c3aba
f010cc12:	08 00 
f010cc14:	a0 bc 3a 5c f0       	mov    0xf05c3abc,%al
f010cc19:	83 e0 e0             	and    $0xffffffe0,%eax
f010cc1c:	a2 bc 3a 5c f0       	mov    %al,0xf05c3abc
f010cc21:	a0 bc 3a 5c f0       	mov    0xf05c3abc,%al
f010cc26:	83 e0 1f             	and    $0x1f,%eax
f010cc29:	a2 bc 3a 5c f0       	mov    %al,0xf05c3abc
f010cc2e:	a0 bd 3a 5c f0       	mov    0xf05c3abd,%al
f010cc33:	83 e0 f0             	and    $0xfffffff0,%eax
f010cc36:	83 c8 0e             	or     $0xe,%eax
f010cc39:	a2 bd 3a 5c f0       	mov    %al,0xf05c3abd
f010cc3e:	a0 bd 3a 5c f0       	mov    0xf05c3abd,%al
f010cc43:	83 e0 ef             	and    $0xffffffef,%eax
f010cc46:	a2 bd 3a 5c f0       	mov    %al,0xf05c3abd
f010cc4b:	a0 bd 3a 5c f0       	mov    0xf05c3abd,%al
f010cc50:	83 c8 60             	or     $0x60,%eax
f010cc53:	a2 bd 3a 5c f0       	mov    %al,0xf05c3abd
f010cc58:	a0 bd 3a 5c f0       	mov    0xf05c3abd,%al
f010cc5d:	83 c8 80             	or     $0xffffff80,%eax
f010cc60:	a2 bd 3a 5c f0       	mov    %al,0xf05c3abd
f010cc65:	b8 76 d7 10 f0       	mov    $0xf010d776,%eax
f010cc6a:	c1 e8 10             	shr    $0x10,%eax
f010cc6d:	66 a3 be 3a 5c f0    	mov    %ax,0xf05c3abe
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010cc73:	b8 7c d7 10 f0       	mov    $0xf010d77c,%eax
f010cc78:	66 a3 c0 3a 5c f0    	mov    %ax,0xf05c3ac0
f010cc7e:	66 c7 05 c2 3a 5c f0 	movw   $0x8,0xf05c3ac2
f010cc85:	08 00 
f010cc87:	a0 c4 3a 5c f0       	mov    0xf05c3ac4,%al
f010cc8c:	83 e0 e0             	and    $0xffffffe0,%eax
f010cc8f:	a2 c4 3a 5c f0       	mov    %al,0xf05c3ac4
f010cc94:	a0 c4 3a 5c f0       	mov    0xf05c3ac4,%al
f010cc99:	83 e0 1f             	and    $0x1f,%eax
f010cc9c:	a2 c4 3a 5c f0       	mov    %al,0xf05c3ac4
f010cca1:	a0 c5 3a 5c f0       	mov    0xf05c3ac5,%al
f010cca6:	83 e0 f0             	and    $0xfffffff0,%eax
f010cca9:	83 c8 0e             	or     $0xe,%eax
f010ccac:	a2 c5 3a 5c f0       	mov    %al,0xf05c3ac5
f010ccb1:	a0 c5 3a 5c f0       	mov    0xf05c3ac5,%al
f010ccb6:	83 e0 ef             	and    $0xffffffef,%eax
f010ccb9:	a2 c5 3a 5c f0       	mov    %al,0xf05c3ac5
f010ccbe:	a0 c5 3a 5c f0       	mov    0xf05c3ac5,%al
f010ccc3:	83 c8 60             	or     $0x60,%eax
f010ccc6:	a2 c5 3a 5c f0       	mov    %al,0xf05c3ac5
f010cccb:	a0 c5 3a 5c f0       	mov    0xf05c3ac5,%al
f010ccd0:	83 c8 80             	or     $0xffffff80,%eax
f010ccd3:	a2 c5 3a 5c f0       	mov    %al,0xf05c3ac5
f010ccd8:	b8 7c d7 10 f0       	mov    $0xf010d77c,%eax
f010ccdd:	c1 e8 10             	shr    $0x10,%eax
f010cce0:	66 a3 c6 3a 5c f0    	mov    %ax,0xf05c3ac6
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010cce6:	b8 82 d7 10 f0       	mov    $0xf010d782,%eax
f010cceb:	66 a3 c8 3a 5c f0    	mov    %ax,0xf05c3ac8
f010ccf1:	66 c7 05 ca 3a 5c f0 	movw   $0x8,0xf05c3aca
f010ccf8:	08 00 
f010ccfa:	a0 cc 3a 5c f0       	mov    0xf05c3acc,%al
f010ccff:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd02:	a2 cc 3a 5c f0       	mov    %al,0xf05c3acc
f010cd07:	a0 cc 3a 5c f0       	mov    0xf05c3acc,%al
f010cd0c:	83 e0 1f             	and    $0x1f,%eax
f010cd0f:	a2 cc 3a 5c f0       	mov    %al,0xf05c3acc
f010cd14:	a0 cd 3a 5c f0       	mov    0xf05c3acd,%al
f010cd19:	83 e0 f0             	and    $0xfffffff0,%eax
f010cd1c:	83 c8 0e             	or     $0xe,%eax
f010cd1f:	a2 cd 3a 5c f0       	mov    %al,0xf05c3acd
f010cd24:	a0 cd 3a 5c f0       	mov    0xf05c3acd,%al
f010cd29:	83 e0 ef             	and    $0xffffffef,%eax
f010cd2c:	a2 cd 3a 5c f0       	mov    %al,0xf05c3acd
f010cd31:	a0 cd 3a 5c f0       	mov    0xf05c3acd,%al
f010cd36:	83 c8 60             	or     $0x60,%eax
f010cd39:	a2 cd 3a 5c f0       	mov    %al,0xf05c3acd
f010cd3e:	a0 cd 3a 5c f0       	mov    0xf05c3acd,%al
f010cd43:	83 c8 80             	or     $0xffffff80,%eax
f010cd46:	a2 cd 3a 5c f0       	mov    %al,0xf05c3acd
f010cd4b:	b8 82 d7 10 f0       	mov    $0xf010d782,%eax
f010cd50:	c1 e8 10             	shr    $0x10,%eax
f010cd53:	66 a3 ce 3a 5c f0    	mov    %ax,0xf05c3ace
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010cd59:	b8 88 d7 10 f0       	mov    $0xf010d788,%eax
f010cd5e:	66 a3 d0 3a 5c f0    	mov    %ax,0xf05c3ad0
f010cd64:	66 c7 05 d2 3a 5c f0 	movw   $0x8,0xf05c3ad2
f010cd6b:	08 00 
f010cd6d:	a0 d4 3a 5c f0       	mov    0xf05c3ad4,%al
f010cd72:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd75:	a2 d4 3a 5c f0       	mov    %al,0xf05c3ad4
f010cd7a:	a0 d4 3a 5c f0       	mov    0xf05c3ad4,%al
f010cd7f:	83 e0 1f             	and    $0x1f,%eax
f010cd82:	a2 d4 3a 5c f0       	mov    %al,0xf05c3ad4
f010cd87:	a0 d5 3a 5c f0       	mov    0xf05c3ad5,%al
f010cd8c:	83 e0 f0             	and    $0xfffffff0,%eax
f010cd8f:	83 c8 0e             	or     $0xe,%eax
f010cd92:	a2 d5 3a 5c f0       	mov    %al,0xf05c3ad5
f010cd97:	a0 d5 3a 5c f0       	mov    0xf05c3ad5,%al
f010cd9c:	83 e0 ef             	and    $0xffffffef,%eax
f010cd9f:	a2 d5 3a 5c f0       	mov    %al,0xf05c3ad5
f010cda4:	a0 d5 3a 5c f0       	mov    0xf05c3ad5,%al
f010cda9:	83 c8 60             	or     $0x60,%eax
f010cdac:	a2 d5 3a 5c f0       	mov    %al,0xf05c3ad5
f010cdb1:	a0 d5 3a 5c f0       	mov    0xf05c3ad5,%al
f010cdb6:	83 c8 80             	or     $0xffffff80,%eax
f010cdb9:	a2 d5 3a 5c f0       	mov    %al,0xf05c3ad5
f010cdbe:	b8 88 d7 10 f0       	mov    $0xf010d788,%eax
f010cdc3:	c1 e8 10             	shr    $0x10,%eax
f010cdc6:	66 a3 d6 3a 5c f0    	mov    %ax,0xf05c3ad6
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010cdcc:	b8 8e d7 10 f0       	mov    $0xf010d78e,%eax
f010cdd1:	66 a3 d8 3a 5c f0    	mov    %ax,0xf05c3ad8
f010cdd7:	66 c7 05 da 3a 5c f0 	movw   $0x8,0xf05c3ada
f010cdde:	08 00 
f010cde0:	a0 dc 3a 5c f0       	mov    0xf05c3adc,%al
f010cde5:	83 e0 e0             	and    $0xffffffe0,%eax
f010cde8:	a2 dc 3a 5c f0       	mov    %al,0xf05c3adc
f010cded:	a0 dc 3a 5c f0       	mov    0xf05c3adc,%al
f010cdf2:	83 e0 1f             	and    $0x1f,%eax
f010cdf5:	a2 dc 3a 5c f0       	mov    %al,0xf05c3adc
f010cdfa:	a0 dd 3a 5c f0       	mov    0xf05c3add,%al
f010cdff:	83 e0 f0             	and    $0xfffffff0,%eax
f010ce02:	83 c8 0e             	or     $0xe,%eax
f010ce05:	a2 dd 3a 5c f0       	mov    %al,0xf05c3add
f010ce0a:	a0 dd 3a 5c f0       	mov    0xf05c3add,%al
f010ce0f:	83 e0 ef             	and    $0xffffffef,%eax
f010ce12:	a2 dd 3a 5c f0       	mov    %al,0xf05c3add
f010ce17:	a0 dd 3a 5c f0       	mov    0xf05c3add,%al
f010ce1c:	83 c8 60             	or     $0x60,%eax
f010ce1f:	a2 dd 3a 5c f0       	mov    %al,0xf05c3add
f010ce24:	a0 dd 3a 5c f0       	mov    0xf05c3add,%al
f010ce29:	83 c8 80             	or     $0xffffff80,%eax
f010ce2c:	a2 dd 3a 5c f0       	mov    %al,0xf05c3add
f010ce31:	b8 8e d7 10 f0       	mov    $0xf010d78e,%eax
f010ce36:	c1 e8 10             	shr    $0x10,%eax
f010ce39:	66 a3 de 3a 5c f0    	mov    %ax,0xf05c3ade
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010ce3f:	b8 94 d7 10 f0       	mov    $0xf010d794,%eax
f010ce44:	66 a3 e0 3a 5c f0    	mov    %ax,0xf05c3ae0
f010ce4a:	66 c7 05 e2 3a 5c f0 	movw   $0x8,0xf05c3ae2
f010ce51:	08 00 
f010ce53:	a0 e4 3a 5c f0       	mov    0xf05c3ae4,%al
f010ce58:	83 e0 e0             	and    $0xffffffe0,%eax
f010ce5b:	a2 e4 3a 5c f0       	mov    %al,0xf05c3ae4
f010ce60:	a0 e4 3a 5c f0       	mov    0xf05c3ae4,%al
f010ce65:	83 e0 1f             	and    $0x1f,%eax
f010ce68:	a2 e4 3a 5c f0       	mov    %al,0xf05c3ae4
f010ce6d:	a0 e5 3a 5c f0       	mov    0xf05c3ae5,%al
f010ce72:	83 e0 f0             	and    $0xfffffff0,%eax
f010ce75:	83 c8 0e             	or     $0xe,%eax
f010ce78:	a2 e5 3a 5c f0       	mov    %al,0xf05c3ae5
f010ce7d:	a0 e5 3a 5c f0       	mov    0xf05c3ae5,%al
f010ce82:	83 e0 ef             	and    $0xffffffef,%eax
f010ce85:	a2 e5 3a 5c f0       	mov    %al,0xf05c3ae5
f010ce8a:	a0 e5 3a 5c f0       	mov    0xf05c3ae5,%al
f010ce8f:	83 c8 60             	or     $0x60,%eax
f010ce92:	a2 e5 3a 5c f0       	mov    %al,0xf05c3ae5
f010ce97:	a0 e5 3a 5c f0       	mov    0xf05c3ae5,%al
f010ce9c:	83 c8 80             	or     $0xffffff80,%eax
f010ce9f:	a2 e5 3a 5c f0       	mov    %al,0xf05c3ae5
f010cea4:	b8 94 d7 10 f0       	mov    $0xf010d794,%eax
f010cea9:	c1 e8 10             	shr    $0x10,%eax
f010ceac:	66 a3 e6 3a 5c f0    	mov    %ax,0xf05c3ae6
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010ceb2:	b8 9a d7 10 f0       	mov    $0xf010d79a,%eax
f010ceb7:	66 a3 e8 3a 5c f0    	mov    %ax,0xf05c3ae8
f010cebd:	66 c7 05 ea 3a 5c f0 	movw   $0x8,0xf05c3aea
f010cec4:	08 00 
f010cec6:	a0 ec 3a 5c f0       	mov    0xf05c3aec,%al
f010cecb:	83 e0 e0             	and    $0xffffffe0,%eax
f010cece:	a2 ec 3a 5c f0       	mov    %al,0xf05c3aec
f010ced3:	a0 ec 3a 5c f0       	mov    0xf05c3aec,%al
f010ced8:	83 e0 1f             	and    $0x1f,%eax
f010cedb:	a2 ec 3a 5c f0       	mov    %al,0xf05c3aec
f010cee0:	a0 ed 3a 5c f0       	mov    0xf05c3aed,%al
f010cee5:	83 e0 f0             	and    $0xfffffff0,%eax
f010cee8:	83 c8 0e             	or     $0xe,%eax
f010ceeb:	a2 ed 3a 5c f0       	mov    %al,0xf05c3aed
f010cef0:	a0 ed 3a 5c f0       	mov    0xf05c3aed,%al
f010cef5:	83 e0 ef             	and    $0xffffffef,%eax
f010cef8:	a2 ed 3a 5c f0       	mov    %al,0xf05c3aed
f010cefd:	a0 ed 3a 5c f0       	mov    0xf05c3aed,%al
f010cf02:	83 c8 60             	or     $0x60,%eax
f010cf05:	a2 ed 3a 5c f0       	mov    %al,0xf05c3aed
f010cf0a:	a0 ed 3a 5c f0       	mov    0xf05c3aed,%al
f010cf0f:	83 c8 80             	or     $0xffffff80,%eax
f010cf12:	a2 ed 3a 5c f0       	mov    %al,0xf05c3aed
f010cf17:	b8 9a d7 10 f0       	mov    $0xf010d79a,%eax
f010cf1c:	c1 e8 10             	shr    $0x10,%eax
f010cf1f:	66 a3 ee 3a 5c f0    	mov    %ax,0xf05c3aee
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010cf25:	b8 a0 d7 10 f0       	mov    $0xf010d7a0,%eax
f010cf2a:	66 a3 f0 3a 5c f0    	mov    %ax,0xf05c3af0
f010cf30:	66 c7 05 f2 3a 5c f0 	movw   $0x8,0xf05c3af2
f010cf37:	08 00 
f010cf39:	a0 f4 3a 5c f0       	mov    0xf05c3af4,%al
f010cf3e:	83 e0 e0             	and    $0xffffffe0,%eax
f010cf41:	a2 f4 3a 5c f0       	mov    %al,0xf05c3af4
f010cf46:	a0 f4 3a 5c f0       	mov    0xf05c3af4,%al
f010cf4b:	83 e0 1f             	and    $0x1f,%eax
f010cf4e:	a2 f4 3a 5c f0       	mov    %al,0xf05c3af4
f010cf53:	a0 f5 3a 5c f0       	mov    0xf05c3af5,%al
f010cf58:	83 e0 f0             	and    $0xfffffff0,%eax
f010cf5b:	83 c8 0e             	or     $0xe,%eax
f010cf5e:	a2 f5 3a 5c f0       	mov    %al,0xf05c3af5
f010cf63:	a0 f5 3a 5c f0       	mov    0xf05c3af5,%al
f010cf68:	83 e0 ef             	and    $0xffffffef,%eax
f010cf6b:	a2 f5 3a 5c f0       	mov    %al,0xf05c3af5
f010cf70:	a0 f5 3a 5c f0       	mov    0xf05c3af5,%al
f010cf75:	83 c8 60             	or     $0x60,%eax
f010cf78:	a2 f5 3a 5c f0       	mov    %al,0xf05c3af5
f010cf7d:	a0 f5 3a 5c f0       	mov    0xf05c3af5,%al
f010cf82:	83 c8 80             	or     $0xffffff80,%eax
f010cf85:	a2 f5 3a 5c f0       	mov    %al,0xf05c3af5
f010cf8a:	b8 a0 d7 10 f0       	mov    $0xf010d7a0,%eax
f010cf8f:	c1 e8 10             	shr    $0x10,%eax
f010cf92:	66 a3 f6 3a 5c f0    	mov    %ax,0xf05c3af6
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010cf98:	b8 a6 d7 10 f0       	mov    $0xf010d7a6,%eax
f010cf9d:	66 a3 f8 3a 5c f0    	mov    %ax,0xf05c3af8
f010cfa3:	66 c7 05 fa 3a 5c f0 	movw   $0x8,0xf05c3afa
f010cfaa:	08 00 
f010cfac:	a0 fc 3a 5c f0       	mov    0xf05c3afc,%al
f010cfb1:	83 e0 e0             	and    $0xffffffe0,%eax
f010cfb4:	a2 fc 3a 5c f0       	mov    %al,0xf05c3afc
f010cfb9:	a0 fc 3a 5c f0       	mov    0xf05c3afc,%al
f010cfbe:	83 e0 1f             	and    $0x1f,%eax
f010cfc1:	a2 fc 3a 5c f0       	mov    %al,0xf05c3afc
f010cfc6:	a0 fd 3a 5c f0       	mov    0xf05c3afd,%al
f010cfcb:	83 e0 f0             	and    $0xfffffff0,%eax
f010cfce:	83 c8 0e             	or     $0xe,%eax
f010cfd1:	a2 fd 3a 5c f0       	mov    %al,0xf05c3afd
f010cfd6:	a0 fd 3a 5c f0       	mov    0xf05c3afd,%al
f010cfdb:	83 e0 ef             	and    $0xffffffef,%eax
f010cfde:	a2 fd 3a 5c f0       	mov    %al,0xf05c3afd
f010cfe3:	a0 fd 3a 5c f0       	mov    0xf05c3afd,%al
f010cfe8:	83 c8 60             	or     $0x60,%eax
f010cfeb:	a2 fd 3a 5c f0       	mov    %al,0xf05c3afd
f010cff0:	a0 fd 3a 5c f0       	mov    0xf05c3afd,%al
f010cff5:	83 c8 80             	or     $0xffffff80,%eax
f010cff8:	a2 fd 3a 5c f0       	mov    %al,0xf05c3afd
f010cffd:	b8 a6 d7 10 f0       	mov    $0xf010d7a6,%eax
f010d002:	c1 e8 10             	shr    $0x10,%eax
f010d005:	66 a3 fe 3a 5c f0    	mov    %ax,0xf05c3afe
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010d00b:	b8 ac d7 10 f0       	mov    $0xf010d7ac,%eax
f010d010:	66 a3 00 3b 5c f0    	mov    %ax,0xf05c3b00
f010d016:	66 c7 05 02 3b 5c f0 	movw   $0x8,0xf05c3b02
f010d01d:	08 00 
f010d01f:	a0 04 3b 5c f0       	mov    0xf05c3b04,%al
f010d024:	83 e0 e0             	and    $0xffffffe0,%eax
f010d027:	a2 04 3b 5c f0       	mov    %al,0xf05c3b04
f010d02c:	a0 04 3b 5c f0       	mov    0xf05c3b04,%al
f010d031:	83 e0 1f             	and    $0x1f,%eax
f010d034:	a2 04 3b 5c f0       	mov    %al,0xf05c3b04
f010d039:	a0 05 3b 5c f0       	mov    0xf05c3b05,%al
f010d03e:	83 e0 f0             	and    $0xfffffff0,%eax
f010d041:	83 c8 0e             	or     $0xe,%eax
f010d044:	a2 05 3b 5c f0       	mov    %al,0xf05c3b05
f010d049:	a0 05 3b 5c f0       	mov    0xf05c3b05,%al
f010d04e:	83 e0 ef             	and    $0xffffffef,%eax
f010d051:	a2 05 3b 5c f0       	mov    %al,0xf05c3b05
f010d056:	a0 05 3b 5c f0       	mov    0xf05c3b05,%al
f010d05b:	83 c8 60             	or     $0x60,%eax
f010d05e:	a2 05 3b 5c f0       	mov    %al,0xf05c3b05
f010d063:	a0 05 3b 5c f0       	mov    0xf05c3b05,%al
f010d068:	83 c8 80             	or     $0xffffff80,%eax
f010d06b:	a2 05 3b 5c f0       	mov    %al,0xf05c3b05
f010d070:	b8 ac d7 10 f0       	mov    $0xf010d7ac,%eax
f010d075:	c1 e8 10             	shr    $0x10,%eax
f010d078:	66 a3 06 3b 5c f0    	mov    %ax,0xf05c3b06
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010d07e:	b8 b2 d7 10 f0       	mov    $0xf010d7b2,%eax
f010d083:	66 a3 08 3b 5c f0    	mov    %ax,0xf05c3b08
f010d089:	66 c7 05 0a 3b 5c f0 	movw   $0x8,0xf05c3b0a
f010d090:	08 00 
f010d092:	a0 0c 3b 5c f0       	mov    0xf05c3b0c,%al
f010d097:	83 e0 e0             	and    $0xffffffe0,%eax
f010d09a:	a2 0c 3b 5c f0       	mov    %al,0xf05c3b0c
f010d09f:	a0 0c 3b 5c f0       	mov    0xf05c3b0c,%al
f010d0a4:	83 e0 1f             	and    $0x1f,%eax
f010d0a7:	a2 0c 3b 5c f0       	mov    %al,0xf05c3b0c
f010d0ac:	a0 0d 3b 5c f0       	mov    0xf05c3b0d,%al
f010d0b1:	83 e0 f0             	and    $0xfffffff0,%eax
f010d0b4:	83 c8 0e             	or     $0xe,%eax
f010d0b7:	a2 0d 3b 5c f0       	mov    %al,0xf05c3b0d
f010d0bc:	a0 0d 3b 5c f0       	mov    0xf05c3b0d,%al
f010d0c1:	83 e0 ef             	and    $0xffffffef,%eax
f010d0c4:	a2 0d 3b 5c f0       	mov    %al,0xf05c3b0d
f010d0c9:	a0 0d 3b 5c f0       	mov    0xf05c3b0d,%al
f010d0ce:	83 c8 60             	or     $0x60,%eax
f010d0d1:	a2 0d 3b 5c f0       	mov    %al,0xf05c3b0d
f010d0d6:	a0 0d 3b 5c f0       	mov    0xf05c3b0d,%al
f010d0db:	83 c8 80             	or     $0xffffff80,%eax
f010d0de:	a2 0d 3b 5c f0       	mov    %al,0xf05c3b0d
f010d0e3:	b8 b2 d7 10 f0       	mov    $0xf010d7b2,%eax
f010d0e8:	c1 e8 10             	shr    $0x10,%eax
f010d0eb:	66 a3 0e 3b 5c f0    	mov    %ax,0xf05c3b0e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010d0f1:	b8 b8 d7 10 f0       	mov    $0xf010d7b8,%eax
f010d0f6:	66 a3 10 3b 5c f0    	mov    %ax,0xf05c3b10
f010d0fc:	66 c7 05 12 3b 5c f0 	movw   $0x8,0xf05c3b12
f010d103:	08 00 
f010d105:	a0 14 3b 5c f0       	mov    0xf05c3b14,%al
f010d10a:	83 e0 e0             	and    $0xffffffe0,%eax
f010d10d:	a2 14 3b 5c f0       	mov    %al,0xf05c3b14
f010d112:	a0 14 3b 5c f0       	mov    0xf05c3b14,%al
f010d117:	83 e0 1f             	and    $0x1f,%eax
f010d11a:	a2 14 3b 5c f0       	mov    %al,0xf05c3b14
f010d11f:	a0 15 3b 5c f0       	mov    0xf05c3b15,%al
f010d124:	83 e0 f0             	and    $0xfffffff0,%eax
f010d127:	83 c8 0e             	or     $0xe,%eax
f010d12a:	a2 15 3b 5c f0       	mov    %al,0xf05c3b15
f010d12f:	a0 15 3b 5c f0       	mov    0xf05c3b15,%al
f010d134:	83 e0 ef             	and    $0xffffffef,%eax
f010d137:	a2 15 3b 5c f0       	mov    %al,0xf05c3b15
f010d13c:	a0 15 3b 5c f0       	mov    0xf05c3b15,%al
f010d141:	83 c8 60             	or     $0x60,%eax
f010d144:	a2 15 3b 5c f0       	mov    %al,0xf05c3b15
f010d149:	a0 15 3b 5c f0       	mov    0xf05c3b15,%al
f010d14e:	83 c8 80             	or     $0xffffff80,%eax
f010d151:	a2 15 3b 5c f0       	mov    %al,0xf05c3b15
f010d156:	b8 b8 d7 10 f0       	mov    $0xf010d7b8,%eax
f010d15b:	c1 e8 10             	shr    $0x10,%eax
f010d15e:	66 a3 16 3b 5c f0    	mov    %ax,0xf05c3b16
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010d164:	b8 be d7 10 f0       	mov    $0xf010d7be,%eax
f010d169:	66 a3 18 3b 5c f0    	mov    %ax,0xf05c3b18
f010d16f:	66 c7 05 1a 3b 5c f0 	movw   $0x8,0xf05c3b1a
f010d176:	08 00 
f010d178:	a0 1c 3b 5c f0       	mov    0xf05c3b1c,%al
f010d17d:	83 e0 e0             	and    $0xffffffe0,%eax
f010d180:	a2 1c 3b 5c f0       	mov    %al,0xf05c3b1c
f010d185:	a0 1c 3b 5c f0       	mov    0xf05c3b1c,%al
f010d18a:	83 e0 1f             	and    $0x1f,%eax
f010d18d:	a2 1c 3b 5c f0       	mov    %al,0xf05c3b1c
f010d192:	a0 1d 3b 5c f0       	mov    0xf05c3b1d,%al
f010d197:	83 e0 f0             	and    $0xfffffff0,%eax
f010d19a:	83 c8 0e             	or     $0xe,%eax
f010d19d:	a2 1d 3b 5c f0       	mov    %al,0xf05c3b1d
f010d1a2:	a0 1d 3b 5c f0       	mov    0xf05c3b1d,%al
f010d1a7:	83 e0 ef             	and    $0xffffffef,%eax
f010d1aa:	a2 1d 3b 5c f0       	mov    %al,0xf05c3b1d
f010d1af:	a0 1d 3b 5c f0       	mov    0xf05c3b1d,%al
f010d1b4:	83 c8 60             	or     $0x60,%eax
f010d1b7:	a2 1d 3b 5c f0       	mov    %al,0xf05c3b1d
f010d1bc:	a0 1d 3b 5c f0       	mov    0xf05c3b1d,%al
f010d1c1:	83 c8 80             	or     $0xffffff80,%eax
f010d1c4:	a2 1d 3b 5c f0       	mov    %al,0xf05c3b1d
f010d1c9:	b8 be d7 10 f0       	mov    $0xf010d7be,%eax
f010d1ce:	c1 e8 10             	shr    $0x10,%eax
f010d1d1:	66 a3 1e 3b 5c f0    	mov    %ax,0xf05c3b1e
f010d1d7:	c7 45 fc a0 39 5c f0 	movl   $0xf05c39a0,-0x4(%ebp)
f010d1de:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010d1e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010d1e8:	48                   	dec    %eax
f010d1e9:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010d1ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010d1f0:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010d1f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010d1f7:	c1 e8 10             	shr    $0x10,%eax
f010d1fa:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010d1fe:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010d201:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010d204:	90                   	nop
f010d205:	c9                   	leave  
f010d206:	c3                   	ret    

f010d207 <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010d207:	55                   	push   %ebp
f010d208:	89 e5                	mov    %esp,%ebp
f010d20a:	53                   	push   %ebx
f010d20b:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010d20e:	83 ec 08             	sub    $0x8,%esp
f010d211:	ff 75 08             	pushl  0x8(%ebp)
f010d214:	68 5e 5e 12 f0       	push   $0xf0125e5e
f010d219:	e8 6d 3d ff ff       	call   f0100f8b <cprintf>
f010d21e:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010d221:	8b 45 08             	mov    0x8(%ebp),%eax
f010d224:	83 ec 0c             	sub    $0xc,%esp
f010d227:	50                   	push   %eax
f010d228:	e8 fd 00 00 00       	call   f010d32a <print_regs>
f010d22d:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010d230:	8b 45 08             	mov    0x8(%ebp),%eax
f010d233:	8b 40 20             	mov    0x20(%eax),%eax
f010d236:	0f b7 c0             	movzwl %ax,%eax
f010d239:	83 ec 08             	sub    $0x8,%esp
f010d23c:	50                   	push   %eax
f010d23d:	68 70 5e 12 f0       	push   $0xf0125e70
f010d242:	e8 44 3d ff ff       	call   f0100f8b <cprintf>
f010d247:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010d24a:	8b 45 08             	mov    0x8(%ebp),%eax
f010d24d:	8b 40 24             	mov    0x24(%eax),%eax
f010d250:	0f b7 c0             	movzwl %ax,%eax
f010d253:	83 ec 08             	sub    $0x8,%esp
f010d256:	50                   	push   %eax
f010d257:	68 83 5e 12 f0       	push   $0xf0125e83
f010d25c:	e8 2a 3d ff ff       	call   f0100f8b <cprintf>
f010d261:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010d264:	8b 45 08             	mov    0x8(%ebp),%eax
f010d267:	8b 58 28             	mov    0x28(%eax),%ebx
f010d26a:	8b 45 08             	mov    0x8(%ebp),%eax
f010d26d:	8b 40 28             	mov    0x28(%eax),%eax
f010d270:	83 ec 0c             	sub    $0xc,%esp
f010d273:	50                   	push   %eax
f010d274:	e8 28 ee ff ff       	call   f010c0a1 <trapname>
f010d279:	83 c4 10             	add    $0x10,%esp
f010d27c:	89 c2                	mov    %eax,%edx
f010d27e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d281:	8b 40 28             	mov    0x28(%eax),%eax
f010d284:	53                   	push   %ebx
f010d285:	52                   	push   %edx
f010d286:	50                   	push   %eax
f010d287:	68 96 5e 12 f0       	push   $0xf0125e96
f010d28c:	e8 fa 3c ff ff       	call   f0100f8b <cprintf>
f010d291:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010d294:	8b 45 08             	mov    0x8(%ebp),%eax
f010d297:	8b 40 2c             	mov    0x2c(%eax),%eax
f010d29a:	83 ec 08             	sub    $0x8,%esp
f010d29d:	50                   	push   %eax
f010d29e:	68 ad 5e 12 f0       	push   $0xf0125ead
f010d2a3:	e8 e3 3c ff ff       	call   f0100f8b <cprintf>
f010d2a8:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010d2ab:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2ae:	8b 40 30             	mov    0x30(%eax),%eax
f010d2b1:	83 ec 08             	sub    $0x8,%esp
f010d2b4:	50                   	push   %eax
f010d2b5:	68 bc 5e 12 f0       	push   $0xf0125ebc
f010d2ba:	e8 cc 3c ff ff       	call   f0100f8b <cprintf>
f010d2bf:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010d2c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2c5:	8b 40 34             	mov    0x34(%eax),%eax
f010d2c8:	0f b7 c0             	movzwl %ax,%eax
f010d2cb:	83 ec 08             	sub    $0x8,%esp
f010d2ce:	50                   	push   %eax
f010d2cf:	68 cb 5e 12 f0       	push   $0xf0125ecb
f010d2d4:	e8 b2 3c ff ff       	call   f0100f8b <cprintf>
f010d2d9:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010d2dc:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2df:	8b 40 38             	mov    0x38(%eax),%eax
f010d2e2:	83 ec 08             	sub    $0x8,%esp
f010d2e5:	50                   	push   %eax
f010d2e6:	68 de 5e 12 f0       	push   $0xf0125ede
f010d2eb:	e8 9b 3c ff ff       	call   f0100f8b <cprintf>
f010d2f0:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010d2f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2f6:	8b 40 3c             	mov    0x3c(%eax),%eax
f010d2f9:	83 ec 08             	sub    $0x8,%esp
f010d2fc:	50                   	push   %eax
f010d2fd:	68 ed 5e 12 f0       	push   $0xf0125eed
f010d302:	e8 84 3c ff ff       	call   f0100f8b <cprintf>
f010d307:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010d30a:	8b 45 08             	mov    0x8(%ebp),%eax
f010d30d:	8b 40 40             	mov    0x40(%eax),%eax
f010d310:	0f b7 c0             	movzwl %ax,%eax
f010d313:	83 ec 08             	sub    $0x8,%esp
f010d316:	50                   	push   %eax
f010d317:	68 fc 5e 12 f0       	push   $0xf0125efc
f010d31c:	e8 6a 3c ff ff       	call   f0100f8b <cprintf>
f010d321:	83 c4 10             	add    $0x10,%esp
}
f010d324:	90                   	nop
f010d325:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010d328:	c9                   	leave  
f010d329:	c3                   	ret    

f010d32a <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010d32a:	55                   	push   %ebp
f010d32b:	89 e5                	mov    %esp,%ebp
f010d32d:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010d330:	8b 45 08             	mov    0x8(%ebp),%eax
f010d333:	8b 00                	mov    (%eax),%eax
f010d335:	83 ec 08             	sub    $0x8,%esp
f010d338:	50                   	push   %eax
f010d339:	68 0f 5f 12 f0       	push   $0xf0125f0f
f010d33e:	e8 48 3c ff ff       	call   f0100f8b <cprintf>
f010d343:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010d346:	8b 45 08             	mov    0x8(%ebp),%eax
f010d349:	8b 40 04             	mov    0x4(%eax),%eax
f010d34c:	83 ec 08             	sub    $0x8,%esp
f010d34f:	50                   	push   %eax
f010d350:	68 1e 5f 12 f0       	push   $0xf0125f1e
f010d355:	e8 31 3c ff ff       	call   f0100f8b <cprintf>
f010d35a:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010d35d:	8b 45 08             	mov    0x8(%ebp),%eax
f010d360:	8b 40 08             	mov    0x8(%eax),%eax
f010d363:	83 ec 08             	sub    $0x8,%esp
f010d366:	50                   	push   %eax
f010d367:	68 2d 5f 12 f0       	push   $0xf0125f2d
f010d36c:	e8 1a 3c ff ff       	call   f0100f8b <cprintf>
f010d371:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010d374:	8b 45 08             	mov    0x8(%ebp),%eax
f010d377:	8b 40 0c             	mov    0xc(%eax),%eax
f010d37a:	83 ec 08             	sub    $0x8,%esp
f010d37d:	50                   	push   %eax
f010d37e:	68 3c 5f 12 f0       	push   $0xf0125f3c
f010d383:	e8 03 3c ff ff       	call   f0100f8b <cprintf>
f010d388:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010d38b:	8b 45 08             	mov    0x8(%ebp),%eax
f010d38e:	8b 40 10             	mov    0x10(%eax),%eax
f010d391:	83 ec 08             	sub    $0x8,%esp
f010d394:	50                   	push   %eax
f010d395:	68 4b 5f 12 f0       	push   $0xf0125f4b
f010d39a:	e8 ec 3b ff ff       	call   f0100f8b <cprintf>
f010d39f:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010d3a2:	8b 45 08             	mov    0x8(%ebp),%eax
f010d3a5:	8b 40 14             	mov    0x14(%eax),%eax
f010d3a8:	83 ec 08             	sub    $0x8,%esp
f010d3ab:	50                   	push   %eax
f010d3ac:	68 5a 5f 12 f0       	push   $0xf0125f5a
f010d3b1:	e8 d5 3b ff ff       	call   f0100f8b <cprintf>
f010d3b6:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010d3b9:	8b 45 08             	mov    0x8(%ebp),%eax
f010d3bc:	8b 40 18             	mov    0x18(%eax),%eax
f010d3bf:	83 ec 08             	sub    $0x8,%esp
f010d3c2:	50                   	push   %eax
f010d3c3:	68 69 5f 12 f0       	push   $0xf0125f69
f010d3c8:	e8 be 3b ff ff       	call   f0100f8b <cprintf>
f010d3cd:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010d3d0:	8b 45 08             	mov    0x8(%ebp),%eax
f010d3d3:	8b 40 1c             	mov    0x1c(%eax),%eax
f010d3d6:	83 ec 08             	sub    $0x8,%esp
f010d3d9:	50                   	push   %eax
f010d3da:	68 78 5f 12 f0       	push   $0xf0125f78
f010d3df:	e8 a7 3b ff ff       	call   f0100f8b <cprintf>
f010d3e4:	83 c4 10             	add    $0x10,%esp
}
f010d3e7:	90                   	nop
f010d3e8:	c9                   	leave  
f010d3e9:	c3                   	ret    

f010d3ea <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010d3ea:	55                   	push   %ebp
f010d3eb:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010d3ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010d3f0:	8b 55 0c             	mov    0xc(%ebp),%edx
f010d3f3:	89 14 85 a0 41 5c f0 	mov    %edx,-0xfa3be60(,%eax,4)
}
f010d3fa:	90                   	nop
f010d3fb:	5d                   	pop    %ebp
f010d3fc:	c3                   	ret    

f010d3fd <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010d3fd:	55                   	push   %ebp
f010d3fe:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010d400:	8b 45 08             	mov    0x8(%ebp),%eax
f010d403:	c7 04 85 a0 41 5c f0 	movl   $0x0,-0xfa3be60(,%eax,4)
f010d40a:	00 00 00 00 
}
f010d40e:	90                   	nop
f010d40f:	5d                   	pop    %ebp
f010d410:	c3                   	ret    

f010d411 <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010d411:	55                   	push   %ebp
f010d412:	89 e5                	mov    %esp,%ebp
f010d414:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010d417:	8b 45 08             	mov    0x8(%ebp),%eax
f010d41a:	8b 40 28             	mov    0x28(%eax),%eax
f010d41d:	83 e8 20             	sub    $0x20,%eax
f010d420:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010d423:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d426:	8b 04 85 a0 41 5c f0 	mov    -0xfa3be60(,%eax,4),%eax
f010d42d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010d430:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010d434:	74 0e                	je     f010d444 <irq_dispatch+0x33>
	{
		handler(tf);
f010d436:	83 ec 0c             	sub    $0xc,%esp
f010d439:	ff 75 08             	pushl  0x8(%ebp)
f010d43c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d43f:	ff d0                	call   *%eax
f010d441:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010d444:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d447:	0f b6 c0             	movzbl %al,%eax
f010d44a:	83 ec 0c             	sub    $0xc,%esp
f010d44d:	50                   	push   %eax
f010d44e:	e8 b8 9c ff ff       	call   f010710b <pic_sendEOI>
f010d453:	83 c4 10             	add    $0x10,%esp
}
f010d456:	90                   	nop
f010d457:	c9                   	leave  
f010d458:	c3                   	ret    

f010d459 <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010d459:	55                   	push   %ebp
f010d45a:	89 e5                	mov    %esp,%ebp
f010d45c:	57                   	push   %edi
f010d45d:	56                   	push   %esi
f010d45e:	53                   	push   %ebx
f010d45f:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010d462:	8b 45 08             	mov    0x8(%ebp),%eax
f010d465:	8b 40 28             	mov    0x28(%eax),%eax
f010d468:	83 f8 0e             	cmp    $0xe,%eax
f010d46b:	75 51                	jne    f010d4be <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010d46d:	a0 e0 41 5c f0       	mov    0xf05c41e0,%al
f010d472:	84 c0                	test   %al,%al
f010d474:	74 1f                	je     f010d495 <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010d476:	8b 45 08             	mov    0x8(%ebp),%eax
f010d479:	8b 40 30             	mov    0x30(%eax),%eax
f010d47c:	89 c2                	mov    %eax,%edx
f010d47e:	a0 e0 41 5c f0       	mov    0xf05c41e0,%al
f010d483:	0f b6 c0             	movzbl %al,%eax
f010d486:	01 d0                	add    %edx,%eax
f010d488:	89 c2                	mov    %eax,%edx
f010d48a:	8b 45 08             	mov    0x8(%ebp),%eax
f010d48d:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010d490:	e9 0c 01 00 00       	jmp    f010d5a1 <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010d495:	83 ec 0c             	sub    $0xc,%esp
f010d498:	6a 01                	push   $0x1
f010d49a:	e8 bf 12 00 00       	call   f010e75e <isPageReplacmentAlgorithmLRU>
f010d49f:	83 c4 10             	add    $0x10,%esp
f010d4a2:	85 c0                	test   %eax,%eax
f010d4a4:	74 05                	je     f010d4ab <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010d4a6:	e8 cf 97 ff ff       	call   f0106c7a <update_WS_time_stamps>
		}
		fault_handler(tf);
f010d4ab:	83 ec 0c             	sub    $0xc,%esp
f010d4ae:	ff 75 08             	pushl  0x8(%ebp)
f010d4b1:	e8 8d 13 00 00       	call   f010e843 <fault_handler>
f010d4b6:	83 c4 10             	add    $0x10,%esp
f010d4b9:	e9 e3 00 00 00       	jmp    f010d5a1 <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010d4be:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4c1:	8b 40 28             	mov    0x28(%eax),%eax
f010d4c4:	83 f8 30             	cmp    $0x30,%eax
f010d4c7:	75 6e                	jne    f010d537 <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010d4c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4cc:	8b 40 38             	mov    0x38(%eax),%eax
f010d4cf:	25 00 02 00 00       	and    $0x200,%eax
f010d4d4:	85 c0                	test   %eax,%eax
f010d4d6:	74 06                	je     f010d4de <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010d4d8:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010d4d9:	e8 45 78 ff ff       	call   f0104d23 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010d4de:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4e1:	8b 78 04             	mov    0x4(%eax),%edi
f010d4e4:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4e7:	8b 30                	mov    (%eax),%esi
f010d4e9:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4ec:	8b 58 10             	mov    0x10(%eax),%ebx
f010d4ef:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4f2:	8b 48 18             	mov    0x18(%eax),%ecx
f010d4f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4f8:	8b 50 14             	mov    0x14(%eax),%edx
f010d4fb:	8b 45 08             	mov    0x8(%ebp),%eax
f010d4fe:	8b 40 1c             	mov    0x1c(%eax),%eax
f010d501:	83 ec 08             	sub    $0x8,%esp
f010d504:	57                   	push   %edi
f010d505:	56                   	push   %esi
f010d506:	53                   	push   %ebx
f010d507:	51                   	push   %ecx
f010d508:	52                   	push   %edx
f010d509:	50                   	push   %eax
f010d50a:	e8 71 09 00 00       	call   f010de80 <syscall>
f010d50f:	83 c4 20             	add    $0x20,%esp
f010d512:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010d515:	8b 45 08             	mov    0x8(%ebp),%eax
f010d518:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010d51b:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d51e:	9c                   	pushf  
f010d51f:	58                   	pop    %eax
f010d520:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010d523:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010d526:	25 00 02 00 00       	and    $0x200,%eax
f010d52b:	85 c0                	test   %eax,%eax
f010d52d:	74 72                	je     f010d5a1 <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010d52f:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010d530:	e8 c6 77 ff ff       	call   f0104cfb <kclock_stop>
f010d535:	eb 6a                	jmp    f010d5a1 <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010d537:	8b 45 08             	mov    0x8(%ebp),%eax
f010d53a:	8b 40 28             	mov    0x28(%eax),%eax
f010d53d:	83 f8 08             	cmp    $0x8,%eax
f010d540:	75 17                	jne    f010d559 <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010d542:	83 ec 04             	sub    $0x4,%esp
f010d545:	68 87 5f 12 f0       	push   $0xf0125f87
f010d54a:	68 22 01 00 00       	push   $0x122
f010d54f:	68 96 5f 12 f0       	push   $0xf0125f96
f010d554:	e8 e0 2d ff ff       	call   f0100339 <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010d559:	83 ec 0c             	sub    $0xc,%esp
f010d55c:	ff 75 08             	pushl  0x8(%ebp)
f010d55f:	e8 a3 fc ff ff       	call   f010d207 <print_trapframe>
f010d564:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010d567:	8b 45 08             	mov    0x8(%ebp),%eax
f010d56a:	8b 40 34             	mov    0x34(%eax),%eax
f010d56d:	66 83 f8 08          	cmp    $0x8,%ax
f010d571:	75 17                	jne    f010d58a <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010d573:	83 ec 04             	sub    $0x4,%esp
f010d576:	68 a7 5f 12 f0       	push   $0xf0125fa7
f010d57b:	68 2a 01 00 00       	push   $0x12a
f010d580:	68 96 5f 12 f0       	push   $0xf0125f96
f010d585:	e8 af 2d ff ff       	call   f0100339 <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010d58a:	83 ec 04             	sub    $0x4,%esp
f010d58d:	68 c0 5f 12 f0       	push   $0xf0125fc0
f010d592:	68 2f 01 00 00       	push   $0x12f
f010d597:	68 96 5f 12 f0       	push   $0xf0125f96
f010d59c:	e8 98 2d ff ff       	call   f0100339 <_panic>
		}
	}
}
f010d5a1:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010d5a4:	5b                   	pop    %ebx
f010d5a5:	5e                   	pop    %esi
f010d5a6:	5f                   	pop    %edi
f010d5a7:	5d                   	pop    %ebp
f010d5a8:	c3                   	ret    

f010d5a9 <trap>:

void trap(struct Trapframe *tf)
{
f010d5a9:	55                   	push   %ebp
f010d5aa:	89 e5                	mov    %esp,%ebp
f010d5ac:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010d5af:	e8 47 77 ff ff       	call   f0104cfb <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d5b4:	9c                   	pushf  
f010d5b5:	58                   	pop    %eax
f010d5b6:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010d5b9:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010d5bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010d5bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d5c2:	25 00 02 00 00       	and    $0x200,%eax
f010d5c7:	85 c0                	test   %eax,%eax
f010d5c9:	74 25                	je     f010d5f0 <trap+0x47>
	{
		print_trapframe(tf);
f010d5cb:	83 ec 0c             	sub    $0xc,%esp
f010d5ce:	ff 75 08             	pushl  0x8(%ebp)
f010d5d1:	e8 31 fc ff ff       	call   f010d207 <print_trapframe>
f010d5d6:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010d5d9:	83 ec 04             	sub    $0x4,%esp
f010d5dc:	68 e0 5f 12 f0       	push   $0xf0125fe0
f010d5e1:	68 45 01 00 00       	push   $0x145
f010d5e6:	68 96 5f 12 f0       	push   $0xf0125f96
f010d5eb:	e8 49 2d ff ff       	call   f0100339 <_panic>
	}

	int userTrap = 0;
f010d5f0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010d5f7:	e8 5d d6 ff ff       	call   f010ac59 <get_cpu_proc>
f010d5fc:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010d5ff:	8b 45 08             	mov    0x8(%ebp),%eax
f010d602:	8b 40 34             	mov    0x34(%eax),%eax
f010d605:	0f b7 c0             	movzwl %ax,%eax
f010d608:	83 e0 03             	and    $0x3,%eax
f010d60b:	83 f8 03             	cmp    $0x3,%eax
f010d60e:	75 54                	jne    f010d664 <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010d610:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010d614:	74 0b                	je     f010d621 <trap+0x78>
f010d616:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d619:	8b 40 18             	mov    0x18(%eax),%eax
f010d61c:	83 f8 02             	cmp    $0x2,%eax
f010d61f:	74 19                	je     f010d63a <trap+0x91>
f010d621:	68 24 60 12 f0       	push   $0xf0126024
f010d626:	68 52 60 12 f0       	push   $0xf0126052
f010d62b:	68 4d 01 00 00       	push   $0x14d
f010d630:	68 96 5f 12 f0       	push   $0xf0125f96
f010d635:	e8 ff 2c ff ff       	call   f0100339 <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010d63a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d63d:	8b 00                	mov    (%eax),%eax
f010d63f:	3b 45 08             	cmp    0x8(%ebp),%eax
f010d642:	74 19                	je     f010d65d <trap+0xb4>
f010d644:	68 67 60 12 f0       	push   $0xf0126067
f010d649:	68 52 60 12 f0       	push   $0xf0126052
f010d64e:	68 4f 01 00 00       	push   $0x14f
f010d653:	68 96 5f 12 f0       	push   $0xf0125f96
f010d658:	e8 dc 2c ff ff       	call   f0100339 <_panic>
		userTrap = 1;
f010d65d:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010d664:	8b 45 08             	mov    0x8(%ebp),%eax
f010d667:	8b 40 28             	mov    0x28(%eax),%eax
f010d66a:	83 f8 1f             	cmp    $0x1f,%eax
f010d66d:	76 1b                	jbe    f010d68a <trap+0xe1>
f010d66f:	8b 45 08             	mov    0x8(%ebp),%eax
f010d672:	8b 40 28             	mov    0x28(%eax),%eax
f010d675:	83 f8 2f             	cmp    $0x2f,%eax
f010d678:	77 10                	ja     f010d68a <trap+0xe1>
	{
		irq_dispatch(tf);
f010d67a:	83 ec 0c             	sub    $0xc,%esp
f010d67d:	ff 75 08             	pushl  0x8(%ebp)
f010d680:	e8 8c fd ff ff       	call   f010d411 <irq_dispatch>
f010d685:	83 c4 10             	add    $0x10,%esp
f010d688:	eb 0e                	jmp    f010d698 <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010d68a:	83 ec 0c             	sub    $0xc,%esp
f010d68d:	ff 75 08             	pushl  0x8(%ebp)
f010d690:	e8 c4 fd ff ff       	call   f010d459 <trap_dispatch>
f010d695:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d698:	9c                   	pushf  
f010d699:	58                   	pop    %eax
f010d69a:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010d69d:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010d6a0:	25 00 02 00 00       	and    $0x200,%eax
f010d6a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010d6a8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010d6ac:	74 19                	je     f010d6c7 <trap+0x11e>
f010d6ae:	68 7d 60 12 f0       	push   $0xf012607d
f010d6b3:	68 52 60 12 f0       	push   $0xf0126052
f010d6b8:	68 66 01 00 00       	push   $0x166
f010d6bd:	68 96 5f 12 f0       	push   $0xf0125f96
f010d6c2:	e8 72 2c ff ff       	call   f0100339 <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010d6c7:	e8 57 76 ff ff       	call   f0104d23 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010d6cc:	90                   	nop
f010d6cd:	c9                   	leave  
f010d6ce:	c3                   	ret    
f010d6cf:	90                   	nop

f010d6d0 <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010d6d0:	6a 08                	push   $0x8
f010d6d2:	e9 ed 00 00 00       	jmp    f010d7c4 <_alltraps>
f010d6d7:	90                   	nop

f010d6d8 <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010d6d8:	6a 0e                	push   $0xe
f010d6da:	e9 e5 00 00 00       	jmp    f010d7c4 <_alltraps>
f010d6df:	90                   	nop

f010d6e0 <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010d6e0:	6a 00                	push   $0x0
f010d6e2:	6a 20                	push   $0x20
f010d6e4:	e9 db 00 00 00       	jmp    f010d7c4 <_alltraps>
f010d6e9:	90                   	nop

f010d6ea <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010d6ea:	6a 00                	push   $0x0
f010d6ec:	6a 21                	push   $0x21
f010d6ee:	e9 d1 00 00 00       	jmp    f010d7c4 <_alltraps>
f010d6f3:	90                   	nop

f010d6f4 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010d6f4:	6a 00                	push   $0x0
f010d6f6:	6a 30                	push   $0x30
f010d6f8:	e9 c7 00 00 00       	jmp    f010d7c4 <_alltraps>
f010d6fd:	90                   	nop

f010d6fe <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010d6fe:	6a 00                	push   $0x0
f010d700:	6a 00                	push   $0x0
f010d702:	e9 bd 00 00 00       	jmp    f010d7c4 <_alltraps>
f010d707:	90                   	nop

f010d708 <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010d708:	6a 00                	push   $0x0
f010d70a:	6a 01                	push   $0x1
f010d70c:	e9 b3 00 00 00       	jmp    f010d7c4 <_alltraps>
f010d711:	90                   	nop

f010d712 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010d712:	6a 00                	push   $0x0
f010d714:	6a 02                	push   $0x2
f010d716:	e9 a9 00 00 00       	jmp    f010d7c4 <_alltraps>
f010d71b:	90                   	nop

f010d71c <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010d71c:	6a 00                	push   $0x0
f010d71e:	6a 03                	push   $0x3
f010d720:	e9 9f 00 00 00       	jmp    f010d7c4 <_alltraps>
f010d725:	90                   	nop

f010d726 <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010d726:	6a 00                	push   $0x0
f010d728:	6a 04                	push   $0x4
f010d72a:	e9 95 00 00 00       	jmp    f010d7c4 <_alltraps>
f010d72f:	90                   	nop

f010d730 <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010d730:	6a 00                	push   $0x0
f010d732:	6a 05                	push   $0x5
f010d734:	e9 8b 00 00 00       	jmp    f010d7c4 <_alltraps>
f010d739:	90                   	nop

f010d73a <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010d73a:	6a 00                	push   $0x0
f010d73c:	6a 06                	push   $0x6
f010d73e:	e9 81 00 00 00       	jmp    f010d7c4 <_alltraps>
f010d743:	90                   	nop

f010d744 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010d744:	6a 00                	push   $0x0
f010d746:	6a 07                	push   $0x7
f010d748:	eb 7a                	jmp    f010d7c4 <_alltraps>

f010d74a <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010d74a:	6a 0a                	push   $0xa
f010d74c:	eb 76                	jmp    f010d7c4 <_alltraps>

f010d74e <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010d74e:	6a 0b                	push   $0xb
f010d750:	eb 72                	jmp    f010d7c4 <_alltraps>

f010d752 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010d752:	6a 0c                	push   $0xc
f010d754:	eb 6e                	jmp    f010d7c4 <_alltraps>

f010d756 <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010d756:	6a 0d                	push   $0xd
f010d758:	eb 6a                	jmp    f010d7c4 <_alltraps>

f010d75a <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010d75a:	6a 00                	push   $0x0
f010d75c:	6a 10                	push   $0x10
f010d75e:	eb 64                	jmp    f010d7c4 <_alltraps>

f010d760 <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010d760:	6a 11                	push   $0x11
f010d762:	eb 60                	jmp    f010d7c4 <_alltraps>

f010d764 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010d764:	6a 00                	push   $0x0
f010d766:	6a 12                	push   $0x12
f010d768:	eb 5a                	jmp    f010d7c4 <_alltraps>

f010d76a <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010d76a:	6a 00                	push   $0x0
f010d76c:	6a 13                	push   $0x13
f010d76e:	eb 54                	jmp    f010d7c4 <_alltraps>

f010d770 <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010d770:	6a 00                	push   $0x0
f010d772:	6a 22                	push   $0x22
f010d774:	eb 4e                	jmp    f010d7c4 <_alltraps>

f010d776 <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010d776:	6a 00                	push   $0x0
f010d778:	6a 23                	push   $0x23
f010d77a:	eb 48                	jmp    f010d7c4 <_alltraps>

f010d77c <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010d77c:	6a 00                	push   $0x0
f010d77e:	6a 24                	push   $0x24
f010d780:	eb 42                	jmp    f010d7c4 <_alltraps>

f010d782 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010d782:	6a 00                	push   $0x0
f010d784:	6a 25                	push   $0x25
f010d786:	eb 3c                	jmp    f010d7c4 <_alltraps>

f010d788 <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010d788:	6a 00                	push   $0x0
f010d78a:	6a 26                	push   $0x26
f010d78c:	eb 36                	jmp    f010d7c4 <_alltraps>

f010d78e <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010d78e:	6a 00                	push   $0x0
f010d790:	6a 27                	push   $0x27
f010d792:	eb 30                	jmp    f010d7c4 <_alltraps>

f010d794 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010d794:	6a 00                	push   $0x0
f010d796:	6a 28                	push   $0x28
f010d798:	eb 2a                	jmp    f010d7c4 <_alltraps>

f010d79a <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010d79a:	6a 00                	push   $0x0
f010d79c:	6a 29                	push   $0x29
f010d79e:	eb 24                	jmp    f010d7c4 <_alltraps>

f010d7a0 <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010d7a0:	6a 00                	push   $0x0
f010d7a2:	6a 2a                	push   $0x2a
f010d7a4:	eb 1e                	jmp    f010d7c4 <_alltraps>

f010d7a6 <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010d7a6:	6a 00                	push   $0x0
f010d7a8:	6a 2b                	push   $0x2b
f010d7aa:	eb 18                	jmp    f010d7c4 <_alltraps>

f010d7ac <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010d7ac:	6a 00                	push   $0x0
f010d7ae:	6a 2c                	push   $0x2c
f010d7b0:	eb 12                	jmp    f010d7c4 <_alltraps>

f010d7b2 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010d7b2:	6a 00                	push   $0x0
f010d7b4:	6a 2d                	push   $0x2d
f010d7b6:	eb 0c                	jmp    f010d7c4 <_alltraps>

f010d7b8 <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010d7b8:	6a 00                	push   $0x0
f010d7ba:	6a 2e                	push   $0x2e
f010d7bc:	eb 06                	jmp    f010d7c4 <_alltraps>

f010d7be <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010d7be:	6a 00                	push   $0x0
f010d7c0:	6a 2f                	push   $0x2f
f010d7c2:	eb 00                	jmp    f010d7c4 <_alltraps>

f010d7c4 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010d7c4:	1e                   	push   %ds
push 	%es
f010d7c5:	06                   	push   %es
pushal
f010d7c6:	60                   	pusha  

mov 	$(GD_KD), %ax
f010d7c7:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010d7cb:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010d7cd:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010d7cf:	54                   	push   %esp
call 	trap
f010d7d0:	e8 d4 fd ff ff       	call   f010d5a9 <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010d7d5:	59                   	pop    %ecx

f010d7d6 <trapret>:
.globl trapret
trapret:
popal
f010d7d6:	61                   	popa   
pop 	%es
f010d7d7:	07                   	pop    %es
pop 	%ds
f010d7d8:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010d7d9:	83 c4 08             	add    $0x8,%esp
iret
f010d7dc:	cf                   	iret   

f010d7dd <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010d7dd:	55                   	push   %ebp
f010d7de:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010d7e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010d7e3:	8b 15 68 c9 5e f0    	mov    0xf05ec968,%edx
f010d7e9:	29 d0                	sub    %edx,%eax
f010d7eb:	c1 f8 02             	sar    $0x2,%eax
f010d7ee:	89 c2                	mov    %eax,%edx
f010d7f0:	89 d0                	mov    %edx,%eax
f010d7f2:	c1 e0 03             	shl    $0x3,%eax
f010d7f5:	01 d0                	add    %edx,%eax
f010d7f7:	c1 e0 03             	shl    $0x3,%eax
f010d7fa:	01 d0                	add    %edx,%eax
f010d7fc:	c1 e0 03             	shl    $0x3,%eax
f010d7ff:	01 d0                	add    %edx,%eax
f010d801:	c1 e0 03             	shl    $0x3,%eax
f010d804:	01 d0                	add    %edx,%eax
f010d806:	89 c1                	mov    %eax,%ecx
f010d808:	c1 e1 0f             	shl    $0xf,%ecx
f010d80b:	01 c8                	add    %ecx,%eax
f010d80d:	c1 e0 03             	shl    $0x3,%eax
f010d810:	01 d0                	add    %edx,%eax
f010d812:	f7 d8                	neg    %eax
}
f010d814:	5d                   	pop    %ebp
f010d815:	c3                   	ret    

f010d816 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010d816:	55                   	push   %ebp
f010d817:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010d819:	ff 75 08             	pushl  0x8(%ebp)
f010d81c:	e8 bc ff ff ff       	call   f010d7dd <to_frame_number>
f010d821:	83 c4 04             	add    $0x4,%esp
f010d824:	c1 e0 0c             	shl    $0xc,%eax
}
f010d827:	c9                   	leave  
f010d828:	c3                   	ret    

f010d829 <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010d829:	55                   	push   %ebp
f010d82a:	89 e5                	mov    %esp,%ebp
f010d82c:	83 ec 18             	sub    $0x18,%esp
f010d82f:	8b 45 10             	mov    0x10(%ebp),%eax
f010d832:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010d835:	e8 cd 99 ff ff       	call   f0107207 <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010d83a:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010d83e:	74 23                	je     f010d863 <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010d840:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010d845:	8b 40 10             	mov    0x10(%eax),%eax
f010d848:	8b 15 04 b1 60 f0    	mov    0xf060b104,%edx
f010d84e:	83 c2 20             	add    $0x20,%edx
f010d851:	83 ec 04             	sub    $0x4,%esp
f010d854:	50                   	push   %eax
f010d855:	52                   	push   %edx
f010d856:	68 30 62 12 f0       	push   $0xf0126230
f010d85b:	e8 2b 37 ff ff       	call   f0100f8b <cprintf>
f010d860:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010d863:	83 ec 04             	sub    $0x4,%esp
f010d866:	ff 75 08             	pushl  0x8(%ebp)
f010d869:	ff 75 0c             	pushl  0xc(%ebp)
f010d86c:	68 39 62 12 f0       	push   $0xf0126239
f010d871:	e8 15 37 ff ff       	call   f0100f8b <cprintf>
f010d876:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010d879:	e8 db 99 ff ff       	call   f0107259 <popcli>
}
f010d87e:	90                   	nop
f010d87f:	c9                   	leave  
f010d880:	c3                   	ret    

f010d881 <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010d881:	55                   	push   %ebp
f010d882:	89 e5                	mov    %esp,%ebp
f010d884:	83 ec 18             	sub    $0x18,%esp
f010d887:	8b 45 08             	mov    0x8(%ebp),%eax
f010d88a:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010d88d:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010d891:	83 ec 08             	sub    $0x8,%esp
f010d894:	50                   	push   %eax
f010d895:	68 3e 62 12 f0       	push   $0xf012623e
f010d89a:	e8 ec 36 ff ff       	call   f0100f8b <cprintf>
f010d89f:	83 c4 10             	add    $0x10,%esp
}
f010d8a2:	90                   	nop
f010d8a3:	c9                   	leave  
f010d8a4:	c3                   	ret    

f010d8a5 <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010d8a5:	55                   	push   %ebp
f010d8a6:	89 e5                	mov    %esp,%ebp
f010d8a8:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d8ab:	9c                   	pushf  
f010d8ac:	58                   	pop    %eax
f010d8ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010d8b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010d8b3:	25 00 02 00 00       	and    $0x200,%eax
f010d8b8:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010d8bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010d8bf:	74 10                	je     f010d8d1 <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010d8c1:	e8 fe 34 ff ff       	call   f0100dc4 <cons_getc2>
f010d8c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d8c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d8cd:	74 f2                	je     f010d8c1 <sys_cgetc+0x1c>
f010d8cf:	eb 0e                	jmp    f010d8df <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010d8d1:	e8 93 34 ff ff       	call   f0100d69 <cons_getc>
f010d8d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d8d9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d8dd:	74 f2                	je     f010d8d1 <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010d8df:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010d8e2:	c9                   	leave  
f010d8e3:	c3                   	ret    

f010d8e4 <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010d8e4:	55                   	push   %ebp
f010d8e5:	89 e5                	mov    %esp,%ebp
f010d8e7:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010d8ea:	e8 c1 35 ff ff       	call   f0100eb0 <cons_lock>
}
f010d8ef:	90                   	nop
f010d8f0:	c9                   	leave  
f010d8f1:	c3                   	ret    

f010d8f2 <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010d8f2:	55                   	push   %ebp
f010d8f3:	89 e5                	mov    %esp,%ebp
f010d8f5:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010d8f8:	e8 fa 35 ff ff       	call   f0100ef7 <cons_unlock>
}
f010d8fd:	90                   	nop
f010d8fe:	c9                   	leave  
f010d8ff:	c3                   	ret    

f010d900 <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010d900:	55                   	push   %ebp
f010d901:	89 e5                	mov    %esp,%ebp
f010d903:	83 ec 18             	sub    $0x18,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010d906:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010d90b:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010d90e:	83 ec 0c             	sub    $0xc,%esp
f010d911:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010d914:	50                   	push   %eax
f010d915:	e8 68 a9 ff ff       	call   f0108282 <allocate_frame>
f010d91a:	83 c4 10             	add    $0x10,%esp
f010d91d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010d920:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010d924:	75 08                	jne    f010d92e <__sys_allocate_page+0x2e>
		return r ;
f010d926:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d929:	e9 e9 00 00 00       	jmp    f010da17 <__sys_allocate_page+0x117>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010d92e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d931:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010d936:	77 0c                	ja     f010d944 <__sys_allocate_page+0x44>
f010d938:	8b 45 08             	mov    0x8(%ebp),%eax
f010d93b:	25 ff 0f 00 00       	and    $0xfff,%eax
f010d940:	85 c0                	test   %eax,%eax
f010d942:	74 0a                	je     f010d94e <__sys_allocate_page+0x4e>
		return E_INVAL;
f010d944:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010d949:	e9 c9 00 00 00       	jmp    f010da17 <__sys_allocate_page+0x117>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010d94e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d951:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010d956:	83 f8 04             	cmp    $0x4,%eax
f010d959:	74 0a                	je     f010d965 <__sys_allocate_page+0x65>
		return E_INVAL;
f010d95b:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010d960:	e9 b2 00 00 00       	jmp    f010da17 <__sys_allocate_page+0x117>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010d965:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d968:	83 ec 0c             	sub    $0xc,%esp
f010d96b:	50                   	push   %eax
f010d96c:	e8 a5 fe ff ff       	call   f010d816 <to_physical_address>
f010d971:	83 c4 10             	add    $0x10,%esp
f010d974:	89 45 ec             	mov    %eax,-0x14(%ebp)
#if USE_KHEAP
	{
		//FIX: we should implement a better solution for this, but for now
		//		we are using an unsed VA in the invalid area of kernel at 0xef800000 (the current USER_LIMIT)
		//		to do temp initialization of a frame.
		map_frame(e->env_page_directory, ptr_frame_info, USER_LIMIT, PERM_WRITEABLE);
f010d977:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010d97a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d97d:	8b 40 64             	mov    0x64(%eax),%eax
f010d980:	6a 02                	push   $0x2
f010d982:	68 00 00 80 ef       	push   $0xef800000
f010d987:	52                   	push   %edx
f010d988:	50                   	push   %eax
f010d989:	e8 c1 ad ff ff       	call   f010874f <map_frame>
f010d98e:	83 c4 10             	add    $0x10,%esp
		memset((void*)USER_LIMIT, 0, PAGE_SIZE);
f010d991:	83 ec 04             	sub    $0x4,%esp
f010d994:	68 00 10 00 00       	push   $0x1000
f010d999:	6a 00                	push   $0x0
f010d99b:	68 00 00 80 ef       	push   $0xef800000
f010d9a0:	e8 28 14 01 00       	call   f011edcd <memset>
f010d9a5:	83 c4 10             	add    $0x10,%esp

		// Temporarily increase the references to prevent unmap_frame from removing the frame
		// we just got from allocate_frame, we will use it for the new page
		ptr_frame_info->references += 1;
f010d9a8:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010d9ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d9ae:	8b 40 08             	mov    0x8(%eax),%eax
f010d9b1:	40                   	inc    %eax
f010d9b2:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(e->env_page_directory, USER_LIMIT);
f010d9b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d9b9:	8b 40 64             	mov    0x64(%eax),%eax
f010d9bc:	83 ec 08             	sub    $0x8,%esp
f010d9bf:	68 00 00 80 ef       	push   $0xef800000
f010d9c4:	50                   	push   %eax
f010d9c5:	e8 e5 ae ff ff       	call   f01088af <unmap_frame>
f010d9ca:	83 c4 10             	add    $0x10,%esp

		//return it to the original status
		ptr_frame_info->references -= 1;
f010d9cd:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010d9d0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d9d3:	8b 40 08             	mov    0x8(%eax),%eax
f010d9d6:	48                   	dec    %eax
f010d9d7:	66 89 42 08          	mov    %ax,0x8(%edx)
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010d9db:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010d9de:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010d9e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d9e4:	8b 40 64             	mov    0x64(%eax),%eax
f010d9e7:	ff 75 0c             	pushl  0xc(%ebp)
f010d9ea:	51                   	push   %ecx
f010d9eb:	52                   	push   %edx
f010d9ec:	50                   	push   %eax
f010d9ed:	e8 5d ad ff ff       	call   f010874f <map_frame>
f010d9f2:	83 c4 10             	add    $0x10,%esp
f010d9f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010d9f8:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010d9fc:	75 14                	jne    f010da12 <__sys_allocate_page+0x112>
	{
		decrement_references(ptr_frame_info);
f010d9fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010da01:	83 ec 0c             	sub    $0xc,%esp
f010da04:	50                   	push   %eax
f010da05:	e8 85 aa ff ff       	call   f010848f <decrement_references>
f010da0a:	83 c4 10             	add    $0x10,%esp
		return r;
f010da0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010da10:	eb 05                	jmp    f010da17 <__sys_allocate_page+0x117>
	}
	return 0 ;
f010da12:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010da17:	c9                   	leave  
f010da18:	c3                   	ret    

f010da19 <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010da19:	55                   	push   %ebp
f010da1a:	89 e5                	mov    %esp,%ebp
f010da1c:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010da1f:	83 ec 04             	sub    $0x4,%esp
f010da22:	68 41 62 12 f0       	push   $0xf0126241
f010da27:	68 dc 00 00 00       	push   $0xdc
f010da2c:	68 5f 62 12 f0       	push   $0xf012625f
f010da31:	e8 03 29 ff ff       	call   f0100339 <_panic>

f010da36 <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010da36:	55                   	push   %ebp
f010da37:	89 e5                	mov    %esp,%ebp
f010da39:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010da3c:	83 ec 04             	sub    $0x4,%esp
f010da3f:	68 74 62 12 f0       	push   $0xf0126274
f010da44:	68 ed 00 00 00       	push   $0xed
f010da49:	68 5f 62 12 f0       	push   $0xf012625f
f010da4e:	e8 e6 28 ff ff       	call   f0100339 <_panic>

f010da53 <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010da53:	55                   	push   %ebp
f010da54:	89 e5                	mov    %esp,%ebp
f010da56:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010da59:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010da5e:	8b 40 64             	mov    0x64(%eax),%eax
f010da61:	83 ec 04             	sub    $0x4,%esp
f010da64:	ff 75 0c             	pushl  0xc(%ebp)
f010da67:	ff 75 08             	pushl  0x8(%ebp)
f010da6a:	50                   	push   %eax
f010da6b:	e8 40 c5 ff ff       	call   f0109fb0 <calculate_required_frames>
f010da70:	83 c4 10             	add    $0x10,%esp
}
f010da73:	c9                   	leave  
f010da74:	c3                   	ret    

f010da75 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010da75:	55                   	push   %ebp
f010da76:	89 e5                	mov    %esp,%ebp
f010da78:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010da7b:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010da7e:	83 ec 0c             	sub    $0xc,%esp
f010da81:	50                   	push   %eax
f010da82:	e8 aa af ff ff       	call   f0108a31 <calculate_available_frames>
f010da87:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010da8a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010da8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010da90:	01 d0                	add    %edx,%eax
}
f010da92:	c9                   	leave  
f010da93:	c3                   	ret    

f010da94 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010da94:	55                   	push   %ebp
f010da95:	89 e5                	mov    %esp,%ebp
f010da97:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010da9a:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010da9d:	83 ec 0c             	sub    $0xc,%esp
f010daa0:	50                   	push   %eax
f010daa1:	e8 8b af ff ff       	call   f0108a31 <calculate_available_frames>
f010daa6:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010daa9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010daac:	c9                   	leave  
f010daad:	c3                   	ret    

f010daae <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010daae:	55                   	push   %ebp
f010daaf:	89 e5                	mov    %esp,%ebp
f010dab1:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010dab4:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010dab7:	83 ec 0c             	sub    $0xc,%esp
f010daba:	50                   	push   %eax
f010dabb:	e8 71 af ff ff       	call   f0108a31 <calculate_available_frames>
f010dac0:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010dac3:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010dac6:	c9                   	leave  
f010dac7:	c3                   	ret    

f010dac8 <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010dac8:	55                   	push   %ebp
f010dac9:	89 e5                	mov    %esp,%ebp
f010dacb:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010dace:	83 ec 0c             	sub    $0xc,%esp
f010dad1:	ff 75 08             	pushl  0x8(%ebp)
f010dad4:	e8 9d fe 00 00       	call   f011d976 <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010dad9:	83 c4 10             	add    $0x10,%esp
}
f010dadc:	c9                   	leave  
f010dadd:	c3                   	ret    

f010dade <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010dade:	55                   	push   %ebp
f010dadf:	89 e5                	mov    %esp,%ebp
f010dae1:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010dae4:	e8 b8 fd 00 00       	call   f011d8a1 <scarce_memory>
}
f010dae9:	90                   	nop
f010daea:	c9                   	leave  
f010daeb:	c3                   	ret    

f010daec <sys_clearFFL>:

void sys_clearFFL()
{
f010daec:	55                   	push   %ebp
f010daed:	89 e5                	mov    %esp,%ebp
f010daef:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010daf2:	83 ec 0c             	sub    $0xc,%esp
f010daf5:	68 20 c5 5e f0       	push   $0xf05ec520
f010dafa:	e8 c0 10 00 00       	call   f010ebbf <acquire_spinlock>
f010daff:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010db02:	a1 0c c5 5e f0       	mov    0xf05ec50c,%eax
f010db07:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010db0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010db11:	eb 12                	jmp    f010db25 <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010db13:	83 ec 0c             	sub    $0xc,%esp
f010db16:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010db19:	50                   	push   %eax
f010db1a:	e8 63 a7 ff ff       	call   f0108282 <allocate_frame>
f010db1f:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010db22:	ff 45 f4             	incl   -0xc(%ebp)
f010db25:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010db28:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010db2b:	7c e6                	jl     f010db13 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010db2d:	83 ec 0c             	sub    $0xc,%esp
f010db30:	68 20 c5 5e f0       	push   $0xf05ec520
f010db35:	e8 0c 11 00 00       	call   f010ec46 <release_spinlock>
f010db3a:	83 c4 10             	add    $0x10,%esp
}
f010db3d:	90                   	nop
f010db3e:	c9                   	leave  
f010db3f:	c3                   	ret    

f010db40 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010db40:	55                   	push   %ebp
f010db41:	89 e5                	mov    %esp,%ebp
f010db43:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010db46:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010db4b:	83 ec 0c             	sub    $0xc,%esp
f010db4e:	50                   	push   %eax
f010db4f:	e8 15 6d ff ff       	call   f0104869 <pf_calculate_allocated_pages>
f010db54:	83 c4 10             	add    $0x10,%esp
}
f010db57:	c9                   	leave  
f010db58:	c3                   	ret    

f010db59 <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010db59:	55                   	push   %ebp
f010db5a:	89 e5                	mov    %esp,%ebp
f010db5c:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010db5f:	e8 bd 0c 00 00       	call   f010e821 <isBufferingEnabled>
f010db64:	84 c0                	test   %al,%al
f010db66:	74 19                	je     f010db81 <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010db68:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010db6d:	83 ec 04             	sub    $0x4,%esp
f010db70:	ff 75 0c             	pushl  0xc(%ebp)
f010db73:	ff 75 08             	pushl  0x8(%ebp)
f010db76:	50                   	push   %eax
f010db77:	e8 92 c4 ff ff       	call   f010a00e <__free_user_mem_with_buffering>
f010db7c:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010db7f:	eb 18                	jmp    f010db99 <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010db81:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010db86:	83 ec 04             	sub    $0x4,%esp
f010db89:	ff 75 0c             	pushl  0xc(%ebp)
f010db8c:	ff 75 08             	pushl  0x8(%ebp)
f010db8f:	50                   	push   %eax
f010db90:	e8 5c c4 ff ff       	call   f0109ff1 <free_user_mem>
f010db95:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010db98:	90                   	nop
}
f010db99:	c9                   	leave  
f010db9a:	c3                   	ret    

f010db9b <sys_allocate_user_mem>:

void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010db9b:	55                   	push   %ebp
f010db9c:	89 e5                	mov    %esp,%ebp
f010db9e:	83 ec 08             	sub    $0x8,%esp



    if (virtual_address == 0 || (virtual_address < USER_HEAP_START || virtual_address >= USER_HEAP_MAX))
f010dba1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010dba5:	74 10                	je     f010dbb7 <sys_allocate_user_mem+0x1c>
f010dba7:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbaa:	85 c0                	test   %eax,%eax
f010dbac:	79 09                	jns    f010dbb7 <sys_allocate_user_mem+0x1c>
f010dbae:	81 7d 08 ff ff ff 9f 	cmpl   $0x9fffffff,0x8(%ebp)
f010dbb5:	76 05                	jbe    f010dbbc <sys_allocate_user_mem+0x21>
    {
        env_exit();
f010dbb7:	e8 5b d0 ff ff       	call   f010ac17 <env_exit>
    }


    allocate_user_mem(cur_env, virtual_address, size);
f010dbbc:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010dbc1:	83 ec 04             	sub    $0x4,%esp
f010dbc4:	ff 75 0c             	pushl  0xc(%ebp)
f010dbc7:	ff 75 08             	pushl  0x8(%ebp)
f010dbca:	50                   	push   %eax
f010dbcb:	e8 04 c4 ff ff       	call   f0109fd4 <allocate_user_mem>
f010dbd0:	83 c4 10             	add    $0x10,%esp
}
f010dbd3:	90                   	nop
f010dbd4:	c9                   	leave  
f010dbd5:	c3                   	ret    

f010dbd6 <sys_allocate_chunk>:

void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010dbd6:	55                   	push   %ebp
f010dbd7:	89 e5                	mov    %esp,%ebp
f010dbd9:	83 ec 08             	sub    $0x8,%esp
	  if (virtual_address == 0 || (virtual_address < USER_HEAP_START || virtual_address >= USER_HEAP_MAX))
f010dbdc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010dbe0:	74 10                	je     f010dbf2 <sys_allocate_chunk+0x1c>
f010dbe2:	8b 45 08             	mov    0x8(%ebp),%eax
f010dbe5:	85 c0                	test   %eax,%eax
f010dbe7:	79 09                	jns    f010dbf2 <sys_allocate_chunk+0x1c>
f010dbe9:	81 7d 08 ff ff ff 9f 	cmpl   $0x9fffffff,0x8(%ebp)
f010dbf0:	76 05                	jbe    f010dbf7 <sys_allocate_chunk+0x21>
	    {
	        env_exit();
f010dbf2:	e8 20 d0 ff ff       	call   f010ac17 <env_exit>
	    }

	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010dbf7:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010dbfc:	8b 40 64             	mov    0x64(%eax),%eax
f010dbff:	ff 75 10             	pushl  0x10(%ebp)
f010dc02:	ff 75 0c             	pushl  0xc(%ebp)
f010dc05:	ff 75 08             	pushl  0x8(%ebp)
f010dc08:	50                   	push   %eax
f010dc09:	e8 6e c3 ff ff       	call   f0109f7c <allocate_chunk>
f010dc0e:	83 c4 10             	add    $0x10,%esp
	return;
f010dc11:	90                   	nop
}
f010dc12:	c9                   	leave  
f010dc13:	c3                   	ret    

f010dc14 <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010dc14:	55                   	push   %ebp
f010dc15:	89 e5                	mov    %esp,%ebp
f010dc17:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010dc1a:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010dc1f:	ff 75 10             	pushl  0x10(%ebp)
f010dc22:	ff 75 0c             	pushl  0xc(%ebp)
f010dc25:	ff 75 08             	pushl  0x8(%ebp)
f010dc28:	50                   	push   %eax
f010dc29:	e8 fd c3 ff ff       	call   f010a02b <move_user_mem>
f010dc2e:	83 c4 10             	add    $0x10,%esp
	return;
f010dc31:	90                   	nop
}
f010dc32:	c9                   	leave  
f010dc33:	c3                   	ret    

f010dc34 <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010dc34:	55                   	push   %ebp
f010dc35:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010dc37:	a1 44 c9 5e f0       	mov    0xf05ec944,%eax
}
f010dc3c:	5d                   	pop    %ebp
f010dc3d:	c3                   	ret    

f010dc3e <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010dc3e:	55                   	push   %ebp
f010dc3f:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010dc41:	8b 45 08             	mov    0x8(%ebp),%eax
f010dc44:	a3 44 c9 5e f0       	mov    %eax,0xf05ec944
}
f010dc49:	90                   	nop
f010dc4a:	5d                   	pop    %ebp
f010dc4b:	c3                   	ret    

f010dc4c <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010dc4c:	55                   	push   %ebp
f010dc4d:	89 e5                	mov    %esp,%ebp
f010dc4f:	83 ec 18             	sub    $0x18,%esp
f010dc52:	8b 45 10             	mov    0x10(%ebp),%eax
f010dc55:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010dc58:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010dc5c:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010dc61:	8b 40 10             	mov    0x10(%eax),%eax
f010dc64:	83 ec 0c             	sub    $0xc,%esp
f010dc67:	ff 75 14             	pushl  0x14(%ebp)
f010dc6a:	52                   	push   %edx
f010dc6b:	ff 75 0c             	pushl  0xc(%ebp)
f010dc6e:	ff 75 08             	pushl  0x8(%ebp)
f010dc71:	50                   	push   %eax
f010dc72:	e8 5c af ff ff       	call   f0108bd3 <createSharedObject>
f010dc77:	83 c4 20             	add    $0x20,%esp
}
f010dc7a:	c9                   	leave  
f010dc7b:	c3                   	ret    

f010dc7c <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010dc7c:	55                   	push   %ebp
f010dc7d:	89 e5                	mov    %esp,%ebp
f010dc7f:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010dc82:	83 ec 08             	sub    $0x8,%esp
f010dc85:	ff 75 0c             	pushl  0xc(%ebp)
f010dc88:	ff 75 08             	pushl  0x8(%ebp)
f010dc8b:	e8 c0 ae ff ff       	call   f0108b50 <getSizeOfSharedObject>
f010dc90:	83 c4 10             	add    $0x10,%esp
}
f010dc93:	c9                   	leave  
f010dc94:	c3                   	ret    

f010dc95 <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010dc95:	55                   	push   %ebp
f010dc96:	89 e5                	mov    %esp,%ebp
f010dc98:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010dc9b:	83 ec 04             	sub    $0x4,%esp
f010dc9e:	ff 75 10             	pushl  0x10(%ebp)
f010dca1:	ff 75 0c             	pushl  0xc(%ebp)
f010dca4:	ff 75 08             	pushl  0x8(%ebp)
f010dca7:	e8 47 af ff ff       	call   f0108bf3 <getSharedObject>
f010dcac:	83 c4 10             	add    $0x10,%esp
}
f010dcaf:	c9                   	leave  
f010dcb0:	c3                   	ret    

f010dcb1 <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010dcb1:	55                   	push   %ebp
f010dcb2:	89 e5                	mov    %esp,%ebp
f010dcb4:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010dcb7:	83 ec 08             	sub    $0x8,%esp
f010dcba:	ff 75 0c             	pushl  0xc(%ebp)
f010dcbd:	ff 75 08             	pushl  0x8(%ebp)
f010dcc0:	e8 65 af ff ff       	call   f0108c2a <freeSharedObject>
f010dcc5:	83 c4 10             	add    $0x10,%esp
}
f010dcc8:	c9                   	leave  
f010dcc9:	c3                   	ret    

f010dcca <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010dcca:	55                   	push   %ebp
f010dccb:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010dccd:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010dcd2:	8b 40 10             	mov    0x10(%eax),%eax
}
f010dcd5:	5d                   	pop    %ebp
f010dcd6:	c3                   	ret    

f010dcd7 <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010dcd7:	55                   	push   %ebp
f010dcd8:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010dcda:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010dcdf:	89 c2                	mov    %eax,%edx
f010dce1:	a1 70 39 5c f0       	mov    0xf05c3970,%eax
f010dce6:	29 c2                	sub    %eax,%edx
f010dce8:	89 d0                	mov    %edx,%eax
f010dcea:	c1 f8 04             	sar    $0x4,%eax
f010dced:	89 c2                	mov    %eax,%edx
f010dcef:	89 d0                	mov    %edx,%eax
f010dcf1:	c1 e0 09             	shl    $0x9,%eax
f010dcf4:	29 d0                	sub    %edx,%eax
f010dcf6:	c1 e0 03             	shl    $0x3,%eax
f010dcf9:	01 d0                	add    %edx,%eax
f010dcfb:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
f010dd02:	01 c8                	add    %ecx,%eax
f010dd04:	c1 e0 03             	shl    $0x3,%eax
f010dd07:	01 d0                	add    %edx,%eax
f010dd09:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010dd10:	01 d0                	add    %edx,%eax
f010dd12:	89 c2                	mov    %eax,%edx
f010dd14:	c1 e2 09             	shl    $0x9,%edx
f010dd17:	01 d0                	add    %edx,%eax
f010dd19:	f7 d8                	neg    %eax
}
f010dd1b:	5d                   	pop    %ebp
f010dd1c:	c3                   	ret    

f010dd1d <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010dd1d:	55                   	push   %ebp
f010dd1e:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010dd20:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010dd25:	8b 40 14             	mov    0x14(%eax),%eax
}
f010dd28:	5d                   	pop    %ebp
f010dd29:	c3                   	ret    

f010dd2a <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010dd2a:	55                   	push   %ebp
f010dd2b:	89 e5                	mov    %esp,%ebp
f010dd2d:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010dd30:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010dd34:	75 0a                	jne    f010dd40 <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010dd36:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010dd3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010dd3e:	eb 22                	jmp    f010dd62 <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010dd40:	83 ec 04             	sub    $0x4,%esp
f010dd43:	6a 00                	push   $0x0
f010dd45:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010dd48:	50                   	push   %eax
f010dd49:	ff 75 08             	pushl  0x8(%ebp)
f010dd4c:	e8 58 cf ff ff       	call   f010aca9 <envid2env>
f010dd51:	83 c4 10             	add    $0x10,%esp
f010dd54:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010dd57:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010dd5b:	79 05                	jns    f010dd62 <sys_destroy_env+0x38>
	{
		return r;
f010dd5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dd60:	eb 5e                	jmp    f010ddc0 <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010dd62:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010dd65:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010dd6a:	39 c2                	cmp    %eax,%edx
f010dd6c:	75 1b                	jne    f010dd89 <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010dd6e:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010dd73:	8b 40 10             	mov    0x10(%eax),%eax
f010dd76:	83 ec 08             	sub    $0x8,%esp
f010dd79:	50                   	push   %eax
f010dd7a:	68 93 62 12 f0       	push   $0xf0126293
f010dd7f:	e8 07 32 ff ff       	call   f0100f8b <cprintf>
f010dd84:	83 c4 10             	add    $0x10,%esp
f010dd87:	eb 20                	jmp    f010dda9 <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010dd89:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dd8c:	8b 50 10             	mov    0x10(%eax),%edx
f010dd8f:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010dd94:	8b 40 10             	mov    0x10(%eax),%eax
f010dd97:	83 ec 04             	sub    $0x4,%esp
f010dd9a:	52                   	push   %edx
f010dd9b:	50                   	push   %eax
f010dd9c:	68 ae 62 12 f0       	push   $0xf01262ae
f010dda1:	e8 e5 31 ff ff       	call   f0100f8b <cprintf>
f010dda6:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010dda9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ddac:	8b 40 10             	mov    0x10(%eax),%eax
f010ddaf:	83 ec 0c             	sub    $0xc,%esp
f010ddb2:	50                   	push   %eax
f010ddb3:	e8 41 7d ff ff       	call   f0105af9 <sched_kill_env>
f010ddb8:	83 c4 10             	add    $0x10,%esp

	return 0;
f010ddbb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ddc0:	c9                   	leave  
f010ddc1:	c3                   	ret    

f010ddc2 <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010ddc2:	55                   	push   %ebp
f010ddc3:	89 e5                	mov    %esp,%ebp
f010ddc5:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010ddc8:	e8 4a ce ff ff       	call   f010ac17 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010ddcd:	90                   	nop
f010ddce:	c9                   	leave  
f010ddcf:	c3                   	ret    

f010ddd0 <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010ddd0:	55                   	push   %ebp
f010ddd1:	89 e5                	mov    %esp,%ebp
f010ddd3:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010ddd6:	ff 75 14             	pushl  0x14(%ebp)
f010ddd9:	ff 75 10             	pushl  0x10(%ebp)
f010dddc:	ff 75 0c             	pushl  0xc(%ebp)
f010dddf:	ff 75 08             	pushl  0x8(%ebp)
f010dde2:	e8 f4 c3 ff ff       	call   f010a1db <env_create>
f010dde7:	83 c4 10             	add    $0x10,%esp
f010ddea:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010dded:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ddf1:	75 07                	jne    f010ddfa <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010ddf3:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010ddf8:	eb 14                	jmp    f010de0e <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010ddfa:	83 ec 0c             	sub    $0xc,%esp
f010ddfd:	ff 75 f4             	pushl  -0xc(%ebp)
f010de00:	e8 58 79 ff ff       	call   f010575d <sched_new_env>
f010de05:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010de08:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010de0b:	8b 40 10             	mov    0x10(%eax),%eax
}
f010de0e:	c9                   	leave  
f010de0f:	c3                   	ret    

f010de10 <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010de10:	55                   	push   %ebp
f010de11:	89 e5                	mov    %esp,%ebp
f010de13:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010de16:	8b 45 08             	mov    0x8(%ebp),%eax
f010de19:	83 ec 0c             	sub    $0xc,%esp
f010de1c:	50                   	push   %eax
f010de1d:	e8 91 79 ff ff       	call   f01057b3 <sched_run_env>
f010de22:	83 c4 10             	add    $0x10,%esp
}
f010de25:	90                   	nop
f010de26:	c9                   	leave  
f010de27:	c3                   	ret    

f010de28 <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010de28:	55                   	push   %ebp
f010de29:	89 e5                	mov    %esp,%ebp
f010de2b:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010de2e:	0f 31                	rdtsc  
f010de30:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010de33:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010de36:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010de39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010de3c:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010de3f:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010de42:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010de45:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010de48:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010de4b:	89 01                	mov    %eax,(%ecx)
f010de4d:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010de50:	8b 45 08             	mov    0x8(%ebp),%eax
f010de53:	c9                   	leave  
f010de54:	c2 04 00             	ret    $0x4

f010de57 <sys_rcr2>:

uint32 sys_rcr2()
{
f010de57:	55                   	push   %ebp
f010de58:	89 e5                	mov    %esp,%ebp
f010de5a:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010de5d:	0f 20 d0             	mov    %cr2,%eax
f010de60:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010de63:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010de66:	90                   	nop
}
f010de67:	c9                   	leave  
f010de68:	c3                   	ret    

f010de69 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010de69:	55                   	push   %ebp
f010de6a:	89 e5                	mov    %esp,%ebp
f010de6c:	83 ec 04             	sub    $0x4,%esp
f010de6f:	8b 45 08             	mov    0x8(%ebp),%eax
f010de72:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010de75:	8a 45 fc             	mov    -0x4(%ebp),%al
f010de78:	a2 e0 41 5c f0       	mov    %al,0xf05c41e0
}
f010de7d:	90                   	nop
f010de7e:	c9                   	leave  
f010de7f:	c3                   	ret    

f010de80 <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010de80:	55                   	push   %ebp
f010de81:	89 e5                	mov    %esp,%ebp
f010de83:	56                   	push   %esi
f010de84:	53                   	push   %ebx
f010de85:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010de88:	e8 cc cd ff ff       	call   f010ac59 <get_cpu_proc>
f010de8d:	a3 04 b1 60 f0       	mov    %eax,0xf060b104
	assert(cur_env != NULL);
f010de92:	a1 04 b1 60 f0       	mov    0xf060b104,%eax
f010de97:	85 c0                	test   %eax,%eax
f010de99:	75 19                	jne    f010deb4 <syscall+0x34>
f010de9b:	68 c6 62 12 f0       	push   $0xf01262c6
f010dea0:	68 d6 62 12 f0       	push   $0xf01262d6
f010dea5:	68 fe 01 00 00       	push   $0x1fe
f010deaa:	68 5f 62 12 f0       	push   $0xf012625f
f010deaf:	e8 85 24 ff ff       	call   f0100339 <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010deb4:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010deb8:	0f 87 0b 04 00 00    	ja     f010e2c9 <syscall+0x449>
f010debe:	8b 45 08             	mov    0x8(%ebp),%eax
f010dec1:	c1 e0 02             	shl    $0x2,%eax
f010dec4:	05 ec 62 12 f0       	add    $0xf01262ec,%eax
f010dec9:	8b 00                	mov    (%eax),%eax
f010decb:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here

	//======================================================================
	case SYS_sbrk :
		sys_sbrk( a1);
f010decd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ded0:	83 ec 0c             	sub    $0xc,%esp
f010ded3:	50                   	push   %eax
f010ded4:	e8 f1 c0 ff ff       	call   f0109fca <sys_sbrk>
f010ded9:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dedc:	b8 00 00 00 00       	mov    $0x0,%eax
f010dee1:	e9 e8 03 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_free_user_mem :
		sys_free_user_mem( a1,a2);
f010dee6:	83 ec 08             	sub    $0x8,%esp
f010dee9:	ff 75 10             	pushl  0x10(%ebp)
f010deec:	ff 75 0c             	pushl  0xc(%ebp)
f010deef:	e8 65 fc ff ff       	call   f010db59 <sys_free_user_mem>
f010def4:	83 c4 10             	add    $0x10,%esp
		return 0;
f010def7:	b8 00 00 00 00       	mov    $0x0,%eax
f010defc:	e9 cd 03 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_allocate_user_mem :
		sys_allocate_user_mem( a1,a2);
f010df01:	83 ec 08             	sub    $0x8,%esp
f010df04:	ff 75 10             	pushl  0x10(%ebp)
f010df07:	ff 75 0c             	pushl  0xc(%ebp)
f010df0a:	e8 8c fc ff ff       	call   f010db9b <sys_allocate_user_mem>
f010df0f:	83 c4 10             	add    $0x10,%esp
			return 0;
f010df12:	b8 00 00 00 00       	mov    $0x0,%eax
f010df17:	e9 b2 03 00 00       	jmp    f010e2ce <syscall+0x44e>
			break;
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010df1c:	8b 45 14             	mov    0x14(%ebp),%eax
f010df1f:	0f b6 d0             	movzbl %al,%edx
f010df22:	8b 45 0c             	mov    0xc(%ebp),%eax
f010df25:	83 ec 04             	sub    $0x4,%esp
f010df28:	52                   	push   %edx
f010df29:	ff 75 10             	pushl  0x10(%ebp)
f010df2c:	50                   	push   %eax
f010df2d:	e8 f7 f8 ff ff       	call   f010d829 <sys_cputs>
f010df32:	83 c4 10             	add    $0x10,%esp
		return 0;
f010df35:	b8 00 00 00 00       	mov    $0x0,%eax
f010df3a:	e9 8f 03 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010df3f:	e8 61 f9 ff ff       	call   f010d8a5 <sys_cgetc>
f010df44:	e9 85 03 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010df49:	e8 96 f9 ff ff       	call   f010d8e4 <sys_lock_cons>
		return 0;
f010df4e:	b8 00 00 00 00       	mov    $0x0,%eax
f010df53:	e9 76 03 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010df58:	e8 95 f9 ff ff       	call   f010d8f2 <sys_unlock_cons>
		return 0;
f010df5d:	b8 00 00 00 00       	mov    $0x0,%eax
f010df62:	e9 67 03 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010df67:	83 ec 08             	sub    $0x8,%esp
f010df6a:	ff 75 10             	pushl  0x10(%ebp)
f010df6d:	ff 75 0c             	pushl  0xc(%ebp)
f010df70:	e8 de fa ff ff       	call   f010da53 <sys_calculate_required_frames>
f010df75:	83 c4 10             	add    $0x10,%esp
f010df78:	e9 51 03 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010df7d:	e8 f3 fa ff ff       	call   f010da75 <sys_calculate_free_frames>
f010df82:	e9 47 03 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010df87:	e8 08 fb ff ff       	call   f010da94 <sys_calculate_modified_frames>
f010df8c:	e9 3d 03 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010df91:	e8 18 fb ff ff       	call   f010daae <sys_calculate_notmod_frames>
f010df96:	e9 33 03 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010df9b:	e8 a0 fb ff ff       	call   f010db40 <sys_pf_calculate_allocated_pages>
f010dfa0:	e9 29 03 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010dfa5:	83 ec 0c             	sub    $0xc,%esp
f010dfa8:	ff 75 0c             	pushl  0xc(%ebp)
f010dfab:	e8 18 fb ff ff       	call   f010dac8 <sys_calculate_pages_tobe_removed_ready_exit>
f010dfb0:	83 c4 10             	add    $0x10,%esp
f010dfb3:	e9 16 03 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010dfb8:	e8 21 fb ff ff       	call   f010dade <sys_scarce_memory>
		return 0;
f010dfbd:	b8 00 00 00 00       	mov    $0x0,%eax
f010dfc2:	e9 07 03 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010dfc7:	83 ec 04             	sub    $0x4,%esp
f010dfca:	ff 75 14             	pushl  0x14(%ebp)
f010dfcd:	ff 75 10             	pushl  0x10(%ebp)
f010dfd0:	ff 75 0c             	pushl  0xc(%ebp)
f010dfd3:	e8 fe fb ff ff       	call   f010dbd6 <sys_allocate_chunk>
f010dfd8:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dfdb:	b8 00 00 00 00       	mov    $0x0,%eax
f010dfe0:	e9 e9 02 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010dfe5:	8b 55 10             	mov    0x10(%ebp),%edx
f010dfe8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dfeb:	83 ec 08             	sub    $0x8,%esp
f010dfee:	52                   	push   %edx
f010dfef:	50                   	push   %eax
f010dff0:	e8 0b f9 ff ff       	call   f010d900 <__sys_allocate_page>
f010dff5:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dff8:	b8 00 00 00 00       	mov    $0x0,%eax
f010dffd:	e9 cc 02 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010e002:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010e005:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010e008:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e00b:	8b 55 10             	mov    0x10(%ebp),%edx
f010e00e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e011:	83 ec 0c             	sub    $0xc,%esp
f010e014:	56                   	push   %esi
f010e015:	53                   	push   %ebx
f010e016:	51                   	push   %ecx
f010e017:	52                   	push   %edx
f010e018:	50                   	push   %eax
f010e019:	e8 fb f9 ff ff       	call   f010da19 <__sys_map_frame>
f010e01e:	83 c4 20             	add    $0x20,%esp
		return 0;
f010e021:	b8 00 00 00 00       	mov    $0x0,%eax
f010e026:	e9 a3 02 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010e02b:	8b 55 10             	mov    0x10(%ebp),%edx
f010e02e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e031:	83 ec 08             	sub    $0x8,%esp
f010e034:	52                   	push   %edx
f010e035:	50                   	push   %eax
f010e036:	e8 fb f9 ff ff       	call   f010da36 <__sys_unmap_frame>
f010e03b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e03e:	b8 00 00 00 00       	mov    $0x0,%eax
f010e043:	e9 86 02 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010e048:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e04b:	0f be c0             	movsbl %al,%eax
f010e04e:	83 ec 0c             	sub    $0xc,%esp
f010e051:	50                   	push   %eax
f010e052:	e8 2a f8 ff ff       	call   f010d881 <sys_cputc>
f010e057:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e05a:	b8 00 00 00 00       	mov    $0x0,%eax
f010e05f:	e9 6a 02 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010e064:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e067:	0f be c0             	movsbl %al,%eax
f010e06a:	83 ec 0c             	sub    $0xc,%esp
f010e06d:	50                   	push   %eax
f010e06e:	e8 79 fa ff ff       	call   f010daec <sys_clearFFL>
f010e073:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e076:	b8 00 00 00 00       	mov    $0x0,%eax
f010e07b:	e9 4e 02 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010e080:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010e083:	8b 45 14             	mov    0x14(%ebp),%eax
f010e086:	0f b6 d0             	movzbl %al,%edx
f010e089:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e08c:	51                   	push   %ecx
f010e08d:	52                   	push   %edx
f010e08e:	ff 75 10             	pushl  0x10(%ebp)
f010e091:	50                   	push   %eax
f010e092:	e8 b5 fb ff ff       	call   f010dc4c <sys_createSharedObject>
f010e097:	83 c4 10             	add    $0x10,%esp
f010e09a:	e9 2f 02 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010e09f:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e0a2:	8b 55 10             	mov    0x10(%ebp),%edx
f010e0a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0a8:	83 ec 04             	sub    $0x4,%esp
f010e0ab:	51                   	push   %ecx
f010e0ac:	52                   	push   %edx
f010e0ad:	50                   	push   %eax
f010e0ae:	e8 e2 fb ff ff       	call   f010dc95 <sys_getSharedObject>
f010e0b3:	83 c4 10             	add    $0x10,%esp
f010e0b6:	e9 13 02 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010e0bb:	8b 55 10             	mov    0x10(%ebp),%edx
f010e0be:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0c1:	83 ec 08             	sub    $0x8,%esp
f010e0c4:	52                   	push   %edx
f010e0c5:	50                   	push   %eax
f010e0c6:	e8 e6 fb ff ff       	call   f010dcb1 <sys_freeSharedObject>
f010e0cb:	83 c4 10             	add    $0x10,%esp
f010e0ce:	e9 fb 01 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010e0d3:	8b 55 10             	mov    0x10(%ebp),%edx
f010e0d6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0d9:	83 ec 08             	sub    $0x8,%esp
f010e0dc:	52                   	push   %edx
f010e0dd:	50                   	push   %eax
f010e0de:	e8 99 fb ff ff       	call   f010dc7c <sys_getSizeOfSharedObject>
f010e0e3:	83 c4 10             	add    $0x10,%esp
f010e0e6:	e9 e3 01 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010e0eb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e0ee:	ff 75 18             	pushl  0x18(%ebp)
f010e0f1:	ff 75 14             	pushl  0x14(%ebp)
f010e0f4:	ff 75 10             	pushl  0x10(%ebp)
f010e0f7:	50                   	push   %eax
f010e0f8:	e8 d3 fc ff ff       	call   f010ddd0 <sys_create_env>
f010e0fd:	83 c4 10             	add    $0x10,%esp
f010e100:	e9 c9 01 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010e105:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e108:	83 ec 0c             	sub    $0xc,%esp
f010e10b:	50                   	push   %eax
f010e10c:	e8 ff fc ff ff       	call   f010de10 <sys_run_env>
f010e111:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e114:	b8 00 00 00 00       	mov    $0x0,%eax
f010e119:	e9 b0 01 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010e11e:	e8 b4 fb ff ff       	call   f010dcd7 <sys_getenvindex>
f010e123:	e9 a6 01 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010e128:	e8 9d fb ff ff       	call   f010dcca <sys_getenvid>
f010e12d:	e9 9c 01 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010e132:	e8 e6 fb ff ff       	call   f010dd1d <sys_getparentenvid>
f010e137:	e9 92 01 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010e13c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e13f:	83 ec 0c             	sub    $0xc,%esp
f010e142:	50                   	push   %eax
f010e143:	e8 e2 fb ff ff       	call   f010dd2a <sys_destroy_env>
f010e148:	83 c4 10             	add    $0x10,%esp
f010e14b:	e9 7e 01 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010e150:	e8 6d fc ff ff       	call   f010ddc2 <sys_exit_env>
		return 0;
f010e155:	b8 00 00 00 00       	mov    $0x0,%eax
f010e15a:	e9 6f 01 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010e15f:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010e162:	83 ec 0c             	sub    $0xc,%esp
f010e165:	50                   	push   %eax
f010e166:	e8 bd fc ff ff       	call   f010de28 <sys_get_virtual_time>
f010e16b:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010e16e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e171:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010e174:	8b 45 10             	mov    0x10(%ebp),%eax
f010e177:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010e17a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010e17d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e180:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010e182:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e185:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e188:	89 10                	mov    %edx,(%eax)
		return 0;
f010e18a:	b8 00 00 00 00       	mov    $0x0,%eax
f010e18f:	e9 3a 01 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010e194:	83 ec 04             	sub    $0x4,%esp
f010e197:	ff 75 14             	pushl  0x14(%ebp)
f010e19a:	ff 75 10             	pushl  0x10(%ebp)
f010e19d:	ff 75 0c             	pushl  0xc(%ebp)
f010e1a0:	e8 6f fa ff ff       	call   f010dc14 <sys_move_user_mem>
f010e1a5:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e1a8:	b8 00 00 00 00       	mov    $0x0,%eax
f010e1ad:	e9 1c 01 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010e1b2:	e8 a0 fc ff ff       	call   f010de57 <sys_rcr2>
f010e1b7:	e9 12 01 00 00       	jmp    f010e2ce <syscall+0x44e>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010e1bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e1bf:	0f b6 c0             	movzbl %al,%eax
f010e1c2:	83 ec 0c             	sub    $0xc,%esp
f010e1c5:	50                   	push   %eax
f010e1c6:	e8 9e fc ff ff       	call   f010de69 <sys_bypassPageFault>
f010e1cb:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e1ce:	b8 00 00 00 00       	mov    $0x0,%eax
f010e1d3:	e9 f6 00 00 00       	jmp    f010e2ce <syscall+0x44e>

	case SYS_rsttst:
		rsttst();
f010e1d8:	e8 78 ed 00 00       	call   f011cf55 <rsttst>
		return 0;
f010e1dd:	b8 00 00 00 00       	mov    $0x0,%eax
f010e1e2:	e9 e7 00 00 00       	jmp    f010e2ce <syscall+0x44e>
	case SYS_inctst:
		inctst();
f010e1e7:	e8 b1 ed 00 00       	call   f011cf9d <inctst>
		return 0;
f010e1ec:	b8 00 00 00 00       	mov    $0x0,%eax
f010e1f1:	e9 d8 00 00 00       	jmp    f010e2ce <syscall+0x44e>
	case SYS_chktst:
		chktst(a1);
f010e1f6:	83 ec 0c             	sub    $0xc,%esp
f010e1f9:	ff 75 0c             	pushl  0xc(%ebp)
f010e1fc:	e8 de ee 00 00       	call   f011d0df <chktst>
f010e201:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e204:	b8 00 00 00 00       	mov    $0x0,%eax
f010e209:	e9 c0 00 00 00       	jmp    f010e2ce <syscall+0x44e>
	case SYS_gettst:
		return gettst();
f010e20e:	e8 be ed 00 00       	call   f011cfd1 <gettst>
f010e213:	e9 b6 00 00 00       	jmp    f010e2ce <syscall+0x44e>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010e218:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010e21b:	8b 45 18             	mov    0x18(%ebp),%eax
f010e21e:	0f be c0             	movsbl %al,%eax
f010e221:	83 ec 0c             	sub    $0xc,%esp
f010e224:	52                   	push   %edx
f010e225:	50                   	push   %eax
f010e226:	ff 75 14             	pushl  0x14(%ebp)
f010e229:	ff 75 10             	pushl  0x10(%ebp)
f010e22c:	ff 75 0c             	pushl  0xc(%ebp)
f010e22f:	e8 a7 ed 00 00       	call   f011cfdb <tst>
f010e234:	83 c4 20             	add    $0x20,%esp
		return 0;
f010e237:	b8 00 00 00 00       	mov    $0x0,%eax
f010e23c:	e9 8d 00 00 00       	jmp    f010e2ce <syscall+0x44e>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010e241:	e8 ee f9 ff ff       	call   f010dc34 <sys_get_heap_strategy>
f010e246:	e9 83 00 00 00       	jmp    f010e2ce <syscall+0x44e>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010e24b:	83 ec 0c             	sub    $0xc,%esp
f010e24e:	ff 75 0c             	pushl  0xc(%ebp)
f010e251:	e8 e8 f9 ff ff       	call   f010dc3e <sys_set_uheap_strategy>
f010e256:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e259:	b8 00 00 00 00       	mov    $0x0,%eax
f010e25e:	eb 6e                	jmp    f010e2ce <syscall+0x44e>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010e260:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010e263:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010e266:	8b 55 10             	mov    0x10(%ebp),%edx
f010e269:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e26c:	53                   	push   %ebx
f010e26d:	51                   	push   %ecx
f010e26e:	52                   	push   %edx
f010e26f:	50                   	push   %eax
f010e270:	e8 bc 1b 00 00       	call   f010fe31 <sys_check_LRU_lists>
f010e275:	83 c4 10             	add    $0x10,%esp
f010e278:	eb 54                	jmp    f010e2ce <syscall+0x44e>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010e27a:	8b 55 10             	mov    0x10(%ebp),%edx
f010e27d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e280:	83 ec 08             	sub    $0x8,%esp
f010e283:	52                   	push   %edx
f010e284:	50                   	push   %eax
f010e285:	e8 69 1d 00 00       	call   f010fff3 <sys_check_LRU_lists_free>
f010e28a:	83 c4 10             	add    $0x10,%esp
f010e28d:	eb 3f                	jmp    f010e2ce <syscall+0x44e>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010e28f:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010e292:	8b 55 10             	mov    0x10(%ebp),%edx
f010e295:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e298:	51                   	push   %ecx
f010e299:	ff 75 14             	pushl  0x14(%ebp)
f010e29c:	52                   	push   %edx
f010e29d:	50                   	push   %eax
f010e29e:	e8 dd 1e 00 00       	call   f0110180 <sys_check_WS_list>
f010e2a3:	83 c4 10             	add    $0x10,%esp
f010e2a6:	eb 26                	jmp    f010e2ce <syscall+0x44e>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010e2a8:	8b 55 10             	mov    0x10(%ebp),%edx
f010e2ab:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e2ae:	83 ec 08             	sub    $0x8,%esp
f010e2b1:	52                   	push   %edx
f010e2b2:	50                   	push   %eax
f010e2b3:	e8 28 f0 00 00       	call   f011d2e0 <sys_utilities>
f010e2b8:	83 c4 10             	add    $0x10,%esp
		return 0;
f010e2bb:	b8 00 00 00 00       	mov    $0x0,%eax
f010e2c0:	eb 0c                	jmp    f010e2ce <syscall+0x44e>

	case NSYSCALLS:
		return 	-E_INVAL;
f010e2c2:	b8 03 00 00 00       	mov    $0x3,%eax
f010e2c7:	eb 05                	jmp    f010e2ce <syscall+0x44e>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010e2c9:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010e2ce:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010e2d1:	5b                   	pop    %ebx
f010e2d2:	5e                   	pop    %esi
f010e2d3:	5d                   	pop    %ebp
f010e2d4:	c3                   	ret    

f010e2d5 <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010e2d5:	55                   	push   %ebp
f010e2d6:	89 e5                	mov    %esp,%ebp
f010e2d8:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010e2db:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e2de:	8b 00                	mov    (%eax),%eax
f010e2e0:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010e2e3:	8b 45 10             	mov    0x10(%ebp),%eax
f010e2e6:	8b 00                	mov    (%eax),%eax
f010e2e8:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010e2eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010e2f2:	e9 ca 00 00 00       	jmp    f010e3c1 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010e2f7:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e2fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e2fd:	01 d0                	add    %edx,%eax
f010e2ff:	89 c2                	mov    %eax,%edx
f010e301:	c1 ea 1f             	shr    $0x1f,%edx
f010e304:	01 d0                	add    %edx,%eax
f010e306:	d1 f8                	sar    %eax
f010e308:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010e30b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e30e:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010e311:	eb 03                	jmp    f010e316 <stab_binsearch+0x41>
			m--;
f010e313:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010e316:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e319:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010e31c:	7c 1e                	jl     f010e33c <stab_binsearch+0x67>
f010e31e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e321:	89 d0                	mov    %edx,%eax
f010e323:	01 c0                	add    %eax,%eax
f010e325:	01 d0                	add    %edx,%eax
f010e327:	c1 e0 02             	shl    $0x2,%eax
f010e32a:	89 c2                	mov    %eax,%edx
f010e32c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e32f:	01 d0                	add    %edx,%eax
f010e331:	8a 40 04             	mov    0x4(%eax),%al
f010e334:	0f b6 c0             	movzbl %al,%eax
f010e337:	3b 45 14             	cmp    0x14(%ebp),%eax
f010e33a:	75 d7                	jne    f010e313 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010e33c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e33f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010e342:	7d 09                	jge    f010e34d <stab_binsearch+0x78>
			l = true_m + 1;
f010e344:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e347:	40                   	inc    %eax
f010e348:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010e34b:	eb 74                	jmp    f010e3c1 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010e34d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010e354:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e357:	89 d0                	mov    %edx,%eax
f010e359:	01 c0                	add    %eax,%eax
f010e35b:	01 d0                	add    %edx,%eax
f010e35d:	c1 e0 02             	shl    $0x2,%eax
f010e360:	89 c2                	mov    %eax,%edx
f010e362:	8b 45 08             	mov    0x8(%ebp),%eax
f010e365:	01 d0                	add    %edx,%eax
f010e367:	8b 40 08             	mov    0x8(%eax),%eax
f010e36a:	3b 45 18             	cmp    0x18(%ebp),%eax
f010e36d:	73 11                	jae    f010e380 <stab_binsearch+0xab>
			*region_left = m;
f010e36f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e372:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e375:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010e377:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e37a:	40                   	inc    %eax
f010e37b:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010e37e:	eb 41                	jmp    f010e3c1 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010e380:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e383:	89 d0                	mov    %edx,%eax
f010e385:	01 c0                	add    %eax,%eax
f010e387:	01 d0                	add    %edx,%eax
f010e389:	c1 e0 02             	shl    $0x2,%eax
f010e38c:	89 c2                	mov    %eax,%edx
f010e38e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e391:	01 d0                	add    %edx,%eax
f010e393:	8b 40 08             	mov    0x8(%eax),%eax
f010e396:	3b 45 18             	cmp    0x18(%ebp),%eax
f010e399:	76 14                	jbe    f010e3af <stab_binsearch+0xda>
			*region_right = m - 1;
f010e39b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e39e:	8d 50 ff             	lea    -0x1(%eax),%edx
f010e3a1:	8b 45 10             	mov    0x10(%ebp),%eax
f010e3a4:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010e3a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e3a9:	48                   	dec    %eax
f010e3aa:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010e3ad:	eb 12                	jmp    f010e3c1 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010e3af:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3b2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e3b5:	89 10                	mov    %edx,(%eax)
			l = m;
f010e3b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e3ba:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010e3bd:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010e3c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e3c4:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010e3c7:	0f 8e 2a ff ff ff    	jle    f010e2f7 <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010e3cd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e3d1:	75 0f                	jne    f010e3e2 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010e3d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3d6:	8b 00                	mov    (%eax),%eax
f010e3d8:	8d 50 ff             	lea    -0x1(%eax),%edx
f010e3db:	8b 45 10             	mov    0x10(%ebp),%eax
f010e3de:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010e3e0:	eb 3d                	jmp    f010e41f <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010e3e2:	8b 45 10             	mov    0x10(%ebp),%eax
f010e3e5:	8b 00                	mov    (%eax),%eax
f010e3e7:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010e3ea:	eb 03                	jmp    f010e3ef <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010e3ec:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010e3ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e3f2:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010e3f4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010e3f7:	7d 1e                	jge    f010e417 <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010e3f9:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e3fc:	89 d0                	mov    %edx,%eax
f010e3fe:	01 c0                	add    %eax,%eax
f010e400:	01 d0                	add    %edx,%eax
f010e402:	c1 e0 02             	shl    $0x2,%eax
f010e405:	89 c2                	mov    %eax,%edx
f010e407:	8b 45 08             	mov    0x8(%ebp),%eax
f010e40a:	01 d0                	add    %edx,%eax
f010e40c:	8a 40 04             	mov    0x4(%eax),%al
f010e40f:	0f b6 c0             	movzbl %al,%eax
f010e412:	3b 45 14             	cmp    0x14(%ebp),%eax
f010e415:	75 d5                	jne    f010e3ec <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010e417:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e41a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e41d:	89 10                	mov    %edx,(%eax)
	}
}
f010e41f:	90                   	nop
f010e420:	c9                   	leave  
f010e421:	c3                   	ret    

f010e422 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010e422:	55                   	push   %ebp
f010e423:	89 e5                	mov    %esp,%ebp
f010e425:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010e428:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e42b:	c7 00 a8 63 12 f0    	movl   $0xf01263a8,(%eax)
	info->eip_line = 0;
f010e431:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e434:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010e43b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e43e:	c7 40 08 a8 63 12 f0 	movl   $0xf01263a8,0x8(%eax)
	info->eip_fn_namelen = 9;
f010e445:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e448:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010e44f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e452:	8b 55 08             	mov    0x8(%ebp),%edx
f010e455:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010e458:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e45b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010e462:	8b 45 08             	mov    0x8(%ebp),%eax
f010e465:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010e46a:	76 1e                	jbe    f010e48a <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010e46c:	c7 45 f4 14 02 13 f0 	movl   $0xf0130214,-0xc(%ebp)
		stab_end = __STAB_END__;
f010e473:	c7 45 f0 b8 18 16 f0 	movl   $0xf01618b8,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010e47a:	c7 45 ec b9 18 16 f0 	movl   $0xf01618b9,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010e481:	c7 45 e8 4a 2e 17 f0 	movl   $0xf0172e4a,-0x18(%ebp)
f010e488:	eb 2a                	jmp    f010e4b4 <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010e48a:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010e491:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e494:	8b 00                	mov    (%eax),%eax
f010e496:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010e499:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e49c:	8b 40 04             	mov    0x4(%eax),%eax
f010e49f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010e4a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e4a5:	8b 40 08             	mov    0x8(%eax),%eax
f010e4a8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010e4ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e4ae:	8b 40 0c             	mov    0xc(%eax),%eax
f010e4b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010e4b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e4b7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e4ba:	76 0a                	jbe    f010e4c6 <debuginfo_eip+0xa4>
f010e4bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e4bf:	48                   	dec    %eax
f010e4c0:	8a 00                	mov    (%eax),%al
f010e4c2:	84 c0                	test   %al,%al
f010e4c4:	74 0a                	je     f010e4d0 <debuginfo_eip+0xae>
		return -1;
f010e4c6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010e4cb:	e9 01 02 00 00       	jmp    f010e6d1 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010e4d0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010e4d7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e4da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e4dd:	29 c2                	sub    %eax,%edx
f010e4df:	89 d0                	mov    %edx,%eax
f010e4e1:	c1 f8 02             	sar    $0x2,%eax
f010e4e4:	89 c2                	mov    %eax,%edx
f010e4e6:	89 d0                	mov    %edx,%eax
f010e4e8:	c1 e0 02             	shl    $0x2,%eax
f010e4eb:	01 d0                	add    %edx,%eax
f010e4ed:	c1 e0 02             	shl    $0x2,%eax
f010e4f0:	01 d0                	add    %edx,%eax
f010e4f2:	c1 e0 02             	shl    $0x2,%eax
f010e4f5:	01 d0                	add    %edx,%eax
f010e4f7:	89 c1                	mov    %eax,%ecx
f010e4f9:	c1 e1 08             	shl    $0x8,%ecx
f010e4fc:	01 c8                	add    %ecx,%eax
f010e4fe:	89 c1                	mov    %eax,%ecx
f010e500:	c1 e1 10             	shl    $0x10,%ecx
f010e503:	01 c8                	add    %ecx,%eax
f010e505:	01 c0                	add    %eax,%eax
f010e507:	01 d0                	add    %edx,%eax
f010e509:	48                   	dec    %eax
f010e50a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010e50d:	ff 75 08             	pushl  0x8(%ebp)
f010e510:	6a 64                	push   $0x64
f010e512:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010e515:	50                   	push   %eax
f010e516:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010e519:	50                   	push   %eax
f010e51a:	ff 75 f4             	pushl  -0xc(%ebp)
f010e51d:	e8 b3 fd ff ff       	call   f010e2d5 <stab_binsearch>
f010e522:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010e525:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e528:	85 c0                	test   %eax,%eax
f010e52a:	75 0a                	jne    f010e536 <debuginfo_eip+0x114>
		return -1;
f010e52c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010e531:	e9 9b 01 00 00       	jmp    f010e6d1 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010e536:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e539:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010e53c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010e53f:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010e542:	ff 75 08             	pushl  0x8(%ebp)
f010e545:	6a 24                	push   $0x24
f010e547:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010e54a:	50                   	push   %eax
f010e54b:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010e54e:	50                   	push   %eax
f010e54f:	ff 75 f4             	pushl  -0xc(%ebp)
f010e552:	e8 7e fd ff ff       	call   f010e2d5 <stab_binsearch>
f010e557:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010e55a:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010e55d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010e560:	39 c2                	cmp    %eax,%edx
f010e562:	0f 8f 86 00 00 00    	jg     f010e5ee <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010e568:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e56b:	89 c2                	mov    %eax,%edx
f010e56d:	89 d0                	mov    %edx,%eax
f010e56f:	01 c0                	add    %eax,%eax
f010e571:	01 d0                	add    %edx,%eax
f010e573:	c1 e0 02             	shl    $0x2,%eax
f010e576:	89 c2                	mov    %eax,%edx
f010e578:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e57b:	01 d0                	add    %edx,%eax
f010e57d:	8b 00                	mov    (%eax),%eax
f010e57f:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010e582:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e585:	29 d1                	sub    %edx,%ecx
f010e587:	89 ca                	mov    %ecx,%edx
f010e589:	39 d0                	cmp    %edx,%eax
f010e58b:	73 22                	jae    f010e5af <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010e58d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e590:	89 c2                	mov    %eax,%edx
f010e592:	89 d0                	mov    %edx,%eax
f010e594:	01 c0                	add    %eax,%eax
f010e596:	01 d0                	add    %edx,%eax
f010e598:	c1 e0 02             	shl    $0x2,%eax
f010e59b:	89 c2                	mov    %eax,%edx
f010e59d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e5a0:	01 d0                	add    %edx,%eax
f010e5a2:	8b 10                	mov    (%eax),%edx
f010e5a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e5a7:	01 c2                	add    %eax,%edx
f010e5a9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e5ac:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010e5af:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e5b2:	89 c2                	mov    %eax,%edx
f010e5b4:	89 d0                	mov    %edx,%eax
f010e5b6:	01 c0                	add    %eax,%eax
f010e5b8:	01 d0                	add    %edx,%eax
f010e5ba:	c1 e0 02             	shl    $0x2,%eax
f010e5bd:	89 c2                	mov    %eax,%edx
f010e5bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e5c2:	01 d0                	add    %edx,%eax
f010e5c4:	8b 50 08             	mov    0x8(%eax),%edx
f010e5c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e5ca:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010e5cd:	8b 55 08             	mov    0x8(%ebp),%edx
f010e5d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e5d3:	8b 40 10             	mov    0x10(%eax),%eax
f010e5d6:	29 c2                	sub    %eax,%edx
f010e5d8:	89 d0                	mov    %edx,%eax
f010e5da:	c1 f8 02             	sar    $0x2,%eax
f010e5dd:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010e5e0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e5e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010e5e6:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010e5e9:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010e5ec:	eb 15                	jmp    f010e603 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010e5ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e5f1:	8b 55 08             	mov    0x8(%ebp),%edx
f010e5f4:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010e5f7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e5fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010e5fd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010e600:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010e603:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e606:	8b 40 08             	mov    0x8(%eax),%eax
f010e609:	83 ec 08             	sub    $0x8,%esp
f010e60c:	6a 3a                	push   $0x3a
f010e60e:	50                   	push   %eax
f010e60f:	e8 8d 07 01 00       	call   f011eda1 <strfind>
f010e614:	83 c4 10             	add    $0x10,%esp
f010e617:	89 c2                	mov    %eax,%edx
f010e619:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e61c:	8b 40 08             	mov    0x8(%eax),%eax
f010e61f:	29 c2                	sub    %eax,%edx
f010e621:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e624:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010e627:	eb 03                	jmp    f010e62c <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010e629:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010e62c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e62f:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010e632:	7c 4e                	jl     f010e682 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010e634:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e637:	89 d0                	mov    %edx,%eax
f010e639:	01 c0                	add    %eax,%eax
f010e63b:	01 d0                	add    %edx,%eax
f010e63d:	c1 e0 02             	shl    $0x2,%eax
f010e640:	89 c2                	mov    %eax,%edx
f010e642:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e645:	01 d0                	add    %edx,%eax
f010e647:	8a 40 04             	mov    0x4(%eax),%al
f010e64a:	3c 84                	cmp    $0x84,%al
f010e64c:	74 34                	je     f010e682 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010e64e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e651:	89 d0                	mov    %edx,%eax
f010e653:	01 c0                	add    %eax,%eax
f010e655:	01 d0                	add    %edx,%eax
f010e657:	c1 e0 02             	shl    $0x2,%eax
f010e65a:	89 c2                	mov    %eax,%edx
f010e65c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e65f:	01 d0                	add    %edx,%eax
f010e661:	8a 40 04             	mov    0x4(%eax),%al
f010e664:	3c 64                	cmp    $0x64,%al
f010e666:	75 c1                	jne    f010e629 <debuginfo_eip+0x207>
f010e668:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e66b:	89 d0                	mov    %edx,%eax
f010e66d:	01 c0                	add    %eax,%eax
f010e66f:	01 d0                	add    %edx,%eax
f010e671:	c1 e0 02             	shl    $0x2,%eax
f010e674:	89 c2                	mov    %eax,%edx
f010e676:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e679:	01 d0                	add    %edx,%eax
f010e67b:	8b 40 08             	mov    0x8(%eax),%eax
f010e67e:	85 c0                	test   %eax,%eax
f010e680:	74 a7                	je     f010e629 <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010e682:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e685:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010e688:	7c 42                	jl     f010e6cc <debuginfo_eip+0x2aa>
f010e68a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e68d:	89 d0                	mov    %edx,%eax
f010e68f:	01 c0                	add    %eax,%eax
f010e691:	01 d0                	add    %edx,%eax
f010e693:	c1 e0 02             	shl    $0x2,%eax
f010e696:	89 c2                	mov    %eax,%edx
f010e698:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e69b:	01 d0                	add    %edx,%eax
f010e69d:	8b 00                	mov    (%eax),%eax
f010e69f:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010e6a2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e6a5:	29 d1                	sub    %edx,%ecx
f010e6a7:	89 ca                	mov    %ecx,%edx
f010e6a9:	39 d0                	cmp    %edx,%eax
f010e6ab:	73 1f                	jae    f010e6cc <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010e6ad:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e6b0:	89 d0                	mov    %edx,%eax
f010e6b2:	01 c0                	add    %eax,%eax
f010e6b4:	01 d0                	add    %edx,%eax
f010e6b6:	c1 e0 02             	shl    $0x2,%eax
f010e6b9:	89 c2                	mov    %eax,%edx
f010e6bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e6be:	01 d0                	add    %edx,%eax
f010e6c0:	8b 10                	mov    (%eax),%edx
f010e6c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e6c5:	01 c2                	add    %eax,%edx
f010e6c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e6ca:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010e6cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e6d1:	c9                   	leave  
f010e6d2:	c3                   	ret    

f010e6d3 <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010e6d3:	55                   	push   %ebp
f010e6d4:	89 e5                	mov    %esp,%ebp
f010e6d6:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010e6d9:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010e6dd:	74 1c                	je     f010e6fb <setPageReplacmentAlgorithmLRU+0x28>
f010e6df:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010e6e3:	74 16                	je     f010e6fb <setPageReplacmentAlgorithmLRU+0x28>
f010e6e5:	68 b4 63 12 f0       	push   $0xf01263b4
f010e6ea:	68 fe 63 12 f0       	push   $0xf01263fe
f010e6ef:	6a 19                	push   $0x19
f010e6f1:	68 13 64 12 f0       	push   $0xf0126413
f010e6f6:	e8 3e 1c ff ff       	call   f0100339 <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010e6fb:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6fe:	a3 a8 cb 5e f0       	mov    %eax,0xf05ecba8
}
f010e703:	90                   	nop
f010e704:	c9                   	leave  
f010e705:	c3                   	ret    

f010e706 <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010e706:	55                   	push   %ebp
f010e707:	89 e5                	mov    %esp,%ebp
f010e709:	c7 05 a8 cb 5e f0 03 	movl   $0x3,0xf05ecba8
f010e710:	00 00 00 
f010e713:	90                   	nop
f010e714:	5d                   	pop    %ebp
f010e715:	c3                   	ret    

f010e716 <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010e716:	55                   	push   %ebp
f010e717:	89 e5                	mov    %esp,%ebp
f010e719:	c7 05 a8 cb 5e f0 04 	movl   $0x4,0xf05ecba8
f010e720:	00 00 00 
f010e723:	90                   	nop
f010e724:	5d                   	pop    %ebp
f010e725:	c3                   	ret    

f010e726 <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010e726:	55                   	push   %ebp
f010e727:	89 e5                	mov    %esp,%ebp
f010e729:	c7 05 a8 cb 5e f0 05 	movl   $0x5,0xf05ecba8
f010e730:	00 00 00 
f010e733:	90                   	nop
f010e734:	5d                   	pop    %ebp
f010e735:	c3                   	ret    

f010e736 <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010e736:	55                   	push   %ebp
f010e737:	89 e5                	mov    %esp,%ebp
f010e739:	c7 05 a8 cb 5e f0 07 	movl   $0x7,0xf05ecba8
f010e740:	00 00 00 
f010e743:	90                   	nop
f010e744:	5d                   	pop    %ebp
f010e745:	c3                   	ret    

f010e746 <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010e746:	55                   	push   %ebp
f010e747:	89 e5                	mov    %esp,%ebp
f010e749:	c7 05 a8 cb 5e f0 06 	movl   $0x6,0xf05ecba8
f010e750:	00 00 00 
f010e753:	8b 45 08             	mov    0x8(%ebp),%eax
f010e756:	a3 f4 c4 5e f0       	mov    %eax,0xf05ec4f4
f010e75b:	90                   	nop
f010e75c:	5d                   	pop    %ebp
f010e75d:	c3                   	ret    

f010e75e <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010e75e:	55                   	push   %ebp
f010e75f:	89 e5                	mov    %esp,%ebp
f010e761:	8b 15 a8 cb 5e f0    	mov    0xf05ecba8,%edx
f010e767:	8b 45 08             	mov    0x8(%ebp),%eax
f010e76a:	39 c2                	cmp    %eax,%edx
f010e76c:	0f 94 c0             	sete   %al
f010e76f:	0f b6 c0             	movzbl %al,%eax
f010e772:	5d                   	pop    %ebp
f010e773:	c3                   	ret    

f010e774 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010e774:	55                   	push   %ebp
f010e775:	89 e5                	mov    %esp,%ebp
f010e777:	a1 a8 cb 5e f0       	mov    0xf05ecba8,%eax
f010e77c:	83 f8 03             	cmp    $0x3,%eax
f010e77f:	75 07                	jne    f010e788 <isPageReplacmentAlgorithmCLOCK+0x14>
f010e781:	b8 01 00 00 00       	mov    $0x1,%eax
f010e786:	eb 05                	jmp    f010e78d <isPageReplacmentAlgorithmCLOCK+0x19>
f010e788:	b8 00 00 00 00       	mov    $0x0,%eax
f010e78d:	5d                   	pop    %ebp
f010e78e:	c3                   	ret    

f010e78f <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010e78f:	55                   	push   %ebp
f010e790:	89 e5                	mov    %esp,%ebp
f010e792:	a1 a8 cb 5e f0       	mov    0xf05ecba8,%eax
f010e797:	83 f8 04             	cmp    $0x4,%eax
f010e79a:	75 07                	jne    f010e7a3 <isPageReplacmentAlgorithmFIFO+0x14>
f010e79c:	b8 01 00 00 00       	mov    $0x1,%eax
f010e7a1:	eb 05                	jmp    f010e7a8 <isPageReplacmentAlgorithmFIFO+0x19>
f010e7a3:	b8 00 00 00 00       	mov    $0x0,%eax
f010e7a8:	5d                   	pop    %ebp
f010e7a9:	c3                   	ret    

f010e7aa <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010e7aa:	55                   	push   %ebp
f010e7ab:	89 e5                	mov    %esp,%ebp
f010e7ad:	a1 a8 cb 5e f0       	mov    0xf05ecba8,%eax
f010e7b2:	83 f8 05             	cmp    $0x5,%eax
f010e7b5:	75 07                	jne    f010e7be <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010e7b7:	b8 01 00 00 00       	mov    $0x1,%eax
f010e7bc:	eb 05                	jmp    f010e7c3 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010e7be:	b8 00 00 00 00       	mov    $0x0,%eax
f010e7c3:	5d                   	pop    %ebp
f010e7c4:	c3                   	ret    

f010e7c5 <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010e7c5:	55                   	push   %ebp
f010e7c6:	89 e5                	mov    %esp,%ebp
f010e7c8:	a1 a8 cb 5e f0       	mov    0xf05ecba8,%eax
f010e7cd:	83 f8 07             	cmp    $0x7,%eax
f010e7d0:	75 07                	jne    f010e7d9 <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010e7d2:	b8 01 00 00 00       	mov    $0x1,%eax
f010e7d7:	eb 05                	jmp    f010e7de <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010e7d9:	b8 00 00 00 00       	mov    $0x0,%eax
f010e7de:	5d                   	pop    %ebp
f010e7df:	c3                   	ret    

f010e7e0 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010e7e0:	55                   	push   %ebp
f010e7e1:	89 e5                	mov    %esp,%ebp
f010e7e3:	a1 a8 cb 5e f0       	mov    0xf05ecba8,%eax
f010e7e8:	83 f8 06             	cmp    $0x6,%eax
f010e7eb:	75 07                	jne    f010e7f4 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010e7ed:	b8 01 00 00 00       	mov    $0x1,%eax
f010e7f2:	eb 05                	jmp    f010e7f9 <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010e7f4:	b8 00 00 00 00       	mov    $0x0,%eax
f010e7f9:	5d                   	pop    %ebp
f010e7fa:	c3                   	ret    

f010e7fb <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010e7fb:	55                   	push   %ebp
f010e7fc:	89 e5                	mov    %esp,%ebp
f010e7fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010e801:	a3 60 c9 5e f0       	mov    %eax,0xf05ec960
f010e806:	90                   	nop
f010e807:	5d                   	pop    %ebp
f010e808:	c3                   	ret    

f010e809 <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010e809:	55                   	push   %ebp
f010e80a:	89 e5                	mov    %esp,%ebp
f010e80c:	a1 60 c9 5e f0       	mov    0xf05ec960,%eax
f010e811:	5d                   	pop    %ebp
f010e812:	c3                   	ret    

f010e813 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010e813:	55                   	push   %ebp
f010e814:	89 e5                	mov    %esp,%ebp
f010e816:	8b 45 08             	mov    0x8(%ebp),%eax
f010e819:	a3 14 cc 5e f0       	mov    %eax,0xf05ecc14
f010e81e:	90                   	nop
f010e81f:	5d                   	pop    %ebp
f010e820:	c3                   	ret    

f010e821 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010e821:	55                   	push   %ebp
f010e822:	89 e5                	mov    %esp,%ebp
f010e824:	a1 14 cc 5e f0       	mov    0xf05ecc14,%eax
f010e829:	5d                   	pop    %ebp
f010e82a:	c3                   	ret    

f010e82b <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010e82b:	55                   	push   %ebp
f010e82c:	89 e5                	mov    %esp,%ebp
f010e82e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e831:	a3 b0 cc 5e f0       	mov    %eax,0xf05eccb0
f010e836:	90                   	nop
f010e837:	5d                   	pop    %ebp
f010e838:	c3                   	ret    

f010e839 <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010e839:	55                   	push   %ebp
f010e83a:	89 e5                	mov    %esp,%ebp
f010e83c:	a1 b0 cc 5e f0       	mov    0xf05eccb0,%eax
f010e841:	5d                   	pop    %ebp
f010e842:	c3                   	ret    

f010e843 <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010e843:	55                   	push   %ebp
f010e844:	89 e5                	mov    %esp,%ebp
f010e846:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010e849:	0f 20 d0             	mov    %cr2,%eax
f010e84c:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010e84f:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010e852:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010e855:	e8 ff c3 ff ff       	call   f010ac59 <get_cpu_proc>
f010e85a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010e85d:	a1 ec 41 5c f0       	mov    0xf05c41ec,%eax
f010e862:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e865:	75 50                	jne    f010e8b7 <fault_handler+0x74>
f010e867:	a1 f8 41 5c f0       	mov    0xf05c41f8,%eax
f010e86c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010e86f:	75 46                	jne    f010e8b7 <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010e871:	a0 f4 41 5c f0       	mov    0xf05c41f4,%al
f010e876:	40                   	inc    %eax
f010e877:	a2 f4 41 5c f0       	mov    %al,0xf05c41f4
		if (num_repeated_fault == 3)
f010e87c:	a0 f4 41 5c f0       	mov    0xf05c41f4,%al
f010e881:	3c 03                	cmp    $0x3,%al
f010e883:	75 4d                	jne    f010e8d2 <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010e885:	83 ec 0c             	sub    $0xc,%esp
f010e888:	ff 75 08             	pushl  0x8(%ebp)
f010e88b:	e8 77 e9 ff ff       	call   f010d207 <print_trapframe>
f010e890:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010e893:	8b 15 e8 41 5c f0    	mov    0xf05c41e8,%edx
f010e899:	a1 f0 41 5c f0       	mov    0xf05c41f0,%eax
f010e89e:	83 ec 08             	sub    $0x8,%esp
f010e8a1:	ff 75 ec             	pushl  -0x14(%ebp)
f010e8a4:	52                   	push   %edx
f010e8a5:	50                   	push   %eax
f010e8a6:	68 30 64 12 f0       	push   $0xf0126430
f010e8ab:	6a 57                	push   $0x57
f010e8ad:	68 13 64 12 f0       	push   $0xf0126413
f010e8b2:	e8 82 1a ff ff       	call   f0100339 <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010e8b7:	a1 ec 41 5c f0       	mov    0xf05c41ec,%eax
f010e8bc:	a3 f0 41 5c f0       	mov    %eax,0xf05c41f0
		before_last_eip = last_eip;
f010e8c1:	a1 e4 41 5c f0       	mov    0xf05c41e4,%eax
f010e8c6:	a3 e8 41 5c f0       	mov    %eax,0xf05c41e8
		num_repeated_fault = 0;
f010e8cb:	c6 05 f4 41 5c f0 00 	movb   $0x0,0xf05c41f4
	}
	last_eip = (uint32)tf->tf_eip;
f010e8d2:	8b 45 08             	mov    0x8(%ebp),%eax
f010e8d5:	8b 40 30             	mov    0x30(%eax),%eax
f010e8d8:	a3 e4 41 5c f0       	mov    %eax,0xf05c41e4
	last_fault_va = fault_va ;
f010e8dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e8e0:	a3 ec 41 5c f0       	mov    %eax,0xf05c41ec
	last_faulted_env = cur_env;
f010e8e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8e8:	a3 f8 41 5c f0       	mov    %eax,0xf05c41f8
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010e8ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010e8f4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e8f7:	8b 40 34             	mov    0x34(%eax),%eax
f010e8fa:	0f b7 c0             	movzwl %ax,%eax
f010e8fd:	83 e0 03             	and    $0x3,%eax
f010e900:	83 f8 03             	cmp    $0x3,%eax
f010e903:	75 07                	jne    f010e90c <fault_handler+0xc9>
		userTrap = 1;
f010e905:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010e90c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e910:	0f 85 c2 00 00 00    	jne    f010e9d8 <fault_handler+0x195>
	{
		struct cpu* c = mycpu();
f010e916:	e8 29 88 ff ff       	call   f0107144 <mycpu>
f010e91b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010e91e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010e922:	74 2f                	je     f010e953 <fault_handler+0x110>
f010e924:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e927:	8b 40 70             	mov    0x70(%eax),%eax
f010e92a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e92d:	77 24                	ja     f010e953 <fault_handler+0x110>
f010e92f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e932:	8b 40 70             	mov    0x70(%eax),%eax
f010e935:	05 00 10 00 00       	add    $0x1000,%eax
f010e93a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e93d:	76 14                	jbe    f010e953 <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010e93f:	83 ec 04             	sub    $0x4,%esp
f010e942:	68 a0 64 12 f0       	push   $0xf01264a0
f010e947:	6a 6e                	push   $0x6e
f010e949:	68 13 64 12 f0       	push   $0xf0126413
f010e94e:	e8 e6 19 ff ff       	call   f0100339 <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010e953:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e956:	8b 40 08             	mov    0x8(%eax),%eax
f010e959:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e95c:	77 5d                	ja     f010e9bb <fault_handler+0x178>
f010e95e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e961:	8b 40 08             	mov    0x8(%eax),%eax
f010e964:	05 00 10 00 00       	add    $0x1000,%eax
f010e969:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e96c:	76 4d                	jbe    f010e9bb <fault_handler+0x178>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010e96e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e971:	ba 40 c6 5e f0       	mov    $0xf05ec640,%edx
f010e976:	29 d0                	sub    %edx,%eax
f010e978:	c1 f8 03             	sar    $0x3,%eax
f010e97b:	89 c2                	mov    %eax,%edx
f010e97d:	89 d0                	mov    %edx,%eax
f010e97f:	c1 e0 02             	shl    $0x2,%eax
f010e982:	01 d0                	add    %edx,%eax
f010e984:	01 c0                	add    %eax,%eax
f010e986:	01 d0                	add    %edx,%eax
f010e988:	c1 e0 03             	shl    $0x3,%eax
f010e98b:	01 d0                	add    %edx,%eax
f010e98d:	89 c1                	mov    %eax,%ecx
f010e98f:	c1 e1 0b             	shl    $0xb,%ecx
f010e992:	01 c8                	add    %ecx,%eax
f010e994:	c1 e0 05             	shl    $0x5,%eax
f010e997:	01 d0                	add    %edx,%eax
f010e999:	c1 e0 02             	shl    $0x2,%eax
f010e99c:	01 d0                	add    %edx,%eax
f010e99e:	01 c0                	add    %eax,%eax
f010e9a0:	01 d0                	add    %edx,%eax
f010e9a2:	c1 e0 03             	shl    $0x3,%eax
f010e9a5:	01 d0                	add    %edx,%eax
f010e9a7:	f7 d8                	neg    %eax
f010e9a9:	50                   	push   %eax
f010e9aa:	68 c8 64 12 f0       	push   $0xf01264c8
f010e9af:	6a 70                	push   $0x70
f010e9b1:	68 13 64 12 f0       	push   $0xf0126413
f010e9b6:	e8 7e 19 ff ff       	call   f0100339 <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010e9bb:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010e9c2:	76 3a                	jbe    f010e9fe <fault_handler+0x1bb>
			panic("Kernel: heap overflow exception!");
f010e9c4:	83 ec 04             	sub    $0x4,%esp
f010e9c7:	68 fc 64 12 f0       	push   $0xf01264fc
f010e9cc:	6a 73                	push   $0x73
f010e9ce:	68 13 64 12 f0       	push   $0xf0126413
f010e9d3:	e8 61 19 ff ff       	call   f0100339 <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010e9d8:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010e9df:	76 1d                	jbe    f010e9fe <fault_handler+0x1bb>
f010e9e1:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010e9e8:	77 14                	ja     f010e9fe <fault_handler+0x1bb>
			panic("User: stack underflow exception!");
f010e9ea:	83 ec 04             	sub    $0x4,%esp
f010e9ed:	68 20 65 12 f0       	push   $0xf0126520
f010e9f2:	6a 7b                	push   $0x7b
f010e9f4:	68 13 64 12 f0       	push   $0xf0126413
f010e9f9:	e8 3b 19 ff ff       	call   f0100339 <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010e9fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ea01:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010ea04:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010ea08:	75 25                	jne    f010ea2f <fault_handler+0x1ec>
	{
		print_trapframe(tf);
f010ea0a:	83 ec 0c             	sub    $0xc,%esp
f010ea0d:	ff 75 08             	pushl  0x8(%ebp)
f010ea10:	e8 f2 e7 ff ff       	call   f010d207 <print_trapframe>
f010ea15:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010ea18:	83 ec 04             	sub    $0x4,%esp
f010ea1b:	68 41 65 12 f0       	push   $0xf0126541
f010ea20:	68 84 00 00 00       	push   $0x84
f010ea25:	68 13 64 12 f0       	push   $0xf0126413
f010ea2a:	e8 0a 19 ff ff       	call   f0100339 <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010ea2f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ea32:	8b 40 64             	mov    0x64(%eax),%eax
f010ea35:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ea38:	c1 ea 16             	shr    $0x16,%edx
f010ea3b:	c1 e2 02             	shl    $0x2,%edx
f010ea3e:	01 d0                	add    %edx,%eax
f010ea40:	8b 00                	mov    (%eax),%eax
f010ea42:	83 e0 01             	and    $0x1,%eax
f010ea45:	85 c0                	test   %eax,%eax
f010ea47:	75 28                	jne    f010ea71 <fault_handler+0x22e>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010ea49:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ea4c:	8b 80 88 05 00 00    	mov    0x588(%eax),%eax
f010ea52:	8d 50 01             	lea    0x1(%eax),%edx
f010ea55:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ea58:	89 90 88 05 00 00    	mov    %edx,0x588(%eax)

		table_fault_handler(faulted_env, fault_va);
f010ea5e:	83 ec 08             	sub    $0x8,%esp
f010ea61:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea64:	ff 75 e0             	pushl  -0x20(%ebp)
f010ea67:	e8 8f 00 00 00       	call   f010eafb <table_fault_handler>
f010ea6c:	83 c4 10             	add    $0x10,%esp
f010ea6f:	eb 7b                	jmp    f010eaec <fault_handler+0x2a9>

			/*============================================================================================*/
		}

		/*2022: Check if fault due to Access Rights */
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010ea71:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ea74:	8b 40 64             	mov    0x64(%eax),%eax
f010ea77:	83 ec 08             	sub    $0x8,%esp
f010ea7a:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea7d:	50                   	push   %eax
f010ea7e:	e8 3f a7 ff ff       	call   f01091c2 <pt_get_page_permissions>
f010ea83:	83 c4 10             	add    $0x10,%esp
f010ea86:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010ea89:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ea8c:	83 e0 01             	and    $0x1,%eax
f010ea8f:	85 c0                	test   %eax,%eax
f010ea91:	74 17                	je     f010eaaa <fault_handler+0x267>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010ea93:	ff 75 ec             	pushl  -0x14(%ebp)
f010ea96:	68 58 65 12 f0       	push   $0xf0126558
f010ea9b:	68 a1 00 00 00       	push   $0xa1
f010eaa0:	68 13 64 12 f0       	push   $0xf0126413
f010eaa5:	e8 8f 18 ff ff       	call   f0100339 <_panic>
		/*============================================================================================*/


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010eaaa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010eaad:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f010eab3:	8d 50 01             	lea    0x1(%eax),%edx
f010eab6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010eab9:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010eabf:	e8 5d fd ff ff       	call   f010e821 <isBufferingEnabled>
f010eac4:	84 c0                	test   %al,%al
f010eac6:	74 13                	je     f010eadb <fault_handler+0x298>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010eac8:	83 ec 08             	sub    $0x8,%esp
f010eacb:	ff 75 ec             	pushl  -0x14(%ebp)
f010eace:	ff 75 e0             	pushl  -0x20(%ebp)
f010ead1:	e8 9b 00 00 00       	call   f010eb71 <__page_fault_handler_with_buffering>
f010ead6:	83 c4 10             	add    $0x10,%esp
f010ead9:	eb 11                	jmp    f010eaec <fault_handler+0x2a9>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010eadb:	83 ec 08             	sub    $0x8,%esp
f010eade:	ff 75 ec             	pushl  -0x14(%ebp)
f010eae1:	ff 75 e0             	pushl  -0x20(%ebp)
f010eae4:	e8 33 00 00 00       	call   f010eb1c <page_fault_handler>
f010eae9:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010eaec:	0f 20 d8             	mov    %cr3,%eax
f010eaef:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010eaf2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010eaf5:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010eaf8:	90                   	nop
f010eaf9:	c9                   	leave  
f010eafa:	c3                   	ret    

f010eafb <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010eafb:	55                   	push   %ebp
f010eafc:	89 e5                	mov    %esp,%ebp
f010eafe:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010eb01:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb04:	8b 40 64             	mov    0x64(%eax),%eax
f010eb07:	83 ec 08             	sub    $0x8,%esp
f010eb0a:	ff 75 0c             	pushl  0xc(%ebp)
f010eb0d:	50                   	push   %eax
f010eb0e:	e8 02 9b ff ff       	call   f0108615 <create_page_table>
f010eb13:	83 c4 10             	add    $0x10,%esp
f010eb16:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010eb19:	90                   	nop
f010eb1a:	c9                   	leave  
f010eb1b:	c3                   	ret    

f010eb1c <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010eb1c:	55                   	push   %ebp
f010eb1d:	89 e5                	mov    %esp,%ebp
f010eb1f:	83 ec 18             	sub    $0x18,%esp
#if USE_KHEAP
		struct WorkingSetElement *victimWSElement = NULL;
f010eb22:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010eb29:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb2c:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010eb32:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
		int iWS =faulted_env->page_last_WS_index;
		uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif

	if(wsSize < (faulted_env->page_WS_max_size))
f010eb35:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb38:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010eb3e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010eb41:	76 17                	jbe    f010eb5a <page_fault_handler+0x3e>
	{
		//cprintf("PLACEMENT=========================WS Size = %d\n", wsSize );
		//TODO: [PROJECT'24.MS2 - #09] [2] FAULT HANDLER I - Placement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
f010eb43:	83 ec 04             	sub    $0x4,%esp
f010eb46:	68 9c 65 12 f0       	push   $0xf012659c
f010eb4b:	68 e6 00 00 00       	push   $0xe6
f010eb50:	68 13 64 12 f0       	push   $0xf0126413
f010eb55:	e8 df 17 ff ff       	call   f0100339 <_panic>
	{
		//cprintf("REPLACEMENT=========================WS Size = %d\n", wsSize );
		//refer to the project presentation and documentation for details
		//TODO: [PROJECT'24.MS3] [2] FAULT HANDLER II - Replacement
		// Write your code here, remove the panic and write your code
		panic("page_fault_handler() Replacement is not implemented yet...!!");
f010eb5a:	83 ec 04             	sub    $0x4,%esp
f010eb5d:	68 d8 65 12 f0       	push   $0xf01265d8
f010eb62:	68 f0 00 00 00       	push   $0xf0
f010eb67:	68 13 64 12 f0       	push   $0xf0126413
f010eb6c:	e8 c8 17 ff ff       	call   f0100339 <_panic>

f010eb71 <__page_fault_handler_with_buffering>:
	}
}

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010eb71:	55                   	push   %ebp
f010eb72:	89 e5                	mov    %esp,%ebp
f010eb74:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010eb77:	83 ec 04             	sub    $0x4,%esp
f010eb7a:	68 18 66 12 f0       	push   $0xf0126618
f010eb7f:	68 f8 00 00 00       	push   $0xf8
f010eb84:	68 13 64 12 f0       	push   $0xf0126413
f010eb89:	e8 ab 17 ff ff       	call   f0100339 <_panic>

f010eb8e <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010eb8e:	55                   	push   %ebp
f010eb8f:	89 e5                	mov    %esp,%ebp
f010eb91:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010eb94:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb97:	83 c0 04             	add    $0x4,%eax
f010eb9a:	83 ec 08             	sub    $0x8,%esp
f010eb9d:	ff 75 0c             	pushl  0xc(%ebp)
f010eba0:	50                   	push   %eax
f010eba1:	e8 88 00 01 00       	call   f011ec2e <strcpy>
f010eba6:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010eba9:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010ebb2:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebb5:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010ebbc:	90                   	nop
f010ebbd:	c9                   	leave  
f010ebbe:	c3                   	ret    

f010ebbf <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010ebbf:	55                   	push   %ebp
f010ebc0:	89 e5                	mov    %esp,%ebp
f010ebc2:	53                   	push   %ebx
f010ebc3:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010ebc6:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebc9:	83 ec 0c             	sub    $0xc,%esp
f010ebcc:	50                   	push   %eax
f010ebcd:	e8 06 02 00 00       	call   f010edd8 <holding_spinlock>
f010ebd2:	83 c4 10             	add    $0x10,%esp
f010ebd5:	85 c0                	test   %eax,%eax
f010ebd7:	74 18                	je     f010ebf1 <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010ebd9:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebdc:	83 c0 04             	add    $0x4,%eax
f010ebdf:	50                   	push   %eax
f010ebe0:	68 5c 66 12 f0       	push   $0xf012665c
f010ebe5:	6a 1f                	push   $0x1f
f010ebe7:	68 99 66 12 f0       	push   $0xf0126699
f010ebec:	e8 48 17 ff ff       	call   f0100339 <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010ebf1:	e8 11 86 ff ff       	call   f0107207 <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010ebf6:	90                   	nop
f010ebf7:	8b 45 08             	mov    0x8(%ebp),%eax
f010ebfa:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ebfd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010ec04:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ec07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ec0a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010ec0d:	f0 87 02             	lock xchg %eax,(%edx)
f010ec10:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010ec13:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ec16:	85 c0                	test   %eax,%eax
f010ec18:	75 dd                	jne    f010ebf7 <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010ec1a:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010ec1f:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010ec22:	e8 1d 85 ff ff       	call   f0107144 <mycpu>
f010ec27:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010ec2a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec2d:	83 c0 48             	add    $0x48,%eax
f010ec30:	83 ec 08             	sub    $0x8,%esp
f010ec33:	50                   	push   %eax
f010ec34:	8d 45 08             	lea    0x8(%ebp),%eax
f010ec37:	50                   	push   %eax
f010ec38:	e8 74 00 00 00       	call   f010ecb1 <getcallerpcs>
f010ec3d:	83 c4 10             	add    $0x10,%esp

}
f010ec40:	90                   	nop
f010ec41:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ec44:	c9                   	leave  
f010ec45:	c3                   	ret    

f010ec46 <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f010ec46:	55                   	push   %ebp
f010ec47:	89 e5                	mov    %esp,%ebp
f010ec49:	83 ec 08             	sub    $0x8,%esp
	if(!holding_spinlock(lk))
f010ec4c:	83 ec 0c             	sub    $0xc,%esp
f010ec4f:	ff 75 08             	pushl  0x8(%ebp)
f010ec52:	e8 81 01 00 00       	call   f010edd8 <holding_spinlock>
f010ec57:	83 c4 10             	add    $0x10,%esp
f010ec5a:	85 c0                	test   %eax,%eax
f010ec5c:	75 26                	jne    f010ec84 <release_spinlock+0x3e>
	{
		printcallstack(lk);
f010ec5e:	83 ec 0c             	sub    $0xc,%esp
f010ec61:	ff 75 08             	pushl  0x8(%ebp)
f010ec64:	e8 08 01 00 00       	call   f010ed71 <printcallstack>
f010ec69:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010ec6c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec6f:	83 c0 04             	add    $0x4,%eax
f010ec72:	50                   	push   %eax
f010ec73:	68 b0 66 12 f0       	push   $0xf01266b0
f010ec78:	6a 3b                	push   $0x3b
f010ec7a:	68 99 66 12 f0       	push   $0xf0126699
f010ec7f:	e8 b5 16 ff ff       	call   f0100339 <_panic>
	}
	lk->pcs[0] = 0;
f010ec84:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec87:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010ec8e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec91:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010ec98:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010ec9d:	8b 45 08             	mov    0x8(%ebp),%eax
f010eca0:	8b 55 08             	mov    0x8(%ebp),%edx
f010eca3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f010eca9:	e8 ab 85 ff ff       	call   f0107259 <popcli>
}
f010ecae:	90                   	nop
f010ecaf:	c9                   	leave  
f010ecb0:	c3                   	ret    

f010ecb1 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010ecb1:	55                   	push   %ebp
f010ecb2:	89 e5                	mov    %esp,%ebp
f010ecb4:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010ecb7:	e8 9d bf ff ff       	call   f010ac59 <get_cpu_proc>
f010ecbc:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010ecbf:	e8 80 84 ff ff       	call   f0107144 <mycpu>
f010ecc4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010ecc7:	8b 45 08             	mov    0x8(%ebp),%eax
f010ecca:	83 e8 08             	sub    $0x8,%eax
f010eccd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010ecd0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010ecd7:	eb 67                	jmp    f010ed40 <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010ecd9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ecdd:	74 67                	je     f010ed46 <getcallerpcs+0x95>
f010ecdf:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010ece6:	76 5e                	jbe    f010ed46 <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010ece8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010eceb:	8b 40 08             	mov    0x8(%eax),%eax
f010ecee:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010ecf3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ecf6:	77 10                	ja     f010ed08 <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010ecf8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ecfb:	8b 40 08             	mov    0x8(%eax),%eax
f010ecfe:	05 00 90 00 00       	add    $0x9000,%eax
f010ed03:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ed06:	77 3e                	ja     f010ed46 <getcallerpcs+0x95>
f010ed08:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ed0c:	74 10                	je     f010ed1e <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010ed0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ed11:	8b 40 70             	mov    0x70(%eax),%eax
f010ed14:	05 00 80 00 00       	add    $0x8000,%eax
f010ed19:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ed1c:	76 28                	jbe    f010ed46 <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010ed1e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ed21:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ed28:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed2b:	01 c2                	add    %eax,%edx
f010ed2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed30:	8b 40 04             	mov    0x4(%eax),%eax
f010ed33:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010ed35:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed38:	8b 00                	mov    (%eax),%eax
f010ed3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010ed3d:	ff 45 f0             	incl   -0x10(%ebp)
f010ed40:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010ed44:	7e 93                	jle    f010ecd9 <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010ed46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ed49:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010ed4c:	eb 18                	jmp    f010ed66 <getcallerpcs+0xb5>
		pcs[i] = 0;
f010ed4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ed51:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ed58:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed5b:	01 d0                	add    %edx,%eax
f010ed5d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010ed63:	ff 45 f0             	incl   -0x10(%ebp)
f010ed66:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010ed6a:	7e e2                	jle    f010ed4e <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010ed6c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010ed6f:	c9                   	leave  
f010ed70:	c3                   	ret    

f010ed71 <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f010ed71:	55                   	push   %ebp
f010ed72:	89 e5                	mov    %esp,%ebp
f010ed74:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010ed77:	83 ec 0c             	sub    $0xc,%esp
f010ed7a:	68 ee 66 12 f0       	push   $0xf01266ee
f010ed7f:	e8 07 22 ff ff       	call   f0100f8b <cprintf>
f010ed84:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010ed87:	8b 45 08             	mov    0x8(%ebp),%eax
f010ed8a:	83 c0 48             	add    $0x48,%eax
f010ed8d:	83 ec 08             	sub    $0x8,%esp
f010ed90:	50                   	push   %eax
f010ed91:	8d 45 08             	lea    0x8(%ebp),%eax
f010ed94:	50                   	push   %eax
f010ed95:	e8 17 ff ff ff       	call   f010ecb1 <getcallerpcs>
f010ed9a:	83 c4 10             	add    $0x10,%esp
f010ed9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010eda0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010eda7:	eb 24                	jmp    f010edcd <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010eda9:	8b 45 08             	mov    0x8(%ebp),%eax
f010edac:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010edaf:	83 c2 10             	add    $0x10,%edx
f010edb2:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010edb6:	83 ec 04             	sub    $0x4,%esp
f010edb9:	50                   	push   %eax
f010edba:	ff 75 f4             	pushl  -0xc(%ebp)
f010edbd:	68 fe 66 12 f0       	push   $0xf01266fe
f010edc2:	e8 c4 21 ff ff       	call   f0100f8b <cprintf>
f010edc7:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010edca:	ff 45 f4             	incl   -0xc(%ebp)
f010edcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010edd0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010edd3:	7c d4                	jl     f010eda9 <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010edd5:	90                   	nop
f010edd6:	c9                   	leave  
f010edd7:	c3                   	ret    

f010edd8 <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f010edd8:	55                   	push   %ebp
f010edd9:	89 e5                	mov    %esp,%ebp
f010eddb:	53                   	push   %ebx
f010eddc:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010eddf:	e8 23 84 ff ff       	call   f0107207 <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010ede4:	8b 45 08             	mov    0x8(%ebp),%eax
f010ede7:	8b 00                	mov    (%eax),%eax
f010ede9:	85 c0                	test   %eax,%eax
f010edeb:	74 16                	je     f010ee03 <holding_spinlock+0x2b>
f010eded:	8b 45 08             	mov    0x8(%ebp),%eax
f010edf0:	8b 58 44             	mov    0x44(%eax),%ebx
f010edf3:	e8 4c 83 ff ff       	call   f0107144 <mycpu>
f010edf8:	39 c3                	cmp    %eax,%ebx
f010edfa:	75 07                	jne    f010ee03 <holding_spinlock+0x2b>
f010edfc:	b8 01 00 00 00       	mov    $0x1,%eax
f010ee01:	eb 05                	jmp    f010ee08 <holding_spinlock+0x30>
f010ee03:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee08:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f010ee0b:	e8 49 84 ff ff       	call   f0107259 <popcli>
	return r;
f010ee10:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ee13:	83 c4 14             	add    $0x14,%esp
f010ee16:	5b                   	pop    %ebx
f010ee17:	5d                   	pop    %ebp
f010ee18:	c3                   	ret    

f010ee19 <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"
#include "kern/cpu/sched.h"
void init_sleeplock(struct sleeplock *lk, char *name)
{
f010ee19:	55                   	push   %ebp
f010ee1a:	89 e5                	mov    %esp,%ebp
f010ee1c:	83 ec 08             	sub    $0x8,%esp
	init_channel(&(lk->chan), "sleep lock channel");
f010ee1f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee22:	83 c0 74             	add    $0x74,%eax
f010ee25:	83 ec 08             	sub    $0x8,%esp
f010ee28:	68 0d 67 12 f0       	push   $0xf012670d
f010ee2d:	50                   	push   %eax
f010ee2e:	e8 5a 01 00 00       	call   f010ef8d <init_channel>
f010ee33:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f010ee36:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee39:	83 c0 04             	add    $0x4,%eax
f010ee3c:	83 ec 08             	sub    $0x8,%esp
f010ee3f:	68 20 67 12 f0       	push   $0xf0126720
f010ee44:	50                   	push   %eax
f010ee45:	e8 44 fd ff ff       	call   f010eb8e <init_spinlock>
f010ee4a:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f010ee4d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee50:	05 c4 00 00 00       	add    $0xc4,%eax
f010ee55:	83 ec 08             	sub    $0x8,%esp
f010ee58:	ff 75 0c             	pushl  0xc(%ebp)
f010ee5b:	50                   	push   %eax
f010ee5c:	e8 cd fd 00 00       	call   f011ec2e <strcpy>
f010ee61:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010ee64:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee67:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f010ee6d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee70:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f010ee77:	00 00 00 
}
f010ee7a:	90                   	nop
f010ee7b:	c9                   	leave  
f010ee7c:	c3                   	ret    

f010ee7d <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk)
{
f010ee7d:	55                   	push   %ebp
f010ee7e:	89 e5                	mov    %esp,%ebp
f010ee80:	53                   	push   %ebx
f010ee81:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f010ee84:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee87:	83 c0 04             	add    $0x4,%eax
f010ee8a:	83 ec 0c             	sub    $0xc,%esp
f010ee8d:	50                   	push   %eax
f010ee8e:	e8 2c fd ff ff       	call   f010ebbf <acquire_spinlock>
f010ee93:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f010ee96:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee99:	8b 00                	mov    (%eax),%eax
f010ee9b:	85 c0                	test   %eax,%eax
f010ee9d:	74 1c                	je     f010eebb <holding_sleeplock+0x3e>
f010ee9f:	8b 45 08             	mov    0x8(%ebp),%eax
f010eea2:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f010eea8:	e8 ac bd ff ff       	call   f010ac59 <get_cpu_proc>
f010eead:	8b 40 10             	mov    0x10(%eax),%eax
f010eeb0:	39 c3                	cmp    %eax,%ebx
f010eeb2:	75 07                	jne    f010eebb <holding_sleeplock+0x3e>
f010eeb4:	b8 01 00 00 00       	mov    $0x1,%eax
f010eeb9:	eb 05                	jmp    f010eec0 <holding_sleeplock+0x43>
f010eebb:	b8 00 00 00 00       	mov    $0x0,%eax
f010eec0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f010eec3:	8b 45 08             	mov    0x8(%ebp),%eax
f010eec6:	83 c0 04             	add    $0x4,%eax
f010eec9:	83 ec 0c             	sub    $0xc,%esp
f010eecc:	50                   	push   %eax
f010eecd:	e8 74 fd ff ff       	call   f010ec46 <release_spinlock>
f010eed2:	83 c4 10             	add    $0x10,%esp
	return r;
f010eed5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010eed8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010eedb:	c9                   	leave  
f010eedc:	c3                   	ret    

f010eedd <acquire_sleeplock>:
//==========================================================================

//sched_init();
//init_spinlock(&ProcessQueues.qlock, "process queues lock");
void acquire_sleeplock(struct sleeplock *lk)
{
f010eedd:	55                   	push   %ebp
f010eede:	89 e5                	mov    %esp,%ebp
f010eee0:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&lk->lk);//&&&--&&&||
f010eee3:	8b 45 08             	mov    0x8(%ebp),%eax
f010eee6:	83 c0 04             	add    $0x4,%eax
f010eee9:	83 ec 0c             	sub    $0xc,%esp
f010eeec:	50                   	push   %eax
f010eeed:	e8 cd fc ff ff       	call   f010ebbf <acquire_spinlock>
f010eef2:	83 c4 10             	add    $0x10,%esp
	while(lk->locked== 1){          //  ||
f010eef5:	eb 19                	jmp    f010ef10 <acquire_sleeplock+0x33>

		//go to sleep	//

		sleep(&lk->chan,&lk->lk);
f010eef7:	8b 45 08             	mov    0x8(%ebp),%eax
f010eefa:	8d 50 04             	lea    0x4(%eax),%edx
f010eefd:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef00:	83 c0 74             	add    $0x74,%eax
f010ef03:	83 ec 08             	sub    $0x8,%esp
f010ef06:	52                   	push   %edx
f010ef07:	50                   	push   %eax
f010ef08:	e8 ad 00 00 00       	call   f010efba <sleep>
f010ef0d:	83 c4 10             	add    $0x10,%esp
//sched_init();
//init_spinlock(&ProcessQueues.qlock, "process queues lock");
void acquire_sleeplock(struct sleeplock *lk)
{
	acquire_spinlock(&lk->lk);//&&&--&&&||
	while(lk->locked== 1){          //  ||
f010ef10:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef13:	8b 00                	mov    (%eax),%eax
f010ef15:	83 f8 01             	cmp    $0x1,%eax
f010ef18:	74 dd                	je     f010eef7 <acquire_sleeplock+0x1a>
		//go to sleep	//

		sleep(&lk->chan,&lk->lk);
		//acquire_spinlock(&lk->lk);
	}
	lk->locked=1;
f010ef1a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef1d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	release_spinlock(&lk->lk);
f010ef23:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef26:	83 c0 04             	add    $0x4,%eax
f010ef29:	83 ec 0c             	sub    $0xc,%esp
f010ef2c:	50                   	push   %eax
f010ef2d:	e8 14 fd ff ff       	call   f010ec46 <release_spinlock>
f010ef32:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("acquire_sleeplock is not implemented yet");
	//Your Code is Here...


}
f010ef35:	90                   	nop
f010ef36:	c9                   	leave  
f010ef37:	c3                   	ret    

f010ef38 <release_sleeplock>:

void release_sleeplock(struct sleeplock *lk)
{
f010ef38:	55                   	push   %ebp
f010ef39:	89 e5                	mov    %esp,%ebp
f010ef3b:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("release_sleeplock is not implemented yet");
	//Your Code is Here...
	acquire_spinlock(&lk->lk);//&&&--&&&||
f010ef3e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef41:	83 c0 04             	add    $0x4,%eax
f010ef44:	83 ec 0c             	sub    $0xc,%esp
f010ef47:	50                   	push   %eax
f010ef48:	e8 72 fc ff ff       	call   f010ebbf <acquire_spinlock>
f010ef4d:	83 c4 10             	add    $0x10,%esp

	if (lk->chan.queue.size>0){
f010ef50:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef53:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010ef59:	85 c0                	test   %eax,%eax
f010ef5b:	74 12                	je     f010ef6f <release_sleeplock+0x37>

		wakeup_all(&lk->chan);
f010ef5d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef60:	83 c0 74             	add    $0x74,%eax
f010ef63:	83 ec 0c             	sub    $0xc,%esp
f010ef66:	50                   	push   %eax
f010ef67:	e8 19 01 00 00       	call   f010f085 <wakeup_all>
f010ef6c:	83 c4 10             	add    $0x10,%esp
	}
	lk->locked=0;
f010ef6f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef72:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	release_spinlock(&lk->lk);
f010ef78:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef7b:	83 c0 04             	add    $0x4,%eax
f010ef7e:	83 ec 0c             	sub    $0xc,%esp
f010ef81:	50                   	push   %eax
f010ef82:	e8 bf fc ff ff       	call   f010ec46 <release_spinlock>
f010ef87:	83 c4 10             	add    $0x10,%esp

}
f010ef8a:	90                   	nop
f010ef8b:	c9                   	leave  
f010ef8c:	c3                   	ret    

f010ef8d <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f010ef8d:	55                   	push   %ebp
f010ef8e:	89 e5                	mov    %esp,%ebp
f010ef90:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f010ef93:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef96:	83 c0 10             	add    $0x10,%eax
f010ef99:	83 ec 08             	sub    $0x8,%esp
f010ef9c:	ff 75 0c             	pushl  0xc(%ebp)
f010ef9f:	50                   	push   %eax
f010efa0:	e8 89 fc 00 00       	call   f011ec2e <strcpy>
f010efa5:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f010efa8:	8b 45 08             	mov    0x8(%ebp),%eax
f010efab:	83 ec 0c             	sub    $0xc,%esp
f010efae:	50                   	push   %eax
f010efaf:	e8 f6 5f ff ff       	call   f0104faa <init_queue>
f010efb4:	83 c4 10             	add    $0x10,%esp
}
f010efb7:	90                   	nop
f010efb8:	c9                   	leave  
f010efb9:	c3                   	ret    

f010efba <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f010efba:	55                   	push   %ebp
f010efbb:	89 e5                	mov    %esp,%ebp
f010efbd:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("sleep is not implemented yet");
	//Your Code is Here...

	acquire_spinlock(&ProcessQueues.qlock);
f010efc0:	83 ec 0c             	sub    $0xc,%esp
f010efc3:	68 60 c4 5e f0       	push   $0xf05ec460
f010efc8:	e8 f2 fb ff ff       	call   f010ebbf <acquire_spinlock>
f010efcd:	83 c4 10             	add    $0x10,%esp
	release_spinlock(lk);
f010efd0:	83 ec 0c             	sub    $0xc,%esp
f010efd3:	ff 75 0c             	pushl  0xc(%ebp)
f010efd6:	e8 6b fc ff ff       	call   f010ec46 <release_spinlock>
f010efdb:	83 c4 10             	add    $0x10,%esp
	struct Env *proc;
	proc=get_cpu_proc();
f010efde:	e8 76 bc ff ff       	call   f010ac59 <get_cpu_proc>
f010efe3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	proc->env_status=ENV_BLOCKED;
f010efe6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010efe9:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%eax)
    enqueue(&chan->queue,proc);
f010eff0:	8b 45 08             	mov    0x8(%ebp),%eax
f010eff3:	83 ec 08             	sub    $0x8,%esp
f010eff6:	ff 75 f4             	pushl  -0xc(%ebp)
f010eff9:	50                   	push   %eax
f010effa:	e8 ec 5f ff ff       	call   f0104feb <enqueue>
f010efff:	83 c4 10             	add    $0x10,%esp
	sched();
f010f002:	e8 cb bd ff ff       	call   f010add2 <sched>
	release_spinlock(&ProcessQueues.qlock);
f010f007:	83 ec 0c             	sub    $0xc,%esp
f010f00a:	68 60 c4 5e f0       	push   $0xf05ec460
f010f00f:	e8 32 fc ff ff       	call   f010ec46 <release_spinlock>
f010f014:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(lk);
f010f017:	83 ec 0c             	sub    $0xc,%esp
f010f01a:	ff 75 0c             	pushl  0xc(%ebp)
f010f01d:	e8 9d fb ff ff       	call   f010ebbf <acquire_spinlock>
f010f022:	83 c4 10             	add    $0x10,%esp
}
f010f025:	90                   	nop
f010f026:	c9                   	leave  
f010f027:	c3                   	ret    

f010f028 <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f010f028:	55                   	push   %ebp
f010f029:	89 e5                	mov    %esp,%ebp
f010f02b:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("wakeup_one is not implemented yet");
	//Your Code is Here...
	struct Env *proc;
	acquire_spinlock(&ProcessQueues.qlock);
f010f02e:	83 ec 0c             	sub    $0xc,%esp
f010f031:	68 60 c4 5e f0       	push   $0xf05ec460
f010f036:	e8 84 fb ff ff       	call   f010ebbf <acquire_spinlock>
f010f03b:	83 c4 10             	add    $0x10,%esp
	if (chan->queue.size!=0){
f010f03e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f041:	8b 40 0c             	mov    0xc(%eax),%eax
f010f044:	85 c0                	test   %eax,%eax
f010f046:	74 2a                	je     f010f072 <wakeup_one+0x4a>
	proc= dequeue(&chan->queue);
f010f048:	8b 45 08             	mov    0x8(%ebp),%eax
f010f04b:	83 ec 0c             	sub    $0xc,%esp
f010f04e:	50                   	push   %eax
f010f04f:	e8 28 60 ff ff       	call   f010507c <dequeue>
f010f054:	83 c4 10             	add    $0x10,%esp
f010f057:	89 45 f4             	mov    %eax,-0xc(%ebp)
	proc->env_status=ENV_READY;
f010f05a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f05d:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
	sched_insert_ready0(proc);}
f010f064:	83 ec 0c             	sub    $0xc,%esp
f010f067:	ff 75 f4             	pushl  -0xc(%ebp)
f010f06a:	e8 48 62 ff ff       	call   f01052b7 <sched_insert_ready0>
f010f06f:	83 c4 10             	add    $0x10,%esp
	release_spinlock(&ProcessQueues.qlock);
f010f072:	83 ec 0c             	sub    $0xc,%esp
f010f075:	68 60 c4 5e f0       	push   $0xf05ec460
f010f07a:	e8 c7 fb ff ff       	call   f010ec46 <release_spinlock>
f010f07f:	83 c4 10             	add    $0x10,%esp
}
f010f082:	90                   	nop
f010f083:	c9                   	leave  
f010f084:	c3                   	ret    

f010f085 <wakeup_all>:
// The queues lock must be held.
 //Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f010f085:	55                   	push   %ebp
f010f086:	89 e5                	mov    %esp,%ebp
f010f088:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("wakeup_all is not implemented yet");
	//Your Code is Here...
		acquire_spinlock(&ProcessQueues.qlock);
f010f08b:	83 ec 0c             	sub    $0xc,%esp
f010f08e:	68 60 c4 5e f0       	push   $0xf05ec460
f010f093:	e8 27 fb ff ff       	call   f010ebbf <acquire_spinlock>
f010f098:	83 c4 10             	add    $0x10,%esp
			struct Env *proc;
	while (chan->queue.size!=0){
f010f09b:	eb 2a                	jmp    f010f0c7 <wakeup_all+0x42>
			proc= dequeue(&chan->queue);
f010f09d:	8b 45 08             	mov    0x8(%ebp),%eax
f010f0a0:	83 ec 0c             	sub    $0xc,%esp
f010f0a3:	50                   	push   %eax
f010f0a4:	e8 d3 5f ff ff       	call   f010507c <dequeue>
f010f0a9:	83 c4 10             	add    $0x10,%esp
f010f0ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
			proc->env_status=ENV_READY;
f010f0af:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f0b2:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
			sched_insert_ready0(proc);
f010f0b9:	83 ec 0c             	sub    $0xc,%esp
f010f0bc:	ff 75 f4             	pushl  -0xc(%ebp)
f010f0bf:	e8 f3 61 ff ff       	call   f01052b7 <sched_insert_ready0>
f010f0c4:	83 c4 10             	add    $0x10,%esp
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("wakeup_all is not implemented yet");
	//Your Code is Here...
		acquire_spinlock(&ProcessQueues.qlock);
			struct Env *proc;
	while (chan->queue.size!=0){
f010f0c7:	8b 45 08             	mov    0x8(%ebp),%eax
f010f0ca:	8b 40 0c             	mov    0xc(%eax),%eax
f010f0cd:	85 c0                	test   %eax,%eax
f010f0cf:	75 cc                	jne    f010f09d <wakeup_all+0x18>
			proc= dequeue(&chan->queue);
			proc->env_status=ENV_READY;
			sched_insert_ready0(proc);
		//wakeup_one(chan);
	}
			release_spinlock(&ProcessQueues.qlock);
f010f0d1:	83 ec 0c             	sub    $0xc,%esp
f010f0d4:	68 60 c4 5e f0       	push   $0xf05ec460
f010f0d9:	e8 68 fb ff ff       	call   f010ec46 <release_spinlock>
f010f0de:	83 c4 10             	add    $0x10,%esp
}
f010f0e1:	90                   	nop
f010f0e2:	c9                   	leave  
f010f0e3:	c3                   	ret    

f010f0e4 <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f010f0e4:	55                   	push   %ebp
f010f0e5:	89 e5                	mov    %esp,%ebp
f010f0e7:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f010f0ea:	83 ec 04             	sub    $0x4,%esp
f010f0ed:	68 34 67 12 f0       	push   $0xf0126734
f010f0f2:	6a 13                	push   $0x13
f010f0f4:	68 5b 67 12 f0       	push   $0xf012675b
f010f0f9:	e8 3b 12 ff ff       	call   f0100339 <_panic>

f010f0fe <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f010f0fe:	55                   	push   %ebp
f010f0ff:	89 e5                	mov    %esp,%ebp
f010f101:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f010f104:	83 ec 04             	sub    $0x4,%esp
f010f107:	68 74 67 12 f0       	push   $0xf0126774
f010f10c:	6a 1b                	push   $0x1b
f010f10e:	68 5b 67 12 f0       	push   $0xf012675b
f010f113:	e8 21 12 ff ff       	call   f0100339 <_panic>

f010f118 <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f010f118:	55                   	push   %ebp
f010f119:	89 e5                	mov    %esp,%ebp
f010f11b:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f010f11e:	83 ec 04             	sub    $0x4,%esp
f010f121:	68 9c 67 12 f0       	push   $0xf012679c
f010f126:	6a 24                	push   $0x24
f010f128:	68 5b 67 12 f0       	push   $0xf012675b
f010f12d:	e8 07 12 ff ff       	call   f0100339 <_panic>

f010f132 <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010f132:	55                   	push   %ebp
f010f133:	89 e5                	mov    %esp,%ebp
f010f135:	c7 05 f0 c9 5e f0 01 	movl   $0x1,0xf05ec9f0
f010f13c:	00 00 00 
f010f13f:	90                   	nop
f010f140:	5d                   	pop    %ebp
f010f141:	c3                   	ret    

f010f142 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f010f142:	55                   	push   %ebp
f010f143:	89 e5                	mov    %esp,%ebp
f010f145:	c7 05 f0 c9 5e f0 02 	movl   $0x2,0xf05ec9f0
f010f14c:	00 00 00 
f010f14f:	90                   	nop
f010f150:	5d                   	pop    %ebp
f010f151:	c3                   	ret    

f010f152 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f010f152:	55                   	push   %ebp
f010f153:	89 e5                	mov    %esp,%ebp
f010f155:	c7 05 f0 c9 5e f0 03 	movl   $0x3,0xf05ec9f0
f010f15c:	00 00 00 
f010f15f:	90                   	nop
f010f160:	5d                   	pop    %ebp
f010f161:	c3                   	ret    

f010f162 <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010f162:	55                   	push   %ebp
f010f163:	89 e5                	mov    %esp,%ebp
f010f165:	a1 f0 c9 5e f0       	mov    0xf05ec9f0,%eax
f010f16a:	83 f8 01             	cmp    $0x1,%eax
f010f16d:	75 04                	jne    f010f173 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f010f16f:	b0 01                	mov    $0x1,%al
f010f171:	eb 02                	jmp    f010f175 <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010f173:	b0 00                	mov    $0x0,%al
f010f175:	5d                   	pop    %ebp
f010f176:	c3                   	ret    

f010f177 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f010f177:	55                   	push   %ebp
f010f178:	89 e5                	mov    %esp,%ebp
f010f17a:	a1 f0 c9 5e f0       	mov    0xf05ec9f0,%eax
f010f17f:	83 f8 02             	cmp    $0x2,%eax
f010f182:	75 04                	jne    f010f188 <isKHeapPlacementStrategyBESTFIT+0x11>
f010f184:	b0 01                	mov    $0x1,%al
f010f186:	eb 02                	jmp    f010f18a <isKHeapPlacementStrategyBESTFIT+0x13>
f010f188:	b0 00                	mov    $0x0,%al
f010f18a:	5d                   	pop    %ebp
f010f18b:	c3                   	ret    

f010f18c <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f010f18c:	55                   	push   %ebp
f010f18d:	89 e5                	mov    %esp,%ebp
f010f18f:	a1 f0 c9 5e f0       	mov    0xf05ec9f0,%eax
f010f194:	83 f8 03             	cmp    $0x3,%eax
f010f197:	75 04                	jne    f010f19d <isKHeapPlacementStrategyNEXTFIT+0x11>
f010f199:	b0 01                	mov    $0x1,%al
f010f19b:	eb 02                	jmp    f010f19f <isKHeapPlacementStrategyNEXTFIT+0x13>
f010f19d:	b0 00                	mov    $0x0,%al
f010f19f:	5d                   	pop    %ebp
f010f1a0:	c3                   	ret    

f010f1a1 <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f010f1a1:	55                   	push   %ebp
f010f1a2:	89 e5                	mov    %esp,%ebp
f010f1a4:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010f1a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010f1ae:	eb 26                	jmp    f010f1d6 <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f010f1b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f1b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010f1ba:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1bd:	01 c2                	add    %eax,%edx
f010f1bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f1c2:	40                   	inc    %eax
f010f1c3:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010f1ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1cd:	01 c8                	add    %ecx,%eax
f010f1cf:	8b 00                	mov    (%eax),%eax
f010f1d1:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010f1d3:	ff 45 f4             	incl   -0xc(%ebp)
f010f1d6:	8b 45 08             	mov    0x8(%ebp),%eax
f010f1d9:	48                   	dec    %eax
f010f1da:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010f1dd:	7f d1                	jg     f010f1b0 <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f010f1df:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f010f1e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010f1e9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010f1f0:	eb 35                	jmp    f010f227 <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f010f1f2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f1f5:	89 d0                	mov    %edx,%eax
f010f1f7:	01 c0                	add    %eax,%eax
f010f1f9:	01 d0                	add    %edx,%eax
f010f1fb:	c1 e0 02             	shl    $0x2,%eax
f010f1fe:	05 00 bd 17 f0       	add    $0xf017bd00,%eax
f010f203:	8b 10                	mov    (%eax),%edx
f010f205:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f208:	8b 00                	mov    (%eax),%eax
f010f20a:	83 ec 08             	sub    $0x8,%esp
f010f20d:	52                   	push   %edx
f010f20e:	50                   	push   %eax
f010f20f:	e8 d7 fa 00 00       	call   f011eceb <strcmp>
f010f214:	83 c4 10             	add    $0x10,%esp
f010f217:	85 c0                	test   %eax,%eax
f010f219:	75 09                	jne    f010f224 <tst_handler+0x83>
		{
			test_found = 1;
f010f21b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f010f222:	eb 0f                	jmp    f010f233 <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010f224:	ff 45 ec             	incl   -0x14(%ebp)
f010f227:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f22a:	a1 b4 bd 17 f0       	mov    0xf017bdb4,%eax
f010f22f:	39 c2                	cmp    %eax,%edx
f010f231:	72 bf                	jb     f010f1f2 <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f010f233:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f237:	74 29                	je     f010f262 <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f010f239:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f23c:	89 d0                	mov    %edx,%eax
f010f23e:	01 c0                	add    %eax,%eax
f010f240:	01 d0                	add    %edx,%eax
f010f242:	c1 e0 02             	shl    $0x2,%eax
f010f245:	05 08 bd 17 f0       	add    $0xf017bd08,%eax
f010f24a:	8b 00                	mov    (%eax),%eax
f010f24c:	83 ec 08             	sub    $0x8,%esp
f010f24f:	ff 75 0c             	pushl  0xc(%ebp)
f010f252:	ff 75 08             	pushl  0x8(%ebp)
f010f255:	ff d0                	call   *%eax
f010f257:	83 c4 10             	add    $0x10,%esp
f010f25a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f010f25d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f260:	eb 1b                	jmp    f010f27d <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f010f262:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f265:	8b 00                	mov    (%eax),%eax
f010f267:	83 ec 08             	sub    $0x8,%esp
f010f26a:	50                   	push   %eax
f010f26b:	68 dc 6a 12 f0       	push   $0xf0126adc
f010f270:	e8 16 1d ff ff       	call   f0100f8b <cprintf>
f010f275:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f278:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f010f27d:	c9                   	leave  
f010f27e:	c3                   	ret    

f010f27f <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f010f27f:	55                   	push   %ebp
f010f280:	89 e5                	mov    %esp,%ebp
f010f282:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f010f285:	e8 e0 d0 00 00       	call   f011c36a <test_three_creation_functions>
	return 0;
f010f28a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f28f:	c9                   	leave  
f010f290:	c3                   	ret    

f010f291 <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f010f291:	55                   	push   %ebp
f010f292:	89 e5                	mov    %esp,%ebp
f010f294:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f010f297:	e8 03 69 00 00       	call   f0115b9f <test_priority_normal_and_higher>
	return 0;
f010f29c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f2a1:	c9                   	leave  
f010f2a2:	c3                   	ret    

f010f2a3 <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f010f2a3:	55                   	push   %ebp
f010f2a4:	89 e5                	mov    %esp,%ebp
f010f2a6:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f010f2a9:	e8 0b 69 00 00       	call   f0115bb9 <test_priority_normal_and_lower>
	return 0;
f010f2ae:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f2b3:	c9                   	leave  
f010f2b4:	c3                   	ret    

f010f2b5 <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f010f2b5:	55                   	push   %ebp
f010f2b6:	89 e5                	mov    %esp,%ebp
f010f2b8:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f010f2bb:	e8 5d d2 00 00       	call   f011c51d <test_kfreeall>
	return 0;
f010f2c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f2c5:	c9                   	leave  
f010f2c6:	c3                   	ret    

f010f2c7 <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f010f2c7:	55                   	push   %ebp
f010f2c8:	89 e5                	mov    %esp,%ebp
f010f2ca:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f010f2cd:	e8 68 d2 00 00       	call   f011c53a <test_kexpand>
	return 0;
f010f2d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f2d7:	c9                   	leave  
f010f2d8:	c3                   	ret    

f010f2d9 <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f010f2d9:	55                   	push   %ebp
f010f2da:	89 e5                	mov    %esp,%ebp
f010f2dc:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f010f2df:	e8 73 d2 00 00       	call   f011c557 <test_kshrink>
	return 0;
f010f2e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f2e9:	c9                   	leave  
f010f2ea:	c3                   	ret    

f010f2eb <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f010f2eb:	55                   	push   %ebp
f010f2ec:	89 e5                	mov    %esp,%ebp
f010f2ee:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f010f2f1:	e8 7e d2 00 00       	call   f011c574 <test_kfreelast>
	return 0;
f010f2f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f2fb:	c9                   	leave  
f010f2fc:	c3                   	ret    

f010f2fd <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f010f2fd:	55                   	push   %ebp
f010f2fe:	89 e5                	mov    %esp,%ebp
f010f300:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f010f303:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f306:	83 c0 04             	add    $0x4,%eax
f010f309:	8b 00                	mov    (%eax),%eax
f010f30b:	83 ec 04             	sub    $0x4,%esp
f010f30e:	6a 0a                	push   $0xa
f010f310:	6a 00                	push   $0x0
f010f312:	50                   	push   %eax
f010f313:	e8 27 fc 00 00       	call   f011ef3f <strtol>
f010f318:	83 c4 10             	add    $0x10,%esp
f010f31b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f010f31e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f010f325:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f010f32c:	83 ec 0c             	sub    $0xc,%esp
f010f32f:	68 60 c4 5e f0       	push   $0xf05ec460
f010f334:	e8 86 f8 ff ff       	call   f010ebbf <acquire_spinlock>
f010f339:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010f33c:	a1 e0 c4 5e f0       	mov    0xf05ec4e0,%eax
f010f341:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f344:	eb 3b                	jmp    f010f381 <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f010f346:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f349:	83 c0 20             	add    $0x20,%eax
f010f34c:	83 ec 08             	sub    $0x8,%esp
f010f34f:	68 ef 6a 12 f0       	push   $0xf0126aef
f010f354:	50                   	push   %eax
f010f355:	e8 91 f9 00 00       	call   f011eceb <strcmp>
f010f35a:	83 c4 10             	add    $0x10,%esp
f010f35d:	85 c0                	test   %eax,%eax
f010f35f:	75 12                	jne    f010f373 <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f010f361:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f365:	74 07                	je     f010f36e <tst_sc_MLFQ+0x71>
					firstTime = 0;
f010f367:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f010f36e:	ff 45 f4             	incl   -0xc(%ebp)
f010f371:	eb 06                	jmp    f010f379 <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f010f373:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f377:	74 31                	je     f010f3aa <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010f379:	a1 e8 c4 5e f0       	mov    0xf05ec4e8,%eax
f010f37e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f381:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010f385:	74 08                	je     f010f38f <tst_sc_MLFQ+0x92>
f010f387:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f38a:	8b 40 08             	mov    0x8(%eax),%eax
f010f38d:	eb 05                	jmp    f010f394 <tst_sc_MLFQ+0x97>
f010f38f:	b8 00 00 00 00       	mov    $0x0,%eax
f010f394:	a3 e8 c4 5e f0       	mov    %eax,0xf05ec4e8
f010f399:	a1 e8 c4 5e f0       	mov    0xf05ec4e8,%eax
f010f39e:	85 c0                	test   %eax,%eax
f010f3a0:	75 a4                	jne    f010f346 <tst_sc_MLFQ+0x49>
f010f3a2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010f3a6:	75 9e                	jne    f010f346 <tst_sc_MLFQ+0x49>
f010f3a8:	eb 01                	jmp    f010f3ab <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f010f3aa:	90                   	nop
			}
		if(cnt == numOfSlave2)
f010f3ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f3ae:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010f3b1:	75 12                	jne    f010f3c5 <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f010f3b3:	83 ec 0c             	sub    $0xc,%esp
f010f3b6:	68 f8 6a 12 f0       	push   $0xf0126af8
f010f3bb:	e8 cb 1b ff ff       	call   f0100f8b <cprintf>
f010f3c0:	83 c4 10             	add    $0x10,%esp
f010f3c3:	eb 17                	jmp    f010f3dc <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f010f3c5:	83 ec 04             	sub    $0x4,%esp
f010f3c8:	68 31 6b 12 f0       	push   $0xf0126b31
f010f3cd:	68 9b 00 00 00       	push   $0x9b
f010f3d2:	68 47 6b 12 f0       	push   $0xf0126b47
f010f3d7:	e8 5d 0f ff ff       	call   f0100339 <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f010f3dc:	83 ec 0c             	sub    $0xc,%esp
f010f3df:	68 60 c4 5e f0       	push   $0xf05ec460
f010f3e4:	e8 5d f8 ff ff       	call   f010ec46 <release_spinlock>
f010f3e9:	83 c4 10             	add    $0x10,%esp
	return 0;
f010f3ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f3f1:	c9                   	leave  
f010f3f2:	c3                   	ret    

f010f3f3 <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f010f3f3:	55                   	push   %ebp
f010f3f4:	89 e5                	mov    %esp,%ebp
f010f3f6:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f010f3f9:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f3fd:	74 17                	je     f010f416 <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f010f3ff:	83 ec 0c             	sub    $0xc,%esp
f010f402:	68 60 6b 12 f0       	push   $0xf0126b60
f010f407:	e8 7f 1b ff ff       	call   f0100f8b <cprintf>
f010f40c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f40f:	b8 00 00 00 00       	mov    $0x0,%eax
f010f414:	eb 45                	jmp    f010f45b <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f010f416:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f419:	83 c0 04             	add    $0x4,%eax
f010f41c:	8b 00                	mov    (%eax),%eax
f010f41e:	83 ec 04             	sub    $0x4,%esp
f010f421:	6a 0a                	push   $0xa
f010f423:	6a 00                	push   $0x0
f010f425:	50                   	push   %eax
f010f426:	e8 14 fb 00 00       	call   f011ef3f <strtol>
f010f42b:	83 c4 10             	add    $0x10,%esp
f010f42e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f010f431:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f434:	83 f8 01             	cmp    $0x1,%eax
f010f437:	74 10                	je     f010f449 <tst_bsd_nice+0x56>
f010f439:	83 f8 02             	cmp    $0x2,%eax
f010f43c:	74 12                	je     f010f450 <tst_bsd_nice+0x5d>
f010f43e:	85 c0                	test   %eax,%eax
f010f440:	75 14                	jne    f010f456 <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f010f442:	e8 30 d3 00 00       	call   f011c777 <test_bsd_nice_0>
		break;
f010f447:	eb 0d                	jmp    f010f456 <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f010f449:	e8 b3 d5 00 00       	call   f011ca01 <test_bsd_nice_1>
		break;
f010f44e:	eb 06                	jmp    f010f456 <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f010f450:	e8 c0 d7 00 00       	call   f011cc15 <test_bsd_nice_2>
		break;
f010f455:	90                   	nop
	}
	return 0;
f010f456:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f45b:	c9                   	leave  
f010f45c:	c3                   	ret    

f010f45d <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f010f45d:	55                   	push   %ebp
f010f45e:	89 e5                	mov    %esp,%ebp
f010f460:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f010f463:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010f467:	74 17                	je     f010f480 <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f010f469:	83 ec 0c             	sub    $0xc,%esp
f010f46c:	68 a0 6b 12 f0       	push   $0xf0126ba0
f010f471:	e8 15 1b ff ff       	call   f0100f8b <cprintf>
f010f476:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f479:	b8 00 00 00 00       	mov    $0x0,%eax
f010f47e:	eb 0a                	jmp    f010f48a <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f010f480:	e8 3f 15 00 00       	call   f01109c4 <test_str2lower_function>
	return 0;
f010f485:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f48a:	c9                   	leave  
f010f48b:	c3                   	ret    

f010f48c <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f010f48c:	55                   	push   %ebp
f010f48d:	89 e5                	mov    %esp,%ebp
f010f48f:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f010f492:	e8 63 11 00 00       	call   f01105fa <TestAutoCompleteCommand>
f010f497:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f010f49a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f49f:	c9                   	leave  
f010f4a0:	c3                   	ret    

f010f4a1 <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f010f4a1:	55                   	push   %ebp
f010f4a2:	89 e5                	mov    %esp,%ebp
f010f4a4:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f4a7:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f4ab:	74 1a                	je     f010f4c7 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f010f4ad:	83 ec 0c             	sub    $0xc,%esp
f010f4b0:	68 d4 6b 12 f0       	push   $0xf0126bd4
f010f4b5:	e8 d1 1a ff ff       	call   f0100f8b <cprintf>
f010f4ba:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f4bd:	b8 00 00 00 00       	mov    $0x0,%eax
f010f4c2:	e9 2f 01 00 00       	jmp    f010f5f6 <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f010f4c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4ca:	83 c0 04             	add    $0x4,%eax
f010f4cd:	8b 00                	mov    (%eax),%eax
f010f4cf:	83 ec 08             	sub    $0x8,%esp
f010f4d2:	68 11 6c 12 f0       	push   $0xf0126c11
f010f4d7:	50                   	push   %eax
f010f4d8:	e8 0e f8 00 00       	call   f011eceb <strcmp>
f010f4dd:	83 c4 10             	add    $0x10,%esp
f010f4e0:	85 c0                	test   %eax,%eax
f010f4e2:	75 0a                	jne    f010f4ee <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f010f4e4:	e8 40 08 00 00       	call   f010fd29 <test_initialize_dynamic_allocator>
f010f4e9:	e9 03 01 00 00       	jmp    f010f5f1 <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f010f4ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4f1:	83 c0 04             	add    $0x4,%eax
f010f4f4:	8b 00                	mov    (%eax),%eax
f010f4f6:	83 ec 08             	sub    $0x8,%esp
f010f4f9:	68 16 6c 12 f0       	push   $0xf0126c16
f010f4fe:	50                   	push   %eax
f010f4ff:	e8 e7 f7 00 00       	call   f011eceb <strcmp>
f010f504:	83 c4 10             	add    $0x10,%esp
f010f507:	85 c0                	test   %eax,%eax
f010f509:	75 0a                	jne    f010f515 <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f010f50b:	e8 4d 08 00 00       	call   f010fd5d <test_alloc_block_FF>
f010f510:	e9 dc 00 00 00       	jmp    f010f5f1 <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f010f515:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f518:	83 c0 04             	add    $0x4,%eax
f010f51b:	8b 00                	mov    (%eax),%eax
f010f51d:	83 ec 08             	sub    $0x8,%esp
f010f520:	68 1e 6c 12 f0       	push   $0xf0126c1e
f010f525:	50                   	push   %eax
f010f526:	e8 c0 f7 00 00       	call   f011eceb <strcmp>
f010f52b:	83 c4 10             	add    $0x10,%esp
f010f52e:	85 c0                	test   %eax,%eax
f010f530:	75 0a                	jne    f010f53c <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f010f532:	e8 43 08 00 00       	call   f010fd7a <test_alloc_block_BF>
f010f537:	e9 b5 00 00 00       	jmp    f010f5f1 <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f010f53c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f53f:	83 c0 04             	add    $0x4,%eax
f010f542:	8b 00                	mov    (%eax),%eax
f010f544:	83 ec 08             	sub    $0x8,%esp
f010f547:	68 26 6c 12 f0       	push   $0xf0126c26
f010f54c:	50                   	push   %eax
f010f54d:	e8 99 f7 00 00       	call   f011eceb <strcmp>
f010f552:	83 c4 10             	add    $0x10,%esp
f010f555:	85 c0                	test   %eax,%eax
f010f557:	75 0a                	jne    f010f563 <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f010f559:	e8 3c 08 00 00       	call   f010fd9a <test_alloc_block_NF>
f010f55e:	e9 8e 00 00 00       	jmp    f010f5f1 <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f010f563:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f566:	83 c0 04             	add    $0x4,%eax
f010f569:	8b 00                	mov    (%eax),%eax
f010f56b:	83 ec 08             	sub    $0x8,%esp
f010f56e:	68 2e 6c 12 f0       	push   $0xf0126c2e
f010f573:	50                   	push   %eax
f010f574:	e8 72 f7 00 00       	call   f011eceb <strcmp>
f010f579:	83 c4 10             	add    $0x10,%esp
f010f57c:	85 c0                	test   %eax,%eax
f010f57e:	75 07                	jne    f010f587 <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f010f580:	e8 1b 08 00 00       	call   f010fda0 <test_free_block_FF>
f010f585:	eb 6a                	jmp    f010f5f1 <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f010f587:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f58a:	83 c0 04             	add    $0x4,%eax
f010f58d:	8b 00                	mov    (%eax),%eax
f010f58f:	83 ec 08             	sub    $0x8,%esp
f010f592:	68 35 6c 12 f0       	push   $0xf0126c35
f010f597:	50                   	push   %eax
f010f598:	e8 4e f7 00 00       	call   f011eceb <strcmp>
f010f59d:	83 c4 10             	add    $0x10,%esp
f010f5a0:	85 c0                	test   %eax,%eax
f010f5a2:	75 07                	jne    f010f5ab <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f010f5a4:	e8 14 08 00 00       	call   f010fdbd <test_free_block_BF>
f010f5a9:	eb 46                	jmp    f010f5f1 <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f010f5ab:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5ae:	83 c0 04             	add    $0x4,%eax
f010f5b1:	8b 00                	mov    (%eax),%eax
f010f5b3:	83 ec 08             	sub    $0x8,%esp
f010f5b6:	68 3c 6c 12 f0       	push   $0xf0126c3c
f010f5bb:	50                   	push   %eax
f010f5bc:	e8 2a f7 00 00       	call   f011eceb <strcmp>
f010f5c1:	83 c4 10             	add    $0x10,%esp
f010f5c4:	85 c0                	test   %eax,%eax
f010f5c6:	75 07                	jne    f010f5cf <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f010f5c8:	e8 0d 08 00 00       	call   f010fdda <test_free_block_NF>
f010f5cd:	eb 22                	jmp    f010f5f1 <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f010f5cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5d2:	83 c0 04             	add    $0x4,%eax
f010f5d5:	8b 00                	mov    (%eax),%eax
f010f5d7:	83 ec 08             	sub    $0x8,%esp
f010f5da:	68 43 6c 12 f0       	push   $0xf0126c43
f010f5df:	50                   	push   %eax
f010f5e0:	e8 06 f7 00 00       	call   f011eceb <strcmp>
f010f5e5:	83 c4 10             	add    $0x10,%esp
f010f5e8:	85 c0                	test   %eax,%eax
f010f5ea:	75 05                	jne    f010f5f1 <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f010f5ec:	e8 06 08 00 00       	call   f010fdf7 <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f010f5f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f5f6:	c9                   	leave  
f010f5f7:	c3                   	ret    

f010f5f8 <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f010f5f8:	55                   	push   %ebp
f010f5f9:	89 e5                	mov    %esp,%ebp
f010f5fb:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f5fe:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f602:	74 1a                	je     f010f61e <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f010f604:	83 ec 0c             	sub    $0xc,%esp
f010f607:	68 50 6c 12 f0       	push   $0xf0126c50
f010f60c:	e8 7a 19 ff ff       	call   f0100f8b <cprintf>
f010f611:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f614:	b8 00 00 00 00       	mov    $0x0,%eax
f010f619:	e9 e1 00 00 00       	jmp    f010f6ff <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f010f61e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f621:	83 c0 04             	add    $0x4,%eax
f010f624:	8b 00                	mov    (%eax),%eax
f010f626:	83 ec 08             	sub    $0x8,%esp
f010f629:	68 89 6c 12 f0       	push   $0xf0126c89
f010f62e:	50                   	push   %eax
f010f62f:	e8 b7 f6 00 00       	call   f011eceb <strcmp>
f010f634:	83 c4 10             	add    $0x10,%esp
f010f637:	85 c0                	test   %eax,%eax
f010f639:	75 0a                	jne    f010f645 <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f010f63b:	e8 97 1c 00 00       	call   f01112d7 <test_cut_paste_pages>
f010f640:	e9 b5 00 00 00       	jmp    f010f6fa <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f010f645:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f648:	83 c0 04             	add    $0x4,%eax
f010f64b:	8b 00                	mov    (%eax),%eax
f010f64d:	83 ec 08             	sub    $0x8,%esp
f010f650:	68 92 6c 12 f0       	push   $0xf0126c92
f010f655:	50                   	push   %eax
f010f656:	e8 90 f6 00 00       	call   f011eceb <strcmp>
f010f65b:	83 c4 10             	add    $0x10,%esp
f010f65e:	85 c0                	test   %eax,%eax
f010f660:	75 0a                	jne    f010f66c <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f010f662:	e8 bb 26 00 00       	call   f0111d22 <test_copy_paste_chunk>
f010f667:	e9 8e 00 00 00       	jmp    f010f6fa <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f010f66c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f66f:	83 c0 04             	add    $0x4,%eax
f010f672:	8b 00                	mov    (%eax),%eax
f010f674:	83 ec 08             	sub    $0x8,%esp
f010f677:	68 9c 6c 12 f0       	push   $0xf0126c9c
f010f67c:	50                   	push   %eax
f010f67d:	e8 69 f6 00 00       	call   f011eceb <strcmp>
f010f682:	83 c4 10             	add    $0x10,%esp
f010f685:	85 c0                	test   %eax,%eax
f010f687:	75 07                	jne    f010f690 <tst_chunks+0x98>
	{
		test_share_chunk();
f010f689:	e8 92 37 00 00       	call   f0112e20 <test_share_chunk>
f010f68e:	eb 6a                	jmp    f010f6fa <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f010f690:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f693:	83 c0 04             	add    $0x4,%eax
f010f696:	8b 00                	mov    (%eax),%eax
f010f698:	83 ec 08             	sub    $0x8,%esp
f010f69b:	68 a2 6c 12 f0       	push   $0xf0126ca2
f010f6a0:	50                   	push   %eax
f010f6a1:	e8 45 f6 00 00       	call   f011eceb <strcmp>
f010f6a6:	83 c4 10             	add    $0x10,%esp
f010f6a9:	85 c0                	test   %eax,%eax
f010f6ab:	75 07                	jne    f010f6b4 <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f010f6ad:	e8 96 41 00 00       	call   f0113848 <test_allocate_chunk>
f010f6b2:	eb 46                	jmp    f010f6fa <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f010f6b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6b7:	83 c0 04             	add    $0x4,%eax
f010f6ba:	8b 00                	mov    (%eax),%eax
f010f6bc:	83 ec 08             	sub    $0x8,%esp
f010f6bf:	68 ab 6c 12 f0       	push   $0xf0126cab
f010f6c4:	50                   	push   %eax
f010f6c5:	e8 21 f6 00 00       	call   f011eceb <strcmp>
f010f6ca:	83 c4 10             	add    $0x10,%esp
f010f6cd:	85 c0                	test   %eax,%eax
f010f6cf:	75 07                	jne    f010f6d8 <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f010f6d1:	e8 79 4a 00 00       	call   f011414f <test_calculate_required_frames>
f010f6d6:	eb 22                	jmp    f010f6fa <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f010f6d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6db:	83 c0 04             	add    $0x4,%eax
f010f6de:	8b 00                	mov    (%eax),%eax
f010f6e0:	83 ec 08             	sub    $0x8,%esp
f010f6e3:	68 ba 6c 12 f0       	push   $0xf0126cba
f010f6e8:	50                   	push   %eax
f010f6e9:	e8 fd f5 00 00       	call   f011eceb <strcmp>
f010f6ee:	83 c4 10             	add    $0x10,%esp
f010f6f1:	85 c0                	test   %eax,%eax
f010f6f3:	75 05                	jne    f010f6fa <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f010f6f5:	e8 c9 52 00 00       	call   f01149c3 <test_calculate_allocated_space>
	}
	return 0;
f010f6fa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f6ff:	c9                   	leave  
f010f700:	c3                   	ret    

f010f701 <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f010f701:	55                   	push   %ebp
f010f702:	89 e5                	mov    %esp,%ebp
f010f704:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f707:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f70b:	74 1a                	je     f010f727 <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f010f70d:	83 ec 0c             	sub    $0xc,%esp
f010f710:	68 cc 6c 12 f0       	push   $0xf0126ccc
f010f715:	e8 71 18 ff ff       	call   f0100f8b <cprintf>
f010f71a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f71d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f722:	e9 ba 00 00 00       	jmp    f010f7e1 <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f010f727:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f72a:	83 c0 04             	add    $0x4,%eax
f010f72d:	8b 00                	mov    (%eax),%eax
f010f72f:	83 ec 08             	sub    $0x8,%esp
f010f732:	68 02 6d 12 f0       	push   $0xf0126d02
f010f737:	50                   	push   %eax
f010f738:	e8 ae f5 00 00       	call   f011eceb <strcmp>
f010f73d:	83 c4 10             	add    $0x10,%esp
f010f740:	85 c0                	test   %eax,%eax
f010f742:	75 0a                	jne    f010f74e <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f010f744:	e8 01 16 00 00       	call   f0110d4a <test_pt_set_page_permissions>
f010f749:	e9 8e 00 00 00       	jmp    f010f7dc <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f010f74e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f751:	83 c0 04             	add    $0x4,%eax
f010f754:	8b 00                	mov    (%eax),%eax
f010f756:	83 ec 08             	sub    $0x8,%esp
f010f759:	68 0a 6d 12 f0       	push   $0xf0126d0a
f010f75e:	50                   	push   %eax
f010f75f:	e8 87 f5 00 00       	call   f011eceb <strcmp>
f010f764:	83 c4 10             	add    $0x10,%esp
f010f767:	85 c0                	test   %eax,%eax
f010f769:	75 07                	jne    f010f772 <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f010f76b:	e8 49 18 00 00       	call   f0110fb9 <test_pt_set_page_permissions_invalid_va>
f010f770:	eb 6a                	jmp    f010f7dc <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f010f772:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f775:	83 c0 04             	add    $0x4,%eax
f010f778:	8b 00                	mov    (%eax),%eax
f010f77a:	83 ec 08             	sub    $0x8,%esp
f010f77d:	68 12 6d 12 f0       	push   $0xf0126d12
f010f782:	50                   	push   %eax
f010f783:	e8 63 f5 00 00       	call   f011eceb <strcmp>
f010f788:	83 c4 10             	add    $0x10,%esp
f010f78b:	85 c0                	test   %eax,%eax
f010f78d:	75 07                	jne    f010f796 <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f010f78f:	e8 6e 18 00 00       	call   f0111002 <test_pt_get_page_permissions>
f010f794:	eb 46                	jmp    f010f7dc <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f010f796:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f799:	83 c0 04             	add    $0x4,%eax
f010f79c:	8b 00                	mov    (%eax),%eax
f010f79e:	83 ec 08             	sub    $0x8,%esp
f010f7a1:	68 1a 6d 12 f0       	push   $0xf0126d1a
f010f7a6:	50                   	push   %eax
f010f7a7:	e8 3f f5 00 00       	call   f011eceb <strcmp>
f010f7ac:	83 c4 10             	add    $0x10,%esp
f010f7af:	85 c0                	test   %eax,%eax
f010f7b1:	75 07                	jne    f010f7ba <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f010f7b3:	e8 8e 19 00 00       	call   f0111146 <test_pt_clear_page_table_entry>
f010f7b8:	eb 22                	jmp    f010f7dc <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f010f7ba:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7bd:	83 c0 04             	add    $0x4,%eax
f010f7c0:	8b 00                	mov    (%eax),%eax
f010f7c2:	83 ec 08             	sub    $0x8,%esp
f010f7c5:	68 21 6d 12 f0       	push   $0xf0126d21
f010f7ca:	50                   	push   %eax
f010f7cb:	e8 1b f5 00 00       	call   f011eceb <strcmp>
f010f7d0:	83 c4 10             	add    $0x10,%esp
f010f7d3:	85 c0                	test   %eax,%eax
f010f7d5:	75 05                	jne    f010f7dc <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f010f7d7:	e8 c3 1a 00 00       	call   f011129f <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f010f7dc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f7e1:	c9                   	leave  
f010f7e2:	c3                   	ret    

f010f7e3 <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f010f7e3:	55                   	push   %ebp
f010f7e4:	89 e5                	mov    %esp,%ebp
f010f7e6:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f010f7e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7ec:	83 c0 08             	add    $0x8,%eax
f010f7ef:	8b 00                	mov    (%eax),%eax
f010f7f1:	83 ec 08             	sub    $0x8,%esp
f010f7f4:	68 28 6d 12 f0       	push   $0xf0126d28
f010f7f9:	50                   	push   %eax
f010f7fa:	e8 ec f4 00 00       	call   f011eceb <strcmp>
f010f7ff:	83 c4 10             	add    $0x10,%esp
f010f802:	85 c0                	test   %eax,%eax
f010f804:	75 20                	jne    f010f826 <tst_kheap+0x43>
f010f806:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f010f80a:	74 1a                	je     f010f826 <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f010f80c:	83 ec 0c             	sub    $0xc,%esp
f010f80f:	68 30 6d 12 f0       	push   $0xf0126d30
f010f814:	e8 72 17 ff ff       	call   f0100f8b <cprintf>
f010f819:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f81c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f821:	e9 42 04 00 00       	jmp    f010fc68 <tst_kheap+0x485>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f010f826:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f829:	83 c0 08             	add    $0x8,%eax
f010f82c:	8b 00                	mov    (%eax),%eax
f010f82e:	83 ec 08             	sub    $0x8,%esp
f010f831:	68 28 6d 12 f0       	push   $0xf0126d28
f010f836:	50                   	push   %eax
f010f837:	e8 af f4 00 00       	call   f011eceb <strcmp>
f010f83c:	83 c4 10             	add    $0x10,%esp
f010f83f:	85 c0                	test   %eax,%eax
f010f841:	74 43                	je     f010f886 <tst_kheap+0xa3>
f010f843:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f010f847:	74 3d                	je     f010f886 <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f010f849:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f84c:	83 c0 08             	add    $0x8,%eax
f010f84f:	8b 00                	mov    (%eax),%eax
f010f851:	83 ec 08             	sub    $0x8,%esp
f010f854:	68 80 6d 12 f0       	push   $0xf0126d80
f010f859:	50                   	push   %eax
f010f85a:	e8 8c f4 00 00       	call   f011eceb <strcmp>
f010f85f:	83 c4 10             	add    $0x10,%esp
f010f862:	85 c0                	test   %eax,%eax
f010f864:	74 20                	je     f010f886 <tst_kheap+0xa3>
f010f866:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f010f86a:	74 1a                	je     f010f886 <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f010f86c:	83 ec 0c             	sub    $0xc,%esp
f010f86f:	68 8c 6d 12 f0       	push   $0xf0126d8c
f010f874:	e8 12 17 ff ff       	call   f0100f8b <cprintf>
f010f879:	83 c4 10             	add    $0x10,%esp
			return 0;
f010f87c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f881:	e9 e2 03 00 00       	jmp    f010fc68 <tst_kheap+0x485>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f010f886:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f889:	83 c0 04             	add    $0x4,%eax
f010f88c:	8b 00                	mov    (%eax),%eax
f010f88e:	83 ec 08             	sub    $0x8,%esp
f010f891:	68 d1 6d 12 f0       	push   $0xf0126dd1
f010f896:	50                   	push   %eax
f010f897:	e8 4f f4 00 00       	call   f011eceb <strcmp>
f010f89c:	83 c4 10             	add    $0x10,%esp
f010f89f:	85 c0                	test   %eax,%eax
f010f8a1:	74 1d                	je     f010f8c0 <tst_kheap+0xdd>
f010f8a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8a6:	83 c0 04             	add    $0x4,%eax
f010f8a9:	8b 00                	mov    (%eax),%eax
f010f8ab:	83 ec 08             	sub    $0x8,%esp
f010f8ae:	68 d4 6d 12 f0       	push   $0xf0126dd4
f010f8b3:	50                   	push   %eax
f010f8b4:	e8 32 f4 00 00       	call   f011eceb <strcmp>
f010f8b9:	83 c4 10             	add    $0x10,%esp
f010f8bc:	85 c0                	test   %eax,%eax
f010f8be:	75 1a                	jne    f010f8da <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f010f8c0:	e8 6d f8 ff ff       	call   f010f132 <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010f8c5:	83 ec 0c             	sub    $0xc,%esp
f010f8c8:	68 d8 6d 12 f0       	push   $0xf0126dd8
f010f8cd:	e8 b9 16 ff ff       	call   f0100f8b <cprintf>
f010f8d2:	83 c4 10             	add    $0x10,%esp
f010f8d5:	e9 a0 00 00 00       	jmp    f010f97a <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f010f8da:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8dd:	83 c0 04             	add    $0x4,%eax
f010f8e0:	8b 00                	mov    (%eax),%eax
f010f8e2:	83 ec 08             	sub    $0x8,%esp
f010f8e5:	68 05 6e 12 f0       	push   $0xf0126e05
f010f8ea:	50                   	push   %eax
f010f8eb:	e8 fb f3 00 00       	call   f011eceb <strcmp>
f010f8f0:	83 c4 10             	add    $0x10,%esp
f010f8f3:	85 c0                	test   %eax,%eax
f010f8f5:	74 1d                	je     f010f914 <tst_kheap+0x131>
f010f8f7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f8fa:	83 c0 04             	add    $0x4,%eax
f010f8fd:	8b 00                	mov    (%eax),%eax
f010f8ff:	83 ec 08             	sub    $0x8,%esp
f010f902:	68 08 6e 12 f0       	push   $0xf0126e08
f010f907:	50                   	push   %eax
f010f908:	e8 de f3 00 00       	call   f011eceb <strcmp>
f010f90d:	83 c4 10             	add    $0x10,%esp
f010f910:	85 c0                	test   %eax,%eax
f010f912:	75 17                	jne    f010f92b <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f010f914:	e8 29 f8 ff ff       	call   f010f142 <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f010f919:	83 ec 0c             	sub    $0xc,%esp
f010f91c:	68 0c 6e 12 f0       	push   $0xf0126e0c
f010f921:	e8 65 16 ff ff       	call   f0100f8b <cprintf>
f010f926:	83 c4 10             	add    $0x10,%esp
f010f929:	eb 4f                	jmp    f010f97a <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f010f92b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f92e:	83 c0 04             	add    $0x4,%eax
f010f931:	8b 00                	mov    (%eax),%eax
f010f933:	83 ec 08             	sub    $0x8,%esp
f010f936:	68 38 6e 12 f0       	push   $0xf0126e38
f010f93b:	50                   	push   %eax
f010f93c:	e8 aa f3 00 00       	call   f011eceb <strcmp>
f010f941:	83 c4 10             	add    $0x10,%esp
f010f944:	85 c0                	test   %eax,%eax
f010f946:	74 1d                	je     f010f965 <tst_kheap+0x182>
f010f948:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f94b:	83 c0 04             	add    $0x4,%eax
f010f94e:	8b 00                	mov    (%eax),%eax
f010f950:	83 ec 08             	sub    $0x8,%esp
f010f953:	68 3b 6e 12 f0       	push   $0xf0126e3b
f010f958:	50                   	push   %eax
f010f959:	e8 8d f3 00 00       	call   f011eceb <strcmp>
f010f95e:	83 c4 10             	add    $0x10,%esp
f010f961:	85 c0                	test   %eax,%eax
f010f963:	75 15                	jne    f010f97a <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f010f965:	e8 e8 f7 ff ff       	call   f010f152 <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f010f96a:	83 ec 0c             	sub    $0xc,%esp
f010f96d:	68 40 6e 12 f0       	push   $0xf0126e40
f010f972:	e8 14 16 ff ff       	call   f0100f8b <cprintf>
f010f977:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f010f97a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f97d:	83 c0 08             	add    $0x8,%eax
f010f980:	8b 00                	mov    (%eax),%eax
f010f982:	83 ec 08             	sub    $0x8,%esp
f010f985:	68 28 6d 12 f0       	push   $0xf0126d28
f010f98a:	50                   	push   %eax
f010f98b:	e8 5b f3 00 00       	call   f011eceb <strcmp>
f010f990:	83 c4 10             	add    $0x10,%esp
f010f993:	85 c0                	test   %eax,%eax
f010f995:	0f 85 13 01 00 00    	jne    f010faae <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f010f99b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f99e:	83 c0 0c             	add    $0xc,%eax
f010f9a1:	8b 00                	mov    (%eax),%eax
f010f9a3:	83 ec 04             	sub    $0x4,%esp
f010f9a6:	6a 0a                	push   $0xa
f010f9a8:	6a 00                	push   $0x0
f010f9aa:	50                   	push   %eax
f010f9ab:	e8 8f f5 00 00       	call   f011ef3f <strtol>
f010f9b0:	83 c4 10             	add    $0x10,%esp
f010f9b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f010f9b6:	e8 a7 f7 ff ff       	call   f010f162 <isKHeapPlacementStrategyFIRSTFIT>
f010f9bb:	84 c0                	test   %al,%al
f010f9bd:	74 54                	je     f010fa13 <tst_kheap+0x230>
		{
			if (testNum == 0)
f010f9bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f9c3:	75 1a                	jne    f010f9df <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f010f9c5:	83 ec 0c             	sub    $0xc,%esp
f010f9c8:	68 6c 6e 12 f0       	push   $0xf0126e6c
f010f9cd:	e8 b9 15 ff ff       	call   f0100f8b <cprintf>
f010f9d2:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f9d5:	b8 00 00 00 00       	mov    $0x0,%eax
f010f9da:	e9 89 02 00 00       	jmp    f010fc68 <tst_kheap+0x485>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f010f9df:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f9e3:	75 0a                	jne    f010f9ef <tst_kheap+0x20c>
				test_kmalloc();
f010f9e5:	e8 ec 61 00 00       	call   f0115bd6 <test_kmalloc>
f010f9ea:	e9 b5 00 00 00       	jmp    f010faa4 <tst_kheap+0x2c1>
			else if (testNum == 2)
f010f9ef:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f9f3:	75 0a                	jne    f010f9ff <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f010f9f5:	e8 7f 6d 00 00       	call   f0116779 <test_kmalloc_firstfit1>
f010f9fa:	e9 a5 00 00 00       	jmp    f010faa4 <tst_kheap+0x2c1>
			else if (testNum == 3)
f010f9ff:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f010fa03:	0f 85 9b 00 00 00    	jne    f010faa4 <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f010fa09:	e8 4f 78 00 00       	call   f011725d <test_kmalloc_firstfit2>
f010fa0e:	e9 91 00 00 00       	jmp    f010faa4 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f010fa13:	e8 5f f7 ff ff       	call   f010f177 <isKHeapPlacementStrategyBESTFIT>
f010fa18:	84 c0                	test   %al,%al
f010fa1a:	74 47                	je     f010fa63 <tst_kheap+0x280>
		{
			if (testNum == 0)
f010fa1c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fa20:	75 1a                	jne    f010fa3c <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f010fa22:	83 ec 0c             	sub    $0xc,%esp
f010fa25:	68 bc 6e 12 f0       	push   $0xf0126ebc
f010fa2a:	e8 5c 15 ff ff       	call   f0100f8b <cprintf>
f010fa2f:	83 c4 10             	add    $0x10,%esp
				return 0;
f010fa32:	b8 00 00 00 00       	mov    $0x0,%eax
f010fa37:	e9 2c 02 00 00       	jmp    f010fc68 <tst_kheap+0x485>
			}
			if (testNum == 1)
f010fa3c:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010fa40:	75 07                	jne    f010fa49 <tst_kheap+0x266>
				test_kmalloc();
f010fa42:	e8 8f 61 00 00       	call   f0115bd6 <test_kmalloc>
f010fa47:	eb 5b                	jmp    f010faa4 <tst_kheap+0x2c1>
			else if (testNum == 2)
f010fa49:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010fa4d:	75 07                	jne    f010fa56 <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f010fa4f:	e8 a2 c8 00 00       	call   f011c2f6 <test_kmalloc_bestfit1>
f010fa54:	eb 4e                	jmp    f010faa4 <tst_kheap+0x2c1>
			else if (testNum == 3)
f010fa56:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f010fa5a:	75 48                	jne    f010faa4 <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f010fa5c:	e8 b2 c8 00 00       	call   f011c313 <test_kmalloc_bestfit2>
f010fa61:	eb 41                	jmp    f010faa4 <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f010fa63:	e8 24 f7 ff ff       	call   f010f18c <isKHeapPlacementStrategyNEXTFIT>
f010fa68:	84 c0                	test   %al,%al
f010fa6a:	74 38                	je     f010faa4 <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f010fa6c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fa70:	75 1a                	jne    f010fa8c <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f010fa72:	83 ec 0c             	sub    $0xc,%esp
f010fa75:	68 0c 6f 12 f0       	push   $0xf0126f0c
f010fa7a:	e8 0c 15 ff ff       	call   f0100f8b <cprintf>
f010fa7f:	83 c4 10             	add    $0x10,%esp
				return 0;
f010fa82:	b8 00 00 00 00       	mov    $0x0,%eax
f010fa87:	e9 dc 01 00 00       	jmp    f010fc68 <tst_kheap+0x485>
			}
			//Test cont. allocation
			if (testNum == 1)
f010fa8c:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010fa90:	75 07                	jne    f010fa99 <tst_kheap+0x2b6>
				test_kmalloc();
f010fa92:	e8 3f 61 00 00       	call   f0115bd6 <test_kmalloc>
f010fa97:	eb 0b                	jmp    f010faa4 <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f010fa99:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010fa9d:	75 05                	jne    f010faa4 <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f010fa9f:	e8 35 c8 00 00       	call   f011c2d9 <test_kmalloc_nextfit>
		}
		return 0;
f010faa4:	b8 00 00 00 00       	mov    $0x0,%eax
f010faa9:	e9 ba 01 00 00       	jmp    f010fc68 <tst_kheap+0x485>
	}
	// Test Fast Implementation of kmalloc/kfree FF
	else if(strcmp(arguments[2], "fast") == 0)
f010faae:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fab1:	83 c0 08             	add    $0x8,%eax
f010fab4:	8b 00                	mov    (%eax),%eax
f010fab6:	83 ec 08             	sub    $0x8,%esp
f010fab9:	68 5a 6f 12 f0       	push   $0xf0126f5a
f010fabe:	50                   	push   %eax
f010fabf:	e8 27 f2 00 00       	call   f011eceb <strcmp>
f010fac4:	83 c4 10             	add    $0x10,%esp
f010fac7:	85 c0                	test   %eax,%eax
f010fac9:	75 2f                	jne    f010fafa <tst_kheap+0x317>
	{
		if(isKHeapPlacementStrategyFIRSTFIT())
f010facb:	e8 92 f6 ff ff       	call   f010f162 <isKHeapPlacementStrategyFIRSTFIT>
f010fad0:	84 c0                	test   %al,%al
f010fad2:	74 0f                	je     f010fae3 <tst_kheap+0x300>
		{
			test_fastfirstfit();
f010fad4:	e8 8b 82 00 00       	call   f0117d64 <test_fastfirstfit>
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
		}
		return 0;
f010fad9:	b8 00 00 00 00       	mov    $0x0,%eax
f010fade:	e9 85 01 00 00       	jmp    f010fc68 <tst_kheap+0x485>
		{
			test_fastfirstfit();
		}
		else
		{
			panic("Fast implementation test is not yet handled for other strategies");
f010fae3:	83 ec 04             	sub    $0x4,%esp
f010fae6:	68 60 6f 12 f0       	push   $0xf0126f60
f010faeb:	68 ac 01 00 00       	push   $0x1ac
f010faf0:	68 47 6b 12 f0       	push   $0xf0126b47
f010faf5:	e8 3f 08 ff ff       	call   f0100339 <_panic>
		}
		return 0;
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f010fafa:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fafd:	83 c0 08             	add    $0x8,%eax
f010fb00:	8b 00                	mov    (%eax),%eax
f010fb02:	83 ec 08             	sub    $0x8,%esp
f010fb05:	68 a1 6f 12 f0       	push   $0xf0126fa1
f010fb0a:	50                   	push   %eax
f010fb0b:	e8 db f1 00 00       	call   f011eceb <strcmp>
f010fb10:	83 c4 10             	add    $0x10,%esp
f010fb13:	85 c0                	test   %eax,%eax
f010fb15:	75 28                	jne    f010fb3f <tst_kheap+0x35c>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f010fb17:	e8 5b f6 ff ff       	call   f010f177 <isKHeapPlacementStrategyBESTFIT>
f010fb1c:	84 c0                	test   %al,%al
f010fb1e:	75 09                	jne    f010fb29 <tst_kheap+0x346>
f010fb20:	e8 3d f6 ff ff       	call   f010f162 <isKHeapPlacementStrategyFIRSTFIT>
f010fb25:	84 c0                	test   %al,%al
f010fb27:	74 07                	je     f010fb30 <tst_kheap+0x34d>
		{
			test_kfree_bestfirstfit();
f010fb29:	e8 05 8b 00 00       	call   f0118633 <test_kfree_bestfirstfit>
f010fb2e:	eb 05                	jmp    f010fb35 <tst_kheap+0x352>
		}
		else //NEXT & CONT
		{
			test_kfree();
f010fb30:	e8 18 c8 00 00       	call   f011c34d <test_kfree>
		}
		return 0;
f010fb35:	b8 00 00 00 00       	mov    $0x0,%eax
f010fb3a:	e9 29 01 00 00       	jmp    f010fc68 <tst_kheap+0x485>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f010fb3f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb42:	83 c0 08             	add    $0x8,%eax
f010fb45:	8b 00                	mov    (%eax),%eax
f010fb47:	83 ec 08             	sub    $0x8,%esp
f010fb4a:	68 a7 6f 12 f0       	push   $0xf0126fa7
f010fb4f:	50                   	push   %eax
f010fb50:	e8 96 f1 00 00       	call   f011eceb <strcmp>
f010fb55:	83 c4 10             	add    $0x10,%esp
f010fb58:	85 c0                	test   %eax,%eax
f010fb5a:	75 0f                	jne    f010fb6b <tst_kheap+0x388>
	{
		test_kheap_phys_addr();
f010fb5c:	e8 7e a1 00 00       	call   f0119cdf <test_kheap_phys_addr>
		return 0;
f010fb61:	b8 00 00 00 00       	mov    $0x0,%eax
f010fb66:	e9 fd 00 00 00       	jmp    f010fc68 <tst_kheap+0x485>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f010fb6b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb6e:	83 c0 08             	add    $0x8,%eax
f010fb71:	8b 00                	mov    (%eax),%eax
f010fb73:	83 ec 08             	sub    $0x8,%esp
f010fb76:	68 b1 6f 12 f0       	push   $0xf0126fb1
f010fb7b:	50                   	push   %eax
f010fb7c:	e8 6a f1 00 00       	call   f011eceb <strcmp>
f010fb81:	83 c4 10             	add    $0x10,%esp
f010fb84:	85 c0                	test   %eax,%eax
f010fb86:	75 0f                	jne    f010fb97 <tst_kheap+0x3b4>
	{
		test_kheap_virt_addr();
f010fb88:	e8 41 af 00 00       	call   f011aace <test_kheap_virt_addr>
		return 0;
f010fb8d:	b8 00 00 00 00       	mov    $0x0,%eax
f010fb92:	e9 d1 00 00 00       	jmp    f010fc68 <tst_kheap+0x485>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f010fb97:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fb9a:	83 c0 08             	add    $0x8,%eax
f010fb9d:	8b 00                	mov    (%eax),%eax
f010fb9f:	83 ec 08             	sub    $0x8,%esp
f010fba2:	68 80 6d 12 f0       	push   $0xf0126d80
f010fba7:	50                   	push   %eax
f010fba8:	e8 3e f1 00 00       	call   f011eceb <strcmp>
f010fbad:	83 c4 10             	add    $0x10,%esp
f010fbb0:	85 c0                	test   %eax,%eax
f010fbb2:	0f 85 89 00 00 00    	jne    f010fc41 <tst_kheap+0x45e>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f010fbb8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fbbb:	83 c0 0c             	add    $0xc,%eax
f010fbbe:	8b 00                	mov    (%eax),%eax
f010fbc0:	83 ec 04             	sub    $0x4,%esp
f010fbc3:	6a 0a                	push   $0xa
f010fbc5:	6a 00                	push   $0x0
f010fbc7:	50                   	push   %eax
f010fbc8:	e8 72 f3 00 00       	call   f011ef3f <strtol>
f010fbcd:	83 c4 10             	add    $0x10,%esp
f010fbd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f010fbd3:	e8 8a f5 ff ff       	call   f010f162 <isKHeapPlacementStrategyFIRSTFIT>
f010fbd8:	84 c0                	test   %al,%al
f010fbda:	74 42                	je     f010fc1e <tst_kheap+0x43b>
		{
			if (testNum == 0)
f010fbdc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fbe0:	75 17                	jne    f010fbf9 <tst_kheap+0x416>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f010fbe2:	83 ec 0c             	sub    $0xc,%esp
f010fbe5:	68 6c 6e 12 f0       	push   $0xf0126e6c
f010fbea:	e8 9c 13 ff ff       	call   f0100f8b <cprintf>
f010fbef:	83 c4 10             	add    $0x10,%esp
				return 0;
f010fbf2:	b8 00 00 00 00       	mov    $0x0,%eax
f010fbf7:	eb 6f                	jmp    f010fc68 <tst_kheap+0x485>
			}
			if (testNum==1)
f010fbf9:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f010fbfd:	75 07                	jne    f010fc06 <tst_kheap+0x423>
				test_krealloc_FF1();
f010fbff:	e8 c7 c9 00 00       	call   f011c5cb <test_krealloc_FF1>
f010fc04:	eb 18                	jmp    f010fc1e <tst_kheap+0x43b>
			else if (testNum==2)
f010fc06:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f010fc0a:	75 07                	jne    f010fc13 <tst_kheap+0x430>
				test_krealloc_FF2();
f010fc0c:	e8 d7 c9 00 00       	call   f011c5e8 <test_krealloc_FF2>
f010fc11:	eb 0b                	jmp    f010fc1e <tst_kheap+0x43b>
			else if (testNum==3)
f010fc13:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f010fc17:	75 05                	jne    f010fc1e <tst_kheap+0x43b>
				test_krealloc_FF3();
f010fc19:	e8 e7 c9 00 00       	call   f011c605 <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f010fc1e:	e8 69 f5 ff ff       	call   f010f18c <isKHeapPlacementStrategyNEXTFIT>
f010fc23:	84 c0                	test   %al,%al
f010fc25:	74 05                	je     f010fc2c <tst_kheap+0x449>
		{
			test_krealloc();
f010fc27:	e8 65 c9 00 00       	call   f011c591 <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f010fc2c:	e8 46 f5 ff ff       	call   f010f177 <isKHeapPlacementStrategyBESTFIT>
f010fc31:	84 c0                	test   %al,%al
f010fc33:	74 05                	je     f010fc3a <tst_kheap+0x457>
		{
			test_krealloc_BF();
f010fc35:	e8 74 c9 00 00       	call   f011c5ae <test_krealloc_BF>
		}
		return 0;
f010fc3a:	b8 00 00 00 00       	mov    $0x0,%eax
f010fc3f:	eb 27                	jmp    f010fc68 <tst_kheap+0x485>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f010fc41:	8b 45 0c             	mov    0xc(%ebp),%eax
f010fc44:	83 c0 08             	add    $0x8,%eax
f010fc47:	8b 00                	mov    (%eax),%eax
f010fc49:	83 ec 08             	sub    $0x8,%esp
f010fc4c:	68 bb 6f 12 f0       	push   $0xf0126fbb
f010fc51:	50                   	push   %eax
f010fc52:	e8 94 f0 00 00       	call   f011eceb <strcmp>
f010fc57:	83 c4 10             	add    $0x10,%esp
f010fc5a:	85 c0                	test   %eax,%eax
f010fc5c:	75 05                	jne    f010fc63 <tst_kheap+0x480>
	{
		test_ksbrk();
f010fc5e:	e8 90 bb 00 00       	call   f011b7f3 <test_ksbrk>
	}
	return 0;
f010fc63:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010fc68:	c9                   	leave  
f010fc69:	c3                   	ret    

f010fc6a <check_block>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int check_block(void* va, void* expectedVA, uint32 expectedSize, uint8 expectedFlag)
{
f010fc6a:	55                   	push   %ebp
f010fc6b:	89 e5                	mov    %esp,%ebp
f010fc6d:	83 ec 28             	sub    $0x28,%esp
f010fc70:	8b 45 14             	mov    0x14(%ebp),%eax
f010fc73:	88 45 e4             	mov    %al,-0x1c(%ebp)

	//Check returned va
	if(va != expectedVA)
f010fc76:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc79:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010fc7c:	74 1d                	je     f010fc9b <check_block+0x31>
	{
		cprintf("wrong block address. Expected %x, Actual %x\n", expectedVA, va);
f010fc7e:	83 ec 04             	sub    $0x4,%esp
f010fc81:	ff 75 08             	pushl  0x8(%ebp)
f010fc84:	ff 75 0c             	pushl  0xc(%ebp)
f010fc87:	68 c0 6f 12 f0       	push   $0xf0126fc0
f010fc8c:	e8 fa 12 ff ff       	call   f0100f8b <cprintf>
f010fc91:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fc94:	b8 00 00 00 00       	mov    $0x0,%eax
f010fc99:	eb 55                	jmp    f010fcf0 <check_block+0x86>
	}
	//Check header & footer
	uint32 header = *((uint32*)va-1);
f010fc9b:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc9e:	8b 40 fc             	mov    -0x4(%eax),%eax
f010fca1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 footer = *((uint32*)(va + expectedSize - 8));
f010fca4:	8b 45 10             	mov    0x10(%ebp),%eax
f010fca7:	8d 50 f8             	lea    -0x8(%eax),%edx
f010fcaa:	8b 45 08             	mov    0x8(%ebp),%eax
f010fcad:	01 d0                	add    %edx,%eax
f010fcaf:	8b 00                	mov    (%eax),%eax
f010fcb1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 expectedData = expectedSize | expectedFlag ;
f010fcb4:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f010fcb8:	0b 45 10             	or     0x10(%ebp),%eax
f010fcbb:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(header != expectedData || footer != expectedData)
f010fcbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010fcc1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fcc4:	75 08                	jne    f010fcce <check_block+0x64>
f010fcc6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fcc9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fccc:	74 1d                	je     f010fceb <check_block+0x81>
	{
		cprintf("wrong header/footer data. Expected %d, Actual H:%d F:%d\n", expectedData, header, footer);
f010fcce:	ff 75 f0             	pushl  -0x10(%ebp)
f010fcd1:	ff 75 f4             	pushl  -0xc(%ebp)
f010fcd4:	ff 75 ec             	pushl  -0x14(%ebp)
f010fcd7:	68 f0 6f 12 f0       	push   $0xf0126ff0
f010fcdc:	e8 aa 12 ff ff       	call   f0100f8b <cprintf>
f010fce1:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fce4:	b8 00 00 00 00       	mov    $0x0,%eax
f010fce9:	eb 05                	jmp    f010fcf0 <check_block+0x86>
	}
	return 1;
f010fceb:	b8 01 00 00 00       	mov    $0x1,%eax
}
f010fcf0:	c9                   	leave  
f010fcf1:	c3                   	ret    

f010fcf2 <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f010fcf2:	55                   	push   %ebp
f010fcf3:	89 e5                	mov    %esp,%ebp
f010fcf5:	83 ec 08             	sub    $0x8,%esp
	if (LIST_SIZE(&freeBlocksList) != expectedListSize)
f010fcf8:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f010fcfd:	3b 45 08             	cmp    0x8(%ebp),%eax
f010fd00:	74 20                	je     f010fd22 <check_list_size+0x30>
	{
		cprintf("freeBlocksList: wrong size! expected %d, actual %d\n", expectedListSize, LIST_SIZE(&freeBlocksList));
f010fd02:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f010fd07:	83 ec 04             	sub    $0x4,%esp
f010fd0a:	50                   	push   %eax
f010fd0b:	ff 75 08             	pushl  0x8(%ebp)
f010fd0e:	68 2c 70 12 f0       	push   $0xf012702c
f010fd13:	e8 73 12 ff ff       	call   f0100f8b <cprintf>
f010fd18:	83 c4 10             	add    $0x10,%esp
		return 0;
f010fd1b:	b8 00 00 00 00       	mov    $0x0,%eax
f010fd20:	eb 05                	jmp    f010fd27 <check_list_size+0x35>
	}
	return 1;
f010fd22:	b8 01 00 00 00       	mov    $0x1,%eax
}
f010fd27:	c9                   	leave  
f010fd28:	c3                   	ret    

f010fd29 <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f010fd29:	55                   	push   %ebp
f010fd2a:	89 e5                	mov    %esp,%ebp
f010fd2c:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
f010fd2f:	83 ec 04             	sub    $0x4,%esp
f010fd32:	68 60 70 12 f0       	push   $0xf0127060
f010fd37:	6a 40                	push   $0x40
f010fd39:	68 c0 70 12 f0       	push   $0xf01270c0
f010fd3e:	e8 f6 05 ff ff       	call   f0100339 <_panic>

f010fd43 <test_initial_alloc>:
	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
}


int test_initial_alloc(int ALLOC_STRATEGY)
{
f010fd43:	55                   	push   %ebp
f010fd44:	89 e5                	mov    %esp,%ebp
f010fd46:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fd49:	83 ec 04             	sub    $0x4,%esp
f010fd4c:	68 e4 70 12 f0       	push   $0xf01270e4
f010fd51:	6a 62                	push   $0x62
f010fd53:	68 c0 70 12 f0       	push   $0xf01270c0
f010fd58:	e8 dc 05 ff ff       	call   f0100339 <_panic>

f010fd5d <test_alloc_block_FF>:
	}
	return eval;
}

void test_alloc_block_FF()
{
f010fd5d:	55                   	push   %ebp
f010fd5e:	89 e5                	mov    %esp,%ebp
f010fd60:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fd63:	83 ec 04             	sub    $0x4,%esp
f010fd66:	68 34 71 12 f0       	push   $0xf0127134
f010fd6b:	68 e8 00 00 00       	push   $0xe8
f010fd70:	68 c0 70 12 f0       	push   $0xf01270c0
f010fd75:	e8 bf 05 ff ff       	call   f0100339 <_panic>

f010fd7a <test_alloc_block_BF>:
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_BF()
{
f010fd7a:	55                   	push   %ebp
f010fd7b:	89 e5                	mov    %esp,%ebp
f010fd7d:	81 ec 88 00 00 00    	sub    $0x88,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fd83:	83 ec 04             	sub    $0x4,%esp
f010fd86:	68 88 71 12 f0       	push   $0xf0127188
f010fd8b:	68 89 01 00 00       	push   $0x189
f010fd90:	68 c0 70 12 f0       	push   $0xf01270c0
f010fd95:	e8 9f 05 ff ff       	call   f0100339 <_panic>

f010fd9a <test_alloc_block_NF>:
	}
	cprintf("test alloc_block_BF completed. Evaluation = %d%\n", eval);
}

void test_alloc_block_NF()
{
f010fd9a:	55                   	push   %ebp
f010fd9b:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f010fd9d:	90                   	nop
f010fd9e:	5d                   	pop    %ebp
f010fd9f:	c3                   	ret    

f010fda0 <test_free_block_FF>:

void test_free_block_FF()
{
f010fda0:	55                   	push   %ebp
f010fda1:	89 e5                	mov    %esp,%ebp
f010fda3:	83 ec 08             	sub    $0x8,%esp

#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fda6:	83 ec 04             	sub    $0x4,%esp
f010fda9:	68 dc 71 12 f0       	push   $0xf01271dc
f010fdae:	68 4f 02 00 00       	push   $0x24f
f010fdb3:	68 c0 70 12 f0       	push   $0xf01270c0
f010fdb8:	e8 7c 05 ff ff       	call   f0100339 <_panic>

f010fdbd <test_free_block_BF>:
	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);

}

void test_free_block_BF()
{
f010fdbd:	55                   	push   %ebp
f010fdbe:	89 e5                	mov    %esp,%ebp
f010fdc0:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fdc3:	83 ec 04             	sub    $0x4,%esp
f010fdc6:	68 dc 71 12 f0       	push   $0xf01271dc
f010fdcb:	68 9b 03 00 00       	push   $0x39b
f010fdd0:	68 c0 70 12 f0       	push   $0xf01270c0
f010fdd5:	e8 5f 05 ff ff       	call   f0100339 <_panic>

f010fdda <test_free_block_NF>:
	cprintf("Congratulations!! test free_block with BEST FIT completed successfully.\n");

}

void test_free_block_NF()
{
f010fdda:	55                   	push   %ebp
f010fddb:	89 e5                	mov    %esp,%ebp
f010fddd:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f010fde0:	83 ec 04             	sub    $0x4,%esp
f010fde3:	68 29 72 12 f0       	push   $0xf0127229
f010fde8:	68 bb 04 00 00       	push   $0x4bb
f010fded:	68 c0 70 12 f0       	push   $0xf01270c0
f010fdf2:	e8 42 05 ff ff       	call   f0100339 <_panic>

f010fdf7 <test_realloc_block_FF>:
}

void test_realloc_block_FF_COMPLETE();
void test_realloc_block_FF()
{
f010fdf7:	55                   	push   %ebp
f010fdf8:	89 e5                	mov    %esp,%ebp
f010fdfa:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fdfd:	83 ec 04             	sub    $0x4,%esp
f010fe00:	68 dc 71 12 f0       	push   $0xf01271dc
f010fe05:	68 c2 04 00 00       	push   $0x4c2
f010fe0a:	68 c0 70 12 f0       	push   $0xf01270c0
f010fe0f:	e8 25 05 ff ff       	call   f0100339 <_panic>

f010fe14 <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f010fe14:	55                   	push   %ebp
f010fe15:	89 e5                	mov    %esp,%ebp
f010fe17:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f010fe1a:	83 ec 04             	sub    $0x4,%esp
f010fe1d:	68 dc 71 12 f0       	push   $0xf01271dc
f010fe22:	68 1a 06 00 00       	push   $0x61a
f010fe27:	68 c0 70 12 f0       	push   $0xf01270c0
f010fe2c:	e8 08 05 ff ff       	call   f0100339 <_panic>

f010fe31 <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f010fe31:	55                   	push   %ebp
f010fe32:	89 e5                	mov    %esp,%ebp
f010fe34:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f010fe37:	e8 1d ae ff ff       	call   f010ac59 <get_cpu_proc>
f010fe3c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f010fe3f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fe43:	75 16                	jne    f010fe5b <sys_check_LRU_lists+0x2a>
f010fe45:	68 3c 72 12 f0       	push   $0xf012723c
f010fe4a:	68 4c 72 12 f0       	push   $0xf012724c
f010fe4f:	6a 10                	push   $0x10
f010fe51:	68 61 72 12 f0       	push   $0xf0127261
f010fe56:	e8 de 04 ff ff       	call   f0100339 <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f010fe5b:	83 ec 0c             	sub    $0xc,%esp
f010fe5e:	68 80 72 12 f0       	push   $0xf0127280
f010fe63:	e8 23 11 ff ff       	call   f0100f8b <cprintf>
f010fe68:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f010fe6b:	83 ec 0c             	sub    $0xc,%esp
f010fe6e:	ff 75 e0             	pushl  -0x20(%ebp)
f010fe71:	e8 35 9a ff ff       	call   f01098ab <env_page_ws_print>
f010fe76:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f010fe79:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fe7c:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f010fe7f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f010fe86:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f010fe8d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010fe91:	0f 84 a5 00 00 00    	je     f010ff3c <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f010fe97:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f010fe9e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fea1:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f010fea7:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010feaa:	eb 4a                	jmp    f010fef6 <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f010feac:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010feaf:	8b 00                	mov    (%eax),%eax
f010feb1:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010feb4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010feb7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010febc:	89 c2                	mov    %eax,%edx
f010febe:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fec1:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010fec8:	8b 45 08             	mov    0x8(%ebp),%eax
f010fecb:	01 c8                	add    %ecx,%eax
f010fecd:	8b 00                	mov    (%eax),%eax
f010fecf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010fed2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fed5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010feda:	39 c2                	cmp    %eax,%edx
f010fedc:	74 09                	je     f010fee7 <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f010fede:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f010fee5:	eb 3e                	jmp    f010ff25 <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f010fee7:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f010feea:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010feed:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010fef3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fef6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010fefa:	74 08                	je     f010ff04 <sys_check_LRU_lists+0xd3>
f010fefc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010feff:	8b 40 10             	mov    0x10(%eax),%eax
f010ff02:	eb 05                	jmp    f010ff09 <sys_check_LRU_lists+0xd8>
f010ff04:	b8 00 00 00 00       	mov    $0x0,%eax
f010ff09:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010ff0c:	89 82 5c 05 00 00    	mov    %eax,0x55c(%edx)
f010ff12:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ff15:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f010ff1b:	85 c0                	test   %eax,%eax
f010ff1d:	75 8d                	jne    f010feac <sys_check_LRU_lists+0x7b>
f010ff1f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ff23:	75 87                	jne    f010feac <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f010ff25:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ff28:	8b 90 60 05 00 00    	mov    0x560(%eax),%edx
f010ff2e:	8b 45 10             	mov    0x10(%ebp),%eax
f010ff31:	39 c2                	cmp    %eax,%edx
f010ff33:	74 07                	je     f010ff3c <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f010ff35:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f010ff3c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010ff40:	0f 84 a5 00 00 00    	je     f010ffeb <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f010ff46:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f010ff4d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ff50:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010ff56:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ff59:	eb 4a                	jmp    f010ffa5 <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f010ff5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ff5e:	8b 00                	mov    (%eax),%eax
f010ff60:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010ff63:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010ff66:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ff6b:	89 c2                	mov    %eax,%edx
f010ff6d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ff70:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010ff77:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ff7a:	01 c8                	add    %ecx,%eax
f010ff7c:	8b 00                	mov    (%eax),%eax
f010ff7e:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010ff81:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff84:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ff89:	39 c2                	cmp    %eax,%edx
f010ff8b:	74 09                	je     f010ff96 <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f010ff8d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f010ff94:	eb 3e                	jmp    f010ffd4 <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f010ff96:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f010ff99:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ff9c:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010ffa2:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ffa5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ffa9:	74 08                	je     f010ffb3 <sys_check_LRU_lists+0x182>
f010ffab:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ffae:	8b 40 10             	mov    0x10(%eax),%eax
f010ffb1:	eb 05                	jmp    f010ffb8 <sys_check_LRU_lists+0x187>
f010ffb3:	b8 00 00 00 00       	mov    $0x0,%eax
f010ffb8:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010ffbb:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f010ffc1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ffc4:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010ffca:	85 c0                	test   %eax,%eax
f010ffcc:	75 8d                	jne    f010ff5b <sys_check_LRU_lists+0x12a>
f010ffce:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ffd2:	75 87                	jne    f010ff5b <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f010ffd4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ffd7:	8b 90 70 05 00 00    	mov    0x570(%eax),%edx
f010ffdd:	8b 45 14             	mov    0x14(%ebp),%eax
f010ffe0:	39 c2                	cmp    %eax,%edx
f010ffe2:	74 07                	je     f010ffeb <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f010ffe4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f010ffeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ffee:	23 45 f0             	and    -0x10(%ebp),%eax
}
f010fff1:	c9                   	leave  
f010fff2:	c3                   	ret    

f010fff3 <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f010fff3:	55                   	push   %ebp
f010fff4:	89 e5                	mov    %esp,%ebp
f010fff6:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f010fff9:	e8 5b ac ff ff       	call   f010ac59 <get_cpu_proc>
f010fffe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0110001:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0110005:	75 16                	jne    f011001d <sys_check_LRU_lists_free+0x2a>
f0110007:	68 3c 72 12 f0       	push   $0xf012723c
f011000c:	68 4c 72 12 f0       	push   $0xf012724c
f0110011:	6a 45                	push   $0x45
f0110013:	68 61 72 12 f0       	push   $0xf0127261
f0110018:	e8 1c 03 ff ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f011001d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110020:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f0110023:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f011002a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011002d:	8b 80 54 05 00 00    	mov    0x554(%eax),%eax
f0110033:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110036:	eb 65                	jmp    f011009d <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f0110038:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011003f:	eb 3a                	jmp    f011007b <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0110041:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110044:	8b 00                	mov    (%eax),%eax
f0110046:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0110049:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011004c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110051:	89 c2                	mov    %eax,%edx
f0110053:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110056:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011005d:	8b 45 08             	mov    0x8(%ebp),%eax
f0110060:	01 c8                	add    %ecx,%eax
f0110062:	8b 00                	mov    (%eax),%eax
f0110064:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0110067:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011006a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011006f:	39 c2                	cmp    %eax,%edx
f0110071:	75 05                	jne    f0110078 <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f0110073:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0110076:	eb 0b                	jmp    f0110083 <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f0110078:	ff 45 ec             	incl   -0x14(%ebp)
f011007b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011007e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110081:	7c be                	jl     f0110041 <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0110083:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110087:	7e 08                	jle    f0110091 <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f0110089:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011008c:	e9 ed 00 00 00       	jmp    f011017e <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0110091:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110094:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f011009a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011009d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01100a1:	74 08                	je     f01100ab <sys_check_LRU_lists_free+0xb8>
f01100a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01100a6:	8b 40 10             	mov    0x10(%eax),%eax
f01100a9:	eb 05                	jmp    f01100b0 <sys_check_LRU_lists_free+0xbd>
f01100ab:	b8 00 00 00 00       	mov    $0x0,%eax
f01100b0:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01100b3:	89 82 5c 05 00 00    	mov    %eax,0x55c(%edx)
f01100b9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01100bc:	8b 80 5c 05 00 00    	mov    0x55c(%eax),%eax
f01100c2:	85 c0                	test   %eax,%eax
f01100c4:	0f 85 6e ff ff ff    	jne    f0110038 <sys_check_LRU_lists_free+0x45>
f01100ca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01100ce:	0f 85 64 ff ff ff    	jne    f0110038 <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01100d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01100d7:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f01100dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01100e0:	eb 62                	jmp    f0110144 <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f01100e2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f01100e9:	eb 3a                	jmp    f0110125 <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f01100eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01100ee:	8b 00                	mov    (%eax),%eax
f01100f0:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01100f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01100f6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01100fb:	89 c2                	mov    %eax,%edx
f01100fd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110100:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0110107:	8b 45 08             	mov    0x8(%ebp),%eax
f011010a:	01 c8                	add    %ecx,%eax
f011010c:	8b 00                	mov    (%eax),%eax
f011010e:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0110111:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110114:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110119:	39 c2                	cmp    %eax,%edx
f011011b:	75 05                	jne    f0110122 <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f011011d:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0110120:	eb 0b                	jmp    f011012d <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f0110122:	ff 45 e8             	incl   -0x18(%ebp)
f0110125:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110128:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011012b:	7c be                	jl     f01100eb <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f011012d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110131:	7e 05                	jle    f0110138 <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f0110133:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110136:	eb 46                	jmp    f011017e <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0110138:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011013b:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0110141:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110144:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110148:	74 08                	je     f0110152 <sys_check_LRU_lists_free+0x15f>
f011014a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011014d:	8b 40 10             	mov    0x10(%eax),%eax
f0110150:	eb 05                	jmp    f0110157 <sys_check_LRU_lists_free+0x164>
f0110152:	b8 00 00 00 00       	mov    $0x0,%eax
f0110157:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011015a:	89 82 6c 05 00 00    	mov    %eax,0x56c(%edx)
f0110160:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110163:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f0110169:	85 c0                	test   %eax,%eax
f011016b:	0f 85 71 ff ff ff    	jne    f01100e2 <sys_check_LRU_lists_free+0xef>
f0110171:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110175:	0f 85 67 ff ff ff    	jne    f01100e2 <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f011017b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011017e:	c9                   	leave  
f011017f:	c3                   	ret    

f0110180 <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f0110180:	55                   	push   %ebp
f0110181:	89 e5                	mov    %esp,%ebp
f0110183:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
	//	env_page_ws_print(curenv);
	struct Env* cur_env = get_cpu_proc();
f0110186:	e8 ce aa ff ff       	call   f010ac59 <get_cpu_proc>
f011018b:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011018e:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0110192:	75 16                	jne    f01101aa <sys_check_WS_list+0x2a>
f0110194:	68 3c 72 12 f0       	push   $0xf012723c
f0110199:	68 4c 72 12 f0       	push   $0xf012724c
f011019e:	6a 79                	push   $0x79
f01101a0:	68 61 72 12 f0       	push   $0xf0127261
f01101a5:	e8 8f 01 ff ff       	call   f0100339 <_panic>
	struct Env* env = cur_env;
f01101aa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01101ad:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f01101b0:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f01101b7:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f01101bb:	74 06                	je     f01101c3 <sys_check_WS_list+0x43>
f01101bd:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f01101c1:	75 1f                	jne    f01101e2 <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f01101c3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01101c6:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f01101cc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01101cf:	39 c2                	cmp    %eax,%edx
f01101d1:	74 0f                	je     f01101e2 <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f01101d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01101da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01101dd:	e9 15 03 00 00       	jmp    f01104f7 <sys_check_WS_list+0x377>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f01101e2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01101e6:	74 39                	je     f0110221 <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f01101e8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01101eb:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f01101f1:	8b 00                	mov    (%eax),%eax
f01101f3:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01101f6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01101f9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01101fe:	89 c2                	mov    %eax,%edx
f0110200:	8b 45 10             	mov    0x10(%ebp),%eax
f0110203:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f0110206:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110209:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011020e:	39 c2                	cmp    %eax,%edx
f0110210:	74 0f                	je     f0110221 <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f0110212:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110219:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011021c:	e9 d6 02 00 00       	jmp    f01104f7 <sys_check_WS_list+0x377>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f0110221:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0110225:	0f 85 3c 01 00 00    	jne    f0110367 <sys_check_WS_list+0x1e7>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f011022b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f0110232:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0110236:	74 4c                	je     f0110284 <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0110238:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011023f:	eb 3b                	jmp    f011027c <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0110241:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110244:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011024b:	8b 45 08             	mov    0x8(%ebp),%eax
f011024e:	01 d0                	add    %edx,%eax
f0110250:	8b 00                	mov    (%eax),%eax
f0110252:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0110255:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110258:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011025d:	89 c2                	mov    %eax,%edx
f011025f:	8b 45 10             	mov    0x10(%ebp),%eax
f0110262:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0110265:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0110268:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011026d:	39 c2                	cmp    %eax,%edx
f011026f:	75 08                	jne    f0110279 <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f0110271:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110274:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f0110277:	eb 0b                	jmp    f0110284 <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f0110279:	ff 45 e8             	incl   -0x18(%ebp)
f011027c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011027f:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110282:	7c bd                	jl     f0110241 <sys_check_WS_list+0xc1>
					idx_WS_list = i ;
					break;
				}
			}
		}
		cprintf("index of last WS element = %d\n",idx_WS_list);
f0110284:	83 ec 08             	sub    $0x8,%esp
f0110287:	ff 75 ec             	pushl  -0x14(%ebp)
f011028a:	68 a8 72 12 f0       	push   $0xf01272a8
f011028f:	e8 f7 0c ff ff       	call   f0100f8b <cprintf>
f0110294:	83 c4 10             	add    $0x10,%esp
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f0110297:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011029a:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f01102a0:	85 c0                	test   %eax,%eax
f01102a2:	74 0e                	je     f01102b2 <sys_check_WS_list+0x132>
			ptr_WS_element = env->page_last_WS_element;
f01102a4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01102a7:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f01102ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01102b0:	eb 0c                	jmp    f01102be <sys_check_WS_list+0x13e>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f01102b2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01102b5:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01102bb:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);
f01102be:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01102c1:	8b 00                	mov    (%eax),%eax
f01102c3:	83 ec 08             	sub    $0x8,%esp
f01102c6:	50                   	push   %eax
f01102c7:	68 c7 72 12 f0       	push   $0xf01272c7
f01102cc:	e8 ba 0c ff ff       	call   f0100f8b <cprintf>
f01102d1:	83 c4 10             	add    $0x10,%esp

		for (int i = 0; i < actual_WS_list_size; ++i)
f01102d4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01102db:	eb 79                	jmp    f0110356 <sys_check_WS_list+0x1d6>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f01102dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01102e0:	8b 00                	mov    (%eax),%eax
f01102e2:	89 45 b8             	mov    %eax,-0x48(%ebp)
f01102e5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01102e8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01102ed:	89 c2                	mov    %eax,%edx
f01102ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01102f2:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01102f9:	8b 45 08             	mov    0x8(%ebp),%eax
f01102fc:	01 c8                	add    %ecx,%eax
f01102fe:	8b 00                	mov    (%eax),%eax
f0110300:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0110303:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0110306:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011030b:	39 c2                	cmp    %eax,%edx
f011030d:	74 0c                	je     f011031b <sys_check_WS_list+0x19b>
			{
				WS_list_validation = 0;
f011030f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0110316:	e9 d9 01 00 00       	jmp    f01104f4 <sys_check_WS_list+0x374>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f011031b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011031e:	40                   	inc    %eax
f011031f:	89 c2                	mov    %eax,%edx
f0110321:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110324:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f011032a:	89 d0                	mov    %edx,%eax
f011032c:	ba 00 00 00 00       	mov    $0x0,%edx
f0110331:	f7 f1                	div    %ecx
f0110333:	89 d0                	mov    %edx,%eax
f0110335:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f0110338:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011033b:	8b 40 10             	mov    0x10(%eax),%eax
f011033e:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f0110341:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110345:	75 0c                	jne    f0110353 <sys_check_WS_list+0x1d3>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0110347:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011034a:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0110350:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		cprintf("comparison star from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f0110353:	ff 45 e4             	incl   -0x1c(%ebp)
f0110356:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110359:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011035c:	0f 8c 7b ff ff ff    	jl     f01102dd <sys_check_WS_list+0x15d>
f0110362:	e9 8d 01 00 00       	jmp    f01104f4 <sys_check_WS_list+0x374>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f0110367:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f011036b:	74 0a                	je     f0110377 <sys_check_WS_list+0x1f7>
f011036d:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f0110371:	0f 85 be 00 00 00    	jne    f0110435 <sys_check_WS_list+0x2b5>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0110377:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011037e:	e9 a1 00 00 00       	jmp    f0110424 <sys_check_WS_list+0x2a4>
		{
			bool found = 0;
f0110383:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011038a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011038d:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0110393:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0110396:	eb 47                	jmp    f01103df <sys_check_WS_list+0x25f>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0110398:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011039b:	8b 00                	mov    (%eax),%eax
f011039d:	89 45 a8             	mov    %eax,-0x58(%ebp)
f01103a0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01103a3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01103a8:	89 c2                	mov    %eax,%edx
f01103aa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01103ad:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01103b4:	8b 45 08             	mov    0x8(%ebp),%eax
f01103b7:	01 c8                	add    %ecx,%eax
f01103b9:	8b 00                	mov    (%eax),%eax
f01103bb:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f01103be:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01103c1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01103c6:	39 c2                	cmp    %eax,%edx
f01103c8:	75 09                	jne    f01103d3 <sys_check_WS_list+0x253>
				{
					found = 1;
f01103ca:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f01103d1:	eb 3b                	jmp    f011040e <sys_check_WS_list+0x28e>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01103d3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01103d6:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01103dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01103df:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01103e3:	74 08                	je     f01103ed <sys_check_WS_list+0x26d>
f01103e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01103e8:	8b 40 10             	mov    0x10(%eax),%eax
f01103eb:	eb 05                	jmp    f01103f2 <sys_check_WS_list+0x272>
f01103ed:	b8 00 00 00 00       	mov    $0x0,%eax
f01103f2:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01103f5:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f01103fb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01103fe:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0110404:	85 c0                	test   %eax,%eax
f0110406:	75 90                	jne    f0110398 <sys_check_WS_list+0x218>
f0110408:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011040c:	75 8a                	jne    f0110398 <sys_check_WS_list+0x218>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f011040e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0110412:	75 0d                	jne    f0110421 <sys_check_WS_list+0x2a1>
			{
				WS_list_validation = 0;
f0110414:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f011041b:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f011041c:	e9 d3 00 00 00       	jmp    f01104f4 <sys_check_WS_list+0x374>
f0110421:	ff 45 e0             	incl   -0x20(%ebp)
f0110424:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110427:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011042a:	0f 8c 53 ff ff ff    	jl     f0110383 <sys_check_WS_list+0x203>
f0110430:	e9 bf 00 00 00       	jmp    f01104f4 <sys_check_WS_list+0x374>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f0110435:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f0110439:	0f 85 b5 00 00 00    	jne    f01104f4 <sys_check_WS_list+0x374>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f011043f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0110446:	e9 9d 00 00 00       	jmp    f01104e8 <sys_check_WS_list+0x368>
		{
			bool found = 0;
f011044b:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f0110452:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110455:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f011045b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011045e:	eb 47                	jmp    f01104a7 <sys_check_WS_list+0x327>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f0110460:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110463:	8b 00                	mov    (%eax),%eax
f0110465:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0110468:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011046b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0110470:	89 c2                	mov    %eax,%edx
f0110472:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0110475:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011047c:	8b 45 08             	mov    0x8(%ebp),%eax
f011047f:	01 c8                	add    %ecx,%eax
f0110481:	8b 00                	mov    (%eax),%eax
f0110483:	89 45 ac             	mov    %eax,-0x54(%ebp)
f0110486:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0110489:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011048e:	39 c2                	cmp    %eax,%edx
f0110490:	75 09                	jne    f011049b <sys_check_WS_list+0x31b>
				{
					found = 1;
f0110492:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f0110499:	eb 3b                	jmp    f01104d6 <sys_check_WS_list+0x356>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011049b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011049e:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01104a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01104a7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01104ab:	74 08                	je     f01104b5 <sys_check_WS_list+0x335>
f01104ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01104b0:	8b 40 10             	mov    0x10(%eax),%eax
f01104b3:	eb 05                	jmp    f01104ba <sys_check_WS_list+0x33a>
f01104b5:	b8 00 00 00 00       	mov    $0x0,%eax
f01104ba:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01104bd:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f01104c3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01104c6:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01104cc:	85 c0                	test   %eax,%eax
f01104ce:	75 90                	jne    f0110460 <sys_check_WS_list+0x2e0>
f01104d0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01104d4:	75 8a                	jne    f0110460 <sys_check_WS_list+0x2e0>
				{
					found = 1;
					break;
				}
			}
			if (found)
f01104d6:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01104da:	74 09                	je     f01104e5 <sys_check_WS_list+0x365>
			{
				WS_list_validation = 0;
f01104dc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f01104e3:	eb 0f                	jmp    f01104f4 <sys_check_WS_list+0x374>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f01104e5:	ff 45 d8             	incl   -0x28(%ebp)
f01104e8:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01104eb:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01104ee:	0f 8c 57 ff ff ff    	jl     f011044b <sys_check_WS_list+0x2cb>
				break;
			}
		}
	}

	return WS_list_validation;
f01104f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f01104f7:	c9                   	leave  
f01104f8:	c3                   	ret    

f01104f9 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f01104f9:	55                   	push   %ebp
f01104fa:	89 e5                	mov    %esp,%ebp
f01104fc:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f01104ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f0110506:	8b 15 b8 cb 5e f0    	mov    0xf05ecbb8,%edx
f011050c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011050f:	39 c2                	cmp    %eax,%edx
f0110511:	74 0a                	je     f011051d <hasExpectedCommands+0x24>
		return 0;
f0110513:	b8 00 00 00 00       	mov    $0x0,%eax
f0110518:	e9 8b 00 00 00       	jmp    f01105a8 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f011051d:	a1 ac cb 5e f0       	mov    0xf05ecbac,%eax
f0110522:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0110525:	eb 55                	jmp    f011057c <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0110527:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011052e:	eb 2a                	jmp    f011055a <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f0110530:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110533:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011053a:	8b 45 08             	mov    0x8(%ebp),%eax
f011053d:	01 d0                	add    %edx,%eax
f011053f:	8b 10                	mov    (%eax),%edx
f0110541:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110544:	8b 00                	mov    (%eax),%eax
f0110546:	83 ec 08             	sub    $0x8,%esp
f0110549:	52                   	push   %edx
f011054a:	50                   	push   %eax
f011054b:	e8 9b e7 00 00       	call   f011eceb <strcmp>
f0110550:	83 c4 10             	add    $0x10,%esp
f0110553:	85 c0                	test   %eax,%eax
f0110555:	74 0d                	je     f0110564 <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0110557:	ff 45 f0             	incl   -0x10(%ebp)
f011055a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011055d:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110560:	7c ce                	jl     f0110530 <hasExpectedCommands+0x37>
f0110562:	eb 01                	jmp    f0110565 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f0110564:	90                   	nop
		if (i == commandsCount)
f0110565:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110568:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011056b:	75 07                	jne    f0110574 <hasExpectedCommands+0x7b>
			return 0;
f011056d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110572:	eb 34                	jmp    f01105a8 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f0110574:	a1 b4 cb 5e f0       	mov    0xf05ecbb4,%eax
f0110579:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011057c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0110580:	74 08                	je     f011058a <hasExpectedCommands+0x91>
f0110582:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110585:	8b 40 10             	mov    0x10(%eax),%eax
f0110588:	eb 05                	jmp    f011058f <hasExpectedCommands+0x96>
f011058a:	b8 00 00 00 00       	mov    $0x0,%eax
f011058f:	a3 b4 cb 5e f0       	mov    %eax,0xf05ecbb4
f0110594:	a1 b4 cb 5e f0       	mov    0xf05ecbb4,%eax
f0110599:	85 c0                	test   %eax,%eax
f011059b:	75 8a                	jne    f0110527 <hasExpectedCommands+0x2e>
f011059d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01105a1:	75 84                	jne    f0110527 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f01105a3:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01105a8:	c9                   	leave  
f01105a9:	c3                   	ret    

f01105aa <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f01105aa:	55                   	push   %ebp
f01105ab:	89 e5                	mov    %esp,%ebp
f01105ad:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01105b0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01105b7:	eb 2e                	jmp    f01105e7 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f01105b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01105bc:	89 d0                	mov    %edx,%eax
f01105be:	01 c0                	add    %eax,%eax
f01105c0:	01 d0                	add    %edx,%eax
f01105c2:	c1 e0 03             	shl    $0x3,%eax
f01105c5:	05 40 b5 17 f0       	add    $0xf017b540,%eax
f01105ca:	8b 00                	mov    (%eax),%eax
f01105cc:	83 ec 08             	sub    $0x8,%esp
f01105cf:	ff 75 08             	pushl  0x8(%ebp)
f01105d2:	50                   	push   %eax
f01105d3:	e8 13 e7 00 00       	call   f011eceb <strcmp>
f01105d8:	83 c4 10             	add    $0x10,%esp
f01105db:	85 c0                	test   %eax,%eax
f01105dd:	75 05                	jne    f01105e4 <getIndexOfCommand+0x3a>
			return i;
f01105df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01105e2:	eb 14                	jmp    f01105f8 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01105e4:	ff 45 f4             	incl   -0xc(%ebp)
f01105e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01105ea:	a1 48 b9 17 f0       	mov    0xf017b948,%eax
f01105ef:	39 c2                	cmp    %eax,%edx
f01105f1:	72 c6                	jb     f01105b9 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f01105f3:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f01105f8:	c9                   	leave  
f01105f9:	c3                   	ret    

f01105fa <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f01105fa:	55                   	push   %ebp
f01105fb:	89 e5                	mov    %esp,%ebp
f01105fd:	57                   	push   %edi
f01105fe:	56                   	push   %esi
f01105ff:	53                   	push   %ebx
f0110600:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f0110606:	83 ec 0c             	sub    $0xc,%esp
f0110609:	68 00 73 12 f0       	push   $0xf0127300
f011060e:	e8 78 09 ff ff       	call   f0100f8b <cprintf>
f0110613:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f0110616:	83 ec 0c             	sub    $0xc,%esp
f0110619:	68 24 73 12 f0       	push   $0xf0127324
f011061e:	e8 68 09 ff ff       	call   f0100f8b <cprintf>
f0110623:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f0110626:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f011062d:	c7 45 8c 3f 73 12 f0 	movl   $0xf012733f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f0110634:	83 ec 08             	sub    $0x8,%esp
f0110637:	8d 45 8c             	lea    -0x74(%ebp),%eax
f011063a:	50                   	push   %eax
f011063b:	6a 01                	push   $0x1
f011063d:	e8 8e 1b ff ff       	call   f01021d0 <process_command>
f0110642:	83 c4 10             	add    $0x10,%esp
f0110645:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f0110648:	83 ec 0c             	sub    $0xc,%esp
f011064b:	68 4c 73 12 f0       	push   $0xf012734c
f0110650:	e8 36 09 ff ff       	call   f0100f8b <cprintf>
f0110655:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f0110658:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011065b:	83 ec 0c             	sub    $0xc,%esp
f011065e:	50                   	push   %eax
f011065f:	e8 46 ff ff ff       	call   f01105aa <getIndexOfCommand>
f0110664:	83 c4 10             	add    $0x10,%esp
f0110667:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011066a:	75 0f                	jne    f011067b <TestAutoCompleteCommand+0x81>
f011066c:	a1 ac cb 5e f0       	mov    0xf05ecbac,%eax
f0110671:	85 c0                	test   %eax,%eax
f0110673:	75 06                	jne    f011067b <TestAutoCompleteCommand+0x81>
		eval += 15;
f0110675:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0110679:	eb 10                	jmp    f011068b <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011067b:	83 ec 0c             	sub    $0xc,%esp
f011067e:	68 7c 73 12 f0       	push   $0xf012737c
f0110683:	e8 03 09 ff ff       	call   f0100f8b <cprintf>
f0110688:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f011068b:	83 ec 0c             	sub    $0xc,%esp
f011068e:	68 cc 73 12 f0       	push   $0xf01273cc
f0110693:	e8 f3 08 ff ff       	call   f0100f8b <cprintf>
f0110698:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f011069b:	c7 45 88 f2 73 12 f0 	movl   $0xf01273f2,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f01106a2:	83 ec 08             	sub    $0x8,%esp
f01106a5:	8d 45 88             	lea    -0x78(%ebp),%eax
f01106a8:	50                   	push   %eax
f01106a9:	6a 01                	push   $0x1
f01106ab:	e8 20 1b ff ff       	call   f01021d0 <process_command>
f01106b0:	83 c4 10             	add    $0x10,%esp
f01106b3:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f01106b6:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01106ba:	75 30                	jne    f01106ec <TestAutoCompleteCommand+0xf2>
f01106bc:	8d 45 90             	lea    -0x70(%ebp),%eax
f01106bf:	bb d0 77 12 f0       	mov    $0xf01277d0,%ebx
f01106c4:	ba 03 00 00 00       	mov    $0x3,%edx
f01106c9:	89 c7                	mov    %eax,%edi
f01106cb:	89 de                	mov    %ebx,%esi
f01106cd:	89 d1                	mov    %edx,%ecx
f01106cf:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01106d1:	83 ec 08             	sub    $0x8,%esp
f01106d4:	6a 03                	push   $0x3
f01106d6:	8d 45 90             	lea    -0x70(%ebp),%eax
f01106d9:	50                   	push   %eax
f01106da:	e8 1a fe ff ff       	call   f01104f9 <hasExpectedCommands>
f01106df:	83 c4 10             	add    $0x10,%esp
f01106e2:	85 c0                	test   %eax,%eax
f01106e4:	74 06                	je     f01106ec <TestAutoCompleteCommand+0xf2>
		eval += 15;
f01106e6:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01106ea:	eb 10                	jmp    f01106fc <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01106ec:	83 ec 0c             	sub    $0xc,%esp
f01106ef:	68 f8 73 12 f0       	push   $0xf01273f8
f01106f4:	e8 92 08 ff ff       	call   f0100f8b <cprintf>
f01106f9:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f01106fc:	83 ec 0c             	sub    $0xc,%esp
f01106ff:	68 48 74 12 f0       	push   $0xf0127448
f0110704:	e8 82 08 ff ff       	call   f0100f8b <cprintf>
f0110709:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f011070c:	c7 45 84 6d 74 12 f0 	movl   $0xf012746d,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f0110713:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0110716:	83 ec 04             	sub    $0x4,%esp
f0110719:	50                   	push   %eax
f011071a:	8d 45 84             	lea    -0x7c(%ebp),%eax
f011071d:	50                   	push   %eax
f011071e:	68 70 74 12 f0       	push   $0xf0127470
f0110723:	e8 63 08 ff ff       	call   f0100f8b <cprintf>
f0110728:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f011072b:	83 ec 08             	sub    $0x8,%esp
f011072e:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0110731:	50                   	push   %eax
f0110732:	6a 01                	push   $0x1
f0110734:	e8 97 1a ff ff       	call   f01021d0 <process_command>
f0110739:	83 c4 10             	add    $0x10,%esp
f011073c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f011073f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0110743:	75 1b                	jne    f0110760 <TestAutoCompleteCommand+0x166>
f0110745:	83 ec 08             	sub    $0x8,%esp
f0110748:	6a 01                	push   $0x1
f011074a:	8d 45 84             	lea    -0x7c(%ebp),%eax
f011074d:	50                   	push   %eax
f011074e:	e8 a6 fd ff ff       	call   f01104f9 <hasExpectedCommands>
f0110753:	83 c4 10             	add    $0x10,%esp
f0110756:	85 c0                	test   %eax,%eax
f0110758:	74 06                	je     f0110760 <TestAutoCompleteCommand+0x166>
		eval += 15;
f011075a:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011075e:	eb 10                	jmp    f0110770 <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f0110760:	83 ec 0c             	sub    $0xc,%esp
f0110763:	68 90 74 12 f0       	push   $0xf0127490
f0110768:	e8 1e 08 ff ff       	call   f0100f8b <cprintf>
f011076d:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f0110770:	83 ec 0c             	sub    $0xc,%esp
f0110773:	68 e8 74 12 f0       	push   $0xf01274e8
f0110778:	e8 0e 08 ff ff       	call   f0100f8b <cprintf>
f011077d:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f0110780:	c7 45 80 0e 75 12 f0 	movl   $0xf012750e,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f0110787:	83 ec 08             	sub    $0x8,%esp
f011078a:	8d 45 80             	lea    -0x80(%ebp),%eax
f011078d:	50                   	push   %eax
f011078e:	6a 01                	push   $0x1
f0110790:	e8 3b 1a ff ff       	call   f01021d0 <process_command>
f0110795:	83 c4 10             	add    $0x10,%esp
f0110798:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f011079b:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f011079f:	75 0f                	jne    f01107b0 <TestAutoCompleteCommand+0x1b6>
f01107a1:	a1 b8 cb 5e f0       	mov    0xf05ecbb8,%eax
f01107a6:	85 c0                	test   %eax,%eax
f01107a8:	75 06                	jne    f01107b0 <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f01107aa:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01107ae:	eb 10                	jmp    f01107c0 <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01107b0:	83 ec 0c             	sub    $0xc,%esp
f01107b3:	68 14 75 12 f0       	push   $0xf0127514
f01107b8:	e8 ce 07 ff ff       	call   f0100f8b <cprintf>
f01107bd:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f01107c0:	83 ec 0c             	sub    $0xc,%esp
f01107c3:	68 64 75 12 f0       	push   $0xf0127564
f01107c8:	e8 be 07 ff ff       	call   f0100f8b <cprintf>
f01107cd:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f01107d0:	c7 85 7c ff ff ff 89 	movl   $0xf0127589,-0x84(%ebp)
f01107d7:	75 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f01107da:	83 ec 08             	sub    $0x8,%esp
f01107dd:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f01107e3:	50                   	push   %eax
f01107e4:	6a 01                	push   $0x1
f01107e6:	e8 e5 19 ff ff       	call   f01021d0 <process_command>
f01107eb:	83 c4 10             	add    $0x10,%esp
f01107ee:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f01107f1:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01107f5:	75 30                	jne    f0110827 <TestAutoCompleteCommand+0x22d>
f01107f7:	8d 45 9c             	lea    -0x64(%ebp),%eax
f01107fa:	bb 60 78 12 f0       	mov    $0xf0127860,%ebx
f01107ff:	ba 0c 00 00 00       	mov    $0xc,%edx
f0110804:	89 c7                	mov    %eax,%edi
f0110806:	89 de                	mov    %ebx,%esi
f0110808:	89 d1                	mov    %edx,%ecx
f011080a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011080c:	83 ec 08             	sub    $0x8,%esp
f011080f:	6a 0c                	push   $0xc
f0110811:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0110814:	50                   	push   %eax
f0110815:	e8 df fc ff ff       	call   f01104f9 <hasExpectedCommands>
f011081a:	83 c4 10             	add    $0x10,%esp
f011081d:	85 c0                	test   %eax,%eax
f011081f:	74 06                	je     f0110827 <TestAutoCompleteCommand+0x22d>
		eval += 10;
f0110821:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0110825:	eb 10                	jmp    f0110837 <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f0110827:	83 ec 0c             	sub    $0xc,%esp
f011082a:	68 8c 75 12 f0       	push   $0xf012758c
f011082f:	e8 57 07 ff ff       	call   f0100f8b <cprintf>
f0110834:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f0110837:	83 ec 0c             	sub    $0xc,%esp
f011083a:	68 e4 75 12 f0       	push   $0xf01275e4
f011083f:	e8 47 07 ff ff       	call   f0100f8b <cprintf>
f0110844:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f0110847:	c7 85 78 ff ff ff 09 	movl   $0xf0127609,-0x88(%ebp)
f011084e:	76 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f0110851:	83 ec 08             	sub    $0x8,%esp
f0110854:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f011085a:	50                   	push   %eax
f011085b:	6a 01                	push   $0x1
f011085d:	e8 6e 19 ff ff       	call   f01021d0 <process_command>
f0110862:	83 c4 10             	add    $0x10,%esp
f0110865:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f0110868:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f011086c:	75 30                	jne    f011089e <TestAutoCompleteCommand+0x2a4>
f011086e:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0110871:	bb a8 78 12 f0       	mov    $0xf01278a8,%ebx
f0110876:	ba 05 00 00 00       	mov    $0x5,%edx
f011087b:	89 c7                	mov    %eax,%edi
f011087d:	89 de                	mov    %ebx,%esi
f011087f:	89 d1                	mov    %edx,%ecx
f0110881:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0110883:	83 ec 08             	sub    $0x8,%esp
f0110886:	6a 05                	push   $0x5
f0110888:	8d 45 cc             	lea    -0x34(%ebp),%eax
f011088b:	50                   	push   %eax
f011088c:	e8 68 fc ff ff       	call   f01104f9 <hasExpectedCommands>
f0110891:	83 c4 10             	add    $0x10,%esp
f0110894:	85 c0                	test   %eax,%eax
f0110896:	74 06                	je     f011089e <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f0110898:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f011089c:	eb 10                	jmp    f01108ae <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f011089e:	83 ec 0c             	sub    $0xc,%esp
f01108a1:	68 0c 76 12 f0       	push   $0xf012760c
f01108a6:	e8 e0 06 ff ff       	call   f0100f8b <cprintf>
f01108ab:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f01108ae:	83 ec 0c             	sub    $0xc,%esp
f01108b1:	68 64 76 12 f0       	push   $0xf0127664
f01108b6:	e8 d0 06 ff ff       	call   f0100f8b <cprintf>
f01108bb:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f01108be:	c7 85 70 ff ff ff 90 	movl   $0xf0127690,-0x90(%ebp)
f01108c5:	76 12 f0 
f01108c8:	c7 85 74 ff ff ff 95 	movl   $0xf0127695,-0x8c(%ebp)
f01108cf:	76 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f01108d2:	83 ec 08             	sub    $0x8,%esp
f01108d5:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f01108db:	50                   	push   %eax
f01108dc:	6a 02                	push   $0x2
f01108de:	e8 ed 18 ff ff       	call   f01021d0 <process_command>
f01108e3:	83 c4 10             	add    $0x10,%esp
f01108e6:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f01108e9:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01108ef:	83 ec 0c             	sub    $0xc,%esp
f01108f2:	50                   	push   %eax
f01108f3:	e8 b2 fc ff ff       	call   f01105aa <getIndexOfCommand>
f01108f8:	83 c4 10             	add    $0x10,%esp
f01108fb:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01108fe:	75 0f                	jne    f011090f <TestAutoCompleteCommand+0x315>
f0110900:	a1 ac cb 5e f0       	mov    0xf05ecbac,%eax
f0110905:	85 c0                	test   %eax,%eax
f0110907:	75 06                	jne    f011090f <TestAutoCompleteCommand+0x315>
		eval += 10;
f0110909:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f011090d:	eb 10                	jmp    f011091f <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011090f:	83 ec 0c             	sub    $0xc,%esp
f0110912:	68 9c 76 12 f0       	push   $0xf012769c
f0110917:	e8 6f 06 ff ff       	call   f0100f8b <cprintf>
f011091c:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f011091f:	83 ec 0c             	sub    $0xc,%esp
f0110922:	68 ec 76 12 f0       	push   $0xf01276ec
f0110927:	e8 5f 06 ff ff       	call   f0100f8b <cprintf>
f011092c:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f011092f:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0110935:	bb d0 78 12 f0       	mov    $0xf01278d0,%ebx
f011093a:	ba 03 00 00 00       	mov    $0x3,%edx
f011093f:	89 c7                	mov    %eax,%edi
f0110941:	89 de                	mov    %ebx,%esi
f0110943:	89 d1                	mov    %edx,%ecx
f0110945:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f0110947:	83 ec 08             	sub    $0x8,%esp
f011094a:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0110950:	50                   	push   %eax
f0110951:	6a 03                	push   $0x3
f0110953:	e8 78 18 ff ff       	call   f01021d0 <process_command>
f0110958:	83 c4 10             	add    $0x10,%esp
f011095b:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f011095e:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0110964:	83 ec 0c             	sub    $0xc,%esp
f0110967:	50                   	push   %eax
f0110968:	e8 3d fc ff ff       	call   f01105aa <getIndexOfCommand>
f011096d:	83 c4 10             	add    $0x10,%esp
f0110970:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0110973:	75 0f                	jne    f0110984 <TestAutoCompleteCommand+0x38a>
f0110975:	a1 ac cb 5e f0       	mov    0xf05ecbac,%eax
f011097a:	85 c0                	test   %eax,%eax
f011097c:	75 06                	jne    f0110984 <TestAutoCompleteCommand+0x38a>
		eval += 10;
f011097e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0110982:	eb 10                	jmp    f0110994 <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0110984:	83 ec 0c             	sub    $0xc,%esp
f0110987:	68 20 77 12 f0       	push   $0xf0127720
f011098c:	e8 fa 05 ff ff       	call   f0100f8b <cprintf>
f0110991:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f0110994:	83 ec 08             	sub    $0x8,%esp
f0110997:	ff 75 e4             	pushl  -0x1c(%ebp)
f011099a:	68 70 77 12 f0       	push   $0xf0127770
f011099f:	e8 e7 05 ff ff       	call   f0100f8b <cprintf>
f01109a4:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f01109a7:	83 ec 0c             	sub    $0xc,%esp
f01109aa:	68 a0 77 12 f0       	push   $0xf01277a0
f01109af:	e8 d7 05 ff ff       	call   f0100f8b <cprintf>
f01109b4:	83 c4 10             	add    $0x10,%esp

	return 0;
f01109b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01109bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01109bf:	5b                   	pop    %ebx
f01109c0:	5e                   	pop    %esi
f01109c1:	5f                   	pop    %edi
f01109c2:	5d                   	pop    %ebp
f01109c3:	c3                   	ret    

f01109c4 <test_str2lower_function>:

int test_str2lower_function()
{
f01109c4:	55                   	push   %ebp
f01109c5:	89 e5                	mov    %esp,%ebp
f01109c7:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f01109cd:	83 ec 0c             	sub    $0xc,%esp
f01109d0:	68 dc 78 12 f0       	push   $0xf01278dc
f01109d5:	e8 b1 05 ff ff       	call   f0100f8b <cprintf>
f01109da:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f01109dd:	83 ec 0c             	sub    $0xc,%esp
f01109e0:	68 fd 78 12 f0       	push   $0xf01278fd
f01109e5:	e8 a1 05 ff ff       	call   f0100f8b <cprintf>
f01109ea:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f01109ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f01109f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f01109fb:	c7 45 ec 17 79 12 f0 	movl   $0xf0127917,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f0110a02:	83 ec 08             	sub    $0x8,%esp
f0110a05:	ff 75 ec             	pushl  -0x14(%ebp)
f0110a08:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f0110a0e:	50                   	push   %eax
f0110a0f:	e8 b4 e8 00 00       	call   f011f2c8 <str2lower>
f0110a14:	83 c4 10             	add    $0x10,%esp
f0110a17:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0110a1a:	83 ec 0c             	sub    $0xc,%esp
f0110a1d:	ff 75 e8             	pushl  -0x18(%ebp)
f0110a20:	e8 ba e1 00 00       	call   f011ebdf <strlen>
f0110a25:	83 c4 10             	add    $0x10,%esp
f0110a28:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0110a2b:	83 ec 08             	sub    $0x8,%esp
f0110a2e:	68 22 79 12 f0       	push   $0xf0127922
f0110a33:	ff 75 e8             	pushl  -0x18(%ebp)
f0110a36:	e8 b0 e2 00 00       	call   f011eceb <strcmp>
f0110a3b:	83 c4 10             	add    $0x10,%esp
f0110a3e:	85 c0                	test   %eax,%eax
f0110a40:	75 13                	jne    f0110a55 <test_str2lower_function+0x91>
f0110a42:	83 ec 0c             	sub    $0xc,%esp
f0110a45:	ff 75 ec             	pushl  -0x14(%ebp)
f0110a48:	e8 92 e1 00 00       	call   f011ebdf <strlen>
f0110a4d:	83 c4 10             	add    $0x10,%esp
f0110a50:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110a53:	74 15                	je     f0110a6a <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f0110a55:	83 ec 08             	sub    $0x8,%esp
f0110a58:	ff 75 e8             	pushl  -0x18(%ebp)
f0110a5b:	68 30 79 12 f0       	push   $0xf0127930
f0110a60:	e8 26 05 ff ff       	call   f0100f8b <cprintf>
f0110a65:	83 c4 10             	add    $0x10,%esp
f0110a68:	eb 04                	jmp    f0110a6e <test_str2lower_function+0xaa>
	else
		eval += 10;
f0110a6a:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f0110a6e:	c7 45 e0 92 79 12 f0 	movl   $0xf0127992,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f0110a75:	83 ec 08             	sub    $0x8,%esp
f0110a78:	ff 75 e0             	pushl  -0x20(%ebp)
f0110a7b:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0110a81:	50                   	push   %eax
f0110a82:	e8 41 e8 00 00       	call   f011f2c8 <str2lower>
f0110a87:	83 c4 10             	add    $0x10,%esp
f0110a8a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0110a8d:	83 ec 0c             	sub    $0xc,%esp
f0110a90:	ff 75 e8             	pushl  -0x18(%ebp)
f0110a93:	e8 47 e1 00 00       	call   f011ebdf <strlen>
f0110a98:	83 c4 10             	add    $0x10,%esp
f0110a9b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f0110a9e:	83 ec 08             	sub    $0x8,%esp
f0110aa1:	68 92 79 12 f0       	push   $0xf0127992
f0110aa6:	ff 75 e8             	pushl  -0x18(%ebp)
f0110aa9:	e8 3d e2 00 00       	call   f011eceb <strcmp>
f0110aae:	83 c4 10             	add    $0x10,%esp
f0110ab1:	85 c0                	test   %eax,%eax
f0110ab3:	75 13                	jne    f0110ac8 <test_str2lower_function+0x104>
f0110ab5:	83 ec 0c             	sub    $0xc,%esp
f0110ab8:	ff 75 e0             	pushl  -0x20(%ebp)
f0110abb:	e8 1f e1 00 00       	call   f011ebdf <strlen>
f0110ac0:	83 c4 10             	add    $0x10,%esp
f0110ac3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110ac6:	74 15                	je     f0110add <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0110ac8:	83 ec 08             	sub    $0x8,%esp
f0110acb:	ff 75 e8             	pushl  -0x18(%ebp)
f0110ace:	68 94 79 12 f0       	push   $0xf0127994
f0110ad3:	e8 b3 04 ff ff       	call   f0100f8b <cprintf>
f0110ad8:	83 c4 10             	add    $0x10,%esp
f0110adb:	eb 04                	jmp    f0110ae1 <test_str2lower_function+0x11d>
	else
		eval += 10;
f0110add:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f0110ae1:	c7 45 dc ec 79 12 f0 	movl   $0xf01279ec,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0110ae8:	83 ec 08             	sub    $0x8,%esp
f0110aeb:	ff 75 dc             	pushl  -0x24(%ebp)
f0110aee:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0110af4:	50                   	push   %eax
f0110af5:	e8 ce e7 00 00       	call   f011f2c8 <str2lower>
f0110afa:	83 c4 10             	add    $0x10,%esp
f0110afd:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0110b00:	83 ec 0c             	sub    $0xc,%esp
f0110b03:	ff 75 e8             	pushl  -0x18(%ebp)
f0110b06:	e8 d4 e0 00 00       	call   f011ebdf <strlen>
f0110b0b:	83 c4 10             	add    $0x10,%esp
f0110b0e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f0110b11:	83 ec 08             	sub    $0x8,%esp
f0110b14:	68 ec 79 12 f0       	push   $0xf01279ec
f0110b19:	ff 75 e8             	pushl  -0x18(%ebp)
f0110b1c:	e8 ca e1 00 00       	call   f011eceb <strcmp>
f0110b21:	83 c4 10             	add    $0x10,%esp
f0110b24:	85 c0                	test   %eax,%eax
f0110b26:	75 13                	jne    f0110b3b <test_str2lower_function+0x177>
f0110b28:	83 ec 0c             	sub    $0xc,%esp
f0110b2b:	ff 75 dc             	pushl  -0x24(%ebp)
f0110b2e:	e8 ac e0 00 00       	call   f011ebdf <strlen>
f0110b33:	83 c4 10             	add    $0x10,%esp
f0110b36:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110b39:	74 15                	je     f0110b50 <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0110b3b:	83 ec 08             	sub    $0x8,%esp
f0110b3e:	ff 75 e8             	pushl  -0x18(%ebp)
f0110b41:	68 f8 79 12 f0       	push   $0xf01279f8
f0110b46:	e8 40 04 ff ff       	call   f0100f8b <cprintf>
f0110b4b:	83 c4 10             	add    $0x10,%esp
f0110b4e:	eb 04                	jmp    f0110b54 <test_str2lower_function+0x190>
	else
		eval += 15;
f0110b50:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f0110b54:	c7 45 d8 5b 7a 12 f0 	movl   $0xf0127a5b,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f0110b5b:	83 ec 08             	sub    $0x8,%esp
f0110b5e:	ff 75 d8             	pushl  -0x28(%ebp)
f0110b61:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f0110b67:	50                   	push   %eax
f0110b68:	e8 5b e7 00 00       	call   f011f2c8 <str2lower>
f0110b6d:	83 c4 10             	add    $0x10,%esp
f0110b70:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0110b73:	83 ec 0c             	sub    $0xc,%esp
f0110b76:	ff 75 e8             	pushl  -0x18(%ebp)
f0110b79:	e8 61 e0 00 00       	call   f011ebdf <strlen>
f0110b7e:	83 c4 10             	add    $0x10,%esp
f0110b81:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f0110b84:	83 ec 08             	sub    $0x8,%esp
f0110b87:	68 5b 7a 12 f0       	push   $0xf0127a5b
f0110b8c:	ff 75 e8             	pushl  -0x18(%ebp)
f0110b8f:	e8 57 e1 00 00       	call   f011eceb <strcmp>
f0110b94:	83 c4 10             	add    $0x10,%esp
f0110b97:	85 c0                	test   %eax,%eax
f0110b99:	75 13                	jne    f0110bae <test_str2lower_function+0x1ea>
f0110b9b:	83 ec 0c             	sub    $0xc,%esp
f0110b9e:	ff 75 d8             	pushl  -0x28(%ebp)
f0110ba1:	e8 39 e0 00 00       	call   f011ebdf <strlen>
f0110ba6:	83 c4 10             	add    $0x10,%esp
f0110ba9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110bac:	74 15                	je     f0110bc3 <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0110bae:	83 ec 08             	sub    $0x8,%esp
f0110bb1:	ff 75 e8             	pushl  -0x18(%ebp)
f0110bb4:	68 68 7a 12 f0       	push   $0xf0127a68
f0110bb9:	e8 cd 03 ff ff       	call   f0100f8b <cprintf>
f0110bbe:	83 c4 10             	add    $0x10,%esp
f0110bc1:	eb 04                	jmp    f0110bc7 <test_str2lower_function+0x203>
	else
		eval += 15;
f0110bc3:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0110bc7:	c7 45 d4 ca 7a 12 f0 	movl   $0xf0127aca,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0110bce:	83 ec 08             	sub    $0x8,%esp
f0110bd1:	ff 75 d4             	pushl  -0x2c(%ebp)
f0110bd4:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0110bda:	50                   	push   %eax
f0110bdb:	e8 e8 e6 00 00       	call   f011f2c8 <str2lower>
f0110be0:	83 c4 10             	add    $0x10,%esp
f0110be3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0110be6:	83 ec 0c             	sub    $0xc,%esp
f0110be9:	ff 75 e8             	pushl  -0x18(%ebp)
f0110bec:	e8 ee df 00 00       	call   f011ebdf <strlen>
f0110bf1:	83 c4 10             	add    $0x10,%esp
f0110bf4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0110bf7:	83 ec 08             	sub    $0x8,%esp
f0110bfa:	68 e0 7a 12 f0       	push   $0xf0127ae0
f0110bff:	ff 75 e8             	pushl  -0x18(%ebp)
f0110c02:	e8 e4 e0 00 00       	call   f011eceb <strcmp>
f0110c07:	83 c4 10             	add    $0x10,%esp
f0110c0a:	85 c0                	test   %eax,%eax
f0110c0c:	75 13                	jne    f0110c21 <test_str2lower_function+0x25d>
f0110c0e:	83 ec 0c             	sub    $0xc,%esp
f0110c11:	ff 75 d4             	pushl  -0x2c(%ebp)
f0110c14:	e8 c6 df 00 00       	call   f011ebdf <strlen>
f0110c19:	83 c4 10             	add    $0x10,%esp
f0110c1c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110c1f:	74 15                	je     f0110c36 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f0110c21:	83 ec 08             	sub    $0x8,%esp
f0110c24:	ff 75 e8             	pushl  -0x18(%ebp)
f0110c27:	68 f8 7a 12 f0       	push   $0xf0127af8
f0110c2c:	e8 5a 03 ff ff       	call   f0100f8b <cprintf>
f0110c31:	83 c4 10             	add    $0x10,%esp
f0110c34:	eb 04                	jmp    f0110c3a <test_str2lower_function+0x276>
	else
		eval += 15;
f0110c36:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0110c3a:	c7 45 d0 65 7b 12 f0 	movl   $0xf0127b65,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f0110c41:	83 ec 08             	sub    $0x8,%esp
f0110c44:	ff 75 d0             	pushl  -0x30(%ebp)
f0110c47:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0110c4d:	50                   	push   %eax
f0110c4e:	e8 75 e6 00 00       	call   f011f2c8 <str2lower>
f0110c53:	83 c4 10             	add    $0x10,%esp
f0110c56:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0110c59:	83 ec 0c             	sub    $0xc,%esp
f0110c5c:	ff 75 e8             	pushl  -0x18(%ebp)
f0110c5f:	e8 7b df 00 00       	call   f011ebdf <strlen>
f0110c64:	83 c4 10             	add    $0x10,%esp
f0110c67:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0110c6a:	83 ec 08             	sub    $0x8,%esp
f0110c6d:	68 71 7b 12 f0       	push   $0xf0127b71
f0110c72:	ff 75 e8             	pushl  -0x18(%ebp)
f0110c75:	e8 71 e0 00 00       	call   f011eceb <strcmp>
f0110c7a:	83 c4 10             	add    $0x10,%esp
f0110c7d:	85 c0                	test   %eax,%eax
f0110c7f:	75 13                	jne    f0110c94 <test_str2lower_function+0x2d0>
f0110c81:	83 ec 0c             	sub    $0xc,%esp
f0110c84:	ff 75 d0             	pushl  -0x30(%ebp)
f0110c87:	e8 53 df 00 00       	call   f011ebdf <strlen>
f0110c8c:	83 c4 10             	add    $0x10,%esp
f0110c8f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110c92:	74 15                	je     f0110ca9 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f0110c94:	83 ec 08             	sub    $0x8,%esp
f0110c97:	ff 75 e8             	pushl  -0x18(%ebp)
f0110c9a:	68 80 7b 12 f0       	push   $0xf0127b80
f0110c9f:	e8 e7 02 ff ff       	call   f0100f8b <cprintf>
f0110ca4:	83 c4 10             	add    $0x10,%esp
f0110ca7:	eb 04                	jmp    f0110cad <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0110ca9:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0110cad:	c7 45 cc e3 7b 12 f0 	movl   $0xf0127be3,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0110cb4:	83 ec 08             	sub    $0x8,%esp
f0110cb7:	ff 75 cc             	pushl  -0x34(%ebp)
f0110cba:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f0110cc0:	50                   	push   %eax
f0110cc1:	e8 02 e6 00 00       	call   f011f2c8 <str2lower>
f0110cc6:	83 c4 10             	add    $0x10,%esp
f0110cc9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0110ccc:	83 ec 0c             	sub    $0xc,%esp
f0110ccf:	ff 75 e8             	pushl  -0x18(%ebp)
f0110cd2:	e8 08 df 00 00       	call   f011ebdf <strlen>
f0110cd7:	83 c4 10             	add    $0x10,%esp
f0110cda:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0110cdd:	83 ec 08             	sub    $0x8,%esp
f0110ce0:	68 fe 7b 12 f0       	push   $0xf0127bfe
f0110ce5:	ff 75 e8             	pushl  -0x18(%ebp)
f0110ce8:	e8 fe df 00 00       	call   f011eceb <strcmp>
f0110ced:	83 c4 10             	add    $0x10,%esp
f0110cf0:	85 c0                	test   %eax,%eax
f0110cf2:	75 13                	jne    f0110d07 <test_str2lower_function+0x343>
f0110cf4:	83 ec 0c             	sub    $0xc,%esp
f0110cf7:	ff 75 cc             	pushl  -0x34(%ebp)
f0110cfa:	e8 e0 de 00 00       	call   f011ebdf <strlen>
f0110cff:	83 c4 10             	add    $0x10,%esp
f0110d02:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110d05:	74 15                	je     f0110d1c <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0110d07:	83 ec 08             	sub    $0x8,%esp
f0110d0a:	ff 75 e8             	pushl  -0x18(%ebp)
f0110d0d:	68 1c 7c 12 f0       	push   $0xf0127c1c
f0110d12:	e8 74 02 ff ff       	call   f0100f8b <cprintf>
f0110d17:	83 c4 10             	add    $0x10,%esp
f0110d1a:	eb 04                	jmp    f0110d20 <test_str2lower_function+0x35c>
	else
		eval += 20;
f0110d1c:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f0110d20:	83 ec 08             	sub    $0x8,%esp
f0110d23:	ff 75 f4             	pushl  -0xc(%ebp)
f0110d26:	68 90 7c 12 f0       	push   $0xf0127c90
f0110d2b:	e8 5b 02 ff ff       	call   f0100f8b <cprintf>
f0110d30:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0110d33:	83 ec 0c             	sub    $0xc,%esp
f0110d36:	68 a0 77 12 f0       	push   $0xf01277a0
f0110d3b:	e8 4b 02 ff ff       	call   f0100f8b <cprintf>
f0110d40:	83 c4 10             	add    $0x10,%esp
	return 0;
f0110d43:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110d48:	c9                   	leave  
f0110d49:	c3                   	ret    

f0110d4a <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f0110d4a:	55                   	push   %ebp
f0110d4b:	89 e5                	mov    %esp,%ebp
f0110d4d:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f0110d50:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0110d57:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0110d5e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110d65:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0110d6a:	ff 75 ec             	pushl  -0x14(%ebp)
f0110d6d:	ff 75 f0             	pushl  -0x10(%ebp)
f0110d70:	ff 75 f4             	pushl  -0xc(%ebp)
f0110d73:	50                   	push   %eax
f0110d74:	e8 85 83 ff ff       	call   f01090fe <pt_set_page_permissions>
f0110d79:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110d7c:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0110d81:	ff 75 ec             	pushl  -0x14(%ebp)
f0110d84:	ff 75 f0             	pushl  -0x10(%ebp)
f0110d87:	ff 75 f4             	pushl  -0xc(%ebp)
f0110d8a:	50                   	push   %eax
f0110d8b:	e8 74 4b 00 00       	call   f0115904 <CP>
f0110d90:	83 c4 10             	add    $0x10,%esp
f0110d93:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110d96:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110d9a:	74 17                	je     f0110db3 <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f0110d9c:	83 ec 04             	sub    $0x4,%esp
f0110d9f:	68 c0 7c 12 f0       	push   $0xf0127cc0
f0110da4:	68 23 01 00 00       	push   $0x123
f0110da9:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0110dae:	e8 86 f5 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0110db3:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0110dba:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f0110dc1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110dc8:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0110dcd:	ff 75 ec             	pushl  -0x14(%ebp)
f0110dd0:	ff 75 f0             	pushl  -0x10(%ebp)
f0110dd3:	ff 75 f4             	pushl  -0xc(%ebp)
f0110dd6:	50                   	push   %eax
f0110dd7:	e8 22 83 ff ff       	call   f01090fe <pt_set_page_permissions>
f0110ddc:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110ddf:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0110de4:	ff 75 ec             	pushl  -0x14(%ebp)
f0110de7:	ff 75 f0             	pushl  -0x10(%ebp)
f0110dea:	ff 75 f4             	pushl  -0xc(%ebp)
f0110ded:	50                   	push   %eax
f0110dee:	e8 11 4b 00 00       	call   f0115904 <CP>
f0110df3:	83 c4 10             	add    $0x10,%esp
f0110df6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110df9:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110dfd:	74 17                	je     f0110e16 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f0110dff:	83 ec 04             	sub    $0x4,%esp
f0110e02:	68 00 7d 12 f0       	push   $0xf0127d00
f0110e07:	68 2f 01 00 00       	push   $0x12f
f0110e0c:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0110e11:	e8 23 f5 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f0110e16:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0110e1d:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0110e24:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110e2b:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0110e30:	ff 75 ec             	pushl  -0x14(%ebp)
f0110e33:	ff 75 f0             	pushl  -0x10(%ebp)
f0110e36:	ff 75 f4             	pushl  -0xc(%ebp)
f0110e39:	50                   	push   %eax
f0110e3a:	e8 bf 82 ff ff       	call   f01090fe <pt_set_page_permissions>
f0110e3f:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110e42:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0110e47:	ff 75 ec             	pushl  -0x14(%ebp)
f0110e4a:	ff 75 f0             	pushl  -0x10(%ebp)
f0110e4d:	ff 75 f4             	pushl  -0xc(%ebp)
f0110e50:	50                   	push   %eax
f0110e51:	e8 ae 4a 00 00       	call   f0115904 <CP>
f0110e56:	83 c4 10             	add    $0x10,%esp
f0110e59:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110e5c:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110e60:	74 17                	je     f0110e79 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f0110e62:	83 ec 04             	sub    $0x4,%esp
f0110e65:	68 24 7d 12 f0       	push   $0xf0127d24
f0110e6a:	68 3a 01 00 00       	push   $0x13a
f0110e6f:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0110e74:	e8 c0 f4 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f0110e79:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f0110e80:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f0110e87:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110e8e:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0110e93:	ff 75 ec             	pushl  -0x14(%ebp)
f0110e96:	ff 75 f0             	pushl  -0x10(%ebp)
f0110e99:	ff 75 f4             	pushl  -0xc(%ebp)
f0110e9c:	50                   	push   %eax
f0110e9d:	e8 5c 82 ff ff       	call   f01090fe <pt_set_page_permissions>
f0110ea2:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110ea5:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0110eaa:	ff 75 ec             	pushl  -0x14(%ebp)
f0110ead:	ff 75 f0             	pushl  -0x10(%ebp)
f0110eb0:	ff 75 f4             	pushl  -0xc(%ebp)
f0110eb3:	50                   	push   %eax
f0110eb4:	e8 4b 4a 00 00       	call   f0115904 <CP>
f0110eb9:	83 c4 10             	add    $0x10,%esp
f0110ebc:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110ebf:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110ec3:	74 17                	je     f0110edc <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0110ec5:	83 ec 04             	sub    $0x4,%esp
f0110ec8:	68 48 7d 12 f0       	push   $0xf0127d48
f0110ecd:	68 46 01 00 00       	push   $0x146
f0110ed2:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0110ed7:	e8 5d f4 fe ff       	call   f0100339 <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0110edc:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0110ee3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0110eea:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110ef1:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0110ef6:	ff 75 ec             	pushl  -0x14(%ebp)
f0110ef9:	ff 75 f0             	pushl  -0x10(%ebp)
f0110efc:	ff 75 f4             	pushl  -0xc(%ebp)
f0110eff:	50                   	push   %eax
f0110f00:	e8 f9 81 ff ff       	call   f01090fe <pt_set_page_permissions>
f0110f05:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110f08:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0110f0d:	ff 75 ec             	pushl  -0x14(%ebp)
f0110f10:	ff 75 f0             	pushl  -0x10(%ebp)
f0110f13:	ff 75 f4             	pushl  -0xc(%ebp)
f0110f16:	50                   	push   %eax
f0110f17:	e8 e8 49 00 00       	call   f0115904 <CP>
f0110f1c:	83 c4 10             	add    $0x10,%esp
f0110f1f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110f22:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110f26:	74 17                	je     f0110f3f <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0110f28:	83 ec 04             	sub    $0x4,%esp
f0110f2b:	68 6c 7d 12 f0       	push   $0xf0127d6c
f0110f30:	68 52 01 00 00       	push   $0x152
f0110f35:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0110f3a:	e8 fa f3 fe ff       	call   f0100339 <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f0110f3f:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f0110f46:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f0110f4d:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110f54:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0110f59:	ff 75 ec             	pushl  -0x14(%ebp)
f0110f5c:	ff 75 f0             	pushl  -0x10(%ebp)
f0110f5f:	ff 75 f4             	pushl  -0xc(%ebp)
f0110f62:	50                   	push   %eax
f0110f63:	e8 96 81 ff ff       	call   f01090fe <pt_set_page_permissions>
f0110f68:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110f6b:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0110f70:	ff 75 ec             	pushl  -0x14(%ebp)
f0110f73:	ff 75 f0             	pushl  -0x10(%ebp)
f0110f76:	ff 75 f4             	pushl  -0xc(%ebp)
f0110f79:	50                   	push   %eax
f0110f7a:	e8 85 49 00 00       	call   f0115904 <CP>
f0110f7f:	83 c4 10             	add    $0x10,%esp
f0110f82:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0110f85:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0110f89:	74 17                	je     f0110fa2 <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f0110f8b:	83 ec 04             	sub    $0x4,%esp
f0110f8e:	68 90 7d 12 f0       	push   $0xf0127d90
f0110f93:	68 5e 01 00 00       	push   $0x15e
f0110f98:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0110f9d:	e8 97 f3 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0110fa2:	83 ec 0c             	sub    $0xc,%esp
f0110fa5:	68 bc 7d 12 f0       	push   $0xf0127dbc
f0110faa:	e8 dc ff fe ff       	call   f0100f8b <cprintf>
f0110faf:	83 c4 10             	add    $0x10,%esp
	return 0;
f0110fb2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110fb7:	c9                   	leave  
f0110fb8:	c3                   	ret    

f0110fb9 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0110fb9:	55                   	push   %ebp
f0110fba:	89 e5                	mov    %esp,%ebp
f0110fbc:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f0110fbf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0110fc6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0110fcd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0110fd4:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0110fd9:	ff 75 ec             	pushl  -0x14(%ebp)
f0110fdc:	ff 75 f0             	pushl  -0x10(%ebp)
f0110fdf:	ff 75 f4             	pushl  -0xc(%ebp)
f0110fe2:	50                   	push   %eax
f0110fe3:	e8 16 81 ff ff       	call   f01090fe <pt_set_page_permissions>
f0110fe8:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0110feb:	83 ec 04             	sub    $0x4,%esp
f0110fee:	68 0c 7e 12 f0       	push   $0xf0127e0c
f0110ff3:	68 6b 01 00 00       	push   $0x16b
f0110ff8:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0110ffd:	e8 37 f3 fe ff       	call   f0100339 <_panic>

f0111002 <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0111002:	55                   	push   %ebp
f0111003:	89 e5                	mov    %esp,%ebp
f0111005:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0111008:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f011100f:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0111014:	83 ec 08             	sub    $0x8,%esp
f0111017:	ff 75 f4             	pushl  -0xc(%ebp)
f011101a:	50                   	push   %eax
f011101b:	e8 a2 81 ff ff       	call   f01091c2 <pt_get_page_permissions>
f0111020:	83 c4 10             	add    $0x10,%esp
f0111023:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0111026:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f011102a:	74 17                	je     f0111043 <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f011102c:	83 ec 04             	sub    $0x4,%esp
f011102f:	68 a8 7e 12 f0       	push   $0xf0127ea8
f0111034:	68 79 01 00 00       	push   $0x179
f0111039:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011103e:	e8 f6 f2 fe ff       	call   f0100339 <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f0111043:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f011104a:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011104f:	83 ec 08             	sub    $0x8,%esp
f0111052:	ff 75 f4             	pushl  -0xc(%ebp)
f0111055:	50                   	push   %eax
f0111056:	e8 67 81 ff ff       	call   f01091c2 <pt_get_page_permissions>
f011105b:	83 c4 10             	add    $0x10,%esp
f011105e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f0111061:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111065:	74 17                	je     f011107e <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f0111067:	83 ec 04             	sub    $0x4,%esp
f011106a:	68 cc 7e 12 f0       	push   $0xf0127ecc
f011106f:	68 81 01 00 00       	push   $0x181
f0111074:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0111079:	e8 bb f2 fe ff       	call   f0100339 <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f011107e:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111085:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011108a:	83 ec 08             	sub    $0x8,%esp
f011108d:	ff 75 f4             	pushl  -0xc(%ebp)
f0111090:	50                   	push   %eax
f0111091:	e8 2c 81 ff ff       	call   f01091c2 <pt_get_page_permissions>
f0111096:	83 c4 10             	add    $0x10,%esp
f0111099:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f011109c:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f01110a0:	74 17                	je     f01110b9 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f01110a2:	83 ec 04             	sub    $0x4,%esp
f01110a5:	68 f0 7e 12 f0       	push   $0xf0127ef0
f01110aa:	68 89 01 00 00       	push   $0x189
f01110af:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01110b4:	e8 80 f2 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF1000000;
f01110b9:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01110c0:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f01110c5:	83 ec 08             	sub    $0x8,%esp
f01110c8:	ff 75 f4             	pushl  -0xc(%ebp)
f01110cb:	50                   	push   %eax
f01110cc:	e8 f1 80 ff ff       	call   f01091c2 <pt_get_page_permissions>
f01110d1:	83 c4 10             	add    $0x10,%esp
f01110d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f01110d7:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f01110db:	74 17                	je     f01110f4 <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f01110dd:	83 ec 04             	sub    $0x4,%esp
f01110e0:	68 14 7f 12 f0       	push   $0xf0127f14
f01110e5:	68 90 01 00 00       	push   $0x190
f01110ea:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01110ef:	e8 45 f2 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f01110f4:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01110fb:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0111100:	83 ec 08             	sub    $0x8,%esp
f0111103:	ff 75 f4             	pushl  -0xc(%ebp)
f0111106:	50                   	push   %eax
f0111107:	e8 b6 80 ff ff       	call   f01091c2 <pt_get_page_permissions>
f011110c:	83 c4 10             	add    $0x10,%esp
f011110f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0111112:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0111116:	74 17                	je     f011112f <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0111118:	83 ec 04             	sub    $0x4,%esp
f011111b:	68 38 7f 12 f0       	push   $0xf0127f38
f0111120:	68 97 01 00 00       	push   $0x197
f0111125:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011112a:	e8 0a f2 fe ff       	call   f0100339 <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f011112f:	83 ec 0c             	sub    $0xc,%esp
f0111132:	68 5c 7f 12 f0       	push   $0xf0127f5c
f0111137:	e8 4f fe fe ff       	call   f0100f8b <cprintf>
f011113c:	83 c4 10             	add    $0x10,%esp
	return 0;
f011113f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111144:	c9                   	leave  
f0111145:	c3                   	ret    

f0111146 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f0111146:	55                   	push   %ebp
f0111147:	89 e5                	mov    %esp,%ebp
f0111149:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f011114c:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111153:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0111158:	83 ec 08             	sub    $0x8,%esp
f011115b:	ff 75 f4             	pushl  -0xc(%ebp)
f011115e:	50                   	push   %eax
f011115f:	e8 a7 80 ff ff       	call   f010920b <pt_clear_page_table_entry>
f0111164:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f0111167:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011116c:	83 ec 08             	sub    $0x8,%esp
f011116f:	ff 75 f4             	pushl  -0xc(%ebp)
f0111172:	50                   	push   %eax
f0111173:	e8 e8 46 00 00       	call   f0115860 <CE>
f0111178:	83 c4 10             	add    $0x10,%esp
f011117b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011117e:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111182:	74 17                	je     f011119b <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f0111184:	83 ec 04             	sub    $0x4,%esp
f0111187:	68 a4 7f 12 f0       	push   $0xf0127fa4
f011118c:	68 a7 01 00 00       	push   $0x1a7
f0111191:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0111196:	e8 9e f1 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0001000;
f011119b:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01111a2:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f01111a7:	83 ec 08             	sub    $0x8,%esp
f01111aa:	ff 75 f4             	pushl  -0xc(%ebp)
f01111ad:	50                   	push   %eax
f01111ae:	e8 58 80 ff ff       	call   f010920b <pt_clear_page_table_entry>
f01111b3:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f01111b6:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f01111bb:	83 ec 08             	sub    $0x8,%esp
f01111be:	ff 75 f4             	pushl  -0xc(%ebp)
f01111c1:	50                   	push   %eax
f01111c2:	e8 99 46 00 00       	call   f0115860 <CE>
f01111c7:	83 c4 10             	add    $0x10,%esp
f01111ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01111cd:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01111d1:	74 17                	je     f01111ea <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f01111d3:	83 ec 04             	sub    $0x4,%esp
f01111d6:	68 d0 7f 12 f0       	push   $0xf0127fd0
f01111db:	68 af 01 00 00       	push   $0x1af
f01111e0:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01111e5:	e8 4f f1 fe ff       	call   f0100339 <_panic>
	}

	va = 0xEF800000;
f01111ea:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01111f1:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f01111f6:	83 ec 08             	sub    $0x8,%esp
f01111f9:	ff 75 f4             	pushl  -0xc(%ebp)
f01111fc:	50                   	push   %eax
f01111fd:	e8 09 80 ff ff       	call   f010920b <pt_clear_page_table_entry>
f0111202:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0111205:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011120a:	83 ec 08             	sub    $0x8,%esp
f011120d:	ff 75 f4             	pushl  -0xc(%ebp)
f0111210:	50                   	push   %eax
f0111211:	e8 4a 46 00 00       	call   f0115860 <CE>
f0111216:	83 c4 10             	add    $0x10,%esp
f0111219:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011121c:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111220:	74 17                	je     f0111239 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f0111222:	83 ec 04             	sub    $0x4,%esp
f0111225:	68 fc 7f 12 f0       	push   $0xf0127ffc
f011122a:	68 b7 01 00 00       	push   $0x1b7
f011122f:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0111234:	e8 00 f1 fe ff       	call   f0100339 <_panic>
	}

	va = 0xF0000000;
f0111239:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111240:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0111245:	83 ec 08             	sub    $0x8,%esp
f0111248:	ff 75 f4             	pushl  -0xc(%ebp)
f011124b:	50                   	push   %eax
f011124c:	e8 ba 7f ff ff       	call   f010920b <pt_clear_page_table_entry>
f0111251:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0111254:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0111259:	83 ec 08             	sub    $0x8,%esp
f011125c:	ff 75 f4             	pushl  -0xc(%ebp)
f011125f:	50                   	push   %eax
f0111260:	e8 fb 45 00 00       	call   f0115860 <CE>
f0111265:	83 c4 10             	add    $0x10,%esp
f0111268:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011126b:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011126f:	74 17                	je     f0111288 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f0111271:	83 ec 04             	sub    $0x4,%esp
f0111274:	68 28 80 12 f0       	push   $0xf0128028
f0111279:	68 bf 01 00 00       	push   $0x1bf
f011127e:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0111283:	e8 b1 f0 fe ff       	call   f0100339 <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f0111288:	83 ec 0c             	sub    $0xc,%esp
f011128b:	68 54 80 12 f0       	push   $0xf0128054
f0111290:	e8 f6 fc fe ff       	call   f0100f8b <cprintf>
f0111295:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111298:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011129d:	c9                   	leave  
f011129e:	c3                   	ret    

f011129f <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f011129f:	55                   	push   %ebp
f01112a0:	89 e5                	mov    %esp,%ebp
f01112a2:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f01112a5:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01112ac:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f01112b1:	83 ec 08             	sub    $0x8,%esp
f01112b4:	ff 75 f4             	pushl  -0xc(%ebp)
f01112b7:	50                   	push   %eax
f01112b8:	e8 4e 7f ff ff       	call   f010920b <pt_clear_page_table_entry>
f01112bd:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f01112c0:	83 ec 04             	sub    $0x4,%esp
f01112c3:	68 a0 80 12 f0       	push   $0xf01280a0
f01112c8:	68 ca 01 00 00       	push   $0x1ca
f01112cd:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01112d2:	e8 62 f0 fe ff       	call   f0100339 <_panic>

f01112d7 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f01112d7:	55                   	push   %ebp
f01112d8:	89 e5                	mov    %esp,%ebp
f01112da:	57                   	push   %edi
f01112db:	56                   	push   %esi
f01112dc:	53                   	push   %ebx
f01112dd:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01112e3:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01112e9:	bb e4 83 12 f0       	mov    $0xf01283e4,%ebx
f01112ee:	ba 0f 00 00 00       	mov    $0xf,%edx
f01112f3:	89 c7                	mov    %eax,%edi
f01112f5:	89 de                	mov    %ebx,%esi
f01112f7:	89 d1                	mov    %edx,%ecx
f01112f9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01112fb:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0111301:	b9 23 00 00 00       	mov    $0x23,%ecx
f0111306:	b0 00                	mov    $0x0,%al
f0111308:	89 d7                	mov    %edx,%edi
f011130a:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011130c:	6a 00                	push   $0x0
f011130e:	6a 0a                	push   $0xa
f0111310:	6a 14                	push   $0x14
f0111312:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0111318:	50                   	push   %eax
f0111319:	e8 bd 8e ff ff       	call   f010a1db <env_create>
f011131e:	83 c4 10             	add    $0x10,%esp
f0111321:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0111324:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111327:	8b 40 64             	mov    0x64(%eax),%eax
f011132a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f011132d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111330:	8b 40 68             	mov    0x68(%eax),%eax
f0111333:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0111336:	8b 45 90             	mov    -0x70(%ebp),%eax
f0111339:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011133c:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f0111343:	75 70 20 
f0111346:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f011134d:	00 00 00 
f0111350:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f0111356:	b9 03 00 00 00       	mov    $0x3,%ecx
f011135b:	b8 00 00 00 00       	mov    $0x0,%eax
f0111360:	89 d7                	mov    %edx,%edi
f0111362:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0111364:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111367:	8b 40 10             	mov    0x10(%eax),%eax
f011136a:	83 ec 08             	sub    $0x8,%esp
f011136d:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0111373:	52                   	push   %edx
f0111374:	50                   	push   %eax
f0111375:	e8 0b dd 00 00       	call   f011f085 <ltostr>
f011137a:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f011137d:	83 ec 04             	sub    $0x4,%esp
f0111380:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111386:	50                   	push   %eax
f0111387:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f011138d:	50                   	push   %eax
f011138e:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f0111394:	50                   	push   %eax
f0111395:	e8 c4 dd 00 00       	call   f011f15e <strcconcat>
f011139a:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f011139d:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f01113a4:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f01113ab:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f01113b2:	83 ec 0c             	sub    $0xc,%esp
f01113b5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01113b8:	e8 85 45 00 00       	call   f0115942 <ClearUserSpace>
f01113bd:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f01113c0:	83 ec 04             	sub    $0x4,%esp
f01113c3:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f01113c9:	50                   	push   %eax
f01113ca:	68 36 81 12 f0       	push   $0xf0128136
f01113cf:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01113d5:	50                   	push   %eax
f01113d6:	e8 83 dd 00 00       	call   f011f15e <strcconcat>
f01113db:	83 c4 10             	add    $0x10,%esp
f01113de:	83 ec 0c             	sub    $0xc,%esp
f01113e1:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f01113e7:	50                   	push   %eax
f01113e8:	e8 0e 0b ff ff       	call   f0101efb <execute_command>
f01113ed:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f01113f0:	83 ec 04             	sub    $0x4,%esp
f01113f3:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01113f9:	50                   	push   %eax
f01113fa:	68 41 81 12 f0       	push   $0xf0128141
f01113ff:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111405:	50                   	push   %eax
f0111406:	e8 53 dd 00 00       	call   f011f15e <strcconcat>
f011140b:	83 c4 10             	add    $0x10,%esp
f011140e:	83 ec 0c             	sub    $0xc,%esp
f0111411:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0111417:	50                   	push   %eax
f0111418:	e8 de 0a ff ff       	call   f0101efb <execute_command>
f011141d:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f0111420:	83 ec 04             	sub    $0x4,%esp
f0111423:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0111429:	50                   	push   %eax
f011142a:	68 4c 81 12 f0       	push   $0xf012814c
f011142f:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111435:	50                   	push   %eax
f0111436:	e8 23 dd 00 00       	call   f011f15e <strcconcat>
f011143b:	83 c4 10             	add    $0x10,%esp
f011143e:	83 ec 0c             	sub    $0xc,%esp
f0111441:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0111447:	50                   	push   %eax
f0111448:	e8 ae 0a ff ff       	call   f0101efb <execute_command>
f011144d:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f0111450:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f0111457:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011145a:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f011145d:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f0111464:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111467:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f011146a:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f0111471:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111474:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f0111477:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011147a:	83 ec 08             	sub    $0x8,%esp
f011147d:	50                   	push   %eax
f011147e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111481:	e8 9d 44 00 00       	call   f0115923 <GP>
f0111486:	83 c4 10             	add    $0x10,%esp
f0111489:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f011148c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f0111493:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f011149a:	e8 d6 c5 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011149f:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f01114a2:	83 ec 0c             	sub    $0xc,%esp
f01114a5:	68 58 81 12 f0       	push   $0xf0128158
f01114aa:	e8 dc fa fe ff       	call   f0100f8b <cprintf>
f01114af:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f01114b2:	6a 03                	push   $0x3
f01114b4:	68 00 00 90 02       	push   $0x2900000
f01114b9:	68 00 00 80 02       	push   $0x2800000
f01114be:	ff 75 d4             	pushl  -0x2c(%ebp)
f01114c1:	e8 68 8a ff ff       	call   f0109f2e <cut_paste_pages>
f01114c6:	83 c4 10             	add    $0x10,%esp
f01114c9:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f01114cc:	e8 a4 c5 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01114d1:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f01114d4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f01114db:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f01114df:	75 08                	jne    f01114e9 <test_cut_paste_pages+0x212>
f01114e1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01114e4:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01114e7:	74 2b                	je     f0111514 <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f01114e9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01114ec:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01114ef:	83 ec 0c             	sub    $0xc,%esp
f01114f2:	50                   	push   %eax
f01114f3:	ff 75 b4             	pushl  -0x4c(%ebp)
f01114f6:	68 88 81 12 f0       	push   $0xf0128188
f01114fb:	68 04 02 00 00       	push   $0x204
f0111500:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0111505:	e8 cc ef fe ff       	call   f01004d6 <_warn>
f011150a:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f011150d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f0111514:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111518:	74 04                	je     f011151e <test_cut_paste_pages+0x247>
f011151a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f011151e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0111525:	83 ec 08             	sub    $0x8,%esp
f0111528:	6a 00                	push   $0x0
f011152a:	6a 01                	push   $0x1
f011152c:	6a 00                	push   $0x0
f011152e:	68 ff 0f 00 00       	push   $0xfff
f0111533:	ff 75 bc             	pushl  -0x44(%ebp)
f0111536:	6a 01                	push   $0x1
f0111538:	68 00 30 00 00       	push   $0x3000
f011153d:	68 00 00 90 02       	push   $0x2900000
f0111542:	68 00 00 80 02       	push   $0x2800000
f0111547:	ff 75 d4             	pushl  -0x2c(%ebp)
f011154a:	e8 27 44 00 00       	call   f0115976 <CCP>
f011154f:	83 c4 30             	add    $0x30,%esp
f0111552:	83 f8 01             	cmp    $0x1,%eax
f0111555:	74 21                	je     f0111578 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0111557:	83 ec 04             	sub    $0x4,%esp
f011155a:	68 dc 81 12 f0       	push   $0xf01281dc
f011155f:	68 0c 02 00 00       	push   $0x20c
f0111564:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0111569:	e8 68 ef fe ff       	call   f01004d6 <_warn>
f011156e:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0111571:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f0111578:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011157c:	74 04                	je     f0111582 <test_cut_paste_pages+0x2ab>
f011157e:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f0111582:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f0111589:	83 ec 04             	sub    $0x4,%esp
f011158c:	6a 00                	push   $0x0
f011158e:	68 00 00 90 02       	push   $0x2900000
f0111593:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111596:	e8 b7 41 00 00       	call   f0115752 <CB>
f011159b:	83 c4 10             	add    $0x10,%esp
f011159e:	85 c0                	test   %eax,%eax
f01115a0:	0f 84 f6 00 00 00    	je     f011169c <test_cut_paste_pages+0x3c5>
f01115a6:	83 ec 04             	sub    $0x4,%esp
f01115a9:	6a 00                	push   $0x0
f01115ab:	68 00 10 90 02       	push   $0x2901000
f01115b0:	ff 75 d4             	pushl  -0x2c(%ebp)
f01115b3:	e8 9a 41 00 00       	call   f0115752 <CB>
f01115b8:	83 c4 10             	add    $0x10,%esp
f01115bb:	85 c0                	test   %eax,%eax
f01115bd:	0f 84 d9 00 00 00    	je     f011169c <test_cut_paste_pages+0x3c5>
f01115c3:	83 ec 04             	sub    $0x4,%esp
f01115c6:	6a 00                	push   $0x0
f01115c8:	68 00 20 90 02       	push   $0x2902000
f01115cd:	ff 75 d4             	pushl  -0x2c(%ebp)
f01115d0:	e8 7d 41 00 00       	call   f0115752 <CB>
f01115d5:	83 c4 10             	add    $0x10,%esp
f01115d8:	85 c0                	test   %eax,%eax
f01115da:	0f 84 bc 00 00 00    	je     f011169c <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f01115e0:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f01115e7:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f01115ee:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f01115f5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01115f8:	8a 00                	mov    (%eax),%al
f01115fa:	3c 61                	cmp    $0x61,%al
f01115fc:	75 12                	jne    f0111610 <test_cut_paste_pages+0x339>
f01115fe:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111601:	8a 00                	mov    (%eax),%al
f0111603:	3c 62                	cmp    $0x62,%al
f0111605:	75 09                	jne    f0111610 <test_cut_paste_pages+0x339>
f0111607:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011160a:	8a 00                	mov    (%eax),%al
f011160c:	3c 63                	cmp    $0x63,%al
f011160e:	74 21                	je     f0111631 <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0111610:	83 ec 04             	sub    $0x4,%esp
f0111613:	68 28 82 12 f0       	push   $0xf0128228
f0111618:	68 19 02 00 00       	push   $0x219
f011161d:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0111622:	e8 af ee fe ff       	call   f01004d6 <_warn>
f0111627:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011162a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0111631:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111635:	74 04                	je     f011163b <test_cut_paste_pages+0x364>
f0111637:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011163b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f0111642:	83 ec 04             	sub    $0x4,%esp
f0111645:	6a 01                	push   $0x1
f0111647:	68 00 10 90 02       	push   $0x2901000
f011164c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011164f:	e8 fe 40 00 00       	call   f0115752 <CB>
f0111654:	83 c4 10             	add    $0x10,%esp
f0111657:	85 c0                	test   %eax,%eax
f0111659:	74 41                	je     f011169c <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f011165b:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011165e:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f0111661:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111664:	8a 00                	mov    (%eax),%al
f0111666:	3c 79                	cmp    $0x79,%al
f0111668:	74 21                	je     f011168b <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011166a:	83 ec 04             	sub    $0x4,%esp
f011166d:	68 28 82 12 f0       	push   $0xf0128228
f0111672:	68 24 02 00 00       	push   $0x224
f0111677:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011167c:	e8 55 ee fe ff       	call   f01004d6 <_warn>
f0111681:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0111684:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f011168b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011168f:	74 04                	je     f0111695 <test_cut_paste_pages+0x3be>
f0111691:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0111695:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f011169c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011169f:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f01116a2:	6a 02                	push   $0x2
f01116a4:	68 00 f0 bf 02       	push   $0x2bff000
f01116a9:	68 00 10 90 02       	push   $0x2901000
f01116ae:	ff 75 d4             	pushl  -0x2c(%ebp)
f01116b1:	e8 78 88 ff ff       	call   f0109f2e <cut_paste_pages>
f01116b6:	83 c4 10             	add    $0x10,%esp
f01116b9:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f01116bc:	e8 b4 c3 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01116c1:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f01116c4:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f01116c8:	75 0b                	jne    f01116d5 <test_cut_paste_pages+0x3fe>
f01116ca:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01116cd:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01116d0:	83 f8 01             	cmp    $0x1,%eax
f01116d3:	74 2b                	je     f0111700 <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f01116d5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01116d8:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01116db:	83 ec 0c             	sub    $0xc,%esp
f01116de:	50                   	push   %eax
f01116df:	ff 75 b4             	pushl  -0x4c(%ebp)
f01116e2:	68 88 81 12 f0       	push   $0xf0128188
f01116e7:	68 35 02 00 00       	push   $0x235
f01116ec:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01116f1:	e8 e0 ed fe ff       	call   f01004d6 <_warn>
f01116f6:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01116f9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0111700:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111704:	74 04                	je     f011170a <test_cut_paste_pages+0x433>
f0111706:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f011170a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0111711:	83 ec 08             	sub    $0x8,%esp
f0111714:	6a 00                	push   $0x0
f0111716:	6a 01                	push   $0x1
f0111718:	6a 00                	push   $0x0
f011171a:	68 ff 0f 00 00       	push   $0xfff
f011171f:	ff 75 bc             	pushl  -0x44(%ebp)
f0111722:	6a 01                	push   $0x1
f0111724:	68 00 20 00 00       	push   $0x2000
f0111729:	68 00 f0 bf 02       	push   $0x2bff000
f011172e:	68 00 10 90 02       	push   $0x2901000
f0111733:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111736:	e8 3b 42 00 00       	call   f0115976 <CCP>
f011173b:	83 c4 30             	add    $0x30,%esp
f011173e:	83 f8 01             	cmp    $0x1,%eax
f0111741:	74 21                	je     f0111764 <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0111743:	83 ec 04             	sub    $0x4,%esp
f0111746:	68 dc 81 12 f0       	push   $0xf01281dc
f011174b:	68 3d 02 00 00       	push   $0x23d
f0111750:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0111755:	e8 7c ed fe ff       	call   f01004d6 <_warn>
f011175a:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f011175d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0111764:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111768:	74 04                	je     f011176e <test_cut_paste_pages+0x497>
f011176a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f011176e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f0111775:	83 ec 04             	sub    $0x4,%esp
f0111778:	6a 00                	push   $0x0
f011177a:	68 ff f7 bf 02       	push   $0x2bff7ff
f011177f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111782:	e8 cb 3f 00 00       	call   f0115752 <CB>
f0111787:	83 c4 10             	add    $0x10,%esp
f011178a:	85 c0                	test   %eax,%eax
f011178c:	74 6b                	je     f01117f9 <test_cut_paste_pages+0x522>
f011178e:	83 ec 04             	sub    $0x4,%esp
f0111791:	6a 00                	push   $0x0
f0111793:	68 ff 0f c0 02       	push   $0x2c00fff
f0111798:	ff 75 d4             	pushl  -0x2c(%ebp)
f011179b:	e8 b2 3f 00 00       	call   f0115752 <CB>
f01117a0:	83 c4 10             	add    $0x10,%esp
f01117a3:	85 c0                	test   %eax,%eax
f01117a5:	74 52                	je     f01117f9 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f01117a7:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f01117ae:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f01117b5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01117b8:	8a 00                	mov    (%eax),%al
f01117ba:	3c 79                	cmp    $0x79,%al
f01117bc:	75 09                	jne    f01117c7 <test_cut_paste_pages+0x4f0>
f01117be:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01117c1:	8a 00                	mov    (%eax),%al
f01117c3:	3c 63                	cmp    $0x63,%al
f01117c5:	74 21                	je     f01117e8 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01117c7:	83 ec 04             	sub    $0x4,%esp
f01117ca:	68 28 82 12 f0       	push   $0xf0128228
f01117cf:	68 49 02 00 00       	push   $0x249
f01117d4:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01117d9:	e8 f8 ec fe ff       	call   f01004d6 <_warn>
f01117de:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01117e1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01117e8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01117ec:	74 04                	je     f01117f2 <test_cut_paste_pages+0x51b>
f01117ee:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01117f2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f01117f9:	83 ec 0c             	sub    $0xc,%esp
f01117fc:	68 61 82 12 f0       	push   $0xf0128261
f0111801:	e8 85 f7 fe ff       	call   f0100f8b <cprintf>
f0111806:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0111809:	83 ec 0c             	sub    $0xc,%esp
f011180c:	68 70 82 12 f0       	push   $0xf0128270
f0111811:	e8 75 f7 fe ff       	call   f0100f8b <cprintf>
f0111816:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f0111819:	83 ec 04             	sub    $0x4,%esp
f011181c:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0111822:	50                   	push   %eax
f0111823:	68 99 82 12 f0       	push   $0xf0128299
f0111828:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011182e:	50                   	push   %eax
f011182f:	e8 2a d9 00 00       	call   f011f15e <strcconcat>
f0111834:	83 c4 10             	add    $0x10,%esp
f0111837:	83 ec 0c             	sub    $0xc,%esp
f011183a:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0111840:	50                   	push   %eax
f0111841:	e8 b5 06 ff ff       	call   f0101efb <execute_command>
f0111846:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f0111849:	83 ec 04             	sub    $0x4,%esp
f011184c:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0111852:	50                   	push   %eax
f0111853:	68 a4 82 12 f0       	push   $0xf01282a4
f0111858:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011185e:	50                   	push   %eax
f011185f:	e8 fa d8 00 00       	call   f011f15e <strcconcat>
f0111864:	83 c4 10             	add    $0x10,%esp
f0111867:	83 ec 0c             	sub    $0xc,%esp
f011186a:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0111870:	50                   	push   %eax
f0111871:	e8 85 06 ff ff       	call   f0101efb <execute_command>
f0111876:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f0111879:	83 ec 04             	sub    $0x4,%esp
f011187c:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0111882:	50                   	push   %eax
f0111883:	68 af 82 12 f0       	push   $0xf01282af
f0111888:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011188e:	50                   	push   %eax
f011188f:	e8 ca d8 00 00       	call   f011f15e <strcconcat>
f0111894:	83 c4 10             	add    $0x10,%esp
f0111897:	83 ec 0c             	sub    $0xc,%esp
f011189a:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f01118a0:	50                   	push   %eax
f01118a1:	e8 55 06 ff ff       	call   f0101efb <execute_command>
f01118a6:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f01118a9:	83 ec 04             	sub    $0x4,%esp
f01118ac:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f01118b2:	50                   	push   %eax
f01118b3:	68 ba 82 12 f0       	push   $0xf01282ba
f01118b8:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01118be:	50                   	push   %eax
f01118bf:	e8 9a d8 00 00       	call   f011f15e <strcconcat>
f01118c4:	83 c4 10             	add    $0x10,%esp
f01118c7:	83 ec 0c             	sub    $0xc,%esp
f01118ca:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f01118d0:	50                   	push   %eax
f01118d1:	e8 25 06 ff ff       	call   f0101efb <execute_command>
f01118d6:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f01118d9:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f01118e0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01118e3:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f01118e6:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f01118ed:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01118f0:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f01118f3:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f01118fa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01118fd:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f0111900:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0111907:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011190a:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f011190d:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f0111914:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111917:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f011191a:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f0111921:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111924:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f0111927:	83 ec 08             	sub    $0x8,%esp
f011192a:	68 00 00 c0 01       	push   $0x1c00000
f011192f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111932:	e8 ec 3f 00 00       	call   f0115923 <GP>
f0111937:	83 c4 10             	add    $0x10,%esp
f011193a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f011193d:	83 ec 08             	sub    $0x8,%esp
f0111940:	68 00 00 40 01       	push   $0x1400000
f0111945:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111948:	e8 d6 3f 00 00       	call   f0115923 <GP>
f011194d:	83 c4 10             	add    $0x10,%esp
f0111950:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f0111953:	e8 1d c1 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0111958:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f011195b:	6a 01                	push   $0x1
f011195d:	68 00 00 40 01       	push   $0x1400000
f0111962:	68 00 00 c0 01       	push   $0x1c00000
f0111967:	ff 75 d4             	pushl  -0x2c(%ebp)
f011196a:	e8 bf 85 ff ff       	call   f0109f2e <cut_paste_pages>
f011196f:	83 c4 10             	add    $0x10,%esp
f0111972:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0111975:	e8 fb c0 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011197a:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f011197d:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0111981:	75 08                	jne    f011198b <test_cut_paste_pages+0x6b4>
f0111983:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111986:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0111989:	74 2b                	je     f01119b6 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f011198b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011198e:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0111991:	83 ec 0c             	sub    $0xc,%esp
f0111994:	50                   	push   %eax
f0111995:	ff 75 b4             	pushl  -0x4c(%ebp)
f0111998:	68 c8 82 12 f0       	push   $0xf01282c8
f011199d:	68 6c 02 00 00       	push   $0x26c
f01119a2:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01119a7:	e8 2a eb fe ff       	call   f01004d6 <_warn>
f01119ac:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01119af:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01119b6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01119ba:	74 04                	je     f01119c0 <test_cut_paste_pages+0x6e9>
f01119bc:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01119c0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f01119c7:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f01119ce:	83 ec 08             	sub    $0x8,%esp
f01119d1:	6a 00                	push   $0x0
f01119d3:	68 ff 0f 00 00       	push   $0xfff
f01119d8:	ff 75 a4             	pushl  -0x5c(%ebp)
f01119db:	68 ff 0f 00 00       	push   $0xfff
f01119e0:	ff 75 a0             	pushl  -0x60(%ebp)
f01119e3:	6a 01                	push   $0x1
f01119e5:	68 00 10 00 00       	push   $0x1000
f01119ea:	68 00 00 40 01       	push   $0x1400000
f01119ef:	68 00 00 c0 01       	push   $0x1c00000
f01119f4:	ff 75 d4             	pushl  -0x2c(%ebp)
f01119f7:	e8 7a 3f 00 00       	call   f0115976 <CCP>
f01119fc:	83 c4 30             	add    $0x30,%esp
f01119ff:	83 f8 01             	cmp    $0x1,%eax
f0111a02:	74 28                	je     f0111a2c <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0111a04:	83 ec 04             	sub    $0x4,%esp
f0111a07:	68 dc 81 12 f0       	push   $0xf01281dc
f0111a0c:	68 75 02 00 00       	push   $0x275
f0111a11:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0111a16:	e8 bb ea fe ff       	call   f01004d6 <_warn>
f0111a1b:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0111a1e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0111a25:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0111a2c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111a30:	74 04                	je     f0111a36 <test_cut_paste_pages+0x75f>
f0111a32:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0111a36:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0111a3d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0111a41:	0f 84 92 00 00 00    	je     f0111ad9 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f0111a47:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0111a4e:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0111a55:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0111a5c:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0111a63:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0111a6a:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0111a71:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111a74:	8a 00                	mov    (%eax),%al
f0111a76:	3c 61                	cmp    $0x61,%al
f0111a78:	75 2d                	jne    f0111aa7 <test_cut_paste_pages+0x7d0>
f0111a7a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111a7d:	8a 00                	mov    (%eax),%al
f0111a7f:	3c 78                	cmp    $0x78,%al
f0111a81:	75 24                	jne    f0111aa7 <test_cut_paste_pages+0x7d0>
f0111a83:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0111a86:	8a 00                	mov    (%eax),%al
f0111a88:	3c 62                	cmp    $0x62,%al
f0111a8a:	75 1b                	jne    f0111aa7 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0111a8c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0111a8f:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0111a91:	3c 79                	cmp    $0x79,%al
f0111a93:	75 12                	jne    f0111aa7 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0111a95:	8b 45 98             	mov    -0x68(%ebp),%eax
f0111a98:	8a 00                	mov    (%eax),%al
f0111a9a:	3c 63                	cmp    $0x63,%al
f0111a9c:	75 09                	jne    f0111aa7 <test_cut_paste_pages+0x7d0>
f0111a9e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0111aa1:	8a 00                	mov    (%eax),%al
f0111aa3:	3c 7a                	cmp    $0x7a,%al
f0111aa5:	74 21                	je     f0111ac8 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0111aa7:	83 ec 04             	sub    $0x4,%esp
f0111aaa:	68 28 82 12 f0       	push   $0xf0128228
f0111aaf:	68 87 02 00 00       	push   $0x287
f0111ab4:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0111ab9:	e8 18 ea fe ff       	call   f01004d6 <_warn>
f0111abe:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0111ac1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0111ac8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111acc:	74 04                	je     f0111ad2 <test_cut_paste_pages+0x7fb>
f0111ace:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0111ad2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0111ad9:	e8 97 bf ff ff       	call   f010da75 <sys_calculate_free_frames>
f0111ade:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f0111ae1:	6a 03                	push   $0x3
f0111ae3:	68 00 f0 bf 01       	push   $0x1bff000
f0111ae8:	68 00 00 40 01       	push   $0x1400000
f0111aed:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111af0:	e8 39 84 ff ff       	call   f0109f2e <cut_paste_pages>
f0111af5:	83 c4 10             	add    $0x10,%esp
f0111af8:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0111afb:	e8 75 bf ff ff       	call   f010da75 <sys_calculate_free_frames>
f0111b00:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0111b03:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0111b07:	75 08                	jne    f0111b11 <test_cut_paste_pages+0x83a>
f0111b09:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111b0c:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0111b0f:	74 2b                	je     f0111b3c <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0111b11:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111b14:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0111b17:	83 ec 0c             	sub    $0xc,%esp
f0111b1a:	50                   	push   %eax
f0111b1b:	ff 75 b4             	pushl  -0x4c(%ebp)
f0111b1e:	68 c8 82 12 f0       	push   $0xf01282c8
f0111b23:	68 96 02 00 00       	push   $0x296
f0111b28:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0111b2d:	e8 a4 e9 fe ff       	call   f01004d6 <_warn>
f0111b32:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0111b35:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0111b3c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111b40:	74 04                	je     f0111b46 <test_cut_paste_pages+0x86f>
f0111b42:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0111b46:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f0111b4d:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0111b54:	83 ec 04             	sub    $0x4,%esp
f0111b57:	6a 00                	push   $0x0
f0111b59:	68 00 00 40 01       	push   $0x1400000
f0111b5e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111b61:	e8 ec 3b 00 00       	call   f0115752 <CB>
f0111b66:	83 c4 10             	add    $0x10,%esp
f0111b69:	83 f8 01             	cmp    $0x1,%eax
f0111b6c:	0f 85 80 00 00 00    	jne    f0111bf2 <test_cut_paste_pages+0x91b>
f0111b72:	83 ec 04             	sub    $0x4,%esp
f0111b75:	6a 00                	push   $0x0
f0111b77:	68 00 10 40 01       	push   $0x1401000
f0111b7c:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111b7f:	e8 ce 3b 00 00       	call   f0115752 <CB>
f0111b84:	83 c4 10             	add    $0x10,%esp
f0111b87:	83 f8 01             	cmp    $0x1,%eax
f0111b8a:	75 66                	jne    f0111bf2 <test_cut_paste_pages+0x91b>
f0111b8c:	83 ec 04             	sub    $0x4,%esp
f0111b8f:	6a 00                	push   $0x0
f0111b91:	68 00 20 40 01       	push   $0x1402000
f0111b96:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111b99:	e8 b4 3b 00 00       	call   f0115752 <CB>
f0111b9e:	83 c4 10             	add    $0x10,%esp
f0111ba1:	83 f8 01             	cmp    $0x1,%eax
f0111ba4:	75 4c                	jne    f0111bf2 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0111ba6:	83 ec 04             	sub    $0x4,%esp
f0111ba9:	6a 00                	push   $0x0
f0111bab:	68 00 f0 bf 01       	push   $0x1bff000
f0111bb0:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111bb3:	e8 9a 3b 00 00       	call   f0115752 <CB>
f0111bb8:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0111bbb:	85 c0                	test   %eax,%eax
f0111bbd:	75 33                	jne    f0111bf2 <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0111bbf:	83 ec 04             	sub    $0x4,%esp
f0111bc2:	6a 00                	push   $0x0
f0111bc4:	68 00 00 c0 01       	push   $0x1c00000
f0111bc9:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111bcc:	e8 81 3b 00 00       	call   f0115752 <CB>
f0111bd1:	83 c4 10             	add    $0x10,%esp
f0111bd4:	83 f8 01             	cmp    $0x1,%eax
f0111bd7:	75 19                	jne    f0111bf2 <test_cut_paste_pages+0x91b>
f0111bd9:	83 ec 04             	sub    $0x4,%esp
f0111bdc:	6a 00                	push   $0x0
f0111bde:	68 00 10 c0 01       	push   $0x1c01000
f0111be3:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111be6:	e8 67 3b 00 00       	call   f0115752 <CB>
f0111beb:	83 c4 10             	add    $0x10,%esp
f0111bee:	85 c0                	test   %eax,%eax
f0111bf0:	74 28                	je     f0111c1a <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f0111bf2:	83 ec 04             	sub    $0x4,%esp
f0111bf5:	68 28 83 12 f0       	push   $0xf0128328
f0111bfa:	68 9f 02 00 00       	push   $0x29f
f0111bff:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0111c04:	e8 cd e8 fe ff       	call   f01004d6 <_warn>
f0111c09:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0111c0c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0111c13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0111c1a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111c1e:	74 04                	je     f0111c24 <test_cut_paste_pages+0x94d>
f0111c20:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0111c24:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0111c2b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0111c2f:	0f 84 99 00 00 00    	je     f0111cce <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0111c35:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0111c3c:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0111c43:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0111c4a:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0111c51:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0111c58:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0111c5f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0111c62:	8a 00                	mov    (%eax),%al
f0111c64:	3c 61                	cmp    $0x61,%al
f0111c66:	75 2d                	jne    f0111c95 <test_cut_paste_pages+0x9be>
f0111c68:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0111c6b:	8a 00                	mov    (%eax),%al
f0111c6d:	3c 78                	cmp    $0x78,%al
f0111c6f:	75 24                	jne    f0111c95 <test_cut_paste_pages+0x9be>
f0111c71:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0111c74:	8a 00                	mov    (%eax),%al
f0111c76:	3c 62                	cmp    $0x62,%al
f0111c78:	75 1b                	jne    f0111c95 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0111c7a:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0111c7d:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0111c7f:	3c 79                	cmp    $0x79,%al
f0111c81:	75 12                	jne    f0111c95 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0111c83:	8b 45 98             	mov    -0x68(%ebp),%eax
f0111c86:	8a 00                	mov    (%eax),%al
f0111c88:	3c 63                	cmp    $0x63,%al
f0111c8a:	75 09                	jne    f0111c95 <test_cut_paste_pages+0x9be>
f0111c8c:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0111c8f:	8a 00                	mov    (%eax),%al
f0111c91:	3c 7a                	cmp    $0x7a,%al
f0111c93:	74 28                	je     f0111cbd <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0111c95:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0111c9c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0111ca3:	83 ec 04             	sub    $0x4,%esp
f0111ca6:	68 28 82 12 f0       	push   $0xf0128228
f0111cab:	68 b3 02 00 00       	push   $0x2b3
f0111cb0:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0111cb5:	e8 1c e8 fe ff       	call   f01004d6 <_warn>
f0111cba:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f0111cbd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111cc1:	74 04                	je     f0111cc7 <test_cut_paste_pages+0x9f0>
f0111cc3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0111cc7:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f0111cce:	83 ec 0c             	sub    $0xc,%esp
f0111cd1:	68 61 83 12 f0       	push   $0xf0128361
f0111cd6:	e8 b0 f2 fe ff       	call   f0100f8b <cprintf>
f0111cdb:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f0111cde:	83 ec 08             	sub    $0x8,%esp
f0111ce1:	ff 75 e4             	pushl  -0x1c(%ebp)
f0111ce4:	68 70 83 12 f0       	push   $0xf0128370
f0111ce9:	e8 9d f2 fe ff       	call   f0100f8b <cprintf>
f0111cee:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0111cf1:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0111cf5:	75 10                	jne    f0111d07 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f0111cf7:	83 ec 0c             	sub    $0xc,%esp
f0111cfa:	68 a4 83 12 f0       	push   $0xf01283a4
f0111cff:	e8 87 f2 fe ff       	call   f0100f8b <cprintf>
f0111d04:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0111d07:	a1 24 cc 5e f0       	mov    0xf05ecc24,%eax
f0111d0c:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0111d0f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111d12:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0111d15:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111d1a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0111d1d:	5b                   	pop    %ebx
f0111d1e:	5e                   	pop    %esi
f0111d1f:	5f                   	pop    %edi
f0111d20:	5d                   	pop    %ebp
f0111d21:	c3                   	ret    

f0111d22 <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f0111d22:	55                   	push   %ebp
f0111d23:	89 e5                	mov    %esp,%ebp
f0111d25:	57                   	push   %edi
f0111d26:	56                   	push   %esi
f0111d27:	53                   	push   %ebx
f0111d28:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0111d2e:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0111d34:	bb e4 83 12 f0       	mov    $0xf01283e4,%ebx
f0111d39:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111d3e:	89 c7                	mov    %eax,%edi
f0111d40:	89 de                	mov    %ebx,%esi
f0111d42:	89 d1                	mov    %edx,%ecx
f0111d44:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111d46:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0111d4c:	b9 23 00 00 00       	mov    $0x23,%ecx
f0111d51:	b0 00                	mov    $0x0,%al
f0111d53:	89 d7                	mov    %edx,%edi
f0111d55:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0111d57:	6a 00                	push   $0x0
f0111d59:	6a 0a                	push   $0xa
f0111d5b:	6a 14                	push   $0x14
f0111d5d:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0111d63:	50                   	push   %eax
f0111d64:	e8 72 84 ff ff       	call   f010a1db <env_create>
f0111d69:	83 c4 10             	add    $0x10,%esp
f0111d6c:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0111d6f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111d72:	8b 40 64             	mov    0x64(%eax),%eax
f0111d75:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0111d78:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111d7b:	8b 40 68             	mov    0x68(%eax),%eax
f0111d7e:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0111d84:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0111d8a:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0111d8d:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f0111d94:	75 70 20 
f0111d97:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f0111d9e:	00 00 00 
f0111da1:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0111da7:	b9 03 00 00 00       	mov    $0x3,%ecx
f0111dac:	b8 00 00 00 00       	mov    $0x0,%eax
f0111db1:	89 d7                	mov    %edx,%edi
f0111db3:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0111db5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111db8:	8b 40 10             	mov    0x10(%eax),%eax
f0111dbb:	83 ec 08             	sub    $0x8,%esp
f0111dbe:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0111dc4:	52                   	push   %edx
f0111dc5:	50                   	push   %eax
f0111dc6:	e8 ba d2 00 00       	call   f011f085 <ltostr>
f0111dcb:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0111dce:	83 ec 04             	sub    $0x4,%esp
f0111dd1:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0111dd7:	50                   	push   %eax
f0111dd8:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f0111dde:	50                   	push   %eax
f0111ddf:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0111de5:	50                   	push   %eax
f0111de6:	e8 73 d3 00 00       	call   f011f15e <strcconcat>
f0111deb:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f0111dee:	83 ec 0c             	sub    $0xc,%esp
f0111df1:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111df4:	e8 49 3b 00 00       	call   f0115942 <ClearUserSpace>
f0111df9:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0111dfc:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0111e03:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0111e0a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0111e11:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0111e18:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0111e1f:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0111e26:	83 ec 0c             	sub    $0xc,%esp
f0111e29:	68 18 84 12 f0       	push   $0xf0128418
f0111e2e:	e8 58 f1 fe ff       	call   f0100f8b <cprintf>
f0111e33:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0111e36:	83 ec 04             	sub    $0x4,%esp
f0111e39:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111e3f:	50                   	push   %eax
f0111e40:	68 4e 84 12 f0       	push   $0xf012844e
f0111e45:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0111e4b:	50                   	push   %eax
f0111e4c:	e8 0d d3 00 00       	call   f011f15e <strcconcat>
f0111e51:	83 c4 10             	add    $0x10,%esp
f0111e54:	83 ec 0c             	sub    $0xc,%esp
f0111e57:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111e5d:	50                   	push   %eax
f0111e5e:	e8 98 00 ff ff       	call   f0101efb <execute_command>
f0111e63:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0111e66:	83 ec 04             	sub    $0x4,%esp
f0111e69:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111e6f:	50                   	push   %eax
f0111e70:	68 53 84 12 f0       	push   $0xf0128453
f0111e75:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0111e7b:	50                   	push   %eax
f0111e7c:	e8 dd d2 00 00       	call   f011f15e <strcconcat>
f0111e81:	83 c4 10             	add    $0x10,%esp
f0111e84:	83 ec 0c             	sub    $0xc,%esp
f0111e87:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0111e8d:	50                   	push   %eax
f0111e8e:	e8 68 00 ff ff       	call   f0101efb <execute_command>
f0111e93:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0111e96:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0111e9c:	bb 59 87 12 f0       	mov    $0xf0128759,%ebx
f0111ea1:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111ea6:	89 c7                	mov    %eax,%edi
f0111ea8:	89 de                	mov    %ebx,%esi
f0111eaa:	89 d1                	mov    %edx,%ecx
f0111eac:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111eae:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0111eb4:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111eb9:	b0 00                	mov    $0x0,%al
f0111ebb:	89 d7                	mov    %edx,%edi
f0111ebd:	f3 aa                	rep stos %al,%es:(%edi)
f0111ebf:	83 ec 0c             	sub    $0xc,%esp
f0111ec2:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0111ec8:	50                   	push   %eax
f0111ec9:	e8 2d 00 ff ff       	call   f0101efb <execute_command>
f0111ece:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f0111ed1:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0111ed7:	bb bd 87 12 f0       	mov    $0xf01287bd,%ebx
f0111edc:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111ee1:	89 c7                	mov    %eax,%edi
f0111ee3:	89 de                	mov    %ebx,%esi
f0111ee5:	89 d1                	mov    %edx,%ecx
f0111ee7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111ee9:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0111eef:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111ef4:	b0 00                	mov    $0x0,%al
f0111ef6:	89 d7                	mov    %edx,%edi
f0111ef8:	f3 aa                	rep stos %al,%es:(%edi)
f0111efa:	83 ec 0c             	sub    $0xc,%esp
f0111efd:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0111f03:	50                   	push   %eax
f0111f04:	e8 f2 ff fe ff       	call   f0101efb <execute_command>
f0111f09:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0111f0c:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0111f12:	bb 21 88 12 f0       	mov    $0xf0128821,%ebx
f0111f17:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111f1c:	89 c7                	mov    %eax,%edi
f0111f1e:	89 de                	mov    %ebx,%esi
f0111f20:	89 d1                	mov    %edx,%ecx
f0111f22:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111f24:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0111f2a:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111f2f:	b0 00                	mov    $0x0,%al
f0111f31:	89 d7                	mov    %edx,%edi
f0111f33:	f3 aa                	rep stos %al,%es:(%edi)
f0111f35:	83 ec 0c             	sub    $0xc,%esp
f0111f38:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0111f3e:	50                   	push   %eax
f0111f3f:	e8 b7 ff fe ff       	call   f0101efb <execute_command>
f0111f44:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f0111f47:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0111f4d:	bb 85 88 12 f0       	mov    $0xf0128885,%ebx
f0111f52:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111f57:	89 c7                	mov    %eax,%edi
f0111f59:	89 de                	mov    %ebx,%esi
f0111f5b:	89 d1                	mov    %edx,%ecx
f0111f5d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111f5f:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0111f65:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111f6a:	b0 00                	mov    $0x0,%al
f0111f6c:	89 d7                	mov    %edx,%edi
f0111f6e:	f3 aa                	rep stos %al,%es:(%edi)
f0111f70:	83 ec 0c             	sub    $0xc,%esp
f0111f73:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0111f79:	50                   	push   %eax
f0111f7a:	e8 7c ff fe ff       	call   f0101efb <execute_command>
f0111f7f:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f0111f82:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0111f88:	bb e9 88 12 f0       	mov    $0xf01288e9,%ebx
f0111f8d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111f92:	89 c7                	mov    %eax,%edi
f0111f94:	89 de                	mov    %ebx,%esi
f0111f96:	89 d1                	mov    %edx,%ecx
f0111f98:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111f9a:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0111fa0:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111fa5:	b0 00                	mov    $0x0,%al
f0111fa7:	89 d7                	mov    %edx,%edi
f0111fa9:	f3 aa                	rep stos %al,%es:(%edi)
f0111fab:	83 ec 0c             	sub    $0xc,%esp
f0111fae:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0111fb4:	50                   	push   %eax
f0111fb5:	e8 41 ff fe ff       	call   f0101efb <execute_command>
f0111fba:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f0111fbd:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0111fc3:	bb 4d 89 12 f0       	mov    $0xf012894d,%ebx
f0111fc8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0111fcd:	89 c7                	mov    %eax,%edi
f0111fcf:	89 de                	mov    %ebx,%esi
f0111fd1:	89 d1                	mov    %edx,%ecx
f0111fd3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0111fd5:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0111fdb:	b9 55 00 00 00       	mov    $0x55,%ecx
f0111fe0:	b0 00                	mov    $0x0,%al
f0111fe2:	89 d7                	mov    %edx,%edi
f0111fe4:	f3 aa                	rep stos %al,%es:(%edi)
f0111fe6:	83 ec 0c             	sub    $0xc,%esp
f0111fe9:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0111fef:	50                   	push   %eax
f0111ff0:	e8 06 ff fe ff       	call   f0101efb <execute_command>
f0111ff5:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f0111ff8:	83 ec 04             	sub    $0x4,%esp
f0111ffb:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112001:	50                   	push   %eax
f0112002:	68 5b 84 12 f0       	push   $0xf012845b
f0112007:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011200d:	50                   	push   %eax
f011200e:	e8 4b d1 00 00       	call   f011f15e <strcconcat>
f0112013:	83 c4 10             	add    $0x10,%esp
f0112016:	83 ec 0c             	sub    $0xc,%esp
f0112019:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011201f:	50                   	push   %eax
f0112020:	e8 d6 fe fe ff       	call   f0101efb <execute_command>
f0112025:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0112028:	83 ec 04             	sub    $0x4,%esp
f011202b:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112031:	50                   	push   %eax
f0112032:	68 65 84 12 f0       	push   $0xf0128465
f0112037:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011203d:	50                   	push   %eax
f011203e:	e8 1b d1 00 00       	call   f011f15e <strcconcat>
f0112043:	83 c4 10             	add    $0x10,%esp
f0112046:	83 ec 0c             	sub    $0xc,%esp
f0112049:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011204f:	50                   	push   %eax
f0112050:	e8 a6 fe fe ff       	call   f0101efb <execute_command>
f0112055:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f0112058:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f011205e:	bb b1 89 12 f0       	mov    $0xf01289b1,%ebx
f0112063:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112068:	89 c7                	mov    %eax,%edi
f011206a:	89 de                	mov    %ebx,%esi
f011206c:	89 d1                	mov    %edx,%ecx
f011206e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112070:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0112076:	b9 55 00 00 00       	mov    $0x55,%ecx
f011207b:	b0 00                	mov    $0x0,%al
f011207d:	89 d7                	mov    %edx,%edi
f011207f:	f3 aa                	rep stos %al,%es:(%edi)
f0112081:	83 ec 0c             	sub    $0xc,%esp
f0112084:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f011208a:	50                   	push   %eax
f011208b:	e8 6b fe fe ff       	call   f0101efb <execute_command>
f0112090:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f0112093:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112099:	bb 15 8a 12 f0       	mov    $0xf0128a15,%ebx
f011209e:	ba 0f 00 00 00       	mov    $0xf,%edx
f01120a3:	89 c7                	mov    %eax,%edi
f01120a5:	89 de                	mov    %ebx,%esi
f01120a7:	89 d1                	mov    %edx,%ecx
f01120a9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01120ab:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01120b1:	b9 55 00 00 00       	mov    $0x55,%ecx
f01120b6:	b0 00                	mov    $0x0,%al
f01120b8:	89 d7                	mov    %edx,%edi
f01120ba:	f3 aa                	rep stos %al,%es:(%edi)
f01120bc:	83 ec 0c             	sub    $0xc,%esp
f01120bf:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01120c5:	50                   	push   %eax
f01120c6:	e8 30 fe fe ff       	call   f0101efb <execute_command>
f01120cb:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f01120ce:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01120d4:	bb 79 8a 12 f0       	mov    $0xf0128a79,%ebx
f01120d9:	ba 0f 00 00 00       	mov    $0xf,%edx
f01120de:	89 c7                	mov    %eax,%edi
f01120e0:	89 de                	mov    %ebx,%esi
f01120e2:	89 d1                	mov    %edx,%ecx
f01120e4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01120e6:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01120ec:	b9 55 00 00 00       	mov    $0x55,%ecx
f01120f1:	b0 00                	mov    $0x0,%al
f01120f3:	89 d7                	mov    %edx,%edi
f01120f5:	f3 aa                	rep stos %al,%es:(%edi)
f01120f7:	83 ec 0c             	sub    $0xc,%esp
f01120fa:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112100:	50                   	push   %eax
f0112101:	e8 f5 fd fe ff       	call   f0101efb <execute_command>
f0112106:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0112109:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0112110:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0112117:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f011211e:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0112125:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f011212c:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f0112133:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f011213a:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f0112141:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f0112148:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f011214f:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0112156:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f011215d:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0112160:	8a 00                	mov    (%eax),%al
f0112162:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f0112168:	8b 45 98             	mov    -0x68(%ebp),%eax
f011216b:	8a 00                	mov    (%eax),%al
f011216d:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f0112173:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112176:	8a 00                	mov    (%eax),%al
f0112178:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f011217e:	e8 f2 b8 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0112183:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f0112186:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0112189:	89 d0                	mov    %edx,%eax
f011218b:	01 c0                	add    %eax,%eax
f011218d:	01 d0                	add    %edx,%eax
f011218f:	01 c0                	add    %eax,%eax
f0112191:	50                   	push   %eax
f0112192:	68 00 00 10 00       	push   $0x100000
f0112197:	6a 00                	push   $0x0
f0112199:	ff 75 d4             	pushl  -0x2c(%ebp)
f011219c:	e8 a7 7d ff ff       	call   f0109f48 <copy_paste_chunk>
f01121a1:	83 c4 10             	add    $0x10,%esp
f01121a4:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01121a7:	e8 c9 b8 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01121ac:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f01121af:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01121b6:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f01121ba:	75 08                	jne    f01121c4 <test_copy_paste_chunk+0x4a2>
f01121bc:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01121bf:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01121c2:	74 2b                	je     f01121ef <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01121c4:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01121c7:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01121ca:	83 ec 0c             	sub    $0xc,%esp
f01121cd:	50                   	push   %eax
f01121ce:	ff 75 88             	pushl  -0x78(%ebp)
f01121d1:	68 74 84 12 f0       	push   $0xf0128474
f01121d6:	68 06 03 00 00       	push   $0x306
f01121db:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01121e0:	e8 f1 e2 fe ff       	call   f01004d6 <_warn>
f01121e5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01121e8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01121ef:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01121f3:	74 04                	je     f01121f9 <test_copy_paste_chunk+0x4d7>
f01121f5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01121f9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f0112200:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112203:	8a 00                	mov    (%eax),%al
f0112205:	3c 61                	cmp    $0x61,%al
f0112207:	75 75                	jne    f011227e <test_copy_paste_chunk+0x55c>
f0112209:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011220c:	8a 00                	mov    (%eax),%al
f011220e:	3c 78                	cmp    $0x78,%al
f0112210:	75 6c                	jne    f011227e <test_copy_paste_chunk+0x55c>
f0112212:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112215:	8a 00                	mov    (%eax),%al
f0112217:	3c 62                	cmp    $0x62,%al
f0112219:	75 63                	jne    f011227e <test_copy_paste_chunk+0x55c>
f011221b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011221e:	8a 00                	mov    (%eax),%al
f0112220:	3c 79                	cmp    $0x79,%al
f0112222:	75 5a                	jne    f011227e <test_copy_paste_chunk+0x55c>
f0112224:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112227:	8a 00                	mov    (%eax),%al
f0112229:	3c 63                	cmp    $0x63,%al
f011222b:	75 51                	jne    f011227e <test_copy_paste_chunk+0x55c>
f011222d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112230:	8a 00                	mov    (%eax),%al
f0112232:	3c 7a                	cmp    $0x7a,%al
f0112234:	75 48                	jne    f011227e <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f0112236:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0112239:	8a 00                	mov    (%eax),%al
f011223b:	3c 64                	cmp    $0x64,%al
f011223d:	75 3f                	jne    f011227e <test_copy_paste_chunk+0x55c>
f011223f:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0112242:	8a 10                	mov    (%eax),%dl
f0112244:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f011224a:	38 c2                	cmp    %al,%dl
f011224c:	75 30                	jne    f011227e <test_copy_paste_chunk+0x55c>
f011224e:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112251:	8a 00                	mov    (%eax),%al
f0112253:	3c 65                	cmp    $0x65,%al
f0112255:	75 27                	jne    f011227e <test_copy_paste_chunk+0x55c>
f0112257:	8b 45 98             	mov    -0x68(%ebp),%eax
f011225a:	8a 10                	mov    (%eax),%dl
f011225c:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f0112262:	38 c2                	cmp    %al,%dl
f0112264:	75 18                	jne    f011227e <test_copy_paste_chunk+0x55c>
f0112266:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112269:	8a 00                	mov    (%eax),%al
f011226b:	3c 66                	cmp    $0x66,%al
f011226d:	75 0f                	jne    f011227e <test_copy_paste_chunk+0x55c>
f011226f:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112272:	8a 10                	mov    (%eax),%dl
f0112274:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f011227a:	38 c2                	cmp    %al,%dl
f011227c:	74 21                	je     f011229f <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f011227e:	83 ec 04             	sub    $0x4,%esp
f0112281:	68 d8 84 12 f0       	push   $0xf01284d8
f0112286:	68 0f 03 00 00       	push   $0x30f
f011228b:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0112290:	e8 41 e2 fe ff       	call   f01004d6 <_warn>
f0112295:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112298:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011229f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01122a3:	74 04                	je     f01122a9 <test_copy_paste_chunk+0x587>
f01122a5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01122a9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f01122b0:	83 ec 0c             	sub    $0xc,%esp
f01122b3:	68 12 85 12 f0       	push   $0xf0128512
f01122b8:	e8 ce ec fe ff       	call   f0100f8b <cprintf>
f01122bd:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f01122c0:	83 ec 0c             	sub    $0xc,%esp
f01122c3:	68 24 85 12 f0       	push   $0xf0128524
f01122c8:	e8 be ec fe ff       	call   f0100f8b <cprintf>
f01122cd:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f01122d0:	83 ec 04             	sub    $0x4,%esp
f01122d3:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01122d9:	50                   	push   %eax
f01122da:	68 5a 85 12 f0       	push   $0xf012855a
f01122df:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01122e5:	50                   	push   %eax
f01122e6:	e8 73 ce 00 00       	call   f011f15e <strcconcat>
f01122eb:	83 c4 10             	add    $0x10,%esp
f01122ee:	83 ec 0c             	sub    $0xc,%esp
f01122f1:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01122f7:	50                   	push   %eax
f01122f8:	e8 fe fb fe ff       	call   f0101efb <execute_command>
f01122fd:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f0112300:	83 ec 04             	sub    $0x4,%esp
f0112303:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112309:	50                   	push   %eax
f011230a:	68 64 85 12 f0       	push   $0xf0128564
f011230f:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112315:	50                   	push   %eax
f0112316:	e8 43 ce 00 00       	call   f011f15e <strcconcat>
f011231b:	83 c4 10             	add    $0x10,%esp
f011231e:	83 ec 0c             	sub    $0xc,%esp
f0112321:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112327:	50                   	push   %eax
f0112328:	e8 ce fb fe ff       	call   f0101efb <execute_command>
f011232d:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f0112330:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112336:	bb dd 8a 12 f0       	mov    $0xf0128add,%ebx
f011233b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112340:	89 c7                	mov    %eax,%edi
f0112342:	89 de                	mov    %ebx,%esi
f0112344:	89 d1                	mov    %edx,%ecx
f0112346:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112348:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f011234e:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112353:	b0 00                	mov    $0x0,%al
f0112355:	89 d7                	mov    %edx,%edi
f0112357:	f3 aa                	rep stos %al,%es:(%edi)
f0112359:	83 ec 0c             	sub    $0xc,%esp
f011235c:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112362:	50                   	push   %eax
f0112363:	e8 93 fb fe ff       	call   f0101efb <execute_command>
f0112368:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f011236b:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112371:	bb 41 8b 12 f0       	mov    $0xf0128b41,%ebx
f0112376:	ba 0f 00 00 00       	mov    $0xf,%edx
f011237b:	89 c7                	mov    %eax,%edi
f011237d:	89 de                	mov    %ebx,%esi
f011237f:	89 d1                	mov    %edx,%ecx
f0112381:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112383:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0112389:	b9 55 00 00 00       	mov    $0x55,%ecx
f011238e:	b0 00                	mov    $0x0,%al
f0112390:	89 d7                	mov    %edx,%edi
f0112392:	f3 aa                	rep stos %al,%es:(%edi)
f0112394:	83 ec 0c             	sub    $0xc,%esp
f0112397:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f011239d:	50                   	push   %eax
f011239e:	e8 58 fb fe ff       	call   f0101efb <execute_command>
f01123a3:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f01123a6:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01123ac:	bb a5 8b 12 f0       	mov    $0xf0128ba5,%ebx
f01123b1:	ba 0f 00 00 00       	mov    $0xf,%edx
f01123b6:	89 c7                	mov    %eax,%edi
f01123b8:	89 de                	mov    %ebx,%esi
f01123ba:	89 d1                	mov    %edx,%ecx
f01123bc:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01123be:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f01123c4:	b9 55 00 00 00       	mov    $0x55,%ecx
f01123c9:	b0 00                	mov    $0x0,%al
f01123cb:	89 d7                	mov    %edx,%edi
f01123cd:	f3 aa                	rep stos %al,%es:(%edi)
f01123cf:	83 ec 0c             	sub    $0xc,%esp
f01123d2:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01123d8:	50                   	push   %eax
f01123d9:	e8 1d fb fe ff       	call   f0101efb <execute_command>
f01123de:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f01123e1:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01123e7:	bb 09 8c 12 f0       	mov    $0xf0128c09,%ebx
f01123ec:	ba 0f 00 00 00       	mov    $0xf,%edx
f01123f1:	89 c7                	mov    %eax,%edi
f01123f3:	89 de                	mov    %ebx,%esi
f01123f5:	89 d1                	mov    %edx,%ecx
f01123f7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01123f9:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f01123ff:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112404:	b0 00                	mov    $0x0,%al
f0112406:	89 d7                	mov    %edx,%edi
f0112408:	f3 aa                	rep stos %al,%es:(%edi)
f011240a:	83 ec 0c             	sub    $0xc,%esp
f011240d:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0112413:	50                   	push   %eax
f0112414:	e8 e2 fa fe ff       	call   f0101efb <execute_command>
f0112419:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f011241c:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112422:	bb 6d 8c 12 f0       	mov    $0xf0128c6d,%ebx
f0112427:	ba 0f 00 00 00       	mov    $0xf,%edx
f011242c:	89 c7                	mov    %eax,%edi
f011242e:	89 de                	mov    %ebx,%esi
f0112430:	89 d1                	mov    %edx,%ecx
f0112432:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112434:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f011243a:	b9 55 00 00 00       	mov    $0x55,%ecx
f011243f:	b0 00                	mov    $0x0,%al
f0112441:	89 d7                	mov    %edx,%edi
f0112443:	f3 aa                	rep stos %al,%es:(%edi)
f0112445:	83 ec 0c             	sub    $0xc,%esp
f0112448:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f011244e:	50                   	push   %eax
f011244f:	e8 a7 fa fe ff       	call   f0101efb <execute_command>
f0112454:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f0112457:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f011245d:	bb d1 8c 12 f0       	mov    $0xf0128cd1,%ebx
f0112462:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112467:	89 c7                	mov    %eax,%edi
f0112469:	89 de                	mov    %ebx,%esi
f011246b:	89 d1                	mov    %edx,%ecx
f011246d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011246f:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0112475:	b9 55 00 00 00       	mov    $0x55,%ecx
f011247a:	b0 00                	mov    $0x0,%al
f011247c:	89 d7                	mov    %edx,%edi
f011247e:	f3 aa                	rep stos %al,%es:(%edi)
f0112480:	83 ec 0c             	sub    $0xc,%esp
f0112483:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112489:	50                   	push   %eax
f011248a:	e8 6c fa fe ff       	call   f0101efb <execute_command>
f011248f:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f0112492:	83 ec 04             	sub    $0x4,%esp
f0112495:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011249b:	50                   	push   %eax
f011249c:	68 6e 85 12 f0       	push   $0xf012856e
f01124a1:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01124a7:	50                   	push   %eax
f01124a8:	e8 b1 cc 00 00       	call   f011f15e <strcconcat>
f01124ad:	83 c4 10             	add    $0x10,%esp
f01124b0:	83 ec 0c             	sub    $0xc,%esp
f01124b3:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01124b9:	50                   	push   %eax
f01124ba:	e8 3c fa fe ff       	call   f0101efb <execute_command>
f01124bf:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f01124c2:	83 ec 04             	sub    $0x4,%esp
f01124c5:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01124cb:	50                   	push   %eax
f01124cc:	68 78 85 12 f0       	push   $0xf0128578
f01124d1:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01124d7:	50                   	push   %eax
f01124d8:	e8 81 cc 00 00       	call   f011f15e <strcconcat>
f01124dd:	83 c4 10             	add    $0x10,%esp
f01124e0:	83 ec 0c             	sub    $0xc,%esp
f01124e3:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01124e9:	50                   	push   %eax
f01124ea:	e8 0c fa fe ff       	call   f0101efb <execute_command>
f01124ef:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f01124f2:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01124f8:	bb 35 8d 12 f0       	mov    $0xf0128d35,%ebx
f01124fd:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112502:	89 c7                	mov    %eax,%edi
f0112504:	89 de                	mov    %ebx,%esi
f0112506:	89 d1                	mov    %edx,%ecx
f0112508:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011250a:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0112510:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112515:	b0 00                	mov    $0x0,%al
f0112517:	89 d7                	mov    %edx,%edi
f0112519:	f3 aa                	rep stos %al,%es:(%edi)
f011251b:	83 ec 0c             	sub    $0xc,%esp
f011251e:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112524:	50                   	push   %eax
f0112525:	e8 d1 f9 fe ff       	call   f0101efb <execute_command>
f011252a:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f011252d:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112533:	bb 99 8d 12 f0       	mov    $0xf0128d99,%ebx
f0112538:	ba 0f 00 00 00       	mov    $0xf,%edx
f011253d:	89 c7                	mov    %eax,%edi
f011253f:	89 de                	mov    %ebx,%esi
f0112541:	89 d1                	mov    %edx,%ecx
f0112543:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112545:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f011254b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112550:	b0 00                	mov    $0x0,%al
f0112552:	89 d7                	mov    %edx,%edi
f0112554:	f3 aa                	rep stos %al,%es:(%edi)
f0112556:	83 ec 0c             	sub    $0xc,%esp
f0112559:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f011255f:	50                   	push   %eax
f0112560:	e8 96 f9 fe ff       	call   f0101efb <execute_command>
f0112565:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f0112568:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011256e:	bb fd 8d 12 f0       	mov    $0xf0128dfd,%ebx
f0112573:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112578:	89 c7                	mov    %eax,%edi
f011257a:	89 de                	mov    %ebx,%esi
f011257c:	89 d1                	mov    %edx,%ecx
f011257e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112580:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0112586:	b9 55 00 00 00       	mov    $0x55,%ecx
f011258b:	b0 00                	mov    $0x0,%al
f011258d:	89 d7                	mov    %edx,%edi
f011258f:	f3 aa                	rep stos %al,%es:(%edi)
f0112591:	83 ec 0c             	sub    $0xc,%esp
f0112594:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011259a:	50                   	push   %eax
f011259b:	e8 5b f9 fe ff       	call   f0101efb <execute_command>
f01125a0:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f01125a3:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f01125aa:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f01125b1:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f01125b8:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f01125bf:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f01125c6:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f01125cd:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f01125d4:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f01125db:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f01125e2:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f01125e9:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f01125f0:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f01125f7:	8b 45 90             	mov    -0x70(%ebp),%eax
f01125fa:	8a 00                	mov    (%eax),%al
f01125fc:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112602:	e8 6e b4 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0112607:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f011260a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011260d:	89 d0                	mov    %edx,%eax
f011260f:	01 c0                	add    %eax,%eax
f0112611:	01 d0                	add    %edx,%eax
f0112613:	01 c0                	add    %eax,%eax
f0112615:	50                   	push   %eax
f0112616:	68 00 00 40 00       	push   $0x400000
f011261b:	68 00 00 20 00       	push   $0x200000
f0112620:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112623:	e8 20 79 ff ff       	call   f0109f48 <copy_paste_chunk>
f0112628:	83 c4 10             	add    $0x10,%esp
f011262b:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011262e:	e8 42 b4 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0112633:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0112636:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f011263d:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0112641:	75 08                	jne    f011264b <test_copy_paste_chunk+0x929>
f0112643:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112646:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0112649:	74 2b                	je     f0112676 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011264b:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011264e:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112651:	83 ec 0c             	sub    $0xc,%esp
f0112654:	50                   	push   %eax
f0112655:	ff 75 80             	pushl  -0x80(%ebp)
f0112658:	68 84 85 12 f0       	push   $0xf0128584
f011265d:	68 3f 03 00 00       	push   $0x33f
f0112662:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0112667:	e8 6a de fe ff       	call   f01004d6 <_warn>
f011266c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011266f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112676:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011267a:	74 04                	je     f0112680 <test_copy_paste_chunk+0x95e>
f011267c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112680:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f0112687:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f011268e:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0112691:	83 ec 08             	sub    $0x8,%esp
f0112694:	6a 01                	push   $0x1
f0112696:	6a 07                	push   $0x7
f0112698:	6a 07                	push   $0x7
f011269a:	6a 07                	push   $0x7
f011269c:	6a 07                	push   $0x7
f011269e:	6a 01                	push   $0x1
f01126a0:	68 00 20 00 00       	push   $0x2000
f01126a5:	68 00 00 40 00       	push   $0x400000
f01126aa:	68 00 00 20 00       	push   $0x200000
f01126af:	ff 75 d4             	pushl  -0x2c(%ebp)
f01126b2:	e8 bf 32 00 00       	call   f0115976 <CCP>
f01126b7:	83 c4 30             	add    $0x30,%esp
f01126ba:	83 f8 01             	cmp    $0x1,%eax
f01126bd:	74 2b                	je     f01126ea <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f01126bf:	83 ec 04             	sub    $0x4,%esp
f01126c2:	68 d8 85 12 f0       	push   $0xf01285d8
f01126c7:	68 48 03 00 00       	push   $0x348
f01126cc:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01126d1:	e8 00 de fe ff       	call   f01004d6 <_warn>
f01126d6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01126d9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f01126e0:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f01126e7:	00 00 00 
		}
		if (correct) eval += 5 ;
f01126ea:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01126ee:	74 04                	je     f01126f4 <test_copy_paste_chunk+0x9d2>
f01126f0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01126f4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f01126fb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01126fe:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f0112701:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112704:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0112707:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011270a:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f011270d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112710:	8a 00                	mov    (%eax),%al
f0112712:	3c 61                	cmp    $0x61,%al
f0112714:	75 69                	jne    f011277f <test_copy_paste_chunk+0xa5d>
f0112716:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112719:	8a 00                	mov    (%eax),%al
f011271b:	3c 61                	cmp    $0x61,%al
f011271d:	75 60                	jne    f011277f <test_copy_paste_chunk+0xa5d>
f011271f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112722:	8a 00                	mov    (%eax),%al
f0112724:	3c 79                	cmp    $0x79,%al
f0112726:	75 57                	jne    f011277f <test_copy_paste_chunk+0xa5d>
f0112728:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011272b:	8a 00                	mov    (%eax),%al
f011272d:	3c 62                	cmp    $0x62,%al
f011272f:	75 4e                	jne    f011277f <test_copy_paste_chunk+0xa5d>
f0112731:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112734:	8a 00                	mov    (%eax),%al
f0112736:	3c 63                	cmp    $0x63,%al
f0112738:	75 45                	jne    f011277f <test_copy_paste_chunk+0xa5d>
f011273a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011273d:	8a 00                	mov    (%eax),%al
f011273f:	3c 7a                	cmp    $0x7a,%al
f0112741:	75 3c                	jne    f011277f <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f0112743:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0112746:	8a 00                	mov    (%eax),%al
f0112748:	3c 77                	cmp    $0x77,%al
f011274a:	75 33                	jne    f011277f <test_copy_paste_chunk+0xa5d>
f011274c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011274f:	8a 00                	mov    (%eax),%al
f0112751:	3c 64                	cmp    $0x64,%al
f0112753:	75 2a                	jne    f011277f <test_copy_paste_chunk+0xa5d>
f0112755:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112758:	8a 00                	mov    (%eax),%al
f011275a:	3c 65                	cmp    $0x65,%al
f011275c:	75 21                	jne    f011277f <test_copy_paste_chunk+0xa5d>
f011275e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112761:	8a 00                	mov    (%eax),%al
f0112763:	3c 65                	cmp    $0x65,%al
f0112765:	75 18                	jne    f011277f <test_copy_paste_chunk+0xa5d>
f0112767:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011276a:	8a 00                	mov    (%eax),%al
f011276c:	3c 66                	cmp    $0x66,%al
f011276e:	75 0f                	jne    f011277f <test_copy_paste_chunk+0xa5d>
f0112770:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112773:	8a 10                	mov    (%eax),%dl
f0112775:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f011277b:	38 c2                	cmp    %al,%dl
f011277d:	74 21                	je     f01127a0 <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f011277f:	83 ec 04             	sub    $0x4,%esp
f0112782:	68 d8 84 12 f0       	push   $0xf01284d8
f0112787:	68 56 03 00 00       	push   $0x356
f011278c:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0112791:	e8 40 dd fe ff       	call   f01004d6 <_warn>
f0112796:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112799:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01127a0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01127a4:	74 04                	je     f01127aa <test_copy_paste_chunk+0xa88>
f01127a6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01127aa:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f01127b1:	8b 45 98             	mov    -0x68(%ebp),%eax
f01127b4:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01127b7:	e8 b9 b2 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01127bc:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f01127bf:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01127c2:	89 c2                	mov    %eax,%edx
f01127c4:	01 d2                	add    %edx,%edx
f01127c6:	01 d0                	add    %edx,%eax
f01127c8:	50                   	push   %eax
f01127c9:	68 00 08 20 00       	push   $0x200800
f01127ce:	68 00 08 40 00       	push   $0x400800
f01127d3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01127d6:	e8 6d 77 ff ff       	call   f0109f48 <copy_paste_chunk>
f01127db:	83 c4 10             	add    $0x10,%esp
f01127de:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01127e1:	e8 8f b2 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01127e6:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01127e9:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01127ed:	75 08                	jne    f01127f7 <test_copy_paste_chunk+0xad5>
f01127ef:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01127f2:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01127f5:	74 2b                	je     f0112822 <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01127f7:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01127fa:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01127fd:	83 ec 0c             	sub    $0xc,%esp
f0112800:	50                   	push   %eax
f0112801:	ff 75 80             	pushl  -0x80(%ebp)
f0112804:	68 84 85 12 f0       	push   $0xf0128584
f0112809:	68 66 03 00 00       	push   $0x366
f011280e:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0112813:	e8 be dc fe ff       	call   f01004d6 <_warn>
f0112818:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011281b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112822:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112826:	74 04                	je     f011282c <test_copy_paste_chunk+0xb0a>
f0112828:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011282c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0112833:	83 ec 08             	sub    $0x8,%esp
f0112836:	6a 01                	push   $0x1
f0112838:	6a 07                	push   $0x7
f011283a:	6a 07                	push   $0x7
f011283c:	6a 07                	push   $0x7
f011283e:	6a 07                	push   $0x7
f0112840:	6a 01                	push   $0x1
f0112842:	68 00 20 00 00       	push   $0x2000
f0112847:	68 00 00 20 00       	push   $0x200000
f011284c:	68 00 00 40 00       	push   $0x400000
f0112851:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112854:	e8 1d 31 00 00       	call   f0115976 <CCP>
f0112859:	83 c4 30             	add    $0x30,%esp
f011285c:	83 f8 01             	cmp    $0x1,%eax
f011285f:	74 21                	je     f0112882 <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0112861:	83 ec 04             	sub    $0x4,%esp
f0112864:	68 24 86 12 f0       	push   $0xf0128624
f0112869:	68 6e 03 00 00       	push   $0x36e
f011286e:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0112873:	e8 5e dc fe ff       	call   f01004d6 <_warn>
f0112878:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011287b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112882:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112886:	74 04                	je     f011288c <test_copy_paste_chunk+0xb6a>
f0112888:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011288c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0112893:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112896:	8a 00                	mov    (%eax),%al
f0112898:	3c 61                	cmp    $0x61,%al
f011289a:	75 69                	jne    f0112905 <test_copy_paste_chunk+0xbe3>
f011289c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011289f:	8a 00                	mov    (%eax),%al
f01128a1:	3c 61                	cmp    $0x61,%al
f01128a3:	75 60                	jne    f0112905 <test_copy_paste_chunk+0xbe3>
f01128a5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01128a8:	8a 00                	mov    (%eax),%al
f01128aa:	3c 79                	cmp    $0x79,%al
f01128ac:	75 57                	jne    f0112905 <test_copy_paste_chunk+0xbe3>
f01128ae:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01128b1:	8a 00                	mov    (%eax),%al
f01128b3:	3c 62                	cmp    $0x62,%al
f01128b5:	75 4e                	jne    f0112905 <test_copy_paste_chunk+0xbe3>
f01128b7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01128ba:	8a 00                	mov    (%eax),%al
f01128bc:	3c 7a                	cmp    $0x7a,%al
f01128be:	75 45                	jne    f0112905 <test_copy_paste_chunk+0xbe3>
f01128c0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01128c3:	8a 00                	mov    (%eax),%al
f01128c5:	3c 7a                	cmp    $0x7a,%al
f01128c7:	75 3c                	jne    f0112905 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f01128c9:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01128cc:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f01128ce:	3c 64                	cmp    $0x64,%al
f01128d0:	75 33                	jne    f0112905 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f01128d2:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01128d5:	8a 00                	mov    (%eax),%al
f01128d7:	3c 64                	cmp    $0x64,%al
f01128d9:	75 2a                	jne    f0112905 <test_copy_paste_chunk+0xbe3>
f01128db:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01128de:	8a 00                	mov    (%eax),%al
f01128e0:	3c 65                	cmp    $0x65,%al
f01128e2:	75 21                	jne    f0112905 <test_copy_paste_chunk+0xbe3>
f01128e4:	8b 45 98             	mov    -0x68(%ebp),%eax
f01128e7:	8a 00                	mov    (%eax),%al
f01128e9:	3c 78                	cmp    $0x78,%al
f01128eb:	75 18                	jne    f0112905 <test_copy_paste_chunk+0xbe3>
f01128ed:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01128f0:	8a 00                	mov    (%eax),%al
f01128f2:	3c 66                	cmp    $0x66,%al
f01128f4:	75 0f                	jne    f0112905 <test_copy_paste_chunk+0xbe3>
f01128f6:	8b 45 90             	mov    -0x70(%ebp),%eax
f01128f9:	8a 10                	mov    (%eax),%dl
f01128fb:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0112901:	38 c2                	cmp    %al,%dl
f0112903:	74 21                	je     f0112926 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0112905:	83 ec 04             	sub    $0x4,%esp
f0112908:	68 d8 84 12 f0       	push   $0xf01284d8
f011290d:	68 77 03 00 00       	push   $0x377
f0112912:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0112917:	e8 ba db fe ff       	call   f01004d6 <_warn>
f011291c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011291f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112926:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011292a:	74 04                	je     f0112930 <test_copy_paste_chunk+0xc0e>
f011292c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112930:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f0112937:	83 ec 0c             	sub    $0xc,%esp
f011293a:	68 6f 86 12 f0       	push   $0xf012866f
f011293f:	e8 47 e6 fe ff       	call   f0100f8b <cprintf>
f0112944:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f0112947:	83 ec 0c             	sub    $0xc,%esp
f011294a:	68 80 86 12 f0       	push   $0xf0128680
f011294f:	e8 37 e6 fe ff       	call   f0100f8b <cprintf>
f0112954:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f0112957:	83 ec 04             	sub    $0x4,%esp
f011295a:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112960:	50                   	push   %eax
f0112961:	68 b4 86 12 f0       	push   $0xf01286b4
f0112966:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011296c:	50                   	push   %eax
f011296d:	e8 ec c7 00 00       	call   f011f15e <strcconcat>
f0112972:	83 c4 10             	add    $0x10,%esp
f0112975:	83 ec 0c             	sub    $0xc,%esp
f0112978:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011297e:	50                   	push   %eax
f011297f:	e8 77 f5 fe ff       	call   f0101efb <execute_command>
f0112984:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f0112987:	83 ec 04             	sub    $0x4,%esp
f011298a:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112990:	50                   	push   %eax
f0112991:	68 be 86 12 f0       	push   $0xf01286be
f0112996:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f011299c:	50                   	push   %eax
f011299d:	e8 bc c7 00 00       	call   f011f15e <strcconcat>
f01129a2:	83 c4 10             	add    $0x10,%esp
f01129a5:	83 ec 0c             	sub    $0xc,%esp
f01129a8:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01129ae:	50                   	push   %eax
f01129af:	e8 47 f5 fe ff       	call   f0101efb <execute_command>
f01129b4:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f01129b7:	83 ec 04             	sub    $0x4,%esp
f01129ba:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01129c0:	50                   	push   %eax
f01129c1:	68 c8 86 12 f0       	push   $0xf01286c8
f01129c6:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01129cc:	50                   	push   %eax
f01129cd:	e8 8c c7 00 00       	call   f011f15e <strcconcat>
f01129d2:	83 c4 10             	add    $0x10,%esp
f01129d5:	83 ec 0c             	sub    $0xc,%esp
f01129d8:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01129de:	50                   	push   %eax
f01129df:	e8 17 f5 fe ff       	call   f0101efb <execute_command>
f01129e4:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f01129e7:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01129ed:	bb 61 8e 12 f0       	mov    $0xf0128e61,%ebx
f01129f2:	ba 0f 00 00 00       	mov    $0xf,%edx
f01129f7:	89 c7                	mov    %eax,%edi
f01129f9:	89 de                	mov    %ebx,%esi
f01129fb:	89 d1                	mov    %edx,%ecx
f01129fd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01129ff:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0112a05:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112a0a:	b0 00                	mov    $0x0,%al
f0112a0c:	89 d7                	mov    %edx,%edi
f0112a0e:	f3 aa                	rep stos %al,%es:(%edi)
f0112a10:	83 ec 0c             	sub    $0xc,%esp
f0112a13:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112a19:	50                   	push   %eax
f0112a1a:	e8 dc f4 fe ff       	call   f0101efb <execute_command>
f0112a1f:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f0112a22:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112a28:	bb c5 8e 12 f0       	mov    $0xf0128ec5,%ebx
f0112a2d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112a32:	89 c7                	mov    %eax,%edi
f0112a34:	89 de                	mov    %ebx,%esi
f0112a36:	89 d1                	mov    %edx,%ecx
f0112a38:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112a3a:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0112a40:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112a45:	b0 00                	mov    $0x0,%al
f0112a47:	89 d7                	mov    %edx,%edi
f0112a49:	f3 aa                	rep stos %al,%es:(%edi)
f0112a4b:	83 ec 0c             	sub    $0xc,%esp
f0112a4e:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112a54:	50                   	push   %eax
f0112a55:	e8 a1 f4 fe ff       	call   f0101efb <execute_command>
f0112a5a:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f0112a5d:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112a63:	bb 29 8f 12 f0       	mov    $0xf0128f29,%ebx
f0112a68:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112a6d:	89 c7                	mov    %eax,%edi
f0112a6f:	89 de                	mov    %ebx,%esi
f0112a71:	89 d1                	mov    %edx,%ecx
f0112a73:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112a75:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0112a7b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112a80:	b0 00                	mov    $0x0,%al
f0112a82:	89 d7                	mov    %edx,%edi
f0112a84:	f3 aa                	rep stos %al,%es:(%edi)
f0112a86:	83 ec 0c             	sub    $0xc,%esp
f0112a89:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112a8f:	50                   	push   %eax
f0112a90:	e8 66 f4 fe ff       	call   f0101efb <execute_command>
f0112a95:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112a98:	e8 d8 af ff ff       	call   f010da75 <sys_calculate_free_frames>
f0112a9d:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f0112aa0:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0112aa3:	89 d0                	mov    %edx,%eax
f0112aa5:	01 c0                	add    %eax,%eax
f0112aa7:	01 d0                	add    %edx,%eax
f0112aa9:	c1 e0 02             	shl    $0x2,%eax
f0112aac:	50                   	push   %eax
f0112aad:	68 00 00 90 00       	push   $0x900000
f0112ab2:	68 00 00 80 00       	push   $0x800000
f0112ab7:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112aba:	e8 89 74 ff ff       	call   f0109f48 <copy_paste_chunk>
f0112abf:	83 c4 10             	add    $0x10,%esp
f0112ac2:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112ac8:	e8 a8 af ff ff       	call   f010da75 <sys_calculate_free_frames>
f0112acd:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0112ad0:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0112ad7:	75 0b                	jne    f0112ae4 <test_copy_paste_chunk+0xdc2>
f0112ad9:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112adc:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112adf:	83 f8 03             	cmp    $0x3,%eax
f0112ae2:	74 2e                	je     f0112b12 <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0112ae4:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112ae7:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112aea:	83 ec 0c             	sub    $0xc,%esp
f0112aed:	50                   	push   %eax
f0112aee:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0112af4:	68 84 85 12 f0       	push   $0xf0128584
f0112af9:	68 95 03 00 00       	push   $0x395
f0112afe:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0112b03:	e8 ce d9 fe ff       	call   f01004d6 <_warn>
f0112b08:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112b0b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112b12:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b16:	74 04                	je     f0112b1c <test_copy_paste_chunk+0xdfa>
f0112b18:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112b1c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f0112b23:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0112b2a:	83 ec 08             	sub    $0x8,%esp
f0112b2d:	6a 01                	push   $0x1
f0112b2f:	6a 07                	push   $0x7
f0112b31:	6a 07                	push   $0x7
f0112b33:	6a 07                	push   $0x7
f0112b35:	6a 07                	push   $0x7
f0112b37:	6a 01                	push   $0x1
f0112b39:	68 00 30 00 00       	push   $0x3000
f0112b3e:	68 00 00 90 00       	push   $0x900000
f0112b43:	68 00 00 80 00       	push   $0x800000
f0112b48:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112b4b:	e8 26 2e 00 00       	call   f0115976 <CCP>
f0112b50:	83 c4 30             	add    $0x30,%esp
f0112b53:	83 f8 01             	cmp    $0x1,%eax
f0112b56:	74 28                	je     f0112b80 <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0112b58:	83 ec 04             	sub    $0x4,%esp
f0112b5b:	68 24 86 12 f0       	push   $0xf0128624
f0112b60:	68 9e 03 00 00       	push   $0x39e
f0112b65:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0112b6a:	e8 67 d9 fe ff       	call   f01004d6 <_warn>
f0112b6f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112b72:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0112b79:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f0112b80:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b84:	74 04                	je     f0112b8a <test_copy_paste_chunk+0xe68>
f0112b86:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112b8a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0112b91:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112b95:	0f 84 9e 00 00 00    	je     f0112c39 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0112b9b:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f0112ba2:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0112ba9:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f0112bb0:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f0112bb7:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f0112bbe:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0112bc5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112bc8:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0112bcb:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112bce:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f0112bd1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112bd4:	8a 00                	mov    (%eax),%al
f0112bd6:	3c 61                	cmp    $0x61,%al
f0112bd8:	75 2d                	jne    f0112c07 <test_copy_paste_chunk+0xee5>
f0112bda:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112bdd:	8a 00                	mov    (%eax),%al
f0112bdf:	3c 61                	cmp    $0x61,%al
f0112be1:	75 24                	jne    f0112c07 <test_copy_paste_chunk+0xee5>
f0112be3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112be6:	8a 00                	mov    (%eax),%al
f0112be8:	3c 79                	cmp    $0x79,%al
f0112bea:	75 1b                	jne    f0112c07 <test_copy_paste_chunk+0xee5>
f0112bec:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112bef:	8a 00                	mov    (%eax),%al
f0112bf1:	3c 62                	cmp    $0x62,%al
f0112bf3:	75 12                	jne    f0112c07 <test_copy_paste_chunk+0xee5>
f0112bf5:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112bf8:	8a 00                	mov    (%eax),%al
f0112bfa:	3c 63                	cmp    $0x63,%al
f0112bfc:	75 09                	jne    f0112c07 <test_copy_paste_chunk+0xee5>
f0112bfe:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112c01:	8a 00                	mov    (%eax),%al
f0112c03:	3c 7a                	cmp    $0x7a,%al
f0112c05:	74 21                	je     f0112c28 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0112c07:	83 ec 04             	sub    $0x4,%esp
f0112c0a:	68 d8 84 12 f0       	push   $0xf01284d8
f0112c0f:	68 b0 03 00 00       	push   $0x3b0
f0112c14:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0112c19:	e8 b8 d8 fe ff       	call   f01004d6 <_warn>
f0112c1e:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0112c21:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0112c28:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112c2c:	74 04                	je     f0112c32 <test_copy_paste_chunk+0xf10>
f0112c2e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f0112c32:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112c39:	e8 37 ae ff ff       	call   f010da75 <sys_calculate_free_frames>
f0112c3e:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f0112c41:	6a 00                	push   $0x0
f0112c43:	6a 02                	push   $0x2
f0112c45:	68 00 10 90 00       	push   $0x901000
f0112c4a:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c4d:	e8 b1 2b 00 00       	call   f0115803 <SB>
f0112c52:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0112c55:	6a 00                	push   $0x0
f0112c57:	6a 02                	push   $0x2
f0112c59:	68 00 20 90 00       	push   $0x902000
f0112c5e:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c61:	e8 9d 2b 00 00       	call   f0115803 <SB>
f0112c66:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0112c69:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0112c6c:	c1 e0 03             	shl    $0x3,%eax
f0112c6f:	50                   	push   %eax
f0112c70:	68 00 f0 bf 00       	push   $0xbff000
f0112c75:	68 00 10 90 00       	push   $0x901000
f0112c7a:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c7d:	e8 c6 72 ff ff       	call   f0109f48 <copy_paste_chunk>
f0112c82:	83 c4 10             	add    $0x10,%esp
f0112c85:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112c8b:	e8 e5 ad ff ff       	call   f010da75 <sys_calculate_free_frames>
f0112c90:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0112c93:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0112c9a:	75 0b                	jne    f0112ca7 <test_copy_paste_chunk+0xf85>
f0112c9c:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112c9f:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112ca2:	83 f8 03             	cmp    $0x3,%eax
f0112ca5:	74 2e                	je     f0112cd5 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0112ca7:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0112caa:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0112cad:	83 ec 0c             	sub    $0xc,%esp
f0112cb0:	50                   	push   %eax
f0112cb1:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0112cb7:	68 84 85 12 f0       	push   $0xf0128584
f0112cbc:	68 c0 03 00 00       	push   $0x3c0
f0112cc1:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0112cc6:	e8 0b d8 fe ff       	call   f01004d6 <_warn>
f0112ccb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112cce:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112cd5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112cd9:	74 04                	je     f0112cdf <test_copy_paste_chunk+0xfbd>
f0112cdb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112cdf:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f0112ce6:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f0112ced:	83 ec 08             	sub    $0x8,%esp
f0112cf0:	6a 01                	push   $0x1
f0112cf2:	6a 07                	push   $0x7
f0112cf4:	6a 03                	push   $0x3
f0112cf6:	6a 07                	push   $0x7
f0112cf8:	6a 03                	push   $0x3
f0112cfa:	6a 01                	push   $0x1
f0112cfc:	68 00 20 00 00       	push   $0x2000
f0112d01:	68 00 f0 bf 00       	push   $0xbff000
f0112d06:	68 00 10 90 00       	push   $0x901000
f0112d0b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d0e:	e8 63 2c 00 00       	call   f0115976 <CCP>
f0112d13:	83 c4 30             	add    $0x30,%esp
f0112d16:	83 f8 01             	cmp    $0x1,%eax
f0112d19:	74 28                	je     f0112d43 <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0112d1b:	83 ec 04             	sub    $0x4,%esp
f0112d1e:	68 24 86 12 f0       	push   $0xf0128624
f0112d23:	68 c9 03 00 00       	push   $0x3c9
f0112d28:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0112d2d:	e8 a4 d7 fe ff       	call   f01004d6 <_warn>
f0112d32:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112d35:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0112d3c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f0112d43:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112d47:	74 04                	je     f0112d4d <test_copy_paste_chunk+0x102b>
f0112d49:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112d4d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0112d54:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112d58:	74 72                	je     f0112dcc <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0112d5a:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f0112d61:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f0112d68:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f0112d6f:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0112d76:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112d79:	8a 00                	mov    (%eax),%al
f0112d7b:	3c 62                	cmp    $0x62,%al
f0112d7d:	75 1b                	jne    f0112d9a <test_copy_paste_chunk+0x1078>
f0112d7f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112d82:	8a 00                	mov    (%eax),%al
f0112d84:	3c 62                	cmp    $0x62,%al
f0112d86:	75 12                	jne    f0112d9a <test_copy_paste_chunk+0x1078>
f0112d88:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112d8b:	8a 00                	mov    (%eax),%al
f0112d8d:	3c 7a                	cmp    $0x7a,%al
f0112d8f:	75 09                	jne    f0112d9a <test_copy_paste_chunk+0x1078>
f0112d91:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112d94:	8a 00                	mov    (%eax),%al
f0112d96:	3c 7a                	cmp    $0x7a,%al
f0112d98:	74 21                	je     f0112dbb <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0112d9a:	83 ec 04             	sub    $0x4,%esp
f0112d9d:	68 d8 84 12 f0       	push   $0xf01284d8
f0112da2:	68 d5 03 00 00       	push   $0x3d5
f0112da7:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0112dac:	e8 25 d7 fe ff       	call   f01004d6 <_warn>
f0112db1:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0112db4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0112dbb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112dbf:	74 04                	je     f0112dc5 <test_copy_paste_chunk+0x10a3>
f0112dc1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0112dc5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0112dcc:	83 ec 0c             	sub    $0xc,%esp
f0112dcf:	68 d2 86 12 f0       	push   $0xf01286d2
f0112dd4:	e8 b2 e1 fe ff       	call   f0100f8b <cprintf>
f0112dd9:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0112ddc:	83 ec 08             	sub    $0x8,%esp
f0112ddf:	ff 75 e4             	pushl  -0x1c(%ebp)
f0112de2:	68 e4 86 12 f0       	push   $0xf01286e4
f0112de7:	e8 9f e1 fe ff       	call   f0100f8b <cprintf>
f0112dec:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0112def:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0112df3:	75 10                	jne    f0112e05 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0112df5:	83 ec 0c             	sub    $0xc,%esp
f0112df8:	68 18 87 12 f0       	push   $0xf0128718
f0112dfd:	e8 89 e1 fe ff       	call   f0100f8b <cprintf>
f0112e02:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0112e05:	a1 24 cc 5e f0       	mov    0xf05ecc24,%eax
f0112e0a:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0112e0d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112e10:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0112e13:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112e18:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0112e1b:	5b                   	pop    %ebx
f0112e1c:	5e                   	pop    %esi
f0112e1d:	5f                   	pop    %edi
f0112e1e:	5d                   	pop    %ebp
f0112e1f:	c3                   	ret    

f0112e20 <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f0112e20:	55                   	push   %ebp
f0112e21:	89 e5                	mov    %esp,%ebp
f0112e23:	57                   	push   %edi
f0112e24:	56                   	push   %esi
f0112e25:	53                   	push   %ebx
f0112e26:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0112e2c:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0112e32:	bb e4 83 12 f0       	mov    $0xf01283e4,%ebx
f0112e37:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112e3c:	89 c7                	mov    %eax,%edi
f0112e3e:	89 de                	mov    %ebx,%esi
f0112e40:	89 d1                	mov    %edx,%ecx
f0112e42:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112e44:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0112e4a:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112e4f:	b0 00                	mov    $0x0,%al
f0112e51:	89 d7                	mov    %edx,%edi
f0112e53:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112e55:	6a 00                	push   $0x0
f0112e57:	6a 0a                	push   $0xa
f0112e59:	6a 14                	push   $0x14
f0112e5b:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0112e61:	50                   	push   %eax
f0112e62:	e8 74 73 ff ff       	call   f010a1db <env_create>
f0112e67:	83 c4 10             	add    $0x10,%esp
f0112e6a:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112e6d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112e70:	8b 40 64             	mov    0x64(%eax),%eax
f0112e73:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0112e76:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112e79:	8b 40 68             	mov    0x68(%eax),%eax
f0112e7c:	89 45 80             	mov    %eax,-0x80(%ebp)
f0112e7f:	8b 45 80             	mov    -0x80(%ebp),%eax
f0112e82:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0112e85:	83 ec 0c             	sub    $0xc,%esp
f0112e88:	ff 75 cc             	pushl  -0x34(%ebp)
f0112e8b:	e8 b2 2a 00 00       	call   f0115942 <ClearUserSpace>
f0112e90:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0112e93:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0112e9a:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0112ea1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0112ea8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f0112eac:	83 ec 0c             	sub    $0xc,%esp
f0112eaf:	68 90 8f 12 f0       	push   $0xf0128f90
f0112eb4:	e8 d2 e0 fe ff       	call   f0100f8b <cprintf>
f0112eb9:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0112ebc:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0112ec3:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0112eca:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112ecd:	8a 00                	mov    (%eax),%al
f0112ecf:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0112ed5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112ed8:	8a 00                	mov    (%eax),%al
f0112eda:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112ee0:	e8 90 ab ff ff       	call   f010da75 <sys_calculate_free_frames>
f0112ee5:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0112ee8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0112eeb:	89 d0                	mov    %edx,%eax
f0112eed:	01 c0                	add    %eax,%eax
f0112eef:	01 d0                	add    %edx,%eax
f0112ef1:	01 c0                	add    %eax,%eax
f0112ef3:	83 ec 0c             	sub    $0xc,%esp
f0112ef6:	6a 02                	push   $0x2
f0112ef8:	50                   	push   %eax
f0112ef9:	68 00 40 10 f0       	push   $0xf0104000
f0112efe:	68 00 00 10 f0       	push   $0xf0100000
f0112f03:	ff 75 cc             	pushl  -0x34(%ebp)
f0112f06:	e8 57 70 ff ff       	call   f0109f62 <share_chunk>
f0112f0b:	83 c4 20             	add    $0x20,%esp
f0112f0e:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0112f11:	e8 5f ab ff ff       	call   f010da75 <sys_calculate_free_frames>
f0112f16:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0112f19:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0112f1d:	75 08                	jne    f0112f27 <test_share_chunk+0x107>
f0112f1f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112f22:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0112f25:	74 28                	je     f0112f4f <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0112f27:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0112f2a:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0112f2d:	83 ec 0c             	sub    $0xc,%esp
f0112f30:	50                   	push   %eax
f0112f31:	ff 75 b0             	pushl  -0x50(%ebp)
f0112f34:	68 bc 8f 12 f0       	push   $0xf0128fbc
f0112f39:	68 11 04 00 00       	push   $0x411
f0112f3e:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0112f43:	e8 8e d5 fe ff       	call   f01004d6 <_warn>
f0112f48:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0112f4b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0112f4f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0112f53:	74 04                	je     f0112f59 <test_share_chunk+0x139>
f0112f55:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112f59:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0112f5d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0112f60:	c1 e0 03             	shl    $0x3,%eax
f0112f63:	83 ec 08             	sub    $0x8,%esp
f0112f66:	68 fd 00 00 00       	push   $0xfd
f0112f6b:	6a 07                	push   $0x7
f0112f6d:	6a 03                	push   $0x3
f0112f6f:	6a 07                	push   $0x7
f0112f71:	6a 03                	push   $0x3
f0112f73:	6a 01                	push   $0x1
f0112f75:	50                   	push   %eax
f0112f76:	68 00 40 10 f0       	push   $0xf0104000
f0112f7b:	68 00 00 10 f0       	push   $0xf0100000
f0112f80:	ff 75 cc             	pushl  -0x34(%ebp)
f0112f83:	e8 ee 29 00 00       	call   f0115976 <CCP>
f0112f88:	83 c4 30             	add    $0x30,%esp
f0112f8b:	85 c0                	test   %eax,%eax
f0112f8d:	75 1e                	jne    f0112fad <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0112f8f:	83 ec 04             	sub    $0x4,%esp
f0112f92:	68 18 90 12 f0       	push   $0xf0129018
f0112f97:	68 19 04 00 00       	push   $0x419
f0112f9c:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0112fa1:	e8 30 d5 fe ff       	call   f01004d6 <_warn>
f0112fa6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112fa9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0112fad:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0112fb1:	74 04                	je     f0112fb7 <test_share_chunk+0x197>
f0112fb3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f0112fb7:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112fba:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f0112fbd:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112fc0:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0112fc3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0112fc6:	8a 00                	mov    (%eax),%al
f0112fc8:	3c 41                	cmp    $0x41,%al
f0112fca:	75 09                	jne    f0112fd5 <test_share_chunk+0x1b5>
f0112fcc:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112fcf:	8a 00                	mov    (%eax),%al
f0112fd1:	3c 42                	cmp    $0x42,%al
f0112fd3:	74 1e                	je     f0112ff3 <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0112fd5:	83 ec 04             	sub    $0x4,%esp
f0112fd8:	68 60 90 12 f0       	push   $0xf0129060
f0112fdd:	68 23 04 00 00       	push   $0x423
f0112fe2:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0112fe7:	e8 ea d4 fe ff       	call   f01004d6 <_warn>
f0112fec:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112fef:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0112ff3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0112ff7:	74 04                	je     f0112ffd <test_share_chunk+0x1dd>
f0112ff9:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112ffd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f0113001:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0113007:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011300a:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f011300c:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f0113012:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113015:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0113017:	83 ec 0c             	sub    $0xc,%esp
f011301a:	68 95 90 12 f0       	push   $0xf0129095
f011301f:	e8 67 df fe ff       	call   f0100f8b <cprintf>
f0113024:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0113027:	83 ec 0c             	sub    $0xc,%esp
f011302a:	68 a4 90 12 f0       	push   $0xf01290a4
f011302f:	e8 57 df fe ff       	call   f0100f8b <cprintf>
f0113034:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113037:	e8 39 aa ff ff       	call   f010da75 <sys_calculate_free_frames>
f011303c:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f011303f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113042:	c1 e0 05             	shl    $0x5,%eax
f0113045:	83 ec 0c             	sub    $0xc,%esp
f0113048:	68 02 0e 00 00       	push   $0xe02
f011304d:	50                   	push   %eax
f011304e:	68 00 00 00 40       	push   $0x40000000
f0113053:	68 00 00 00 f0       	push   $0xf0000000
f0113058:	ff 75 cc             	pushl  -0x34(%ebp)
f011305b:	e8 02 6f ff ff       	call   f0109f62 <share_chunk>
f0113060:	83 c4 20             	add    $0x20,%esp
f0113063:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113066:	e8 0a aa ff ff       	call   f010da75 <sys_calculate_free_frames>
f011306b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f011306e:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0113072:	75 1f                	jne    f0113093 <test_share_chunk+0x273>
f0113074:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113077:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011307a:	89 c1                	mov    %eax,%ecx
f011307c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011307f:	c1 e0 05             	shl    $0x5,%eax
f0113082:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113085:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f011308c:	99                   	cltd   
f011308d:	f7 fb                	idiv   %ebx
f011308f:	39 c1                	cmp    %eax,%ecx
f0113091:	74 28                	je     f01130bb <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113093:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113096:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113099:	83 ec 0c             	sub    $0xc,%esp
f011309c:	50                   	push   %eax
f011309d:	ff 75 a8             	pushl  -0x58(%ebp)
f01130a0:	68 e0 90 12 f0       	push   $0xf01290e0
f01130a5:	68 3b 04 00 00       	push   $0x43b
f01130aa:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01130af:	e8 22 d4 fe ff       	call   f01004d6 <_warn>
f01130b4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01130b7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01130bb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01130bf:	74 04                	je     f01130c5 <test_share_chunk+0x2a5>
f01130c1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01130c5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f01130c9:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f01130d0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01130d3:	c1 e0 05             	shl    $0x5,%eax
f01130d6:	83 ec 08             	sub    $0x8,%esp
f01130d9:	6a 02                	push   $0x2
f01130db:	6a 07                	push   $0x7
f01130dd:	6a 03                	push   $0x3
f01130df:	68 07 0e 00 00       	push   $0xe07
f01130e4:	68 03 0e 00 00       	push   $0xe03
f01130e9:	6a ff                	push   $0xffffffff
f01130eb:	50                   	push   %eax
f01130ec:	68 00 00 00 40       	push   $0x40000000
f01130f1:	68 00 00 00 f0       	push   $0xf0000000
f01130f6:	ff 75 cc             	pushl  -0x34(%ebp)
f01130f9:	e8 78 28 00 00       	call   f0115976 <CCP>
f01130fe:	83 c4 30             	add    $0x30,%esp
f0113101:	85 c0                	test   %eax,%eax
f0113103:	75 25                	jne    f011312a <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113105:	83 ec 04             	sub    $0x4,%esp
f0113108:	68 18 90 12 f0       	push   $0xf0129018
f011310d:	68 44 04 00 00       	push   $0x444
f0113112:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113117:	e8 ba d3 fe ff       	call   f01004d6 <_warn>
f011311c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011311f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0113123:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f011312a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011312d:	89 d0                	mov    %edx,%eax
f011312f:	01 c0                	add    %eax,%eax
f0113131:	01 d0                	add    %edx,%eax
f0113133:	c1 e0 02             	shl    $0x2,%eax
f0113136:	83 ec 08             	sub    $0x8,%esp
f0113139:	6a 02                	push   $0x2
f011313b:	6a 07                	push   $0x7
f011313d:	6a 03                	push   $0x3
f011313f:	68 07 0e 00 00       	push   $0xe07
f0113144:	68 03 0e 00 00       	push   $0xe03
f0113149:	6a 02                	push   $0x2
f011314b:	50                   	push   %eax
f011314c:	68 00 00 00 40       	push   $0x40000000
f0113151:	68 00 00 00 f0       	push   $0xf0000000
f0113156:	ff 75 cc             	pushl  -0x34(%ebp)
f0113159:	e8 18 28 00 00       	call   f0115976 <CCP>
f011315e:	83 c4 30             	add    $0x30,%esp
f0113161:	85 c0                	test   %eax,%eax
f0113163:	75 1e                	jne    f0113183 <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113165:	83 ec 04             	sub    $0x4,%esp
f0113168:	68 18 90 12 f0       	push   $0xf0129018
f011316d:	68 4b 04 00 00       	push   $0x44b
f0113172:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113177:	e8 5a d3 fe ff       	call   f01004d6 <_warn>
f011317c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011317f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113183:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113187:	74 04                	je     f011318d <test_share_chunk+0x36d>
f0113189:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011318d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f0113191:	b8 f4 f5 60 f0       	mov    $0xf060f5f4,%eax
f0113196:	05 00 00 00 10       	add    $0x10000000,%eax
f011319b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f011319e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01131a1:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f01131a6:	83 ec 08             	sub    $0x8,%esp
f01131a9:	6a 02                	push   $0x2
f01131ab:	6a 07                	push   $0x7
f01131ad:	6a 03                	push   $0x3
f01131af:	68 07 0e 00 00       	push   $0xe07
f01131b4:	68 03 0e 00 00       	push   $0xe03
f01131b9:	6a 02                	push   $0x2
f01131bb:	50                   	push   %eax
f01131bc:	68 00 00 0a 40       	push   $0x400a0000
f01131c1:	68 00 00 0a f0       	push   $0xf00a0000
f01131c6:	ff 75 cc             	pushl  -0x34(%ebp)
f01131c9:	e8 a8 27 00 00       	call   f0115976 <CCP>
f01131ce:	83 c4 30             	add    $0x30,%esp
f01131d1:	85 c0                	test   %eax,%eax
f01131d3:	75 1e                	jne    f01131f3 <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01131d5:	83 ec 04             	sub    $0x4,%esp
f01131d8:	68 18 90 12 f0       	push   $0xf0129018
f01131dd:	68 55 04 00 00       	push   $0x455
f01131e2:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01131e7:	e8 ea d2 fe ff       	call   f01004d6 <_warn>
f01131ec:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01131ef:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01131f3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01131f7:	74 04                	je     f01131fd <test_share_chunk+0x3dd>
f01131f9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01131fd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0113201:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113205:	0f 84 a4 00 00 00    	je     f01132af <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f011320b:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f0113212:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113215:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0113218:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f011321f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113222:	8a 00                	mov    (%eax),%al
f0113224:	3c 41                	cmp    $0x41,%al
f0113226:	75 09                	jne    f0113231 <test_share_chunk+0x411>
f0113228:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011322b:	8a 00                	mov    (%eax),%al
f011322d:	3c 41                	cmp    $0x41,%al
f011322f:	74 1e                	je     f011324f <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113231:	83 ec 04             	sub    $0x4,%esp
f0113234:	68 60 90 12 f0       	push   $0xf0129060
f0113239:	68 62 04 00 00       	push   $0x462
f011323e:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113243:	e8 8e d2 fe ff       	call   f01004d6 <_warn>
f0113248:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011324b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011324f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113253:	74 04                	je     f0113259 <test_share_chunk+0x439>
f0113255:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113259:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f011325d:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f0113264:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113267:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f011326a:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f0113271:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113274:	8a 00                	mov    (%eax),%al
f0113276:	3c 43                	cmp    $0x43,%al
f0113278:	75 09                	jne    f0113283 <test_share_chunk+0x463>
f011327a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011327d:	8a 00                	mov    (%eax),%al
f011327f:	3c 43                	cmp    $0x43,%al
f0113281:	74 1e                	je     f01132a1 <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113283:	83 ec 04             	sub    $0x4,%esp
f0113286:	68 60 90 12 f0       	push   $0xf0129060
f011328b:	68 6d 04 00 00       	push   $0x46d
f0113290:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113295:	e8 3c d2 fe ff       	call   f01004d6 <_warn>
f011329a:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011329d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01132a1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01132a5:	74 04                	je     f01132ab <test_share_chunk+0x48b>
f01132a7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01132ab:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f01132af:	83 ec 0c             	sub    $0xc,%esp
f01132b2:	68 6f 86 12 f0       	push   $0xf012866f
f01132b7:	e8 cf dc fe ff       	call   f0100f8b <cprintf>
f01132bc:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f01132bf:	83 ec 0c             	sub    $0xc,%esp
f01132c2:	68 30 91 12 f0       	push   $0xf0129130
f01132c7:	e8 bf dc fe ff       	call   f0100f8b <cprintf>
f01132cc:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01132cf:	e8 a1 a7 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01132d4:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f01132d7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01132da:	89 d0                	mov    %edx,%eax
f01132dc:	c1 e0 03             	shl    $0x3,%eax
f01132df:	01 d0                	add    %edx,%eax
f01132e1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01132e8:	01 d0                	add    %edx,%eax
f01132ea:	c1 e0 03             	shl    $0x3,%eax
f01132ed:	83 ec 0c             	sub    $0xc,%esp
f01132f0:	6a 06                	push   $0x6
f01132f2:	50                   	push   %eax
f01132f3:	6a 00                	push   $0x0
f01132f5:	68 00 00 00 40       	push   $0x40000000
f01132fa:	ff 75 cc             	pushl  -0x34(%ebp)
f01132fd:	e8 60 6c ff ff       	call   f0109f62 <share_chunk>
f0113302:	83 c4 20             	add    $0x20,%esp
f0113305:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113308:	e8 68 a7 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011330d:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0113310:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f0113314:	75 0b                	jne    f0113321 <test_share_chunk+0x501>
f0113316:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113319:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011331c:	83 f8 01             	cmp    $0x1,%eax
f011331f:	74 28                	je     f0113349 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113321:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113324:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113327:	83 ec 0c             	sub    $0xc,%esp
f011332a:	50                   	push   %eax
f011332b:	ff 75 a0             	pushl  -0x60(%ebp)
f011332e:	68 e0 90 12 f0       	push   $0xf01290e0
f0113333:	68 83 04 00 00       	push   $0x483
f0113338:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011333d:	e8 94 d1 fe ff       	call   f01004d6 <_warn>
f0113342:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113345:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113349:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011334d:	74 04                	je     f0113353 <test_share_chunk+0x533>
f011334f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113353:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0113357:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011335e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113361:	05 00 80 02 00       	add    $0x28000,%eax
f0113366:	c1 e0 02             	shl    $0x2,%eax
f0113369:	83 ec 08             	sub    $0x8,%esp
f011336c:	6a 02                	push   $0x2
f011336e:	6a 07                	push   $0x7
f0113370:	6a 03                	push   $0x3
f0113372:	6a 07                	push   $0x7
f0113374:	6a 07                	push   $0x7
f0113376:	6a ff                	push   $0xffffffff
f0113378:	50                   	push   %eax
f0113379:	6a 00                	push   $0x0
f011337b:	68 00 00 00 40       	push   $0x40000000
f0113380:	ff 75 cc             	pushl  -0x34(%ebp)
f0113383:	e8 ee 25 00 00       	call   f0115976 <CCP>
f0113388:	83 c4 30             	add    $0x30,%esp
f011338b:	85 c0                	test   %eax,%eax
f011338d:	75 25                	jne    f01133b4 <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011338f:	83 ec 04             	sub    $0x4,%esp
f0113392:	68 18 90 12 f0       	push   $0xf0129018
f0113397:	68 8c 04 00 00       	push   $0x48c
f011339c:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01133a1:	e8 30 d1 fe ff       	call   f01004d6 <_warn>
f01133a6:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01133a9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01133ad:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01133b4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01133b7:	89 d0                	mov    %edx,%eax
f01133b9:	01 c0                	add    %eax,%eax
f01133bb:	01 d0                	add    %edx,%eax
f01133bd:	c1 e0 02             	shl    $0x2,%eax
f01133c0:	83 ec 08             	sub    $0x8,%esp
f01133c3:	6a 02                	push   $0x2
f01133c5:	6a 07                	push   $0x7
f01133c7:	6a 03                	push   $0x3
f01133c9:	6a 07                	push   $0x7
f01133cb:	6a 07                	push   $0x7
f01133cd:	6a 03                	push   $0x3
f01133cf:	50                   	push   %eax
f01133d0:	6a 00                	push   $0x0
f01133d2:	68 00 00 00 40       	push   $0x40000000
f01133d7:	ff 75 cc             	pushl  -0x34(%ebp)
f01133da:	e8 97 25 00 00       	call   f0115976 <CCP>
f01133df:	83 c4 30             	add    $0x30,%esp
f01133e2:	85 c0                	test   %eax,%eax
f01133e4:	75 1e                	jne    f0113404 <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01133e6:	83 ec 04             	sub    $0x4,%esp
f01133e9:	68 18 90 12 f0       	push   $0xf0129018
f01133ee:	68 93 04 00 00       	push   $0x493
f01133f3:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01133f8:	e8 d9 d0 fe ff       	call   f01004d6 <_warn>
f01133fd:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113400:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113404:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113408:	74 04                	je     f011340e <test_share_chunk+0x5ee>
f011340a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011340e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0113412:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113415:	89 d0                	mov    %edx,%eax
f0113417:	01 c0                	add    %eax,%eax
f0113419:	01 d0                	add    %edx,%eax
f011341b:	c1 e0 02             	shl    $0x2,%eax
f011341e:	f7 d8                	neg    %eax
f0113420:	05 00 00 0a 00       	add    $0xa0000,%eax
f0113425:	83 ec 08             	sub    $0x8,%esp
f0113428:	6a 02                	push   $0x2
f011342a:	6a 07                	push   $0x7
f011342c:	6a 03                	push   $0x3
f011342e:	6a 07                	push   $0x7
f0113430:	6a 07                	push   $0x7
f0113432:	6a 02                	push   $0x2
f0113434:	50                   	push   %eax
f0113435:	68 00 30 00 00       	push   $0x3000
f011343a:	68 00 30 00 40       	push   $0x40003000
f011343f:	ff 75 cc             	pushl  -0x34(%ebp)
f0113442:	e8 2f 25 00 00       	call   f0115976 <CCP>
f0113447:	83 c4 30             	add    $0x30,%esp
f011344a:	85 c0                	test   %eax,%eax
f011344c:	75 1e                	jne    f011346c <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011344e:	83 ec 04             	sub    $0x4,%esp
f0113451:	68 18 90 12 f0       	push   $0xf0129018
f0113456:	68 9b 04 00 00       	push   $0x49b
f011345b:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113460:	e8 71 d0 fe ff       	call   f01004d6 <_warn>
f0113465:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113468:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011346c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113470:	74 04                	je     f0113476 <test_share_chunk+0x656>
f0113472:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113476:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011347a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011347d:	c1 e0 02             	shl    $0x2,%eax
f0113480:	83 ec 08             	sub    $0x8,%esp
f0113483:	6a 02                	push   $0x2
f0113485:	6a 07                	push   $0x7
f0113487:	6a 03                	push   $0x3
f0113489:	6a 07                	push   $0x7
f011348b:	6a 07                	push   $0x7
f011348d:	6a 03                	push   $0x3
f011348f:	50                   	push   %eax
f0113490:	68 00 00 0a 00       	push   $0xa0000
f0113495:	68 00 00 0a 40       	push   $0x400a0000
f011349a:	ff 75 cc             	pushl  -0x34(%ebp)
f011349d:	e8 d4 24 00 00       	call   f0115976 <CCP>
f01134a2:	83 c4 30             	add    $0x30,%esp
f01134a5:	85 c0                	test   %eax,%eax
f01134a7:	75 1e                	jne    f01134c7 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01134a9:	83 ec 04             	sub    $0x4,%esp
f01134ac:	68 18 90 12 f0       	push   $0xf0129018
f01134b1:	68 a3 04 00 00       	push   $0x4a3
f01134b6:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01134bb:	e8 16 d0 fe ff       	call   f01004d6 <_warn>
f01134c0:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01134c3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01134c7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01134cb:	74 04                	je     f01134d1 <test_share_chunk+0x6b1>
f01134cd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01134d1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01134d5:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f01134d9:	0f 84 92 00 00 00    	je     f0113571 <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f01134df:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f01134e6:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f01134ed:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f01134f4:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f01134fb:	8b 45 98             	mov    -0x68(%ebp),%eax
f01134fe:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f0113501:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f0113508:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f011350f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113512:	8a 00                	mov    (%eax),%al
f0113514:	3c 41                	cmp    $0x41,%al
f0113516:	75 2d                	jne    f0113545 <test_share_chunk+0x725>
f0113518:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011351b:	8a 00                	mov    (%eax),%al
f011351d:	3c 41                	cmp    $0x41,%al
f011351f:	75 24                	jne    f0113545 <test_share_chunk+0x725>
f0113521:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113524:	8a 00                	mov    (%eax),%al
f0113526:	3c 41                	cmp    $0x41,%al
f0113528:	75 1b                	jne    f0113545 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f011352a:	8b 45 98             	mov    -0x68(%ebp),%eax
f011352d:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f011352f:	3c 44                	cmp    $0x44,%al
f0113531:	75 12                	jne    f0113545 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0113533:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113536:	8a 00                	mov    (%eax),%al
f0113538:	3c 44                	cmp    $0x44,%al
f011353a:	75 09                	jne    f0113545 <test_share_chunk+0x725>
f011353c:	8b 45 90             	mov    -0x70(%ebp),%eax
f011353f:	8a 00                	mov    (%eax),%al
f0113541:	3c 44                	cmp    $0x44,%al
f0113543:	74 1e                	je     f0113563 <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113545:	83 ec 04             	sub    $0x4,%esp
f0113548:	68 60 90 12 f0       	push   $0xf0129060
f011354d:	68 b5 04 00 00       	push   $0x4b5
f0113552:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113557:	e8 7a cf fe ff       	call   f01004d6 <_warn>
f011355c:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011355f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0113563:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113567:	74 04                	je     f011356d <test_share_chunk+0x74d>
f0113569:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011356d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0113571:	83 ec 0c             	sub    $0xc,%esp
f0113574:	68 d2 86 12 f0       	push   $0xf01286d2
f0113579:	e8 0d da fe ff       	call   f0100f8b <cprintf>
f011357e:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f0113581:	83 ec 0c             	sub    $0xc,%esp
f0113584:	68 6c 91 12 f0       	push   $0xf012916c
f0113589:	e8 fd d9 fe ff       	call   f0100f8b <cprintf>
f011358e:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113591:	e8 df a4 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0113596:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f0113599:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011359c:	89 d0                	mov    %edx,%eax
f011359e:	01 c0                	add    %eax,%eax
f01135a0:	01 d0                	add    %edx,%eax
f01135a2:	01 c0                	add    %eax,%eax
f01135a4:	01 d0                	add    %edx,%eax
f01135a6:	83 ec 0c             	sub    $0xc,%esp
f01135a9:	6a 04                	push   $0x4
f01135ab:	50                   	push   %eax
f01135ac:	68 00 fc 3f 00       	push   $0x3ffc00
f01135b1:	68 00 fc 09 00       	push   $0x9fc00
f01135b6:	ff 75 cc             	pushl  -0x34(%ebp)
f01135b9:	e8 a4 69 ff ff       	call   f0109f62 <share_chunk>
f01135be:	83 c4 20             	add    $0x20,%esp
f01135c1:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01135c4:	e8 ac a4 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01135c9:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f01135cc:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f01135d0:	75 0b                	jne    f01135dd <test_share_chunk+0x7bd>
f01135d2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01135d5:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01135d8:	83 f8 01             	cmp    $0x1,%eax
f01135db:	74 28                	je     f0113605 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01135dd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01135e0:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01135e3:	83 ec 0c             	sub    $0xc,%esp
f01135e6:	50                   	push   %eax
f01135e7:	ff 75 8c             	pushl  -0x74(%ebp)
f01135ea:	68 e0 90 12 f0       	push   $0xf01290e0
f01135ef:	68 cb 04 00 00       	push   $0x4cb
f01135f4:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01135f9:	e8 d8 ce fe ff       	call   f01004d6 <_warn>
f01135fe:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113601:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0113605:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113609:	74 04                	je     f011360f <test_share_chunk+0x7ef>
f011360b:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011360f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0113613:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f011361a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011361d:	89 d0                	mov    %edx,%eax
f011361f:	01 c0                	add    %eax,%eax
f0113621:	01 d0                	add    %edx,%eax
f0113623:	c1 e0 02             	shl    $0x2,%eax
f0113626:	83 ec 08             	sub    $0x8,%esp
f0113629:	6a 02                	push   $0x2
f011362b:	6a 07                	push   $0x7
f011362d:	6a 07                	push   $0x7
f011362f:	6a 07                	push   $0x7
f0113631:	6a 05                	push   $0x5
f0113633:	6a ff                	push   $0xffffffff
f0113635:	50                   	push   %eax
f0113636:	68 00 f0 3f 00       	push   $0x3ff000
f011363b:	68 00 f0 09 00       	push   $0x9f000
f0113640:	ff 75 cc             	pushl  -0x34(%ebp)
f0113643:	e8 2e 23 00 00       	call   f0115976 <CCP>
f0113648:	83 c4 30             	add    $0x30,%esp
f011364b:	85 c0                	test   %eax,%eax
f011364d:	75 25                	jne    f0113674 <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011364f:	83 ec 04             	sub    $0x4,%esp
f0113652:	68 18 90 12 f0       	push   $0xf0129018
f0113657:	68 d4 04 00 00       	push   $0x4d4
f011365c:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113661:	e8 70 ce fe ff       	call   f01004d6 <_warn>
f0113666:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113669:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f011366d:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f0113674:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113678:	74 04                	je     f011367e <test_share_chunk+0x85e>
f011367a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011367e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0113682:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113685:	c1 e0 02             	shl    $0x2,%eax
f0113688:	83 ec 08             	sub    $0x8,%esp
f011368b:	6a 02                	push   $0x2
f011368d:	6a 07                	push   $0x7
f011368f:	6a 07                	push   $0x7
f0113691:	6a 07                	push   $0x7
f0113693:	6a 05                	push   $0x5
f0113695:	6a 03                	push   $0x3
f0113697:	50                   	push   %eax
f0113698:	68 00 f0 3f 00       	push   $0x3ff000
f011369d:	68 00 f0 09 00       	push   $0x9f000
f01136a2:	ff 75 cc             	pushl  -0x34(%ebp)
f01136a5:	e8 cc 22 00 00       	call   f0115976 <CCP>
f01136aa:	83 c4 30             	add    $0x30,%esp
f01136ad:	85 c0                	test   %eax,%eax
f01136af:	75 1e                	jne    f01136cf <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01136b1:	83 ec 04             	sub    $0x4,%esp
f01136b4:	68 18 90 12 f0       	push   $0xf0129018
f01136b9:	68 dd 04 00 00       	push   $0x4dd
f01136be:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01136c3:	e8 0e ce fe ff       	call   f01004d6 <_warn>
f01136c8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01136cb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01136cf:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01136d3:	74 04                	je     f01136d9 <test_share_chunk+0x8b9>
f01136d5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01136d9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01136dd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01136e0:	c1 e0 03             	shl    $0x3,%eax
f01136e3:	83 ec 08             	sub    $0x8,%esp
f01136e6:	6a 02                	push   $0x2
f01136e8:	6a 07                	push   $0x7
f01136ea:	6a 07                	push   $0x7
f01136ec:	6a 07                	push   $0x7
f01136ee:	6a 05                	push   $0x5
f01136f0:	6a 04                	push   $0x4
f01136f2:	50                   	push   %eax
f01136f3:	68 00 00 40 00       	push   $0x400000
f01136f8:	68 00 00 0a 00       	push   $0xa0000
f01136fd:	ff 75 cc             	pushl  -0x34(%ebp)
f0113700:	e8 71 22 00 00       	call   f0115976 <CCP>
f0113705:	83 c4 30             	add    $0x30,%esp
f0113708:	85 c0                	test   %eax,%eax
f011370a:	75 1e                	jne    f011372a <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011370c:	83 ec 04             	sub    $0x4,%esp
f011370f:	68 18 90 12 f0       	push   $0xf0129018
f0113714:	68 e5 04 00 00       	push   $0x4e5
f0113719:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011371e:	e8 b3 cd fe ff       	call   f01004d6 <_warn>
f0113723:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113726:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011372a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011372e:	74 04                	je     f0113734 <test_share_chunk+0x914>
f0113730:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113734:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0113738:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011373c:	0f 84 b2 00 00 00    	je     f01137f4 <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f0113742:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f0113749:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f0113750:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f0113757:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f011375e:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f0113765:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f011376c:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f0113773:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f011377a:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011377d:	8a 00                	mov    (%eax),%al
f011377f:	3c 44                	cmp    $0x44,%al
f0113781:	75 45                	jne    f01137c8 <test_share_chunk+0x9a8>
f0113783:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113786:	8a 00                	mov    (%eax),%al
f0113788:	3c 44                	cmp    $0x44,%al
f011378a:	75 3c                	jne    f01137c8 <test_share_chunk+0x9a8>
f011378c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011378f:	8a 00                	mov    (%eax),%al
f0113791:	3c 44                	cmp    $0x44,%al
f0113793:	75 33                	jne    f01137c8 <test_share_chunk+0x9a8>
f0113795:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113798:	8a 00                	mov    (%eax),%al
f011379a:	3c 44                	cmp    $0x44,%al
f011379c:	75 2a                	jne    f01137c8 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f011379e:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01137a1:	8a 10                	mov    (%eax),%dl
f01137a3:	8b 45 90             	mov    -0x70(%ebp),%eax
f01137a6:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f01137a8:	38 c2                	cmp    %al,%dl
f01137aa:	75 1c                	jne    f01137c8 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f01137ac:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01137af:	8a 10                	mov    (%eax),%dl
f01137b1:	8b 45 88             	mov    -0x78(%ebp),%eax
f01137b4:	8a 00                	mov    (%eax),%al
f01137b6:	38 c2                	cmp    %al,%dl
f01137b8:	75 0e                	jne    f01137c8 <test_share_chunk+0x9a8>
f01137ba:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01137bd:	8a 10                	mov    (%eax),%dl
f01137bf:	8b 45 84             	mov    -0x7c(%ebp),%eax
f01137c2:	8a 00                	mov    (%eax),%al
f01137c4:	38 c2                	cmp    %al,%dl
f01137c6:	74 1e                	je     f01137e6 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01137c8:	83 ec 04             	sub    $0x4,%esp
f01137cb:	68 60 90 12 f0       	push   $0xf0129060
f01137d0:	68 fa 04 00 00       	push   $0x4fa
f01137d5:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01137da:	e8 f7 cc fe ff       	call   f01004d6 <_warn>
f01137df:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01137e2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01137e6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01137ea:	74 04                	je     f01137f0 <test_share_chunk+0x9d0>
f01137ec:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01137f0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f01137f4:	83 ec 0c             	sub    $0xc,%esp
f01137f7:	68 a4 91 12 f0       	push   $0xf01291a4
f01137fc:	e8 8a d7 fe ff       	call   f0100f8b <cprintf>
f0113801:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f0113804:	83 ec 08             	sub    $0x8,%esp
f0113807:	ff 75 e4             	pushl  -0x1c(%ebp)
f011380a:	68 b4 91 12 f0       	push   $0xf01291b4
f011380f:	e8 77 d7 fe ff       	call   f0100f8b <cprintf>
f0113814:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0113817:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f011381b:	75 10                	jne    f011382d <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f011381d:	83 ec 0c             	sub    $0xc,%esp
f0113820:	68 e4 91 12 f0       	push   $0xf01291e4
f0113825:	e8 61 d7 fe ff       	call   f0100f8b <cprintf>
f011382a:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f011382d:	a1 24 cc 5e f0       	mov    0xf05ecc24,%eax
f0113832:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0113835:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0113838:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011383b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113840:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113843:	5b                   	pop    %ebx
f0113844:	5e                   	pop    %esi
f0113845:	5f                   	pop    %edi
f0113846:	5d                   	pop    %ebp
f0113847:	c3                   	ret    

f0113848 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f0113848:	55                   	push   %ebp
f0113849:	89 e5                	mov    %esp,%ebp
f011384b:	57                   	push   %edi
f011384c:	56                   	push   %esi
f011384d:	53                   	push   %ebx
f011384e:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0113854:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f011385a:	bb e4 83 12 f0       	mov    $0xf01283e4,%ebx
f011385f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113864:	89 c7                	mov    %eax,%edi
f0113866:	89 de                	mov    %ebx,%esi
f0113868:	89 d1                	mov    %edx,%ecx
f011386a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011386c:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0113872:	b9 23 00 00 00       	mov    $0x23,%ecx
f0113877:	b0 00                	mov    $0x0,%al
f0113879:	89 d7                	mov    %edx,%edi
f011387b:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011387d:	6a 00                	push   $0x0
f011387f:	6a 0a                	push   $0xa
f0113881:	6a 14                	push   $0x14
f0113883:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0113889:	50                   	push   %eax
f011388a:	e8 4c 69 ff ff       	call   f010a1db <env_create>
f011388f:	83 c4 10             	add    $0x10,%esp
f0113892:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0113895:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113898:	8b 40 64             	mov    0x64(%eax),%eax
f011389b:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f011389e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01138a1:	8b 40 68             	mov    0x68(%eax),%eax
f01138a4:	89 45 90             	mov    %eax,-0x70(%ebp)
f01138a7:	8b 45 90             	mov    -0x70(%ebp),%eax
f01138aa:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f01138ad:	83 ec 0c             	sub    $0xc,%esp
f01138b0:	ff 75 cc             	pushl  -0x34(%ebp)
f01138b3:	e8 8a 20 00 00       	call   f0115942 <ClearUserSpace>
f01138b8:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f01138bb:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f01138c2:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f01138c9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f01138d0:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f01138d4:	83 ec 0c             	sub    $0xc,%esp
f01138d7:	68 20 92 12 f0       	push   $0xf0129220
f01138dc:	e8 aa d6 fe ff       	call   f0100f8b <cprintf>
f01138e1:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f01138e4:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f01138eb:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f01138f2:	eb 03                	jmp    f01138f7 <test_allocate_chunk+0xaf>
f01138f4:	ff 4d e4             	decl   -0x1c(%ebp)
f01138f7:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f01138fe:	76 09                	jbe    f0113909 <test_allocate_chunk+0xc1>
f0113900:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113903:	8a 00                	mov    (%eax),%al
f0113905:	84 c0                	test   %al,%al
f0113907:	74 eb                	je     f01138f4 <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0113909:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0113910:	75 06                	jne    f0113918 <test_allocate_chunk+0xd0>
f0113912:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113915:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f0113918:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011391b:	8a 00                	mov    (%eax),%al
f011391d:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f0113923:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113926:	8a 00                	mov    (%eax),%al
f0113928:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f011392e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113931:	8a 00                	mov    (%eax),%al
f0113933:	0f be c0             	movsbl %al,%eax
f0113936:	83 ec 08             	sub    $0x8,%esp
f0113939:	50                   	push   %eax
f011393a:	68 4a 92 12 f0       	push   $0xf012924a
f011393f:	e8 47 d6 fe ff       	call   f0100f8b <cprintf>
f0113944:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f0113947:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011394a:	8a 00                	mov    (%eax),%al
f011394c:	0f be c0             	movsbl %al,%eax
f011394f:	83 ec 08             	sub    $0x8,%esp
f0113952:	50                   	push   %eax
f0113953:	68 56 92 12 f0       	push   $0xf0129256
f0113958:	e8 2e d6 fe ff       	call   f0100f8b <cprintf>
f011395d:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f0113960:	83 ec 08             	sub    $0x8,%esp
f0113963:	68 00 f0 bf ef       	push   $0xefbff000
f0113968:	ff 75 cc             	pushl  -0x34(%ebp)
f011396b:	e8 b3 1f 00 00       	call   f0115923 <GP>
f0113970:	83 c4 10             	add    $0x10,%esp
f0113973:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113976:	e8 fa a0 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011397b:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f011397e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113981:	c1 e0 02             	shl    $0x2,%eax
f0113984:	6a 02                	push   $0x2
f0113986:	50                   	push   %eax
f0113987:	68 00 f0 bf ef       	push   $0xefbff000
f011398c:	ff 75 cc             	pushl  -0x34(%ebp)
f011398f:	e8 e8 65 ff ff       	call   f0109f7c <allocate_chunk>
f0113994:	83 c4 10             	add    $0x10,%esp
f0113997:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011399a:	e8 d6 a0 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011399f:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f01139a2:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f01139a6:	75 08                	jne    f01139b0 <test_allocate_chunk+0x168>
f01139a8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01139ab:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f01139ae:	74 2a                	je     f01139da <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f01139b0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01139b3:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01139b6:	83 ec 08             	sub    $0x8,%esp
f01139b9:	6a 00                	push   $0x0
f01139bb:	50                   	push   %eax
f01139bc:	ff 75 b0             	pushl  -0x50(%ebp)
f01139bf:	68 64 92 12 f0       	push   $0xf0129264
f01139c4:	68 3a 05 00 00       	push   $0x53a
f01139c9:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01139ce:	e8 03 cb fe ff       	call   f01004d6 <_warn>
f01139d3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01139d6:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01139da:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01139de:	74 04                	je     f01139e4 <test_allocate_chunk+0x19c>
f01139e0:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01139e4:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f01139e8:	e8 88 a0 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01139ed:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f01139f0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01139f3:	01 c0                	add    %eax,%eax
f01139f5:	89 c1                	mov    %eax,%ecx
f01139f7:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01139fa:	89 d0                	mov    %edx,%eax
f01139fc:	c1 e0 02             	shl    $0x2,%eax
f01139ff:	01 d0                	add    %edx,%eax
f0113a01:	f7 d8                	neg    %eax
f0113a03:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0113a08:	6a 02                	push   $0x2
f0113a0a:	51                   	push   %ecx
f0113a0b:	50                   	push   %eax
f0113a0c:	ff 75 cc             	pushl  -0x34(%ebp)
f0113a0f:	e8 68 65 ff ff       	call   f0109f7c <allocate_chunk>
f0113a14:	83 c4 10             	add    $0x10,%esp
f0113a17:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113a1a:	e8 56 a0 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0113a1f:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0113a22:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0113a26:	75 08                	jne    f0113a30 <test_allocate_chunk+0x1e8>
f0113a28:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113a2b:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0113a2e:	74 2a                	je     f0113a5a <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0113a30:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113a33:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113a36:	83 ec 08             	sub    $0x8,%esp
f0113a39:	6a 00                	push   $0x0
f0113a3b:	50                   	push   %eax
f0113a3c:	ff 75 b0             	pushl  -0x50(%ebp)
f0113a3f:	68 64 92 12 f0       	push   $0xf0129264
f0113a44:	68 48 05 00 00       	push   $0x548
f0113a49:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113a4e:	e8 83 ca fe ff       	call   f01004d6 <_warn>
f0113a53:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113a56:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0113a5a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113a5e:	74 04                	je     f0113a64 <test_allocate_chunk+0x21c>
f0113a60:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0113a64:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f0113a68:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113a6b:	c1 e0 02             	shl    $0x2,%eax
f0113a6e:	83 ec 08             	sub    $0x8,%esp
f0113a71:	6a 03                	push   $0x3
f0113a73:	6a 00                	push   $0x0
f0113a75:	6a 00                	push   $0x0
f0113a77:	68 ff 0f 00 00       	push   $0xfff
f0113a7c:	ff 75 b8             	pushl  -0x48(%ebp)
f0113a7f:	6a 01                	push   $0x1
f0113a81:	50                   	push   %eax
f0113a82:	68 00 f0 bf ef       	push   $0xefbff000
f0113a87:	6a 00                	push   $0x0
f0113a89:	ff 75 cc             	pushl  -0x34(%ebp)
f0113a8c:	e8 e5 1e 00 00       	call   f0115976 <CCP>
f0113a91:	83 c4 30             	add    $0x30,%esp
f0113a94:	85 c0                	test   %eax,%eax
f0113a96:	75 1e                	jne    f0113ab6 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0113a98:	83 ec 04             	sub    $0x4,%esp
f0113a9b:	68 cc 92 12 f0       	push   $0xf01292cc
f0113aa0:	68 50 05 00 00       	push   $0x550
f0113aa5:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113aaa:	e8 27 ca fe ff       	call   f01004d6 <_warn>
f0113aaf:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113ab2:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0113ab6:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113aba:	74 04                	je     f0113ac0 <test_allocate_chunk+0x278>
f0113abc:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0113ac0:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f0113ac4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113ac7:	8a 10                	mov    (%eax),%dl
f0113ac9:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f0113acf:	38 c2                	cmp    %al,%dl
f0113ad1:	75 0f                	jne    f0113ae2 <test_allocate_chunk+0x29a>
f0113ad3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113ad6:	8a 10                	mov    (%eax),%dl
f0113ad8:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f0113ade:	38 c2                	cmp    %al,%dl
f0113ae0:	74 1e                	je     f0113b00 <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0113ae2:	83 ec 04             	sub    $0x4,%esp
f0113ae5:	68 18 93 12 f0       	push   $0xf0129318
f0113aea:	68 58 05 00 00       	push   $0x558
f0113aef:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113af4:	e8 dd c9 fe ff       	call   f01004d6 <_warn>
f0113af9:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113afc:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0113b00:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113b04:	74 04                	je     f0113b0a <test_allocate_chunk+0x2c2>
f0113b06:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0113b0a:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0113b0e:	83 ec 0c             	sub    $0xc,%esp
f0113b11:	68 95 90 12 f0       	push   $0xf0129095
f0113b16:	e8 70 d4 fe ff       	call   f0100f8b <cprintf>
f0113b1b:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f0113b1e:	83 ec 0c             	sub    $0xc,%esp
f0113b21:	68 50 93 12 f0       	push   $0xf0129350
f0113b26:	e8 60 d4 fe ff       	call   f0100f8b <cprintf>
f0113b2b:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113b2e:	e8 42 9f ff ff       	call   f010da75 <sys_calculate_free_frames>
f0113b33:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0113b36:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b39:	c1 e0 05             	shl    $0x5,%eax
f0113b3c:	68 02 0e 00 00       	push   $0xe02
f0113b41:	50                   	push   %eax
f0113b42:	6a 00                	push   $0x0
f0113b44:	ff 75 cc             	pushl  -0x34(%ebp)
f0113b47:	e8 30 64 ff ff       	call   f0109f7c <allocate_chunk>
f0113b4c:	83 c4 10             	add    $0x10,%esp
f0113b4f:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113b52:	e8 1e 9f ff ff       	call   f010da75 <sys_calculate_free_frames>
f0113b57:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0113b5a:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0113b5e:	75 36                	jne    f0113b96 <test_allocate_chunk+0x34e>
f0113b60:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113b63:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113b66:	89 c1                	mov    %eax,%ecx
f0113b68:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b6b:	c1 e0 05             	shl    $0x5,%eax
f0113b6e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113b71:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0113b78:	99                   	cltd   
f0113b79:	f7 fe                	idiv   %esi
f0113b7b:	89 c3                	mov    %eax,%ebx
f0113b7d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b80:	c1 e0 05             	shl    $0x5,%eax
f0113b83:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113b86:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0113b8d:	99                   	cltd   
f0113b8e:	f7 fe                	idiv   %esi
f0113b90:	01 d8                	add    %ebx,%eax
f0113b92:	39 c1                	cmp    %eax,%ecx
f0113b94:	74 54                	je     f0113bea <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0113b96:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113b99:	c1 e0 05             	shl    $0x5,%eax
f0113b9c:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113b9f:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0113ba6:	99                   	cltd   
f0113ba7:	f7 ff                	idiv   %edi
f0113ba9:	89 c1                	mov    %eax,%ecx
f0113bab:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113bae:	c1 e0 05             	shl    $0x5,%eax
f0113bb1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113bb4:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0113bbb:	99                   	cltd   
f0113bbc:	f7 fe                	idiv   %esi
f0113bbe:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0113bc1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113bc4:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113bc7:	83 ec 08             	sub    $0x8,%esp
f0113bca:	52                   	push   %edx
f0113bcb:	50                   	push   %eax
f0113bcc:	ff 75 a8             	pushl  -0x58(%ebp)
f0113bcf:	68 90 93 12 f0       	push   $0xf0129390
f0113bd4:	68 6d 05 00 00       	push   $0x56d
f0113bd9:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113bde:	e8 f3 c8 fe ff       	call   f01004d6 <_warn>
f0113be3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113be6:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0113bea:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113bee:	74 04                	je     f0113bf4 <test_allocate_chunk+0x3ac>
f0113bf0:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0113bf4:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0113bf8:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0113bff:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113c02:	c1 e0 05             	shl    $0x5,%eax
f0113c05:	83 ec 08             	sub    $0x8,%esp
f0113c08:	6a 03                	push   $0x3
f0113c0a:	6a 00                	push   $0x0
f0113c0c:	6a 00                	push   $0x0
f0113c0e:	68 07 0e 00 00       	push   $0xe07
f0113c13:	68 03 0e 00 00       	push   $0xe03
f0113c18:	6a 01                	push   $0x1
f0113c1a:	50                   	push   %eax
f0113c1b:	6a 00                	push   $0x0
f0113c1d:	6a 00                	push   $0x0
f0113c1f:	ff 75 cc             	pushl  -0x34(%ebp)
f0113c22:	e8 4f 1d 00 00       	call   f0115976 <CCP>
f0113c27:	83 c4 30             	add    $0x30,%esp
f0113c2a:	85 c0                	test   %eax,%eax
f0113c2c:	75 25                	jne    f0113c53 <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0113c2e:	83 ec 04             	sub    $0x4,%esp
f0113c31:	68 cc 92 12 f0       	push   $0xf01292cc
f0113c36:	68 76 05 00 00       	push   $0x576
f0113c3b:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113c40:	e8 91 c8 fe ff       	call   f01004d6 <_warn>
f0113c45:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113c48:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0113c4c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f0113c53:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113c57:	74 04                	je     f0113c5d <test_allocate_chunk+0x415>
f0113c59:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0113c5d:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0113c61:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0113c65:	74 5a                	je     f0113cc1 <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f0113c67:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113c6a:	01 c0                	add    %eax,%eax
f0113c6c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0113c6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113c72:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0113c75:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113c78:	01 c0                	add    %eax,%eax
f0113c7a:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0113c7d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113c80:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0113c83:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113c86:	8a 00                	mov    (%eax),%al
f0113c88:	3c 4b                	cmp    $0x4b,%al
f0113c8a:	75 09                	jne    f0113c95 <test_allocate_chunk+0x44d>
f0113c8c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113c8f:	8a 00                	mov    (%eax),%al
f0113c91:	3c 4d                	cmp    $0x4d,%al
f0113c93:	74 1e                	je     f0113cb3 <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0113c95:	83 ec 04             	sub    $0x4,%esp
f0113c98:	68 18 93 12 f0       	push   $0xf0129318
f0113c9d:	68 84 05 00 00       	push   $0x584
f0113ca2:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113ca7:	e8 2a c8 fe ff       	call   f01004d6 <_warn>
f0113cac:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113caf:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0113cb3:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113cb7:	74 04                	je     f0113cbd <test_allocate_chunk+0x475>
f0113cb9:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0113cbd:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0113cc1:	83 ec 0c             	sub    $0xc,%esp
f0113cc4:	68 6f 86 12 f0       	push   $0xf012866f
f0113cc9:	e8 bd d2 fe ff       	call   f0100f8b <cprintf>
f0113cce:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f0113cd1:	83 ec 0c             	sub    $0xc,%esp
f0113cd4:	68 f0 93 12 f0       	push   $0xf01293f0
f0113cd9:	e8 ad d2 fe ff       	call   f0100f8b <cprintf>
f0113cde:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113ce1:	e8 8f 9d ff ff       	call   f010da75 <sys_calculate_free_frames>
f0113ce6:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f0113ce9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113cec:	c1 e0 06             	shl    $0x6,%eax
f0113cef:	89 c2                	mov    %eax,%edx
f0113cf1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113cf4:	c1 e0 05             	shl    $0x5,%eax
f0113cf7:	6a 00                	push   $0x0
f0113cf9:	52                   	push   %edx
f0113cfa:	50                   	push   %eax
f0113cfb:	ff 75 cc             	pushl  -0x34(%ebp)
f0113cfe:	e8 79 62 ff ff       	call   f0109f7c <allocate_chunk>
f0113d03:	83 c4 10             	add    $0x10,%esp
f0113d06:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113d09:	e8 67 9d ff ff       	call   f010da75 <sys_calculate_free_frames>
f0113d0e:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f0113d11:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0113d15:	75 36                	jne    f0113d4d <test_allocate_chunk+0x505>
f0113d17:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113d1a:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113d1d:	89 c1                	mov    %eax,%ecx
f0113d1f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113d22:	c1 e0 06             	shl    $0x6,%eax
f0113d25:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113d28:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0113d2f:	99                   	cltd   
f0113d30:	f7 ff                	idiv   %edi
f0113d32:	89 c3                	mov    %eax,%ebx
f0113d34:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113d37:	c1 e0 06             	shl    $0x6,%eax
f0113d3a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113d3d:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0113d44:	99                   	cltd   
f0113d45:	f7 fe                	idiv   %esi
f0113d47:	01 d8                	add    %ebx,%eax
f0113d49:	39 c1                	cmp    %eax,%ecx
f0113d4b:	74 54                	je     f0113da1 <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0113d4d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113d50:	c1 e0 06             	shl    $0x6,%eax
f0113d53:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113d56:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0113d5d:	99                   	cltd   
f0113d5e:	f7 fb                	idiv   %ebx
f0113d60:	89 c1                	mov    %eax,%ecx
f0113d62:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113d65:	c1 e0 06             	shl    $0x6,%eax
f0113d68:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113d6b:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0113d72:	99                   	cltd   
f0113d73:	f7 ff                	idiv   %edi
f0113d75:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0113d78:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113d7b:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113d7e:	83 ec 08             	sub    $0x8,%esp
f0113d81:	52                   	push   %edx
f0113d82:	50                   	push   %eax
f0113d83:	ff 75 a4             	pushl  -0x5c(%ebp)
f0113d86:	68 90 93 12 f0       	push   $0xf0129390
f0113d8b:	68 9a 05 00 00       	push   $0x59a
f0113d90:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113d95:	e8 3c c7 fe ff       	call   f01004d6 <_warn>
f0113d9a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113d9d:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0113da1:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113da5:	74 04                	je     f0113dab <test_allocate_chunk+0x563>
f0113da7:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0113dab:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0113daf:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0113db6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113db9:	c1 e0 06             	shl    $0x6,%eax
f0113dbc:	89 c2                	mov    %eax,%edx
f0113dbe:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113dc1:	c1 e0 05             	shl    $0x5,%eax
f0113dc4:	83 ec 08             	sub    $0x8,%esp
f0113dc7:	6a 03                	push   $0x3
f0113dc9:	6a 00                	push   $0x0
f0113dcb:	6a 00                	push   $0x0
f0113dcd:	68 07 0e 00 00       	push   $0xe07
f0113dd2:	6a 01                	push   $0x1
f0113dd4:	6a 01                	push   $0x1
f0113dd6:	52                   	push   %edx
f0113dd7:	50                   	push   %eax
f0113dd8:	6a 00                	push   $0x0
f0113dda:	ff 75 cc             	pushl  -0x34(%ebp)
f0113ddd:	e8 94 1b 00 00       	call   f0115976 <CCP>
f0113de2:	83 c4 30             	add    $0x30,%esp
f0113de5:	85 c0                	test   %eax,%eax
f0113de7:	75 25                	jne    f0113e0e <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0113de9:	83 ec 04             	sub    $0x4,%esp
f0113dec:	68 cc 92 12 f0       	push   $0xf01292cc
f0113df1:	68 a3 05 00 00       	push   $0x5a3
f0113df6:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113dfb:	e8 d6 c6 fe ff       	call   f01004d6 <_warn>
f0113e00:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113e03:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0113e07:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0113e0e:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113e12:	74 04                	je     f0113e18 <test_allocate_chunk+0x5d0>
f0113e14:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0113e18:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0113e1c:	83 ec 0c             	sub    $0xc,%esp
f0113e1f:	68 d2 86 12 f0       	push   $0xf01286d2
f0113e24:	e8 62 d1 fe ff       	call   f0100f8b <cprintf>
f0113e29:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0113e2c:	83 ec 0c             	sub    $0xc,%esp
f0113e2f:	68 30 94 12 f0       	push   $0xf0129430
f0113e34:	e8 52 d1 fe ff       	call   f0100f8b <cprintf>
f0113e39:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113e3c:	e8 34 9c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0113e41:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0113e44:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113e47:	c1 e0 06             	shl    $0x6,%eax
f0113e4a:	68 06 0e 00 00       	push   $0xe06
f0113e4f:	50                   	push   %eax
f0113e50:	68 00 00 00 80       	push   $0x80000000
f0113e55:	ff 75 cc             	pushl  -0x34(%ebp)
f0113e58:	e8 1f 61 ff ff       	call   f0109f7c <allocate_chunk>
f0113e5d:	83 c4 10             	add    $0x10,%esp
f0113e60:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113e63:	e8 0d 9c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0113e68:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0113e6b:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f0113e6f:	75 36                	jne    f0113ea7 <test_allocate_chunk+0x65f>
f0113e71:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113e74:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113e77:	89 c1                	mov    %eax,%ecx
f0113e79:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113e7c:	c1 e0 06             	shl    $0x6,%eax
f0113e7f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113e82:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0113e89:	99                   	cltd   
f0113e8a:	f7 fb                	idiv   %ebx
f0113e8c:	89 c3                	mov    %eax,%ebx
f0113e8e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113e91:	c1 e0 06             	shl    $0x6,%eax
f0113e94:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113e97:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0113e9e:	99                   	cltd   
f0113e9f:	f7 fe                	idiv   %esi
f0113ea1:	01 d8                	add    %ebx,%eax
f0113ea3:	39 c1                	cmp    %eax,%ecx
f0113ea5:	74 54                	je     f0113efb <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0113ea7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113eaa:	c1 e0 06             	shl    $0x6,%eax
f0113ead:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113eb0:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0113eb7:	99                   	cltd   
f0113eb8:	f7 ff                	idiv   %edi
f0113eba:	89 c1                	mov    %eax,%ecx
f0113ebc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113ebf:	c1 e0 06             	shl    $0x6,%eax
f0113ec2:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113ec5:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0113ecc:	99                   	cltd   
f0113ecd:	f7 fb                	idiv   %ebx
f0113ecf:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0113ed2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113ed5:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113ed8:	83 ec 08             	sub    $0x8,%esp
f0113edb:	52                   	push   %edx
f0113edc:	50                   	push   %eax
f0113edd:	ff 75 9c             	pushl  -0x64(%ebp)
f0113ee0:	68 90 93 12 f0       	push   $0xf0129390
f0113ee5:	68 b9 05 00 00       	push   $0x5b9
f0113eea:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113eef:	e8 e2 c5 fe ff       	call   f01004d6 <_warn>
f0113ef4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113ef7:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0113efb:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113eff:	74 04                	je     f0113f05 <test_allocate_chunk+0x6bd>
f0113f01:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0113f05:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0113f09:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0113f10:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113f13:	c1 e0 06             	shl    $0x6,%eax
f0113f16:	83 ec 08             	sub    $0x8,%esp
f0113f19:	6a 03                	push   $0x3
f0113f1b:	6a 00                	push   $0x0
f0113f1d:	6a 00                	push   $0x0
f0113f1f:	68 07 0e 00 00       	push   $0xe07
f0113f24:	68 07 0e 00 00       	push   $0xe07
f0113f29:	6a 01                	push   $0x1
f0113f2b:	50                   	push   %eax
f0113f2c:	68 00 00 00 80       	push   $0x80000000
f0113f31:	6a 00                	push   $0x0
f0113f33:	ff 75 cc             	pushl  -0x34(%ebp)
f0113f36:	e8 3b 1a 00 00       	call   f0115976 <CCP>
f0113f3b:	83 c4 30             	add    $0x30,%esp
f0113f3e:	85 c0                	test   %eax,%eax
f0113f40:	75 25                	jne    f0113f67 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0113f42:	83 ec 04             	sub    $0x4,%esp
f0113f45:	68 cc 92 12 f0       	push   $0xf01292cc
f0113f4a:	68 c2 05 00 00       	push   $0x5c2
f0113f4f:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113f54:	e8 7d c5 fe ff       	call   f01004d6 <_warn>
f0113f59:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113f5c:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0113f60:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f0113f67:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113f6b:	74 04                	je     f0113f71 <test_allocate_chunk+0x729>
f0113f6d:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0113f71:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0113f75:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0113f79:	74 6f                	je     f0113fea <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0113f7b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113f7e:	01 c0                	add    %eax,%eax
f0113f80:	05 00 00 00 80       	add    $0x80000000,%eax
f0113f85:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0113f88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113f8b:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f0113f8e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113f91:	89 d0                	mov    %edx,%eax
f0113f93:	c1 e0 02             	shl    $0x2,%eax
f0113f96:	01 d0                	add    %edx,%eax
f0113f98:	01 c0                	add    %eax,%eax
f0113f9a:	01 d0                	add    %edx,%eax
f0113f9c:	01 c0                	add    %eax,%eax
f0113f9e:	05 00 00 00 80       	add    $0x80000000,%eax
f0113fa3:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0113fa6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113fa9:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0113fac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0113faf:	8a 00                	mov    (%eax),%al
f0113fb1:	3c 4b                	cmp    $0x4b,%al
f0113fb3:	75 09                	jne    f0113fbe <test_allocate_chunk+0x776>
f0113fb5:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113fb8:	8a 00                	mov    (%eax),%al
f0113fba:	3c 4d                	cmp    $0x4d,%al
f0113fbc:	74 1e                	je     f0113fdc <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0113fbe:	83 ec 04             	sub    $0x4,%esp
f0113fc1:	68 18 93 12 f0       	push   $0xf0129318
f0113fc6:	68 d0 05 00 00       	push   $0x5d0
f0113fcb:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0113fd0:	e8 01 c5 fe ff       	call   f01004d6 <_warn>
f0113fd5:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113fd8:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0113fdc:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0113fe0:	74 04                	je     f0113fe6 <test_allocate_chunk+0x79e>
f0113fe2:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0113fe6:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f0113fea:	83 ec 0c             	sub    $0xc,%esp
f0113fed:	68 a4 91 12 f0       	push   $0xf01291a4
f0113ff2:	e8 94 cf fe ff       	call   f0100f8b <cprintf>
f0113ff7:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f0113ffa:	83 ec 0c             	sub    $0xc,%esp
f0113ffd:	68 6c 94 12 f0       	push   $0xf012946c
f0114002:	e8 84 cf fe ff       	call   f0100f8b <cprintf>
f0114007:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011400a:	e8 66 9a ff ff       	call   f010da75 <sys_calculate_free_frames>
f011400f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f0114012:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114015:	89 d0                	mov    %edx,%eax
f0114017:	01 c0                	add    %eax,%eax
f0114019:	01 d0                	add    %edx,%eax
f011401b:	01 c0                	add    %eax,%eax
f011401d:	01 d0                	add    %edx,%eax
f011401f:	68 04 0e 00 00       	push   $0xe04
f0114024:	50                   	push   %eax
f0114025:	68 00 fc 3f 40       	push   $0x403ffc00
f011402a:	ff 75 cc             	pushl  -0x34(%ebp)
f011402d:	e8 4a 5f ff ff       	call   f0109f7c <allocate_chunk>
f0114032:	83 c4 10             	add    $0x10,%esp
f0114035:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114038:	e8 38 9a ff ff       	call   f010da75 <sys_calculate_free_frames>
f011403d:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f0114040:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0114044:	75 0b                	jne    f0114051 <test_allocate_chunk+0x809>
f0114046:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114049:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011404c:	83 f8 05             	cmp    $0x5,%eax
f011404f:	74 2a                	je     f011407b <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f0114051:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114054:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114057:	83 ec 08             	sub    $0x8,%esp
f011405a:	6a 05                	push   $0x5
f011405c:	50                   	push   %eax
f011405d:	ff 75 98             	pushl  -0x68(%ebp)
f0114060:	68 90 93 12 f0       	push   $0xf0129390
f0114065:	68 e7 05 00 00       	push   $0x5e7
f011406a:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011406f:	e8 62 c4 fe ff       	call   f01004d6 <_warn>
f0114074:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114077:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f011407b:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011407f:	74 04                	je     f0114085 <test_allocate_chunk+0x83d>
f0114081:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114085:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114089:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114090:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114093:	89 d0                	mov    %edx,%eax
f0114095:	01 c0                	add    %eax,%eax
f0114097:	01 d0                	add    %edx,%eax
f0114099:	c1 e0 02             	shl    $0x2,%eax
f011409c:	83 ec 08             	sub    $0x8,%esp
f011409f:	6a 03                	push   $0x3
f01140a1:	6a 00                	push   $0x0
f01140a3:	6a 00                	push   $0x0
f01140a5:	68 07 0e 00 00       	push   $0xe07
f01140aa:	68 05 0e 00 00       	push   $0xe05
f01140af:	6a 01                	push   $0x1
f01140b1:	50                   	push   %eax
f01140b2:	68 00 f0 3f 40       	push   $0x403ff000
f01140b7:	6a 00                	push   $0x0
f01140b9:	ff 75 cc             	pushl  -0x34(%ebp)
f01140bc:	e8 b5 18 00 00       	call   f0115976 <CCP>
f01140c1:	83 c4 30             	add    $0x30,%esp
f01140c4:	85 c0                	test   %eax,%eax
f01140c6:	75 25                	jne    f01140ed <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01140c8:	83 ec 04             	sub    $0x4,%esp
f01140cb:	68 cc 92 12 f0       	push   $0xf01292cc
f01140d0:	68 f0 05 00 00       	push   $0x5f0
f01140d5:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01140da:	e8 f7 c3 fe ff       	call   f01004d6 <_warn>
f01140df:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01140e2:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01140e6:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f01140ed:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01140f1:	74 04                	je     f01140f7 <test_allocate_chunk+0x8af>
f01140f3:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01140f7:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f01140fb:	83 ec 0c             	sub    $0xc,%esp
f01140fe:	68 a3 94 12 f0       	push   $0xf01294a3
f0114103:	e8 83 ce fe ff       	call   f0100f8b <cprintf>
f0114108:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f011410b:	83 ec 08             	sub    $0x8,%esp
f011410e:	ff 75 e0             	pushl  -0x20(%ebp)
f0114111:	68 b4 94 12 f0       	push   $0xf01294b4
f0114116:	e8 70 ce fe ff       	call   f0100f8b <cprintf>
f011411b:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011411e:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f0114122:	75 10                	jne    f0114134 <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0114124:	83 ec 0c             	sub    $0xc,%esp
f0114127:	68 e8 94 12 f0       	push   $0xf01294e8
f011412c:	e8 5a ce fe ff       	call   f0100f8b <cprintf>
f0114131:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114134:	a1 24 cc 5e f0       	mov    0xf05ecc24,%eax
f0114139:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011413c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011413f:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114142:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114147:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011414a:	5b                   	pop    %ebx
f011414b:	5e                   	pop    %esi
f011414c:	5f                   	pop    %edi
f011414d:	5d                   	pop    %ebp
f011414e:	c3                   	ret    

f011414f <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f011414f:	55                   	push   %ebp
f0114150:	89 e5                	mov    %esp,%ebp
f0114152:	57                   	push   %edi
f0114153:	56                   	push   %esi
f0114154:	53                   	push   %ebx
f0114155:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011415b:	8d 45 8e             	lea    -0x72(%ebp),%eax
f011415e:	bb e4 83 12 f0       	mov    $0xf01283e4,%ebx
f0114163:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114168:	89 c7                	mov    %eax,%edi
f011416a:	89 de                	mov    %ebx,%esi
f011416c:	89 d1                	mov    %edx,%ecx
f011416e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114170:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0114173:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114178:	b0 00                	mov    $0x0,%al
f011417a:	89 d7                	mov    %edx,%edi
f011417c:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011417e:	6a 00                	push   $0x0
f0114180:	6a 0a                	push   $0xa
f0114182:	6a 14                	push   $0x14
f0114184:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0114187:	50                   	push   %eax
f0114188:	e8 4e 60 ff ff       	call   f010a1db <env_create>
f011418d:	83 c4 10             	add    $0x10,%esp
f0114190:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114193:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114196:	8b 40 64             	mov    0x64(%eax),%eax
f0114199:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f011419c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011419f:	8b 40 68             	mov    0x68(%eax),%eax
f01141a2:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01141a5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01141a8:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01141ab:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f01141b2:	75 70 20 
f01141b5:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f01141bc:	00 00 00 
f01141bf:	8d 55 82             	lea    -0x7e(%ebp),%edx
f01141c2:	b9 03 00 00 00       	mov    $0x3,%ecx
f01141c7:	b8 00 00 00 00       	mov    $0x0,%eax
f01141cc:	89 d7                	mov    %edx,%edi
f01141ce:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01141d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01141d3:	8b 40 10             	mov    0x10(%eax),%eax
f01141d6:	83 ec 08             	sub    $0x8,%esp
f01141d9:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f01141df:	52                   	push   %edx
f01141e0:	50                   	push   %eax
f01141e1:	e8 9f ae 00 00       	call   f011f085 <ltostr>
f01141e6:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01141e9:	83 ec 04             	sub    $0x4,%esp
f01141ec:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01141f2:	50                   	push   %eax
f01141f3:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f01141f9:	50                   	push   %eax
f01141fa:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0114200:	50                   	push   %eax
f0114201:	e8 58 af 00 00       	call   f011f15e <strcconcat>
f0114206:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114209:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0114210:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0114217:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f011421e:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f0114225:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0114229:	83 ec 0c             	sub    $0xc,%esp
f011422c:	ff 75 d8             	pushl  -0x28(%ebp)
f011422f:	e8 0e 17 00 00       	call   f0115942 <ClearUserSpace>
f0114234:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0114237:	83 ec 0c             	sub    $0xc,%esp
f011423a:	68 28 95 12 f0       	push   $0xf0129528
f011423f:	e8 47 cd fe ff       	call   f0100f8b <cprintf>
f0114244:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0114247:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011424a:	c1 e0 03             	shl    $0x3,%eax
f011424d:	83 ec 04             	sub    $0x4,%esp
f0114250:	50                   	push   %eax
f0114251:	6a 00                	push   $0x0
f0114253:	ff 75 d8             	pushl  -0x28(%ebp)
f0114256:	e8 55 5d ff ff       	call   f0109fb0 <calculate_required_frames>
f011425b:	83 c4 10             	add    $0x10,%esp
f011425e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0114261:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0114265:	74 23                	je     f011428a <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0114267:	83 ec 0c             	sub    $0xc,%esp
f011426a:	6a 03                	push   $0x3
f011426c:	ff 75 c8             	pushl  -0x38(%ebp)
f011426f:	68 5c 95 12 f0       	push   $0xf012955c
f0114274:	68 29 06 00 00       	push   $0x629
f0114279:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011427e:	e8 53 c2 fe ff       	call   f01004d6 <_warn>
f0114283:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114286:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011428a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011428e:	74 04                	je     f0114294 <test_calculate_required_frames+0x145>
f0114290:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114294:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f0114298:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011429b:	c1 e0 02             	shl    $0x2,%eax
f011429e:	83 ec 04             	sub    $0x4,%esp
f01142a1:	50                   	push   %eax
f01142a2:	6a 00                	push   $0x0
f01142a4:	ff 75 d8             	pushl  -0x28(%ebp)
f01142a7:	e8 04 5d ff ff       	call   f0109fb0 <calculate_required_frames>
f01142ac:	83 c4 10             	add    $0x10,%esp
f01142af:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f01142b2:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f01142b9:	74 26                	je     f01142e1 <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f01142bb:	83 ec 0c             	sub    $0xc,%esp
f01142be:	68 01 04 00 00       	push   $0x401
f01142c3:	ff 75 c8             	pushl  -0x38(%ebp)
f01142c6:	68 5c 95 12 f0       	push   $0xf012955c
f01142cb:	68 33 06 00 00       	push   $0x633
f01142d0:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01142d5:	e8 fc c1 fe ff       	call   f01004d6 <_warn>
f01142da:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01142dd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01142e1:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01142e5:	74 04                	je     f01142eb <test_calculate_required_frames+0x19c>
f01142e7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01142eb:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f01142ef:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01142f2:	c1 e0 0a             	shl    $0xa,%eax
f01142f5:	83 ec 04             	sub    $0x4,%esp
f01142f8:	50                   	push   %eax
f01142f9:	6a 00                	push   $0x0
f01142fb:	ff 75 d8             	pushl  -0x28(%ebp)
f01142fe:	e8 ad 5c ff ff       	call   f0109fb0 <calculate_required_frames>
f0114303:	83 c4 10             	add    $0x10,%esp
f0114306:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0114309:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011430c:	c1 e0 0a             	shl    $0xa,%eax
f011430f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114312:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114319:	99                   	cltd   
f011431a:	f7 fb                	idiv   %ebx
f011431c:	89 c1                	mov    %eax,%ecx
f011431e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114321:	c1 e0 0a             	shl    $0xa,%eax
f0114324:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114327:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011432e:	99                   	cltd   
f011432f:	f7 fe                	idiv   %esi
f0114331:	01 c8                	add    %ecx,%eax
f0114333:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0114336:	74 4c                	je     f0114384 <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f0114338:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011433b:	c1 e0 0a             	shl    $0xa,%eax
f011433e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114341:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114348:	99                   	cltd   
f0114349:	f7 fb                	idiv   %ebx
f011434b:	89 c1                	mov    %eax,%ecx
f011434d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114350:	c1 e0 0a             	shl    $0xa,%eax
f0114353:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114356:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011435d:	99                   	cltd   
f011435e:	f7 fe                	idiv   %esi
f0114360:	01 c8                	add    %ecx,%eax
f0114362:	83 ec 0c             	sub    $0xc,%esp
f0114365:	50                   	push   %eax
f0114366:	ff 75 c8             	pushl  -0x38(%ebp)
f0114369:	68 5c 95 12 f0       	push   $0xf012955c
f011436e:	68 3d 06 00 00       	push   $0x63d
f0114373:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114378:	e8 59 c1 fe ff       	call   f01004d6 <_warn>
f011437d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114380:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114384:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114388:	74 04                	je     f011438e <test_calculate_required_frames+0x23f>
f011438a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011438e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f0114392:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114395:	89 d0                	mov    %edx,%eax
f0114397:	01 c0                	add    %eax,%eax
f0114399:	01 d0                	add    %edx,%eax
f011439b:	01 c0                	add    %eax,%eax
f011439d:	83 ec 04             	sub    $0x4,%esp
f01143a0:	50                   	push   %eax
f01143a1:	68 00 10 00 00       	push   $0x1000
f01143a6:	ff 75 d8             	pushl  -0x28(%ebp)
f01143a9:	e8 02 5c ff ff       	call   f0109fb0 <calculate_required_frames>
f01143ae:	83 c4 10             	add    $0x10,%esp
f01143b1:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01143b4:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01143b8:	74 23                	je     f01143dd <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01143ba:	83 ec 0c             	sub    $0xc,%esp
f01143bd:	6a 03                	push   $0x3
f01143bf:	ff 75 c8             	pushl  -0x38(%ebp)
f01143c2:	68 5c 95 12 f0       	push   $0xf012955c
f01143c7:	68 49 06 00 00       	push   $0x649
f01143cc:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01143d1:	e8 00 c1 fe ff       	call   f01004d6 <_warn>
f01143d6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01143d9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01143dd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01143e1:	74 04                	je     f01143e7 <test_calculate_required_frames+0x298>
f01143e3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01143e7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f01143eb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01143ee:	89 c2                	mov    %eax,%edx
f01143f0:	01 d2                	add    %edx,%edx
f01143f2:	01 d0                	add    %edx,%eax
f01143f4:	83 ec 04             	sub    $0x4,%esp
f01143f7:	50                   	push   %eax
f01143f8:	68 00 18 00 00       	push   $0x1800
f01143fd:	ff 75 d8             	pushl  -0x28(%ebp)
f0114400:	e8 ab 5b ff ff       	call   f0109fb0 <calculate_required_frames>
f0114405:	83 c4 10             	add    $0x10,%esp
f0114408:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f011440b:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f011440f:	74 23                	je     f0114434 <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0114411:	83 ec 0c             	sub    $0xc,%esp
f0114414:	6a 03                	push   $0x3
f0114416:	ff 75 c8             	pushl  -0x38(%ebp)
f0114419:	68 5c 95 12 f0       	push   $0xf012955c
f011441e:	68 53 06 00 00       	push   $0x653
f0114423:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114428:	e8 a9 c0 fe ff       	call   f01004d6 <_warn>
f011442d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114430:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114434:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114438:	74 04                	je     f011443e <test_calculate_required_frames+0x2ef>
f011443a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011443e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0114442:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114445:	89 d0                	mov    %edx,%eax
f0114447:	c1 e0 02             	shl    $0x2,%eax
f011444a:	01 d0                	add    %edx,%eax
f011444c:	01 c0                	add    %eax,%eax
f011444e:	83 ec 04             	sub    $0x4,%esp
f0114451:	50                   	push   %eax
f0114452:	68 00 00 40 00       	push   $0x400000
f0114457:	ff 75 d8             	pushl  -0x28(%ebp)
f011445a:	e8 51 5b ff ff       	call   f0109fb0 <calculate_required_frames>
f011445f:	83 c4 10             	add    $0x10,%esp
f0114462:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f0114465:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f011446c:	74 26                	je     f0114494 <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f011446e:	83 ec 0c             	sub    $0xc,%esp
f0114471:	68 03 0a 00 00       	push   $0xa03
f0114476:	ff 75 c8             	pushl  -0x38(%ebp)
f0114479:	68 5c 95 12 f0       	push   $0xf012955c
f011447e:	68 5d 06 00 00       	push   $0x65d
f0114483:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114488:	e8 49 c0 fe ff       	call   f01004d6 <_warn>
f011448d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114490:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114494:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114498:	74 04                	je     f011449e <test_calculate_required_frames+0x34f>
f011449a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011449e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f01144a2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01144a5:	01 c0                	add    %eax,%eax
f01144a7:	83 ec 04             	sub    $0x4,%esp
f01144aa:	50                   	push   %eax
f01144ab:	68 00 00 70 00       	push   $0x700000
f01144b0:	ff 75 d8             	pushl  -0x28(%ebp)
f01144b3:	e8 f8 5a ff ff       	call   f0109fb0 <calculate_required_frames>
f01144b8:	83 c4 10             	add    $0x10,%esp
f01144bb:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f01144be:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f01144c5:	74 26                	je     f01144ed <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f01144c7:	83 ec 0c             	sub    $0xc,%esp
f01144ca:	68 02 02 00 00       	push   $0x202
f01144cf:	ff 75 c8             	pushl  -0x38(%ebp)
f01144d2:	68 5c 95 12 f0       	push   $0xf012955c
f01144d7:	68 69 06 00 00       	push   $0x669
f01144dc:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01144e1:	e8 f0 bf fe ff       	call   f01004d6 <_warn>
f01144e6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01144e9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01144ed:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01144f1:	74 04                	je     f01144f7 <test_calculate_required_frames+0x3a8>
f01144f3:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01144f7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f01144fb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01144fe:	83 ec 04             	sub    $0x4,%esp
f0114501:	50                   	push   %eax
f0114502:	68 ff ff 3f 00       	push   $0x3fffff
f0114507:	ff 75 d8             	pushl  -0x28(%ebp)
f011450a:	e8 a1 5a ff ff       	call   f0109fb0 <calculate_required_frames>
f011450f:	83 c4 10             	add    $0x10,%esp
f0114512:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f0114515:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f0114519:	74 23                	je     f011453e <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f011451b:	83 ec 0c             	sub    $0xc,%esp
f011451e:	6a 04                	push   $0x4
f0114520:	ff 75 c8             	pushl  -0x38(%ebp)
f0114523:	68 5c 95 12 f0       	push   $0xf012955c
f0114528:	68 73 06 00 00       	push   $0x673
f011452d:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114532:	e8 9f bf fe ff       	call   f01004d6 <_warn>
f0114537:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011453a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011453e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114542:	74 04                	je     f0114548 <test_calculate_required_frames+0x3f9>
f0114544:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114548:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011454c:	83 ec 0c             	sub    $0xc,%esp
f011454f:	68 95 90 12 f0       	push   $0xf0129095
f0114554:	e8 32 ca fe ff       	call   f0100f8b <cprintf>
f0114559:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f011455c:	83 ec 0c             	sub    $0xc,%esp
f011455f:	68 b4 95 12 f0       	push   $0xf01295b4
f0114564:	e8 22 ca fe ff       	call   f0100f8b <cprintf>
f0114569:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f011456c:	83 ec 04             	sub    $0x4,%esp
f011456f:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0114575:	50                   	push   %eax
f0114576:	68 4e 84 12 f0       	push   $0xf012844e
f011457b:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114581:	50                   	push   %eax
f0114582:	e8 d7 ab 00 00       	call   f011f15e <strcconcat>
f0114587:	83 c4 10             	add    $0x10,%esp
f011458a:	83 ec 0c             	sub    $0xc,%esp
f011458d:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0114593:	50                   	push   %eax
f0114594:	e8 62 d9 fe ff       	call   f0101efb <execute_command>
f0114599:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f011459c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011459f:	c1 e0 03             	shl    $0x3,%eax
f01145a2:	83 ec 04             	sub    $0x4,%esp
f01145a5:	50                   	push   %eax
f01145a6:	6a 00                	push   $0x0
f01145a8:	ff 75 d8             	pushl  -0x28(%ebp)
f01145ab:	e8 00 5a ff ff       	call   f0109fb0 <calculate_required_frames>
f01145b0:	83 c4 10             	add    $0x10,%esp
f01145b3:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f01145b6:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f01145bd:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01145c0:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01145c3:	74 24                	je     f01145e9 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01145c5:	83 ec 0c             	sub    $0xc,%esp
f01145c8:	ff 75 c4             	pushl  -0x3c(%ebp)
f01145cb:	ff 75 c8             	pushl  -0x38(%ebp)
f01145ce:	68 5c 95 12 f0       	push   $0xf012955c
f01145d3:	68 87 06 00 00       	push   $0x687
f01145d8:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01145dd:	e8 f4 be fe ff       	call   f01004d6 <_warn>
f01145e2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01145e5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01145e9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01145ed:	74 04                	je     f01145f3 <test_calculate_required_frames+0x4a4>
f01145ef:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01145f3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f01145f7:	83 ec 04             	sub    $0x4,%esp
f01145fa:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0114600:	50                   	push   %eax
f0114601:	68 5b 84 12 f0       	push   $0xf012845b
f0114606:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011460c:	50                   	push   %eax
f011460d:	e8 4c ab 00 00       	call   f011f15e <strcconcat>
f0114612:	83 c4 10             	add    $0x10,%esp
f0114615:	83 ec 0c             	sub    $0xc,%esp
f0114618:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011461e:	50                   	push   %eax
f011461f:	e8 d7 d8 fe ff       	call   f0101efb <execute_command>
f0114624:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0114627:	83 ec 04             	sub    $0x4,%esp
f011462a:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0114630:	50                   	push   %eax
f0114631:	68 e8 95 12 f0       	push   $0xf01295e8
f0114636:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011463c:	50                   	push   %eax
f011463d:	e8 1c ab 00 00       	call   f011f15e <strcconcat>
f0114642:	83 c4 10             	add    $0x10,%esp
f0114645:	83 ec 0c             	sub    $0xc,%esp
f0114648:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011464e:	50                   	push   %eax
f011464f:	e8 a7 d8 fe ff       	call   f0101efb <execute_command>
f0114654:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f0114657:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011465a:	c1 e0 03             	shl    $0x3,%eax
f011465d:	83 ec 04             	sub    $0x4,%esp
f0114660:	50                   	push   %eax
f0114661:	6a 00                	push   $0x0
f0114663:	ff 75 d8             	pushl  -0x28(%ebp)
f0114666:	e8 45 59 ff ff       	call   f0109fb0 <calculate_required_frames>
f011466b:	83 c4 10             	add    $0x10,%esp
f011466e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f0114671:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f0114678:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011467b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011467e:	74 24                	je     f01146a4 <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0114680:	83 ec 0c             	sub    $0xc,%esp
f0114683:	ff 75 c4             	pushl  -0x3c(%ebp)
f0114686:	ff 75 c8             	pushl  -0x38(%ebp)
f0114689:	68 5c 95 12 f0       	push   $0xf012955c
f011468e:	68 95 06 00 00       	push   $0x695
f0114693:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114698:	e8 39 be fe ff       	call   f01004d6 <_warn>
f011469d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01146a0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01146a4:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01146a8:	74 04                	je     f01146ae <test_calculate_required_frames+0x55f>
f01146aa:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01146ae:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f01146b2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01146b5:	c1 e0 0a             	shl    $0xa,%eax
f01146b8:	83 ec 04             	sub    $0x4,%esp
f01146bb:	50                   	push   %eax
f01146bc:	6a 00                	push   $0x0
f01146be:	ff 75 d8             	pushl  -0x28(%ebp)
f01146c1:	e8 ea 58 ff ff       	call   f0109fb0 <calculate_required_frames>
f01146c6:	83 c4 10             	add    $0x10,%esp
f01146c9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f01146cc:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01146cf:	c1 e0 0a             	shl    $0xa,%eax
f01146d2:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01146d5:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01146dc:	99                   	cltd   
f01146dd:	f7 fb                	idiv   %ebx
f01146df:	89 c1                	mov    %eax,%ecx
f01146e1:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01146e4:	c1 e0 0a             	shl    $0xa,%eax
f01146e7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01146ea:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01146f1:	99                   	cltd   
f01146f2:	f7 fe                	idiv   %esi
f01146f4:	01 c8                	add    %ecx,%eax
f01146f6:	83 e8 05             	sub    $0x5,%eax
f01146f9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f01146fc:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01146ff:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0114702:	74 24                	je     f0114728 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0114704:	83 ec 0c             	sub    $0xc,%esp
f0114707:	ff 75 c4             	pushl  -0x3c(%ebp)
f011470a:	ff 75 c8             	pushl  -0x38(%ebp)
f011470d:	68 5c 95 12 f0       	push   $0xf012955c
f0114712:	68 a0 06 00 00       	push   $0x6a0
f0114717:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011471c:	e8 b5 bd fe ff       	call   f01004d6 <_warn>
f0114721:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114724:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114728:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011472c:	74 04                	je     f0114732 <test_calculate_required_frames+0x5e3>
f011472e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114732:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0114736:	83 ec 04             	sub    $0x4,%esp
f0114739:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011473f:	50                   	push   %eax
f0114740:	68 f4 95 12 f0       	push   $0xf01295f4
f0114745:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011474b:	50                   	push   %eax
f011474c:	e8 0d aa 00 00       	call   f011f15e <strcconcat>
f0114751:	83 c4 10             	add    $0x10,%esp
f0114754:	83 ec 0c             	sub    $0xc,%esp
f0114757:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011475d:	50                   	push   %eax
f011475e:	e8 98 d7 fe ff       	call   f0101efb <execute_command>
f0114763:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0114766:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114769:	89 c2                	mov    %eax,%edx
f011476b:	01 d2                	add    %edx,%edx
f011476d:	01 d0                	add    %edx,%eax
f011476f:	83 ec 04             	sub    $0x4,%esp
f0114772:	50                   	push   %eax
f0114773:	68 00 18 00 00       	push   $0x1800
f0114778:	ff 75 d8             	pushl  -0x28(%ebp)
f011477b:	e8 30 58 ff ff       	call   f0109fb0 <calculate_required_frames>
f0114780:	83 c4 10             	add    $0x10,%esp
f0114783:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0114786:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f011478d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114790:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0114793:	74 24                	je     f01147b9 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0114795:	83 ec 0c             	sub    $0xc,%esp
f0114798:	ff 75 c4             	pushl  -0x3c(%ebp)
f011479b:	ff 75 c8             	pushl  -0x38(%ebp)
f011479e:	68 5c 95 12 f0       	push   $0xf012955c
f01147a3:	68 af 06 00 00       	push   $0x6af
f01147a8:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01147ad:	e8 24 bd fe ff       	call   f01004d6 <_warn>
f01147b2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01147b5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01147b9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01147bd:	74 04                	je     f01147c3 <test_calculate_required_frames+0x674>
f01147bf:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01147c3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f01147c7:	83 ec 04             	sub    $0x4,%esp
f01147ca:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01147d0:	50                   	push   %eax
f01147d1:	68 b4 86 12 f0       	push   $0xf01286b4
f01147d6:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01147dc:	50                   	push   %eax
f01147dd:	e8 7c a9 00 00       	call   f011f15e <strcconcat>
f01147e2:	83 c4 10             	add    $0x10,%esp
f01147e5:	83 ec 0c             	sub    $0xc,%esp
f01147e8:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01147ee:	50                   	push   %eax
f01147ef:	e8 07 d7 fe ff       	call   f0101efb <execute_command>
f01147f4:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f01147f7:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01147fa:	89 d0                	mov    %edx,%eax
f01147fc:	c1 e0 02             	shl    $0x2,%eax
f01147ff:	01 d0                	add    %edx,%eax
f0114801:	01 c0                	add    %eax,%eax
f0114803:	83 ec 04             	sub    $0x4,%esp
f0114806:	50                   	push   %eax
f0114807:	68 00 00 40 00       	push   $0x400000
f011480c:	ff 75 d8             	pushl  -0x28(%ebp)
f011480f:	e8 9c 57 ff ff       	call   f0109fb0 <calculate_required_frames>
f0114814:	83 c4 10             	add    $0x10,%esp
f0114817:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f011481a:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f0114821:	74 26                	je     f0114849 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0114823:	83 ec 0c             	sub    $0xc,%esp
f0114826:	68 03 0a 00 00       	push   $0xa03
f011482b:	ff 75 c8             	pushl  -0x38(%ebp)
f011482e:	68 5c 95 12 f0       	push   $0xf012955c
f0114833:	68 bb 06 00 00       	push   $0x6bb
f0114838:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011483d:	e8 94 bc fe ff       	call   f01004d6 <_warn>
f0114842:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114845:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114849:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011484d:	74 04                	je     f0114853 <test_calculate_required_frames+0x704>
f011484f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114853:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0114857:	83 ec 04             	sub    $0x4,%esp
f011485a:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0114860:	50                   	push   %eax
f0114861:	68 be 86 12 f0       	push   $0xf01286be
f0114866:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011486c:	50                   	push   %eax
f011486d:	e8 ec a8 00 00       	call   f011f15e <strcconcat>
f0114872:	83 c4 10             	add    $0x10,%esp
f0114875:	83 ec 0c             	sub    $0xc,%esp
f0114878:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011487e:	50                   	push   %eax
f011487f:	e8 77 d6 fe ff       	call   f0101efb <execute_command>
f0114884:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0114887:	83 ec 04             	sub    $0x4,%esp
f011488a:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0114890:	50                   	push   %eax
f0114891:	68 fc 95 12 f0       	push   $0xf01295fc
f0114896:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011489c:	50                   	push   %eax
f011489d:	e8 bc a8 00 00       	call   f011f15e <strcconcat>
f01148a2:	83 c4 10             	add    $0x10,%esp
f01148a5:	83 ec 0c             	sub    $0xc,%esp
f01148a8:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01148ae:	50                   	push   %eax
f01148af:	e8 47 d6 fe ff       	call   f0101efb <execute_command>
f01148b4:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f01148b7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01148ba:	01 c0                	add    %eax,%eax
f01148bc:	83 ec 04             	sub    $0x4,%esp
f01148bf:	50                   	push   %eax
f01148c0:	68 00 00 70 00       	push   $0x700000
f01148c5:	ff 75 d8             	pushl  -0x28(%ebp)
f01148c8:	e8 e3 56 ff ff       	call   f0109fb0 <calculate_required_frames>
f01148cd:	83 c4 10             	add    $0x10,%esp
f01148d0:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f01148d3:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f01148da:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01148dd:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01148e0:	74 24                	je     f0114906 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01148e2:	83 ec 0c             	sub    $0xc,%esp
f01148e5:	ff 75 c4             	pushl  -0x3c(%ebp)
f01148e8:	ff 75 c8             	pushl  -0x38(%ebp)
f01148eb:	68 5c 95 12 f0       	push   $0xf012955c
f01148f0:	68 cb 06 00 00       	push   $0x6cb
f01148f5:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01148fa:	e8 d7 bb fe ff       	call   f01004d6 <_warn>
f01148ff:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114902:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114906:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011490a:	74 04                	je     f0114910 <test_calculate_required_frames+0x7c1>
f011490c:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114910:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0114914:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114917:	83 ec 04             	sub    $0x4,%esp
f011491a:	50                   	push   %eax
f011491b:	68 ff ff 3f 00       	push   $0x3fffff
f0114920:	ff 75 d8             	pushl  -0x28(%ebp)
f0114923:	e8 88 56 ff ff       	call   f0109fb0 <calculate_required_frames>
f0114928:	83 c4 10             	add    $0x10,%esp
f011492b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f011492e:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f0114935:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114938:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011493b:	74 24                	je     f0114961 <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011493d:	83 ec 0c             	sub    $0xc,%esp
f0114940:	ff 75 c4             	pushl  -0x3c(%ebp)
f0114943:	ff 75 c8             	pushl  -0x38(%ebp)
f0114946:	68 5c 95 12 f0       	push   $0xf012955c
f011494b:	68 d6 06 00 00       	push   $0x6d6
f0114950:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114955:	e8 7c bb fe ff       	call   f01004d6 <_warn>
f011495a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011495d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114961:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114965:	74 04                	je     f011496b <test_calculate_required_frames+0x81c>
f0114967:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011496b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f011496f:	83 ec 0c             	sub    $0xc,%esp
f0114972:	68 6f 86 12 f0       	push   $0xf012866f
f0114977:	e8 0f c6 fe ff       	call   f0100f8b <cprintf>
f011497c:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f011497f:	83 ec 08             	sub    $0x8,%esp
f0114982:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114985:	68 08 96 12 f0       	push   $0xf0129608
f011498a:	e8 fc c5 fe ff       	call   f0100f8b <cprintf>
f011498f:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114992:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114996:	75 10                	jne    f01149a8 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0114998:	83 ec 0c             	sub    $0xc,%esp
f011499b:	68 48 96 12 f0       	push   $0xf0129648
f01149a0:	e8 e6 c5 fe ff       	call   f0100f8b <cprintf>
f01149a5:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01149a8:	a1 24 cc 5e f0       	mov    0xf05ecc24,%eax
f01149ad:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01149b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01149b3:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01149b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01149bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01149be:	5b                   	pop    %ebx
f01149bf:	5e                   	pop    %esi
f01149c0:	5f                   	pop    %edi
f01149c1:	5d                   	pop    %ebp
f01149c2:	c3                   	ret    

f01149c3 <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f01149c3:	55                   	push   %ebp
f01149c4:	89 e5                	mov    %esp,%ebp
f01149c6:	57                   	push   %edi
f01149c7:	56                   	push   %esi
f01149c8:	53                   	push   %ebx
f01149c9:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01149cf:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01149d2:	bb e4 83 12 f0       	mov    $0xf01283e4,%ebx
f01149d7:	ba 0f 00 00 00       	mov    $0xf,%edx
f01149dc:	89 c7                	mov    %eax,%edi
f01149de:	89 de                	mov    %ebx,%esi
f01149e0:	89 d1                	mov    %edx,%ecx
f01149e2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01149e4:	8d 55 9d             	lea    -0x63(%ebp),%edx
f01149e7:	b9 23 00 00 00       	mov    $0x23,%ecx
f01149ec:	b0 00                	mov    $0x0,%al
f01149ee:	89 d7                	mov    %edx,%edi
f01149f0:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01149f2:	6a 00                	push   $0x0
f01149f4:	6a 0a                	push   $0xa
f01149f6:	6a 14                	push   $0x14
f01149f8:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01149fb:	50                   	push   %eax
f01149fc:	e8 da 57 ff ff       	call   f010a1db <env_create>
f0114a01:	83 c4 10             	add    $0x10,%esp
f0114a04:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114a07:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114a0a:	8b 40 64             	mov    0x64(%eax),%eax
f0114a0d:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0114a10:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114a13:	8b 40 68             	mov    0x68(%eax),%eax
f0114a16:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0114a19:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114a1c:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0114a1f:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0114a26:	75 70 20 
f0114a29:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0114a30:	00 00 00 
f0114a33:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0114a36:	b9 03 00 00 00       	mov    $0x3,%ecx
f0114a3b:	b8 00 00 00 00       	mov    $0x0,%eax
f0114a40:	89 d7                	mov    %edx,%edi
f0114a42:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0114a44:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0114a47:	8b 40 10             	mov    0x10(%eax),%eax
f0114a4a:	83 ec 08             	sub    $0x8,%esp
f0114a4d:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f0114a53:	52                   	push   %edx
f0114a54:	50                   	push   %eax
f0114a55:	e8 2b a6 00 00       	call   f011f085 <ltostr>
f0114a5a:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0114a5d:	83 ec 04             	sub    $0x4,%esp
f0114a60:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0114a66:	50                   	push   %eax
f0114a67:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0114a6d:	50                   	push   %eax
f0114a6e:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0114a74:	50                   	push   %eax
f0114a75:	e8 e4 a6 00 00       	call   f011f15e <strcconcat>
f0114a7a:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114a7d:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0114a84:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0114a8b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f0114a92:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0114a96:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114a9d:	00 00 00 
	uint32 num_tables = 0;
f0114aa0:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114aa7:	00 00 00 
	ClearUserSpace(proc_directory);
f0114aaa:	83 ec 0c             	sub    $0xc,%esp
f0114aad:	ff 75 d8             	pushl  -0x28(%ebp)
f0114ab0:	e8 8d 0e 00 00       	call   f0115942 <ClearUserSpace>
f0114ab5:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0114ab8:	83 ec 0c             	sub    $0xc,%esp
f0114abb:	68 28 95 12 f0       	push   $0xf0129528
f0114ac0:	e8 c6 c4 fe ff       	call   f0100f8b <cprintf>
f0114ac5:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0114ac8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114acb:	c1 e0 03             	shl    $0x3,%eax
f0114ace:	89 c2                	mov    %eax,%edx
f0114ad0:	83 ec 0c             	sub    $0xc,%esp
f0114ad3:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114ad9:	50                   	push   %eax
f0114ada:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114ae0:	50                   	push   %eax
f0114ae1:	52                   	push   %edx
f0114ae2:	6a 00                	push   $0x0
f0114ae4:	ff 75 d8             	pushl  -0x28(%ebp)
f0114ae7:	e8 aa 54 ff ff       	call   f0109f96 <calculate_allocated_space>
f0114aec:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114aef:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114af5:	85 c0                	test   %eax,%eax
f0114af7:	74 27                	je     f0114b20 <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114af9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114aff:	83 ec 0c             	sub    $0xc,%esp
f0114b02:	6a 00                	push   $0x0
f0114b04:	50                   	push   %eax
f0114b05:	68 94 96 12 f0       	push   $0xf0129694
f0114b0a:	68 0b 07 00 00       	push   $0x70b
f0114b0f:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114b14:	e8 bd b9 fe ff       	call   f01004d6 <_warn>
f0114b19:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114b1c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114b20:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114b26:	85 c0                	test   %eax,%eax
f0114b28:	74 27                	je     f0114b51 <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114b2a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114b30:	83 ec 0c             	sub    $0xc,%esp
f0114b33:	6a 00                	push   $0x0
f0114b35:	50                   	push   %eax
f0114b36:	68 f4 96 12 f0       	push   $0xf01296f4
f0114b3b:	68 10 07 00 00       	push   $0x710
f0114b40:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114b45:	e8 8c b9 fe ff       	call   f01004d6 <_warn>
f0114b4a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114b4d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114b51:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114b55:	74 04                	je     f0114b5b <test_calculate_allocated_space+0x198>
f0114b57:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114b5b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f0114b5f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114b66:	00 00 00 
		num_pages = 0;
f0114b69:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114b70:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f0114b73:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114b76:	c1 e0 02             	shl    $0x2,%eax
f0114b79:	89 c2                	mov    %eax,%edx
f0114b7b:	83 ec 0c             	sub    $0xc,%esp
f0114b7e:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114b84:	50                   	push   %eax
f0114b85:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114b8b:	50                   	push   %eax
f0114b8c:	52                   	push   %edx
f0114b8d:	6a 00                	push   $0x0
f0114b8f:	ff 75 d8             	pushl  -0x28(%ebp)
f0114b92:	e8 ff 53 ff ff       	call   f0109f96 <calculate_allocated_space>
f0114b97:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114b9a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114ba0:	85 c0                	test   %eax,%eax
f0114ba2:	74 27                	je     f0114bcb <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114ba4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114baa:	83 ec 0c             	sub    $0xc,%esp
f0114bad:	6a 00                	push   $0x0
f0114baf:	50                   	push   %eax
f0114bb0:	68 94 96 12 f0       	push   $0xf0129694
f0114bb5:	68 1c 07 00 00       	push   $0x71c
f0114bba:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114bbf:	e8 12 b9 fe ff       	call   f01004d6 <_warn>
f0114bc4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114bc7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114bcb:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114bd1:	85 c0                	test   %eax,%eax
f0114bd3:	74 27                	je     f0114bfc <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114bd5:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114bdb:	83 ec 0c             	sub    $0xc,%esp
f0114bde:	6a 00                	push   $0x0
f0114be0:	50                   	push   %eax
f0114be1:	68 f4 96 12 f0       	push   $0xf01296f4
f0114be6:	68 21 07 00 00       	push   $0x721
f0114beb:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114bf0:	e8 e1 b8 fe ff       	call   f01004d6 <_warn>
f0114bf5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114bf8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114bfc:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114c00:	74 04                	je     f0114c06 <test_calculate_allocated_space+0x243>
f0114c02:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114c06:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0114c0a:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114c11:	00 00 00 
		num_pages = 0;
f0114c14:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114c1b:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0114c1e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114c21:	c1 e0 0a             	shl    $0xa,%eax
f0114c24:	89 c2                	mov    %eax,%edx
f0114c26:	83 ec 0c             	sub    $0xc,%esp
f0114c29:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114c2f:	50                   	push   %eax
f0114c30:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114c36:	50                   	push   %eax
f0114c37:	52                   	push   %edx
f0114c38:	6a 00                	push   $0x0
f0114c3a:	ff 75 d8             	pushl  -0x28(%ebp)
f0114c3d:	e8 54 53 ff ff       	call   f0109f96 <calculate_allocated_space>
f0114c42:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114c45:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114c4b:	85 c0                	test   %eax,%eax
f0114c4d:	74 27                	je     f0114c76 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114c4f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114c55:	83 ec 0c             	sub    $0xc,%esp
f0114c58:	6a 00                	push   $0x0
f0114c5a:	50                   	push   %eax
f0114c5b:	68 94 96 12 f0       	push   $0xf0129694
f0114c60:	68 2d 07 00 00       	push   $0x72d
f0114c65:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114c6a:	e8 67 b8 fe ff       	call   f01004d6 <_warn>
f0114c6f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114c72:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114c76:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114c7c:	85 c0                	test   %eax,%eax
f0114c7e:	74 27                	je     f0114ca7 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114c80:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114c86:	83 ec 0c             	sub    $0xc,%esp
f0114c89:	6a 00                	push   $0x0
f0114c8b:	50                   	push   %eax
f0114c8c:	68 f4 96 12 f0       	push   $0xf01296f4
f0114c91:	68 32 07 00 00       	push   $0x732
f0114c96:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114c9b:	e8 36 b8 fe ff       	call   f01004d6 <_warn>
f0114ca0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114ca3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114ca7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114cab:	74 04                	je     f0114cb1 <test_calculate_allocated_space+0x2ee>
f0114cad:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114cb1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f0114cb5:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114cbc:	00 00 00 
		num_pages = 0;
f0114cbf:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114cc6:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f0114cc9:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0114ccc:	89 d0                	mov    %edx,%eax
f0114cce:	01 c0                	add    %eax,%eax
f0114cd0:	01 d0                	add    %edx,%eax
f0114cd2:	01 c0                	add    %eax,%eax
f0114cd4:	05 00 10 00 00       	add    $0x1000,%eax
f0114cd9:	89 c2                	mov    %eax,%edx
f0114cdb:	83 ec 0c             	sub    $0xc,%esp
f0114cde:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114ce4:	50                   	push   %eax
f0114ce5:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114ceb:	50                   	push   %eax
f0114cec:	52                   	push   %edx
f0114ced:	68 00 10 00 00       	push   $0x1000
f0114cf2:	ff 75 d8             	pushl  -0x28(%ebp)
f0114cf5:	e8 9c 52 ff ff       	call   f0109f96 <calculate_allocated_space>
f0114cfa:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114cfd:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114d03:	85 c0                	test   %eax,%eax
f0114d05:	74 27                	je     f0114d2e <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114d07:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114d0d:	83 ec 0c             	sub    $0xc,%esp
f0114d10:	6a 00                	push   $0x0
f0114d12:	50                   	push   %eax
f0114d13:	68 94 96 12 f0       	push   $0xf0129694
f0114d18:	68 3f 07 00 00       	push   $0x73f
f0114d1d:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114d22:	e8 af b7 fe ff       	call   f01004d6 <_warn>
f0114d27:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114d2a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114d2e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114d34:	85 c0                	test   %eax,%eax
f0114d36:	74 27                	je     f0114d5f <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114d38:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114d3e:	83 ec 0c             	sub    $0xc,%esp
f0114d41:	6a 00                	push   $0x0
f0114d43:	50                   	push   %eax
f0114d44:	68 f4 96 12 f0       	push   $0xf01296f4
f0114d49:	68 44 07 00 00       	push   $0x744
f0114d4e:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114d53:	e8 7e b7 fe ff       	call   f01004d6 <_warn>
f0114d58:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114d5b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114d5f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114d63:	74 04                	je     f0114d69 <test_calculate_allocated_space+0x3a6>
f0114d65:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114d69:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0114d6d:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114d74:	00 00 00 
		num_pages = 0;
f0114d77:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114d7e:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0114d81:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114d84:	89 c2                	mov    %eax,%edx
f0114d86:	01 d2                	add    %edx,%edx
f0114d88:	01 d0                	add    %edx,%eax
f0114d8a:	05 00 18 00 00       	add    $0x1800,%eax
f0114d8f:	89 c2                	mov    %eax,%edx
f0114d91:	83 ec 0c             	sub    $0xc,%esp
f0114d94:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114d9a:	50                   	push   %eax
f0114d9b:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114da1:	50                   	push   %eax
f0114da2:	52                   	push   %edx
f0114da3:	68 00 18 00 00       	push   $0x1800
f0114da8:	ff 75 d8             	pushl  -0x28(%ebp)
f0114dab:	e8 e6 51 ff ff       	call   f0109f96 <calculate_allocated_space>
f0114db0:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114db3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114db9:	85 c0                	test   %eax,%eax
f0114dbb:	74 27                	je     f0114de4 <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114dbd:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114dc3:	83 ec 0c             	sub    $0xc,%esp
f0114dc6:	6a 00                	push   $0x0
f0114dc8:	50                   	push   %eax
f0114dc9:	68 94 96 12 f0       	push   $0xf0129694
f0114dce:	68 50 07 00 00       	push   $0x750
f0114dd3:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114dd8:	e8 f9 b6 fe ff       	call   f01004d6 <_warn>
f0114ddd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114de0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114de4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114dea:	85 c0                	test   %eax,%eax
f0114dec:	74 27                	je     f0114e15 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114dee:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114df4:	83 ec 0c             	sub    $0xc,%esp
f0114df7:	6a 00                	push   $0x0
f0114df9:	50                   	push   %eax
f0114dfa:	68 f4 96 12 f0       	push   $0xf01296f4
f0114dff:	68 55 07 00 00       	push   $0x755
f0114e04:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114e09:	e8 c8 b6 fe ff       	call   f01004d6 <_warn>
f0114e0e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114e11:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114e15:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114e19:	74 04                	je     f0114e1f <test_calculate_allocated_space+0x45c>
f0114e1b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114e1f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0114e23:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114e2a:	00 00 00 
		num_pages = 0;
f0114e2d:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114e34:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0114e37:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0114e3a:	89 d0                	mov    %edx,%eax
f0114e3c:	c1 e0 02             	shl    $0x2,%eax
f0114e3f:	01 d0                	add    %edx,%eax
f0114e41:	01 c0                	add    %eax,%eax
f0114e43:	05 00 00 40 00       	add    $0x400000,%eax
f0114e48:	89 c2                	mov    %eax,%edx
f0114e4a:	83 ec 0c             	sub    $0xc,%esp
f0114e4d:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114e53:	50                   	push   %eax
f0114e54:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114e5a:	50                   	push   %eax
f0114e5b:	52                   	push   %edx
f0114e5c:	68 00 00 40 00       	push   $0x400000
f0114e61:	ff 75 d8             	pushl  -0x28(%ebp)
f0114e64:	e8 2d 51 ff ff       	call   f0109f96 <calculate_allocated_space>
f0114e69:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114e6c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114e72:	85 c0                	test   %eax,%eax
f0114e74:	74 27                	je     f0114e9d <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114e76:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114e7c:	83 ec 0c             	sub    $0xc,%esp
f0114e7f:	6a 00                	push   $0x0
f0114e81:	50                   	push   %eax
f0114e82:	68 94 96 12 f0       	push   $0xf0129694
f0114e87:	68 61 07 00 00       	push   $0x761
f0114e8c:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114e91:	e8 40 b6 fe ff       	call   f01004d6 <_warn>
f0114e96:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114e99:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114e9d:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114ea3:	85 c0                	test   %eax,%eax
f0114ea5:	74 27                	je     f0114ece <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114ea7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114ead:	83 ec 0c             	sub    $0xc,%esp
f0114eb0:	6a 00                	push   $0x0
f0114eb2:	50                   	push   %eax
f0114eb3:	68 f4 96 12 f0       	push   $0xf01296f4
f0114eb8:	68 66 07 00 00       	push   $0x766
f0114ebd:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114ec2:	e8 0f b6 fe ff       	call   f01004d6 <_warn>
f0114ec7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114eca:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114ece:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114ed2:	74 04                	je     f0114ed8 <test_calculate_allocated_space+0x515>
f0114ed4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114ed8:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0114edc:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114ee3:	00 00 00 
		num_pages = 0;
f0114ee6:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114eed:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0114ef0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0114ef3:	05 00 00 38 00       	add    $0x380000,%eax
f0114ef8:	01 c0                	add    %eax,%eax
f0114efa:	89 c2                	mov    %eax,%edx
f0114efc:	83 ec 0c             	sub    $0xc,%esp
f0114eff:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114f05:	50                   	push   %eax
f0114f06:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114f0c:	50                   	push   %eax
f0114f0d:	52                   	push   %edx
f0114f0e:	68 00 00 70 00       	push   $0x700000
f0114f13:	ff 75 d8             	pushl  -0x28(%ebp)
f0114f16:	e8 7b 50 ff ff       	call   f0109f96 <calculate_allocated_space>
f0114f1b:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114f1e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114f24:	85 c0                	test   %eax,%eax
f0114f26:	74 27                	je     f0114f4f <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114f28:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114f2e:	83 ec 0c             	sub    $0xc,%esp
f0114f31:	6a 00                	push   $0x0
f0114f33:	50                   	push   %eax
f0114f34:	68 94 96 12 f0       	push   $0xf0129694
f0114f39:	68 73 07 00 00       	push   $0x773
f0114f3e:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114f43:	e8 8e b5 fe ff       	call   f01004d6 <_warn>
f0114f48:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f4b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114f4f:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114f55:	85 c0                	test   %eax,%eax
f0114f57:	74 27                	je     f0114f80 <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0114f59:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0114f5f:	83 ec 0c             	sub    $0xc,%esp
f0114f62:	6a 00                	push   $0x0
f0114f64:	50                   	push   %eax
f0114f65:	68 f4 96 12 f0       	push   $0xf01296f4
f0114f6a:	68 78 07 00 00       	push   $0x778
f0114f6f:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114f74:	e8 5d b5 fe ff       	call   f01004d6 <_warn>
f0114f79:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114f7c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114f80:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114f84:	74 04                	je     f0114f8a <test_calculate_allocated_space+0x5c7>
f0114f86:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114f8a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f0114f8e:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0114f95:	00 00 00 
		num_pages = 0;
f0114f98:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0114f9f:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0114fa2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114fa5:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0114faa:	89 c2                	mov    %eax,%edx
f0114fac:	83 ec 0c             	sub    $0xc,%esp
f0114faf:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0114fb5:	50                   	push   %eax
f0114fb6:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0114fbc:	50                   	push   %eax
f0114fbd:	52                   	push   %edx
f0114fbe:	68 ff ff 3f 00       	push   $0x3fffff
f0114fc3:	ff 75 d8             	pushl  -0x28(%ebp)
f0114fc6:	e8 cb 4f ff ff       	call   f0109f96 <calculate_allocated_space>
f0114fcb:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0114fce:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114fd4:	85 c0                	test   %eax,%eax
f0114fd6:	74 27                	je     f0114fff <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0114fd8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0114fde:	83 ec 0c             	sub    $0xc,%esp
f0114fe1:	6a 00                	push   $0x0
f0114fe3:	50                   	push   %eax
f0114fe4:	68 94 96 12 f0       	push   $0xf0129694
f0114fe9:	68 84 07 00 00       	push   $0x784
f0114fee:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0114ff3:	e8 de b4 fe ff       	call   f01004d6 <_warn>
f0114ff8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114ffb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0114fff:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115005:	85 c0                	test   %eax,%eax
f0115007:	74 27                	je     f0115030 <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115009:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011500f:	83 ec 0c             	sub    $0xc,%esp
f0115012:	6a 00                	push   $0x0
f0115014:	50                   	push   %eax
f0115015:	68 f4 96 12 f0       	push   $0xf01296f4
f011501a:	68 89 07 00 00       	push   $0x789
f011501f:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0115024:	e8 ad b4 fe ff       	call   f01004d6 <_warn>
f0115029:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011502c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115030:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115034:	74 04                	je     f011503a <test_calculate_allocated_space+0x677>
f0115036:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011503a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011503e:	83 ec 0c             	sub    $0xc,%esp
f0115041:	68 95 90 12 f0       	push   $0xf0129095
f0115046:	e8 40 bf fe ff       	call   f0100f8b <cprintf>
f011504b:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f011504e:	83 ec 0c             	sub    $0xc,%esp
f0115051:	68 b4 95 12 f0       	push   $0xf01295b4
f0115056:	e8 30 bf fe ff       	call   f0100f8b <cprintf>
f011505b:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f011505e:	83 ec 04             	sub    $0x4,%esp
f0115061:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0115067:	50                   	push   %eax
f0115068:	68 4e 84 12 f0       	push   $0xf012844e
f011506d:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115073:	50                   	push   %eax
f0115074:	e8 e5 a0 00 00       	call   f011f15e <strcconcat>
f0115079:	83 c4 10             	add    $0x10,%esp
f011507c:	83 ec 0c             	sub    $0xc,%esp
f011507f:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0115085:	50                   	push   %eax
f0115086:	e8 70 ce fe ff       	call   f0101efb <execute_command>
f011508b:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f011508e:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115095:	00 00 00 
		num_pages = 0;
f0115098:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011509f:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f01150a2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01150a5:	c1 e0 03             	shl    $0x3,%eax
f01150a8:	89 c2                	mov    %eax,%edx
f01150aa:	83 ec 0c             	sub    $0xc,%esp
f01150ad:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01150b3:	50                   	push   %eax
f01150b4:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01150ba:	50                   	push   %eax
f01150bb:	52                   	push   %edx
f01150bc:	6a 00                	push   $0x0
f01150be:	ff 75 d8             	pushl  -0x28(%ebp)
f01150c1:	e8 d0 4e ff ff       	call   f0109f96 <calculate_allocated_space>
f01150c6:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f01150c9:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f01150d0:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01150d7:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01150dd:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01150e0:	74 28                	je     f011510a <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01150e2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01150e8:	83 ec 0c             	sub    $0xc,%esp
f01150eb:	ff 75 c8             	pushl  -0x38(%ebp)
f01150ee:	50                   	push   %eax
f01150ef:	68 94 96 12 f0       	push   $0xf0129694
f01150f4:	68 a0 07 00 00       	push   $0x7a0
f01150f9:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01150fe:	e8 d3 b3 fe ff       	call   f01004d6 <_warn>
f0115103:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115106:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f011510a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115110:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115113:	74 28                	je     f011513d <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115115:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011511b:	83 ec 0c             	sub    $0xc,%esp
f011511e:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115121:	50                   	push   %eax
f0115122:	68 f4 96 12 f0       	push   $0xf01296f4
f0115127:	68 a5 07 00 00       	push   $0x7a5
f011512c:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0115131:	e8 a0 b3 fe ff       	call   f01004d6 <_warn>
f0115136:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115139:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011513d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115141:	74 04                	je     f0115147 <test_calculate_allocated_space+0x784>
f0115143:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115147:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f011514b:	83 ec 04             	sub    $0x4,%esp
f011514e:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115154:	50                   	push   %eax
f0115155:	68 5b 84 12 f0       	push   $0xf012845b
f011515a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115160:	50                   	push   %eax
f0115161:	e8 f8 9f 00 00       	call   f011f15e <strcconcat>
f0115166:	83 c4 10             	add    $0x10,%esp
f0115169:	83 ec 0c             	sub    $0xc,%esp
f011516c:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115172:	50                   	push   %eax
f0115173:	e8 83 cd fe ff       	call   f0101efb <execute_command>
f0115178:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f011517b:	83 ec 04             	sub    $0x4,%esp
f011517e:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115184:	50                   	push   %eax
f0115185:	68 e8 95 12 f0       	push   $0xf01295e8
f011518a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115190:	50                   	push   %eax
f0115191:	e8 c8 9f 00 00       	call   f011f15e <strcconcat>
f0115196:	83 c4 10             	add    $0x10,%esp
f0115199:	83 ec 0c             	sub    $0xc,%esp
f011519c:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01151a2:	50                   	push   %eax
f01151a3:	e8 53 cd fe ff       	call   f0101efb <execute_command>
f01151a8:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f01151ab:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01151b2:	00 00 00 
		num_pages = 0;
f01151b5:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01151bc:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f01151bf:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01151c2:	c1 e0 03             	shl    $0x3,%eax
f01151c5:	89 c2                	mov    %eax,%edx
f01151c7:	83 ec 0c             	sub    $0xc,%esp
f01151ca:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01151d0:	50                   	push   %eax
f01151d1:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01151d7:	50                   	push   %eax
f01151d8:	52                   	push   %edx
f01151d9:	6a 00                	push   $0x0
f01151db:	ff 75 d8             	pushl  -0x28(%ebp)
f01151de:	e8 b3 4d ff ff       	call   f0109f96 <calculate_allocated_space>
f01151e3:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f01151e6:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f01151ed:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01151f4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01151fa:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01151fd:	74 28                	je     f0115227 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01151ff:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115205:	83 ec 0c             	sub    $0xc,%esp
f0115208:	ff 75 c8             	pushl  -0x38(%ebp)
f011520b:	50                   	push   %eax
f011520c:	68 94 96 12 f0       	push   $0xf0129694
f0115211:	68 b6 07 00 00       	push   $0x7b6
f0115216:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011521b:	e8 b6 b2 fe ff       	call   f01004d6 <_warn>
f0115220:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115223:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115227:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011522d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115230:	74 28                	je     f011525a <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115232:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115238:	83 ec 0c             	sub    $0xc,%esp
f011523b:	ff 75 c4             	pushl  -0x3c(%ebp)
f011523e:	50                   	push   %eax
f011523f:	68 f4 96 12 f0       	push   $0xf01296f4
f0115244:	68 bb 07 00 00       	push   $0x7bb
f0115249:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011524e:	e8 83 b2 fe ff       	call   f01004d6 <_warn>
f0115253:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115256:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011525a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011525e:	74 04                	je     f0115264 <test_calculate_allocated_space+0x8a1>
f0115260:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115264:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0115268:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011526f:	00 00 00 
		num_pages = 0;
f0115272:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115279:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f011527c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011527f:	c1 e0 0a             	shl    $0xa,%eax
f0115282:	89 c2                	mov    %eax,%edx
f0115284:	83 ec 0c             	sub    $0xc,%esp
f0115287:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011528d:	50                   	push   %eax
f011528e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115294:	50                   	push   %eax
f0115295:	52                   	push   %edx
f0115296:	6a 00                	push   $0x0
f0115298:	ff 75 d8             	pushl  -0x28(%ebp)
f011529b:	e8 f6 4c ff ff       	call   f0109f96 <calculate_allocated_space>
f01152a0:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f01152a3:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f01152aa:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01152b1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01152b7:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01152ba:	74 28                	je     f01152e4 <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01152bc:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01152c2:	83 ec 0c             	sub    $0xc,%esp
f01152c5:	ff 75 c8             	pushl  -0x38(%ebp)
f01152c8:	50                   	push   %eax
f01152c9:	68 94 96 12 f0       	push   $0xf0129694
f01152ce:	68 c9 07 00 00       	push   $0x7c9
f01152d3:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01152d8:	e8 f9 b1 fe ff       	call   f01004d6 <_warn>
f01152dd:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01152e0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01152e4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01152ea:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01152ed:	74 28                	je     f0115317 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01152ef:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01152f5:	83 ec 0c             	sub    $0xc,%esp
f01152f8:	ff 75 c4             	pushl  -0x3c(%ebp)
f01152fb:	50                   	push   %eax
f01152fc:	68 f4 96 12 f0       	push   $0xf01296f4
f0115301:	68 ce 07 00 00       	push   $0x7ce
f0115306:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011530b:	e8 c6 b1 fe ff       	call   f01004d6 <_warn>
f0115310:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115313:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115317:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011531b:	74 04                	je     f0115321 <test_calculate_allocated_space+0x95e>
f011531d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115321:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0115325:	83 ec 04             	sub    $0x4,%esp
f0115328:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011532e:	50                   	push   %eax
f011532f:	68 f4 95 12 f0       	push   $0xf01295f4
f0115334:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011533a:	50                   	push   %eax
f011533b:	e8 1e 9e 00 00       	call   f011f15e <strcconcat>
f0115340:	83 c4 10             	add    $0x10,%esp
f0115343:	83 ec 0c             	sub    $0xc,%esp
f0115346:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011534c:	50                   	push   %eax
f011534d:	e8 a9 cb fe ff       	call   f0101efb <execute_command>
f0115352:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f0115355:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011535c:	00 00 00 
		num_pages = 0;
f011535f:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115366:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0115369:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011536c:	89 c2                	mov    %eax,%edx
f011536e:	01 d2                	add    %edx,%edx
f0115370:	01 d0                	add    %edx,%eax
f0115372:	05 00 18 00 00       	add    $0x1800,%eax
f0115377:	89 c2                	mov    %eax,%edx
f0115379:	83 ec 0c             	sub    $0xc,%esp
f011537c:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115382:	50                   	push   %eax
f0115383:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115389:	50                   	push   %eax
f011538a:	52                   	push   %edx
f011538b:	68 00 18 00 00       	push   $0x1800
f0115390:	ff 75 d8             	pushl  -0x28(%ebp)
f0115393:	e8 fe 4b ff ff       	call   f0109f96 <calculate_allocated_space>
f0115398:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011539b:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f01153a2:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01153a9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01153af:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01153b2:	74 28                	je     f01153dc <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01153b4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01153ba:	83 ec 0c             	sub    $0xc,%esp
f01153bd:	ff 75 c8             	pushl  -0x38(%ebp)
f01153c0:	50                   	push   %eax
f01153c1:	68 94 96 12 f0       	push   $0xf0129694
f01153c6:	68 df 07 00 00       	push   $0x7df
f01153cb:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01153d0:	e8 01 b1 fe ff       	call   f01004d6 <_warn>
f01153d5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01153d8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01153dc:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01153e2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01153e5:	74 28                	je     f011540f <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01153e7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01153ed:	83 ec 0c             	sub    $0xc,%esp
f01153f0:	ff 75 c4             	pushl  -0x3c(%ebp)
f01153f3:	50                   	push   %eax
f01153f4:	68 f4 96 12 f0       	push   $0xf01296f4
f01153f9:	68 e4 07 00 00       	push   $0x7e4
f01153fe:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0115403:	e8 ce b0 fe ff       	call   f01004d6 <_warn>
f0115408:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011540b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011540f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115413:	74 04                	je     f0115419 <test_calculate_allocated_space+0xa56>
f0115415:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115419:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f011541d:	83 ec 04             	sub    $0x4,%esp
f0115420:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115426:	50                   	push   %eax
f0115427:	68 b4 86 12 f0       	push   $0xf01286b4
f011542c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115432:	50                   	push   %eax
f0115433:	e8 26 9d 00 00       	call   f011f15e <strcconcat>
f0115438:	83 c4 10             	add    $0x10,%esp
f011543b:	83 ec 0c             	sub    $0xc,%esp
f011543e:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115444:	50                   	push   %eax
f0115445:	e8 b1 ca fe ff       	call   f0101efb <execute_command>
f011544a:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f011544d:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115454:	00 00 00 
		num_pages = 0;
f0115457:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011545e:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0115461:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115464:	89 d0                	mov    %edx,%eax
f0115466:	c1 e0 02             	shl    $0x2,%eax
f0115469:	01 d0                	add    %edx,%eax
f011546b:	01 c0                	add    %eax,%eax
f011546d:	05 00 00 40 00       	add    $0x400000,%eax
f0115472:	89 c2                	mov    %eax,%edx
f0115474:	83 ec 0c             	sub    $0xc,%esp
f0115477:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011547d:	50                   	push   %eax
f011547e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115484:	50                   	push   %eax
f0115485:	52                   	push   %edx
f0115486:	68 00 00 40 00       	push   $0x400000
f011548b:	ff 75 d8             	pushl  -0x28(%ebp)
f011548e:	e8 03 4b ff ff       	call   f0109f96 <calculate_allocated_space>
f0115493:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0115496:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f011549d:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01154a4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01154aa:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01154ad:	74 28                	je     f01154d7 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01154af:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01154b5:	83 ec 0c             	sub    $0xc,%esp
f01154b8:	ff 75 c8             	pushl  -0x38(%ebp)
f01154bb:	50                   	push   %eax
f01154bc:	68 94 96 12 f0       	push   $0xf0129694
f01154c1:	68 f4 07 00 00       	push   $0x7f4
f01154c6:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01154cb:	e8 06 b0 fe ff       	call   f01004d6 <_warn>
f01154d0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01154d3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01154d7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01154dd:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01154e0:	74 28                	je     f011550a <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01154e2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01154e8:	83 ec 0c             	sub    $0xc,%esp
f01154eb:	ff 75 c4             	pushl  -0x3c(%ebp)
f01154ee:	50                   	push   %eax
f01154ef:	68 f4 96 12 f0       	push   $0xf01296f4
f01154f4:	68 f9 07 00 00       	push   $0x7f9
f01154f9:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01154fe:	e8 d3 af fe ff       	call   f01004d6 <_warn>
f0115503:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115506:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011550a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011550e:	74 04                	je     f0115514 <test_calculate_allocated_space+0xb51>
f0115510:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115514:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0115518:	83 ec 04             	sub    $0x4,%esp
f011551b:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115521:	50                   	push   %eax
f0115522:	68 be 86 12 f0       	push   $0xf01286be
f0115527:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011552d:	50                   	push   %eax
f011552e:	e8 2b 9c 00 00       	call   f011f15e <strcconcat>
f0115533:	83 c4 10             	add    $0x10,%esp
f0115536:	83 ec 0c             	sub    $0xc,%esp
f0115539:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011553f:	50                   	push   %eax
f0115540:	e8 b6 c9 fe ff       	call   f0101efb <execute_command>
f0115545:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0115548:	83 ec 04             	sub    $0x4,%esp
f011554b:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115551:	50                   	push   %eax
f0115552:	68 fc 95 12 f0       	push   $0xf01295fc
f0115557:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011555d:	50                   	push   %eax
f011555e:	e8 fb 9b 00 00       	call   f011f15e <strcconcat>
f0115563:	83 c4 10             	add    $0x10,%esp
f0115566:	83 ec 0c             	sub    $0xc,%esp
f0115569:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011556f:	50                   	push   %eax
f0115570:	e8 86 c9 fe ff       	call   f0101efb <execute_command>
f0115575:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f0115578:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011557f:	00 00 00 
		num_pages = 0;
f0115582:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115589:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f011558c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011558f:	05 00 00 38 00       	add    $0x380000,%eax
f0115594:	01 c0                	add    %eax,%eax
f0115596:	89 c2                	mov    %eax,%edx
f0115598:	83 ec 0c             	sub    $0xc,%esp
f011559b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01155a1:	50                   	push   %eax
f01155a2:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01155a8:	50                   	push   %eax
f01155a9:	52                   	push   %edx
f01155aa:	68 00 00 70 00       	push   $0x700000
f01155af:	ff 75 d8             	pushl  -0x28(%ebp)
f01155b2:	e8 df 49 ff ff       	call   f0109f96 <calculate_allocated_space>
f01155b7:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01155ba:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f01155c1:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01155c8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01155ce:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01155d1:	74 28                	je     f01155fb <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01155d3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01155d9:	83 ec 0c             	sub    $0xc,%esp
f01155dc:	ff 75 c8             	pushl  -0x38(%ebp)
f01155df:	50                   	push   %eax
f01155e0:	68 94 96 12 f0       	push   $0xf0129694
f01155e5:	68 0b 08 00 00       	push   $0x80b
f01155ea:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01155ef:	e8 e2 ae fe ff       	call   f01004d6 <_warn>
f01155f4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01155f7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01155fb:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115601:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115604:	74 28                	je     f011562e <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115606:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011560c:	83 ec 0c             	sub    $0xc,%esp
f011560f:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115612:	50                   	push   %eax
f0115613:	68 f4 96 12 f0       	push   $0xf01296f4
f0115618:	68 10 08 00 00       	push   $0x810
f011561d:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0115622:	e8 af ae fe ff       	call   f01004d6 <_warn>
f0115627:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011562a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011562e:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115632:	74 04                	je     f0115638 <test_calculate_allocated_space+0xc75>
f0115634:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115638:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f011563c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115643:	00 00 00 
		num_pages = 0;
f0115646:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011564d:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0115650:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115653:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0115658:	89 c2                	mov    %eax,%edx
f011565a:	83 ec 0c             	sub    $0xc,%esp
f011565d:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115663:	50                   	push   %eax
f0115664:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011566a:	50                   	push   %eax
f011566b:	52                   	push   %edx
f011566c:	68 ff ff 3f 00       	push   $0x3fffff
f0115671:	ff 75 d8             	pushl  -0x28(%ebp)
f0115674:	e8 1d 49 ff ff       	call   f0109f96 <calculate_allocated_space>
f0115679:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f011567c:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f0115683:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011568a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115690:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115693:	74 28                	je     f01156bd <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115695:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011569b:	83 ec 0c             	sub    $0xc,%esp
f011569e:	ff 75 c8             	pushl  -0x38(%ebp)
f01156a1:	50                   	push   %eax
f01156a2:	68 94 96 12 f0       	push   $0xf0129694
f01156a7:	68 1e 08 00 00       	push   $0x81e
f01156ac:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01156b1:	e8 20 ae fe ff       	call   f01004d6 <_warn>
f01156b6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01156b9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01156bd:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01156c3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01156c6:	74 28                	je     f01156f0 <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01156c8:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01156ce:	83 ec 0c             	sub    $0xc,%esp
f01156d1:	ff 75 c4             	pushl  -0x3c(%ebp)
f01156d4:	50                   	push   %eax
f01156d5:	68 f4 96 12 f0       	push   $0xf01296f4
f01156da:	68 23 08 00 00       	push   $0x823
f01156df:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01156e4:	e8 ed ad fe ff       	call   f01004d6 <_warn>
f01156e9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01156ec:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01156f0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01156f4:	74 04                	je     f01156fa <test_calculate_allocated_space+0xd37>
f01156f6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01156fa:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f01156fe:	83 ec 0c             	sub    $0xc,%esp
f0115701:	68 6f 86 12 f0       	push   $0xf012866f
f0115706:	e8 80 b8 fe ff       	call   f0100f8b <cprintf>
f011570b:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f011570e:	83 ec 08             	sub    $0x8,%esp
f0115711:	ff 75 e4             	pushl  -0x1c(%ebp)
f0115714:	68 50 97 12 f0       	push   $0xf0129750
f0115719:	e8 6d b8 fe ff       	call   f0100f8b <cprintf>
f011571e:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0115721:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0115725:	75 10                	jne    f0115737 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f0115727:	83 ec 0c             	sub    $0xc,%esp
f011572a:	68 90 97 12 f0       	push   $0xf0129790
f011572f:	e8 57 b8 fe ff       	call   f0100f8b <cprintf>
f0115734:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115737:	a1 24 cc 5e f0       	mov    0xf05ecc24,%eax
f011573c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011573f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115742:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115745:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011574a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011574d:	5b                   	pop    %ebx
f011574e:	5e                   	pop    %esi
f011574f:	5f                   	pop    %edi
f0115750:	5d                   	pop    %ebp
f0115751:	c3                   	ret    

f0115752 <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f0115752:	55                   	push   %ebp
f0115753:	89 e5                	mov    %esp,%ebp
f0115755:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f0115758:	8b 45 10             	mov    0x10(%ebp),%eax
f011575b:	ba 01 00 00 00       	mov    $0x1,%edx
f0115760:	88 c1                	mov    %al,%cl
f0115762:	d3 e2                	shl    %cl,%edx
f0115764:	89 d0                	mov    %edx,%eax
f0115766:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0115769:	8b 45 0c             	mov    0xc(%ebp),%eax
f011576c:	c1 e8 16             	shr    $0x16,%eax
f011576f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0115776:	8b 45 08             	mov    0x8(%ebp),%eax
f0115779:	01 d0                	add    %edx,%eax
f011577b:	8b 00                	mov    (%eax),%eax
f011577d:	83 e0 01             	and    $0x1,%eax
f0115780:	85 c0                	test   %eax,%eax
f0115782:	75 07                	jne    f011578b <CB+0x39>
f0115784:	b8 00 00 00 00       	mov    $0x0,%eax
f0115789:	eb 76                	jmp    f0115801 <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f011578b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011578e:	c1 e8 16             	shr    $0x16,%eax
f0115791:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0115798:	8b 45 08             	mov    0x8(%ebp),%eax
f011579b:	01 d0                	add    %edx,%eax
f011579d:	8b 00                	mov    (%eax),%eax
f011579f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01157a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01157a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01157aa:	c1 e8 0c             	shr    $0xc,%eax
f01157ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01157b0:	a1 f8 c6 5e f0       	mov    0xf05ec6f8,%eax
f01157b5:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01157b8:	72 17                	jb     f01157d1 <CB+0x7f>
f01157ba:	ff 75 f0             	pushl  -0x10(%ebp)
f01157bd:	68 dc 97 12 f0       	push   $0xf01297dc
f01157c2:	68 3e 08 00 00       	push   $0x83e
f01157c7:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01157cc:	e8 68 ab fe ff       	call   f0100339 <_panic>
f01157d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01157d4:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01157d9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f01157dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01157df:	c1 e8 0c             	shr    $0xc,%eax
f01157e2:	25 ff 03 00 00       	and    $0x3ff,%eax
f01157e7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01157ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01157f1:	01 d0                	add    %edx,%eax
f01157f3:	8b 00                	mov    (%eax),%eax
f01157f5:	23 45 f4             	and    -0xc(%ebp),%eax
f01157f8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01157fb:	0f 94 c0             	sete   %al
f01157fe:	0f b6 c0             	movzbl %al,%eax
}
f0115801:	c9                   	leave  
f0115802:	c3                   	ret    

f0115803 <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f0115803:	55                   	push   %ebp
f0115804:	89 e5                	mov    %esp,%ebp
f0115806:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0115809:	68 0b 98 12 f0       	push   $0xf012980b
f011580e:	68 1a 98 12 f0       	push   $0xf012981a
f0115813:	68 43 08 00 00       	push   $0x843
f0115818:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011581d:	e8 17 ab fe ff       	call   f0100339 <_panic>

f0115822 <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f0115822:	55                   	push   %ebp
f0115823:	89 e5                	mov    %esp,%ebp
f0115825:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0115828:	68 0b 98 12 f0       	push   $0xf012980b
f011582d:	68 1a 98 12 f0       	push   $0xf012981a
f0115832:	68 4d 08 00 00       	push   $0x84d
f0115837:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011583c:	e8 f8 aa fe ff       	call   f0100339 <_panic>

f0115841 <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f0115841:	55                   	push   %ebp
f0115842:	89 e5                	mov    %esp,%ebp
f0115844:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0115847:	68 0b 98 12 f0       	push   $0xf012980b
f011584c:	68 1a 98 12 f0       	push   $0xf012981a
f0115851:	68 5c 08 00 00       	push   $0x85c
f0115856:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011585b:	e8 d9 aa fe ff       	call   f0100339 <_panic>

f0115860 <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
}

int CE(uint32 *_d, uint32 va)
{
f0115860:	55                   	push   %ebp
f0115861:	89 e5                	mov    %esp,%ebp
f0115863:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0115866:	8b 45 0c             	mov    0xc(%ebp),%eax
f0115869:	c1 e8 16             	shr    $0x16,%eax
f011586c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0115873:	8b 45 08             	mov    0x8(%ebp),%eax
f0115876:	01 d0                	add    %edx,%eax
f0115878:	8b 00                	mov    (%eax),%eax
f011587a:	83 e0 01             	and    $0x1,%eax
f011587d:	85 c0                	test   %eax,%eax
f011587f:	75 07                	jne    f0115888 <CE+0x28>
f0115881:	b8 00 00 00 00       	mov    $0x0,%eax
f0115886:	eb 7a                	jmp    f0115902 <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0115888:	8b 45 0c             	mov    0xc(%ebp),%eax
f011588b:	c1 e8 16             	shr    $0x16,%eax
f011588e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0115895:	8b 45 08             	mov    0x8(%ebp),%eax
f0115898:	01 d0                	add    %edx,%eax
f011589a:	8b 00                	mov    (%eax),%eax
f011589c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01158a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01158a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01158a7:	c1 e8 0c             	shr    $0xc,%eax
f01158aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01158ad:	a1 f8 c6 5e f0       	mov    0xf05ec6f8,%eax
f01158b2:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f01158b5:	72 17                	jb     f01158ce <CE+0x6e>
f01158b7:	ff 75 f4             	pushl  -0xc(%ebp)
f01158ba:	68 dc 97 12 f0       	push   $0xf01297dc
f01158bf:	68 65 08 00 00       	push   $0x865
f01158c4:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01158c9:	e8 6b aa fe ff       	call   f0100339 <_panic>
f01158ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01158d1:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01158d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f01158d9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01158dc:	c1 e8 0c             	shr    $0xc,%eax
f01158df:	25 ff 03 00 00       	and    $0x3ff,%eax
f01158e4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01158eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01158ee:	01 d0                	add    %edx,%eax
f01158f0:	8b 00                	mov    (%eax),%eax
f01158f2:	85 c0                	test   %eax,%eax
f01158f4:	74 07                	je     f01158fd <CE+0x9d>
f01158f6:	b8 00 00 00 00       	mov    $0x0,%eax
f01158fb:	eb 05                	jmp    f0115902 <CE+0xa2>
	return 1;
f01158fd:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0115902:	c9                   	leave  
f0115903:	c3                   	ret    

f0115904 <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f0115904:	55                   	push   %ebp
f0115905:	89 e5                	mov    %esp,%ebp
f0115907:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f011590a:	68 0b 98 12 f0       	push   $0xf012980b
f011590f:	68 1a 98 12 f0       	push   $0xf012981a
f0115914:	68 6c 08 00 00       	push   $0x86c
f0115919:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011591e:	e8 16 aa fe ff       	call   f0100339 <_panic>

f0115923 <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f0115923:	55                   	push   %ebp
f0115924:	89 e5                	mov    %esp,%ebp
f0115926:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0115929:	68 0b 98 12 f0       	push   $0xf012980b
f011592e:	68 1a 98 12 f0       	push   $0xf012981a
f0115933:	68 7c 08 00 00       	push   $0x87c
f0115938:	68 e2 7c 12 f0       	push   $0xf0127ce2
f011593d:	e8 f7 a9 fe ff       	call   f0100339 <_panic>

f0115942 <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f0115942:	55                   	push   %ebp
f0115943:	89 e5                	mov    %esp,%ebp
f0115945:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0115948:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011594f:	eb 18                	jmp    f0115969 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f0115951:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0115954:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011595b:	8b 45 08             	mov    0x8(%ebp),%eax
f011595e:	01 d0                	add    %edx,%eax
f0115960:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0115966:	ff 45 fc             	incl   -0x4(%ebp)
f0115969:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011596c:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0115971:	76 de                	jbe    f0115951 <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f0115973:	90                   	nop
f0115974:	c9                   	leave  
f0115975:	c3                   	ret    

f0115976 <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f0115976:	55                   	push   %ebp
f0115977:	89 e5                	mov    %esp,%ebp
f0115979:	83 ec 38             	sub    $0x38,%esp
f011597c:	8b 45 2c             	mov    0x2c(%ebp),%eax
f011597f:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f0115982:	8b 45 0c             	mov    0xc(%ebp),%eax
f0115985:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011598a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f011598d:	8b 45 10             	mov    0x10(%ebp),%eax
f0115990:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0115995:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0115998:	e9 ea 01 00 00       	jmp    f0115b87 <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f011599d:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f01159a1:	74 44                	je     f01159e7 <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f01159a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01159a6:	83 ec 04             	sub    $0x4,%esp
f01159a9:	8d 55 dc             	lea    -0x24(%ebp),%edx
f01159ac:	52                   	push   %edx
f01159ad:	50                   	push   %eax
f01159ae:	ff 75 08             	pushl  0x8(%ebp)
f01159b1:	e8 83 2e ff ff       	call   f0108839 <get_frame_info>
f01159b6:	83 c4 10             	add    $0x10,%esp
f01159b9:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f01159bc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01159bf:	85 c0                	test   %eax,%eax
f01159c1:	75 24                	jne    f01159e7 <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f01159c3:	83 ec 04             	sub    $0x4,%esp
f01159c6:	68 30 98 12 f0       	push   $0xf0129830
f01159cb:	68 99 08 00 00       	push   $0x899
f01159d0:	68 e2 7c 12 f0       	push   $0xf0127ce2
f01159d5:	e8 fc aa fe ff       	call   f01004d6 <_warn>
f01159da:	83 c4 10             	add    $0x10,%esp
				return 0;
f01159dd:	b8 00 00 00 00       	mov    $0x0,%eax
f01159e2:	e9 b6 01 00 00       	jmp    f0115b9d <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f01159e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01159ea:	83 ec 04             	sub    $0x4,%esp
f01159ed:	8d 55 d8             	lea    -0x28(%ebp),%edx
f01159f0:	52                   	push   %edx
f01159f1:	50                   	push   %eax
f01159f2:	ff 75 08             	pushl  0x8(%ebp)
f01159f5:	e8 3f 2e ff ff       	call   f0108839 <get_frame_info>
f01159fa:	83 c4 10             	add    $0x10,%esp
f01159fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f0115a00:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0115a03:	85 c0                	test   %eax,%eax
f0115a05:	75 24                	jne    f0115a2b <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0115a07:	83 ec 04             	sub    $0x4,%esp
f0115a0a:	68 5c 98 12 f0       	push   $0xf012985c
f0115a0f:	68 a0 08 00 00       	push   $0x8a0
f0115a14:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0115a19:	e8 b8 aa fe ff       	call   f01004d6 <_warn>
f0115a1e:	83 c4 10             	add    $0x10,%esp
			return 0;
f0115a21:	b8 00 00 00 00       	mov    $0x0,%eax
f0115a26:	e9 72 01 00 00       	jmp    f0115b9d <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0115a2b:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f0115a2f:	75 70                	jne    f0115aa1 <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f0115a31:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115a34:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0115a37:	c1 ea 0c             	shr    $0xc,%edx
f0115a3a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0115a40:	c1 e2 02             	shl    $0x2,%edx
f0115a43:	01 d0                	add    %edx,%eax
f0115a45:	8b 00                	mov    (%eax),%eax
f0115a47:	c1 e8 0c             	shr    $0xc,%eax
f0115a4a:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f0115a4d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0115a50:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0115a53:	c1 ea 0c             	shr    $0xc,%edx
f0115a56:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0115a5c:	c1 e2 02             	shl    $0x2,%edx
f0115a5f:	01 d0                	add    %edx,%eax
f0115a61:	8b 00                	mov    (%eax),%eax
f0115a63:	c1 e8 0c             	shr    $0xc,%eax
f0115a66:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0115a69:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0115a6c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0115a6f:	74 30                	je     f0115aa1 <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f0115a71:	83 ec 04             	sub    $0x4,%esp
f0115a74:	ff 75 e4             	pushl  -0x1c(%ebp)
f0115a77:	ff 75 e8             	pushl  -0x18(%ebp)
f0115a7a:	ff 75 f0             	pushl  -0x10(%ebp)
f0115a7d:	ff 75 f4             	pushl  -0xc(%ebp)
f0115a80:	68 88 98 12 f0       	push   $0xf0129888
f0115a85:	68 aa 08 00 00       	push   $0x8aa
f0115a8a:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0115a8f:	e8 42 aa fe ff       	call   f01004d6 <_warn>
f0115a94:	83 c4 20             	add    $0x20,%esp
				return 0;
f0115a97:	b8 00 00 00 00       	mov    $0x0,%eax
f0115a9c:	e9 fc 00 00 00       	jmp    f0115b9d <CCP+0x227>
			}
		}
		if (ref != -1)
f0115aa1:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f0115aa5:	74 52                	je     f0115af9 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f0115aa7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0115aab:	74 0e                	je     f0115abb <CCP+0x145>
f0115aad:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0115ab0:	8b 40 08             	mov    0x8(%eax),%eax
f0115ab3:	0f b7 c0             	movzwl %ax,%eax
f0115ab6:	3b 45 18             	cmp    0x18(%ebp),%eax
f0115ab9:	74 3e                	je     f0115af9 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0115abb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0115abf:	74 0b                	je     f0115acc <CCP+0x156>
f0115ac1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0115ac4:	8b 40 08             	mov    0x8(%eax),%eax
f0115ac7:	0f b7 c0             	movzwl %ax,%eax
f0115aca:	eb 05                	jmp    f0115ad1 <CCP+0x15b>
f0115acc:	b8 00 00 00 00       	mov    $0x0,%eax
f0115ad1:	83 ec 0c             	sub    $0xc,%esp
f0115ad4:	50                   	push   %eax
f0115ad5:	ff 75 f0             	pushl  -0x10(%ebp)
f0115ad8:	68 e4 98 12 f0       	push   $0xf01298e4
f0115add:	68 b2 08 00 00       	push   $0x8b2
f0115ae2:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0115ae7:	e8 ea a9 fe ff       	call   f01004d6 <_warn>
f0115aec:	83 c4 20             	add    $0x20,%esp
				return 0;
f0115aef:	b8 00 00 00 00       	mov    $0x0,%eax
f0115af4:	e9 a4 00 00 00       	jmp    f0115b9d <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0115af9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0115afc:	ff 75 20             	pushl  0x20(%ebp)
f0115aff:	ff 75 1c             	pushl  0x1c(%ebp)
f0115b02:	50                   	push   %eax
f0115b03:	ff 75 08             	pushl  0x8(%ebp)
f0115b06:	e8 17 fd ff ff       	call   f0115822 <CPs>
f0115b0b:	83 c4 10             	add    $0x10,%esp
f0115b0e:	85 c0                	test   %eax,%eax
f0115b10:	7f 21                	jg     f0115b33 <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f0115b12:	83 ec 04             	sub    $0x4,%esp
f0115b15:	68 54 99 12 f0       	push   $0xf0129954
f0115b1a:	68 b8 08 00 00       	push   $0x8b8
f0115b1f:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0115b24:	e8 ad a9 fe ff       	call   f01004d6 <_warn>
f0115b29:	83 c4 10             	add    $0x10,%esp
			return 0;
f0115b2c:	b8 00 00 00 00       	mov    $0x0,%eax
f0115b31:	eb 6a                	jmp    f0115b9d <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f0115b33:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0115b37:	74 3a                	je     f0115b73 <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0115b39:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0115b3c:	ff 75 28             	pushl  0x28(%ebp)
f0115b3f:	ff 75 24             	pushl  0x24(%ebp)
f0115b42:	50                   	push   %eax
f0115b43:	ff 75 08             	pushl  0x8(%ebp)
f0115b46:	e8 d7 fc ff ff       	call   f0115822 <CPs>
f0115b4b:	83 c4 10             	add    $0x10,%esp
f0115b4e:	85 c0                	test   %eax,%eax
f0115b50:	7f 21                	jg     f0115b73 <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f0115b52:	83 ec 04             	sub    $0x4,%esp
f0115b55:	68 9c 99 12 f0       	push   $0xf012999c
f0115b5a:	68 bf 08 00 00       	push   $0x8bf
f0115b5f:	68 e2 7c 12 f0       	push   $0xf0127ce2
f0115b64:	e8 6d a9 fe ff       	call   f01004d6 <_warn>
f0115b69:	83 c4 10             	add    $0x10,%esp
				return 0;
f0115b6c:	b8 00 00 00 00       	mov    $0x0,%eax
f0115b71:	eb 2a                	jmp    f0115b9d <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f0115b73:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0115b77:	74 07                	je     f0115b80 <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0115b79:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0115b80:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0115b87:	8b 55 10             	mov    0x10(%ebp),%edx
f0115b8a:	8b 45 14             	mov    0x14(%ebp),%eax
f0115b8d:	01 d0                	add    %edx,%eax
f0115b8f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0115b92:	0f 87 05 fe ff ff    	ja     f011599d <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0115b98:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0115b9d:	c9                   	leave  
f0115b9e:	c3                   	ret    

f0115b9f <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f0115b9f:	55                   	push   %ebp
f0115ba0:	89 e5                	mov    %esp,%ebp
f0115ba2:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0115ba5:	83 ec 04             	sub    $0x4,%esp
f0115ba8:	68 dc 99 12 f0       	push   $0xf01299dc
f0115bad:	6a 0e                	push   $0xe
f0115baf:	68 ec 99 12 f0       	push   $0xf01299ec
f0115bb4:	e8 80 a7 fe ff       	call   f0100339 <_panic>

f0115bb9 <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f0115bb9:	55                   	push   %ebp
f0115bba:	89 e5                	mov    %esp,%ebp
f0115bbc:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f0115bbf:	83 ec 04             	sub    $0x4,%esp
f0115bc2:	68 dc 99 12 f0       	push   $0xf01299dc
f0115bc7:	68 d7 00 00 00       	push   $0xd7
f0115bcc:	68 ec 99 12 f0       	push   $0xf01299ec
f0115bd1:	e8 63 a7 fe ff       	call   f0100339 <_panic>

f0115bd6 <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f0115bd6:	55                   	push   %ebp
f0115bd7:	89 e5                	mov    %esp,%ebp
f0115bd9:	57                   	push   %edi
f0115bda:	53                   	push   %ebx
f0115bdb:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0115be1:	83 ec 0c             	sub    $0xc,%esp
f0115be4:	68 08 9a 12 f0       	push   $0xf0129a08
f0115be9:	e8 9d b3 fe ff       	call   f0100f8b <cprintf>
f0115bee:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0115bf1:	83 ec 0c             	sub    $0xc,%esp
f0115bf4:	68 38 9a 12 f0       	push   $0xf0129a38
f0115bf9:	e8 8d b3 fe ff       	call   f0100f8b <cprintf>
f0115bfe:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0115c01:	83 ec 0c             	sub    $0xc,%esp
f0115c04:	68 08 9a 12 f0       	push   $0xf0129a08
f0115c09:	e8 7d b3 fe ff       	call   f0100f8b <cprintf>
f0115c0e:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0115c11:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f0115c15:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f0115c19:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f0115c1f:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f0115c25:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f0115c2c:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f0115c33:	e8 3d 7e ff ff       	call   f010da75 <sys_calculate_free_frames>
f0115c38:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f0115c3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0115c42:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f0115c49:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f0115c4f:	b9 14 00 00 00       	mov    $0x14,%ecx
f0115c54:	b8 00 00 00 00       	mov    $0x0,%eax
f0115c59:	89 d7                	mov    %edx,%edi
f0115c5b:	f3 ab                	rep stos %eax,%es:(%edi)

	cprintf("\n1. Insufficient space [10%]\n");
f0115c5d:	83 ec 0c             	sub    $0xc,%esp
f0115c60:	68 91 9a 12 f0       	push   $0xf0129a91
f0115c65:	e8 21 b3 fe ff       	call   f0100f8b <cprintf>
f0115c6a:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0115c6d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f0115c74:	e8 fc 7d ff ff       	call   f010da75 <sys_calculate_free_frames>
f0115c79:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115c7c:	e8 88 ec fe ff       	call   f0104909 <pf_calculate_free_frames>
f0115c81:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f0115c84:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f0115c8b:	83 ec 0c             	sub    $0xc,%esp
f0115c8e:	ff 75 cc             	pushl  -0x34(%ebp)
f0115c91:	e8 9a 31 ff ff       	call   f0108e30 <kmalloc>
f0115c96:	83 c4 10             	add    $0x10,%esp
f0115c99:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f0115c9f:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0115ca5:	85 c0                	test   %eax,%eax
f0115ca7:	74 17                	je     f0115cc0 <test_kmalloc+0xea>
f0115ca9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115cb0:	83 ec 0c             	sub    $0xc,%esp
f0115cb3:	68 b0 9a 12 f0       	push   $0xf0129ab0
f0115cb8:	e8 ce b2 fe ff       	call   f0100f8b <cprintf>
f0115cbd:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115cc0:	e8 44 ec fe ff       	call   f0104909 <pf_calculate_free_frames>
f0115cc5:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115cc8:	74 17                	je     f0115ce1 <test_kmalloc+0x10b>
f0115cca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115cd1:	83 ec 0c             	sub    $0xc,%esp
f0115cd4:	68 e4 9a 12 f0       	push   $0xf0129ae4
f0115cd9:	e8 ad b2 fe ff       	call   f0100f8b <cprintf>
f0115cde:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0115ce1:	e8 8f 7d ff ff       	call   f010da75 <sys_calculate_free_frames>
f0115ce6:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0115ce9:	74 17                	je     f0115d02 <test_kmalloc+0x12c>
f0115ceb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115cf2:	83 ec 0c             	sub    $0xc,%esp
f0115cf5:	68 50 9b 12 f0       	push   $0xf0129b50
f0115cfa:	e8 8c b2 fe ff       	call   f0100f8b <cprintf>
f0115cff:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0115d02:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0115d06:	74 04                	je     f0115d0c <test_kmalloc+0x136>
f0115d08:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\n2. Allocate spaces of different sizes in BOTH ALLOCATORS [40%]\n");
f0115d0c:	83 ec 0c             	sub    $0xc,%esp
f0115d0f:	68 94 9b 12 f0       	push   $0xf0129b94
f0115d14:	e8 72 b2 fe ff       	call   f0100f8b <cprintf>
f0115d19:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0115d1c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0115d23:	e8 4d 7d ff ff       	call   f010da75 <sys_calculate_free_frames>
f0115d28:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115d2b:	e8 d9 eb fe ff       	call   f0104909 <pf_calculate_free_frames>
f0115d30:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0115d33:	83 ec 0c             	sub    $0xc,%esp
f0115d36:	68 00 fc 1f 00       	push   $0x1ffc00
f0115d3b:	e8 f0 30 ff ff       	call   f0108e30 <kmalloc>
f0115d40:	83 c4 10             	add    $0x10,%esp
f0115d43:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		//cprintf("supossssss%x/n",ACTUAL_START);
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... check return address of kmalloc\n it should be %x\n",ptr_allocations[0]); }
f0115d49:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0115d4f:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0115d54:	74 1e                	je     f0115d74 <test_kmalloc+0x19e>
f0115d56:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115d5d:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0115d63:	83 ec 08             	sub    $0x8,%esp
f0115d66:	50                   	push   %eax
f0115d67:	68 d8 9b 12 f0       	push   $0xf0129bd8
f0115d6c:	e8 1a b2 fe ff       	call   f0100f8b <cprintf>
f0115d71:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115d74:	e8 90 eb fe ff       	call   f0104909 <pf_calculate_free_frames>
f0115d79:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115d7c:	74 17                	je     f0115d95 <test_kmalloc+0x1bf>
f0115d7e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115d85:	83 ec 0c             	sub    $0xc,%esp
f0115d88:	68 3c 9c 12 f0       	push   $0xf0129c3c
f0115d8d:	e8 f9 b1 fe ff       	call   f0100f8b <cprintf>
f0115d92:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0115d95:	e8 db 7c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0115d9a:	89 c2                	mov    %eax,%edx
f0115d9c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115d9f:	29 d0                	sub    %edx,%eax
f0115da1:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0115da6:	7f 17                	jg     f0115dbf <test_kmalloc+0x1e9>
f0115da8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115daf:	83 ec 0c             	sub    $0xc,%esp
f0115db2:	68 a8 9c 12 f0       	push   $0xf0129ca8
f0115db7:	e8 cf b1 fe ff       	call   f0100f8b <cprintf>
f0115dbc:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0115dbf:	e8 b1 7c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0115dc4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115dc7:	e8 3d eb fe ff       	call   f0104909 <pf_calculate_free_frames>
f0115dcc:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0115dcf:	83 ec 0c             	sub    $0xc,%esp
f0115dd2:	68 00 fc 1f 00       	push   $0x1ffc00
f0115dd7:	e8 54 30 ff ff       	call   f0108e30 <kmalloc>
f0115ddc:	83 c4 10             	add    $0x10,%esp
f0115ddf:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... check return address of kmalloc\n we found %x\n",ptr_allocations[1]); }
f0115de5:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0115deb:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0115df0:	74 1e                	je     f0115e10 <test_kmalloc+0x23a>
f0115df2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115df9:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0115dff:	83 ec 08             	sub    $0x8,%esp
f0115e02:	50                   	push   %eax
f0115e03:	68 ec 9c 12 f0       	push   $0xf0129cec
f0115e08:	e8 7e b1 fe ff       	call   f0100f8b <cprintf>
f0115e0d:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115e10:	e8 f4 ea fe ff       	call   f0104909 <pf_calculate_free_frames>
f0115e15:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115e18:	74 17                	je     f0115e31 <test_kmalloc+0x25b>
f0115e1a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115e21:	83 ec 0c             	sub    $0xc,%esp
f0115e24:	68 4c 9d 12 f0       	push   $0xf0129d4c
f0115e29:	e8 5d b1 fe ff       	call   f0100f8b <cprintf>
f0115e2e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0115e31:	e8 3f 7c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0115e36:	89 c2                	mov    %eax,%edx
f0115e38:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115e3b:	29 d0                	sub    %edx,%eax
f0115e3d:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0115e42:	7f 17                	jg     f0115e5b <test_kmalloc+0x285>
f0115e44:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115e4b:	83 ec 0c             	sub    $0xc,%esp
f0115e4e:	68 b8 9d 12 f0       	push   $0xf0129db8
f0115e53:	e8 33 b1 fe ff       	call   f0100f8b <cprintf>
f0115e58:	83 c4 10             	add    $0x10,%esp

		freeFrames = (int)sys_calculate_free_frames() ;
f0115e5b:	e8 15 7c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0115e60:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		{
			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115e63:	e8 a1 ea fe ff       	call   f0104909 <pf_calculate_free_frames>
f0115e68:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo-1);
f0115e6b:	83 ec 0c             	sub    $0xc,%esp
f0115e6e:	68 ff 07 00 00       	push   $0x7ff
f0115e73:	e8 b8 2f ff ff       	call   f0108e30 <kmalloc>
f0115e78:	83 c4 10             	add    $0x10,%esp
f0115e7b:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0115e81:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0115e87:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0115e8c:	76 28                	jbe    f0115eb6 <test_kmalloc+0x2e0>
f0115e8e:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0115e94:	83 ec 0c             	sub    $0xc,%esp
f0115e97:	6a 00                	push   $0x0
f0115e99:	e8 97 2e ff ff       	call   f0108d35 <sbrk>
f0115e9e:	83 c4 10             	add    $0x10,%esp
f0115ea1:	39 c3                	cmp    %eax,%ebx
f0115ea3:	73 11                	jae    f0115eb6 <test_kmalloc+0x2e0>
f0115ea5:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0115eab:	89 c2                	mov    %eax,%edx
f0115ead:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0115eb2:	39 c2                	cmp    %eax,%edx
f0115eb4:	72 17                	jb     f0115ecd <test_kmalloc+0x2f7>
			{ correct = 0; cprintf("3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0115eb6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115ebd:	83 ec 0c             	sub    $0xc,%esp
f0115ec0:	68 fc 9d 12 f0       	push   $0xf0129dfc
f0115ec5:	e8 c1 b0 fe ff       	call   f0100f8b <cprintf>
f0115eca:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115ecd:	e8 37 ea fe ff       	call   f0104909 <pf_calculate_free_frames>
f0115ed2:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115ed5:	74 17                	je     f0115eee <test_kmalloc+0x318>
f0115ed7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115ede:	83 ec 0c             	sub    $0xc,%esp
f0115ee1:	68 88 9e 12 f0       	push   $0xf0129e88
f0115ee6:	e8 a0 b0 fe ff       	call   f0100f8b <cprintf>
f0115eeb:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115eee:	e8 16 ea fe ff       	call   f0104909 <pf_calculate_free_frames>
f0115ef3:	89 45 d0             	mov    %eax,-0x30(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo-1);
f0115ef6:	83 ec 0c             	sub    $0xc,%esp
f0115ef9:	68 ff 07 00 00       	push   $0x7ff
f0115efe:	e8 2d 2f ff ff       	call   f0108e30 <kmalloc>
f0115f03:	83 c4 10             	add    $0x10,%esp
f0115f06:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0115f0c:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0115f12:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0115f17:	76 28                	jbe    f0115f41 <test_kmalloc+0x36b>
f0115f19:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f0115f1f:	83 ec 0c             	sub    $0xc,%esp
f0115f22:	6a 00                	push   $0x0
f0115f24:	e8 0c 2e ff ff       	call   f0108d35 <sbrk>
f0115f29:	83 c4 10             	add    $0x10,%esp
f0115f2c:	39 c3                	cmp    %eax,%ebx
f0115f2e:	73 11                	jae    f0115f41 <test_kmalloc+0x36b>
f0115f30:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0115f36:	89 c2                	mov    %eax,%edx
f0115f38:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0115f3d:	39 c2                	cmp    %eax,%edx
f0115f3f:	72 17                	jb     f0115f58 <test_kmalloc+0x382>
			{

				//if(ptr_allocations[3] >= sbrk(0))cprintf("hell yAAAAAAAH%x\n",sbrk(0));


				correct = 0; cprintf("4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0115f41:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115f48:	83 ec 0c             	sub    $0xc,%esp
f0115f4b:	68 f4 9e 12 f0       	push   $0xf0129ef4
f0115f50:	e8 36 b0 fe ff       	call   f0100f8b <cprintf>
f0115f55:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115f58:	e8 ac e9 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0115f5d:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115f60:	74 17                	je     f0115f79 <test_kmalloc+0x3a3>
f0115f62:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115f69:	83 ec 0c             	sub    $0xc,%esp
f0115f6c:	68 80 9f 12 f0       	push   $0xf0129f80
f0115f71:	e8 15 b0 fe ff       	call   f0100f8b <cprintf>
f0115f76:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("4 Wrong allocation: sbrk error\n%d---%d",freeFrames ,(int)sys_calculate_free_frames()); }
f0115f79:	e8 f7 7a ff ff       	call   f010da75 <sys_calculate_free_frames>
f0115f7e:	89 c2                	mov    %eax,%edx
f0115f80:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115f83:	29 d0                	sub    %edx,%eax
f0115f85:	83 f8 01             	cmp    $0x1,%eax
f0115f88:	74 20                	je     f0115faa <test_kmalloc+0x3d4>
f0115f8a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115f91:	e8 df 7a ff ff       	call   f010da75 <sys_calculate_free_frames>
f0115f96:	83 ec 04             	sub    $0x4,%esp
f0115f99:	50                   	push   %eax
f0115f9a:	ff 75 d4             	pushl  -0x2c(%ebp)
f0115f9d:	68 ec 9f 12 f0       	push   $0xf0129fec
f0115fa2:	e8 e4 af fe ff       	call   f0100f8b <cprintf>
f0115fa7:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0115faa:	e8 c6 7a ff ff       	call   f010da75 <sys_calculate_free_frames>
f0115faf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0115fb2:	e8 52 e9 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0115fb7:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f0115fba:	83 ec 0c             	sub    $0xc,%esp
f0115fbd:	68 00 1c 00 00       	push   $0x1c00
f0115fc2:	e8 69 2e ff ff       	call   f0108e30 <kmalloc>
f0115fc7:	83 c4 10             	add    $0x10,%esp
f0115fca:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0115fd0:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f0115fd6:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0115fdb:	74 17                	je     f0115ff4 <test_kmalloc+0x41e>
f0115fdd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0115fe4:	83 ec 0c             	sub    $0xc,%esp
f0115fe7:	68 14 a0 12 f0       	push   $0xf012a014
f0115fec:	e8 9a af fe ff       	call   f0100f8b <cprintf>
f0115ff1:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0115ff4:	e8 10 e9 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0115ff9:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0115ffc:	74 17                	je     f0116015 <test_kmalloc+0x43f>
f0115ffe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116005:	83 ec 0c             	sub    $0xc,%esp
f0116008:	68 68 a0 12 f0       	push   $0xf012a068
f011600d:	e8 79 af fe ff       	call   f0100f8b <cprintf>
f0116012:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116015:	e8 5b 7a ff ff       	call   f010da75 <sys_calculate_free_frames>
f011601a:	89 c2                	mov    %eax,%edx
f011601c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011601f:	29 d0                	sub    %edx,%eax
f0116021:	83 f8 01             	cmp    $0x1,%eax
f0116024:	7f 17                	jg     f011603d <test_kmalloc+0x467>
f0116026:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011602d:	83 ec 0c             	sub    $0xc,%esp
f0116030:	68 d4 a0 12 f0       	push   $0xf012a0d4
f0116035:	e8 51 af fe ff       	call   f0100f8b <cprintf>
f011603a:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011603d:	e8 33 7a ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116042:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116045:	e8 bf e8 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011604a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f011604d:	83 ec 0c             	sub    $0xc,%esp
f0116050:	68 00 fc 2f 00       	push   $0x2ffc00
f0116055:	e8 d6 2d ff ff       	call   f0108e30 <kmalloc>
f011605a:	83 c4 10             	add    $0x10,%esp
f011605d:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0116063:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f0116069:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011606e:	74 17                	je     f0116087 <test_kmalloc+0x4b1>
f0116070:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116077:	83 ec 0c             	sub    $0xc,%esp
f011607a:	68 18 a1 12 f0       	push   $0xf012a118
f011607f:	e8 07 af fe ff       	call   f0100f8b <cprintf>
f0116084:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116087:	e8 7d e8 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011608c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011608f:	74 17                	je     f01160a8 <test_kmalloc+0x4d2>
f0116091:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116098:	83 ec 0c             	sub    $0xc,%esp
f011609b:	68 6c a1 12 f0       	push   $0xf012a16c
f01160a0:	e8 e6 ae fe ff       	call   f0100f8b <cprintf>
f01160a5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01160a8:	e8 c8 79 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01160ad:	89 c2                	mov    %eax,%edx
f01160af:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01160b2:	29 d0                	sub    %edx,%eax
f01160b4:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01160b9:	7f 17                	jg     f01160d2 <test_kmalloc+0x4fc>
f01160bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01160c2:	83 ec 0c             	sub    $0xc,%esp
f01160c5:	68 d8 a1 12 f0       	push   $0xf012a1d8
f01160ca:	e8 bc ae fe ff       	call   f0100f8b <cprintf>
f01160cf:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01160d2:	e8 9e 79 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01160d7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01160da:	e8 2a e8 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01160df:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f01160e2:	83 ec 0c             	sub    $0xc,%esp
f01160e5:	68 00 fc 5f 00       	push   $0x5ffc00
f01160ea:	e8 41 2d ff ff       	call   f0108e30 <kmalloc>
f01160ef:	83 c4 10             	add    $0x10,%esp
f01160f2:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01160f8:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f01160fe:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0116103:	74 17                	je     f011611c <test_kmalloc+0x546>
f0116105:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011610c:	83 ec 0c             	sub    $0xc,%esp
f011610f:	68 1c a2 12 f0       	push   $0xf012a21c
f0116114:	e8 72 ae fe ff       	call   f0100f8b <cprintf>
f0116119:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011611c:	e8 e8 e7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116121:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0116124:	74 17                	je     f011613d <test_kmalloc+0x567>
f0116126:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011612d:	83 ec 0c             	sub    $0xc,%esp
f0116130:	68 70 a2 12 f0       	push   $0xf012a270
f0116135:	e8 51 ae fe ff       	call   f0100f8b <cprintf>
f011613a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011613d:	e8 33 79 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116142:	89 c2                	mov    %eax,%edx
f0116144:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116147:	29 d0                	sub    %edx,%eax
f0116149:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011614e:	7f 17                	jg     f0116167 <test_kmalloc+0x591>
f0116150:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116157:	83 ec 0c             	sub    $0xc,%esp
f011615a:	68 dc a2 12 f0       	push   $0xf012a2dc
f011615f:	e8 27 ae fe ff       	call   f0100f8b <cprintf>
f0116164:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116167:	e8 09 79 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011616c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011616f:	e8 95 e7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116174:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f0116177:	83 ec 0c             	sub    $0xc,%esp
f011617a:	68 00 38 00 00       	push   $0x3800
f011617f:	e8 ac 2c ff ff       	call   f0108e30 <kmalloc>
f0116184:	83 c4 10             	add    $0x10,%esp
f0116187:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011618d:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0116193:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0116198:	74 17                	je     f01161b1 <test_kmalloc+0x5db>
f011619a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01161a1:	83 ec 0c             	sub    $0xc,%esp
f01161a4:	68 20 a3 12 f0       	push   $0xf012a320
f01161a9:	e8 dd ad fe ff       	call   f0100f8b <cprintf>
f01161ae:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01161b1:	e8 53 e7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01161b6:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01161b9:	74 17                	je     f01161d2 <test_kmalloc+0x5fc>
f01161bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01161c2:	83 ec 0c             	sub    $0xc,%esp
f01161c5:	68 74 a3 12 f0       	push   $0xf012a374
f01161ca:	e8 bc ad fe ff       	call   f0100f8b <cprintf>
f01161cf:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01161d2:	e8 9e 78 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01161d7:	89 c2                	mov    %eax,%edx
f01161d9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01161dc:	29 d0                	sub    %edx,%eax
f01161de:	83 f8 03             	cmp    $0x3,%eax
f01161e1:	7f 17                	jg     f01161fa <test_kmalloc+0x624>
f01161e3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01161ea:	83 ec 0c             	sub    $0xc,%esp
f01161ed:	68 e0 a3 12 f0       	push   $0xf012a3e0
f01161f2:	e8 94 ad fe ff       	call   f0100f8b <cprintf>
f01161f7:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f01161fa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01161fe:	74 04                	je     f0116204 <test_kmalloc+0x62e>
f0116200:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0116204:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	cprintf("\n3. Checking read/write on the allocated spaces [30%]\n");
f011620b:	83 ec 0c             	sub    $0xc,%esp
f011620e:	68 24 a4 12 f0       	push   $0xf012a424
f0116213:	e8 73 ad fe ff       	call   f0100f8b <cprintf>
f0116218:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f011621b:	e8 55 78 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116220:	89 45 d4             	mov    %eax,-0x2c(%ebp)

		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116223:	e8 e1 e6 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116228:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB

		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f011622b:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)

		byteArr = (char *) ptr_allocations[0];
f0116232:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0116238:	89 45 c4             	mov    %eax,-0x3c(%ebp)

		byteArr[0] = minByte ;
f011623b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011623e:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0116241:	88 10                	mov    %dl,(%eax)

		byteArr[lastIndexOfByte] = maxByte ;
f0116243:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0116246:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116249:	01 c2                	add    %eax,%edx
f011624b:	8a 45 ea             	mov    -0x16(%ebp),%al
f011624e:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f0116250:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0116256:	89 45 c0             	mov    %eax,-0x40(%ebp)

		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f0116259:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f0116260:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0116263:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116266:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f0116269:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011626c:	01 c0                	add    %eax,%eax
f011626e:	89 c2                	mov    %eax,%edx
f0116270:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116273:	01 c2                	add    %eax,%edx
f0116275:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0116279:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f011627c:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0116282:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f0116285:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f011628c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011628f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0116292:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f0116294:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116297:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011629e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01162a1:	01 c2                	add    %eax,%edx
f01162a3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01162a6:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f01162a8:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f01162ae:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f01162b1:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f01162b8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01162bb:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01162be:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f01162c0:	8b 55 ac             	mov    -0x54(%ebp),%edx
f01162c3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01162c6:	01 c2                	add    %eax,%edx
f01162c8:	8a 45 ea             	mov    -0x16(%ebp),%al
f01162cb:	88 02                	mov    %al,(%edx)
		}


		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f01162cd:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f01162d3:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f01162d6:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f01162dd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01162e0:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01162e3:	88 10                	mov    %dl,(%eax)
f01162e5:	8b 55 a8             	mov    -0x58(%ebp),%edx
f01162e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01162eb:	66 89 42 02          	mov    %ax,0x2(%edx)
f01162ef:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01162f2:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01162f5:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f01162f8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01162fb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116302:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116305:	01 c2                	add    %eax,%edx
f0116307:	8a 45 ea             	mov    -0x16(%ebp),%al
f011630a:	88 02                	mov    %al,(%edx)
f011630c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011630f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116316:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116319:	01 c2                	add    %eax,%edx
f011631b:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f011631f:	66 89 42 02          	mov    %ax,0x2(%edx)
f0116323:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116326:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011632d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116330:	01 c2                	add    %eax,%edx
f0116332:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116335:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f0116338:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f011633f:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0116345:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f0116348:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011634b:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011634e:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f0116350:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0116353:	89 c2                	mov    %eax,%edx
f0116355:	c1 ea 1f             	shr    $0x1f,%edx
f0116358:	01 d0                	add    %edx,%eax
f011635a:	d1 f8                	sar    %eax
f011635c:	89 c2                	mov    %eax,%edx
f011635e:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116361:	01 c2                	add    %eax,%edx
f0116363:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116366:	88 c1                	mov    %al,%cl
f0116368:	c0 e9 07             	shr    $0x7,%cl
f011636b:	01 c8                	add    %ecx,%eax
f011636d:	d0 f8                	sar    %al
f011636f:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f0116371:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0116374:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116377:	01 c2                	add    %eax,%edx
f0116379:	8a 45 ea             	mov    -0x16(%ebp),%al
f011637c:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f011637e:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0116384:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f0116387:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f011638e:	8b 55 98             	mov    -0x68(%ebp),%edx
f0116391:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116394:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f0116397:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011639a:	01 c0                	add    %eax,%eax
f011639c:	89 c2                	mov    %eax,%edx
f011639e:	8b 45 98             	mov    -0x68(%ebp),%eax
f01163a1:	01 c2                	add    %eax,%edx
f01163a3:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f01163a7:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("9 Wrong allocation: stored values are wrongly changed!\n"); }
f01163aa:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01163ad:	8a 00                	mov    (%eax),%al
f01163af:	3a 45 eb             	cmp    -0x15(%ebp),%al
f01163b2:	75 0f                	jne    f01163c3 <test_kmalloc+0x7ed>
f01163b4:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01163b7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01163ba:	01 d0                	add    %edx,%eax
f01163bc:	8a 00                	mov    (%eax),%al
f01163be:	3a 45 ea             	cmp    -0x16(%ebp),%al
f01163c1:	74 17                	je     f01163da <test_kmalloc+0x804>
f01163c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01163ca:	83 ec 0c             	sub    $0xc,%esp
f01163cd:	68 5c a4 12 f0       	push   $0xf012a45c
f01163d2:	e8 b4 ab fe ff       	call   f0100f8b <cprintf>
f01163d7:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("10 Wrong allocation: stored values are wrongly changed!\n"); }
f01163da:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01163dd:	66 8b 00             	mov    (%eax),%ax
f01163e0:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f01163e4:	75 15                	jne    f01163fb <test_kmalloc+0x825>
f01163e6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01163e9:	01 c0                	add    %eax,%eax
f01163eb:	89 c2                	mov    %eax,%edx
f01163ed:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01163f0:	01 d0                	add    %edx,%eax
f01163f2:	66 8b 00             	mov    (%eax),%ax
f01163f5:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f01163f9:	74 17                	je     f0116412 <test_kmalloc+0x83c>
f01163fb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116402:	83 ec 0c             	sub    $0xc,%esp
f0116405:	68 94 a4 12 f0       	push   $0xf012a494
f011640a:	e8 7c ab fe ff       	call   f0100f8b <cprintf>
f011640f:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("11 Wrong allocation: stored values are wrongly changed!\n"); }
f0116412:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116415:	8b 00                	mov    (%eax),%eax
f0116417:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011641a:	75 16                	jne    f0116432 <test_kmalloc+0x85c>
f011641c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011641f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116426:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116429:	01 d0                	add    %edx,%eax
f011642b:	8b 00                	mov    (%eax),%eax
f011642d:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0116430:	74 17                	je     f0116449 <test_kmalloc+0x873>
f0116432:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116439:	83 ec 0c             	sub    $0xc,%esp
f011643c:	68 d0 a4 12 f0       	push   $0xf012a4d0
f0116441:	e8 45 ab fe ff       	call   f0100f8b <cprintf>
f0116446:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("12 Wrong allocation: stored values are wrongly changed!\n"); }
f0116449:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011644c:	8a 00                	mov    (%eax),%al
f011644e:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116451:	75 0f                	jne    f0116462 <test_kmalloc+0x88c>
f0116453:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0116456:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116459:	01 d0                	add    %edx,%eax
f011645b:	8a 00                	mov    (%eax),%al
f011645d:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116460:	74 17                	je     f0116479 <test_kmalloc+0x8a3>
f0116462:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116469:	83 ec 0c             	sub    $0xc,%esp
f011646c:	68 0c a5 12 f0       	push   $0xf012a50c
f0116471:	e8 15 ab fe ff       	call   f0100f8b <cprintf>
f0116476:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("13 Wrong allocation: stored values are wrongly changed!\n"); }
f0116479:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011647c:	8a 00                	mov    (%eax),%al
f011647e:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0116481:	75 16                	jne    f0116499 <test_kmalloc+0x8c3>
f0116483:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116486:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f011648d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116490:	01 d0                	add    %edx,%eax
f0116492:	8a 00                	mov    (%eax),%al
f0116494:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116497:	74 17                	je     f01164b0 <test_kmalloc+0x8da>
f0116499:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01164a0:	83 ec 0c             	sub    $0xc,%esp
f01164a3:	68 48 a5 12 f0       	push   $0xf012a548
f01164a8:	e8 de aa fe ff       	call   f0100f8b <cprintf>
f01164ad:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("14 Wrong allocation: stored values are wrongly changed!\n"); }
f01164b0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01164b3:	66 8b 40 02          	mov    0x2(%eax),%ax
f01164b7:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f01164bb:	75 19                	jne    f01164d6 <test_kmalloc+0x900>
f01164bd:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01164c0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01164c7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01164ca:	01 d0                	add    %edx,%eax
f01164cc:	66 8b 40 02          	mov    0x2(%eax),%ax
f01164d0:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f01164d4:	74 17                	je     f01164ed <test_kmalloc+0x917>
f01164d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01164dd:	83 ec 0c             	sub    $0xc,%esp
f01164e0:	68 84 a5 12 f0       	push   $0xf012a584
f01164e5:	e8 a1 aa fe ff       	call   f0100f8b <cprintf>
f01164ea:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("15 Wrong allocation: stored values are wrongly changed!\n"); }
f01164ed:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01164f0:	8b 40 04             	mov    0x4(%eax),%eax
f01164f3:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01164f6:	75 17                	jne    f011650f <test_kmalloc+0x939>
f01164f8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01164fb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0116502:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116505:	01 d0                	add    %edx,%eax
f0116507:	8b 40 04             	mov    0x4(%eax),%eax
f011650a:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011650d:	74 17                	je     f0116526 <test_kmalloc+0x950>
f011650f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116516:	83 ec 0c             	sub    $0xc,%esp
f0116519:	68 c0 a5 12 f0       	push   $0xf012a5c0
f011651e:	e8 68 aa fe ff       	call   f0100f8b <cprintf>
f0116523:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0116526:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116529:	8a 00                	mov    (%eax),%al
f011652b:	3a 45 eb             	cmp    -0x15(%ebp),%al
f011652e:	75 34                	jne    f0116564 <test_kmalloc+0x98e>
f0116530:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0116533:	89 c2                	mov    %eax,%edx
f0116535:	c1 ea 1f             	shr    $0x1f,%edx
f0116538:	01 d0                	add    %edx,%eax
f011653a:	d1 f8                	sar    %eax
f011653c:	89 c2                	mov    %eax,%edx
f011653e:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116541:	01 d0                	add    %edx,%eax
f0116543:	8a 10                	mov    (%eax),%dl
f0116545:	8a 45 ea             	mov    -0x16(%ebp),%al
f0116548:	88 c1                	mov    %al,%cl
f011654a:	c0 e9 07             	shr    $0x7,%cl
f011654d:	01 c8                	add    %ecx,%eax
f011654f:	d0 f8                	sar    %al
f0116551:	38 c2                	cmp    %al,%dl
f0116553:	75 0f                	jne    f0116564 <test_kmalloc+0x98e>
f0116555:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0116558:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011655b:	01 d0                	add    %edx,%eax
f011655d:	8a 00                	mov    (%eax),%al
f011655f:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0116562:	74 17                	je     f011657b <test_kmalloc+0x9a5>
f0116564:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011656b:	83 ec 0c             	sub    $0xc,%esp
f011656e:	68 fc a5 12 f0       	push   $0xf012a5fc
f0116573:	e8 13 aa fe ff       	call   f0100f8b <cprintf>
f0116578:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("16 Wrong allocation: stored values are wrongly changed!\n"); }
f011657b:	8b 45 98             	mov    -0x68(%ebp),%eax
f011657e:	66 8b 00             	mov    (%eax),%ax
f0116581:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0116585:	75 15                	jne    f011659c <test_kmalloc+0x9c6>
f0116587:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011658a:	01 c0                	add    %eax,%eax
f011658c:	89 c2                	mov    %eax,%edx
f011658e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0116591:	01 d0                	add    %edx,%eax
f0116593:	66 8b 00             	mov    (%eax),%ax
f0116596:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f011659a:	74 17                	je     f01165b3 <test_kmalloc+0x9dd>
f011659c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01165a3:	83 ec 0c             	sub    $0xc,%esp
f01165a6:	68 34 a6 12 f0       	push   $0xf012a634
f01165ab:	e8 db a9 fe ff       	call   f0100f8b <cprintf>
f01165b0:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01165b3:	e8 bd 74 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01165b8:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01165bb:	74 17                	je     f01165d4 <test_kmalloc+0x9fe>
f01165bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01165c4:	83 ec 0c             	sub    $0xc,%esp
f01165c7:	68 70 a6 12 f0       	push   $0xf012a670
f01165cc:	e8 ba a9 fe ff       	call   f0100f8b <cprintf>
f01165d1:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01165d4:	e8 30 e3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01165d9:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01165dc:	74 17                	je     f01165f5 <test_kmalloc+0xa1f>
f01165de:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01165e5:	83 ec 0c             	sub    $0xc,%esp
f01165e8:	68 b4 a6 12 f0       	push   $0xf012a6b4
f01165ed:	e8 99 a9 fe ff       	call   f0100f8b <cprintf>
f01165f2:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f01165f5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01165f9:	74 04                	je     f01165ff <test_kmalloc+0xa29>
f01165fb:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f01165ff:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	cprintf("\n4. Insufficient Space Again [10%]\n");
f0116606:	83 ec 0c             	sub    $0xc,%esp
f0116609:	68 20 a7 12 f0       	push   $0xf012a720
f011660e:	e8 78 a9 fe ff       	call   f0100f8b <cprintf>
f0116613:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f0116616:	e8 5a 74 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011661b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011661e:	e8 e6 e2 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116623:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo) ;
f0116626:	c7 45 90 00 80 2f 07 	movl   $0x72f8000,-0x70(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap+1);
f011662d:	8b 45 90             	mov    -0x70(%ebp),%eax
f0116630:	40                   	inc    %eax
f0116631:	83 ec 0c             	sub    $0xc,%esp
f0116634:	50                   	push   %eax
f0116635:	e8 f6 27 ff ff       	call   f0108e30 <kmalloc>
f011663a:	83 c4 10             	add    $0x10,%esp
f011663d:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("18 Allocating insufficient space: should return NULL\n"); }
f0116643:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0116649:	85 c0                	test   %eax,%eax
f011664b:	74 17                	je     f0116664 <test_kmalloc+0xa8e>
f011664d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116654:	83 ec 0c             	sub    $0xc,%esp
f0116657:	68 44 a7 12 f0       	push   $0xf012a744
f011665c:	e8 2a a9 fe ff       	call   f0100f8b <cprintf>
f0116661:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116664:	e8 a0 e2 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116669:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011666c:	74 17                	je     f0116685 <test_kmalloc+0xaaf>
f011666e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116675:	83 ec 0c             	sub    $0xc,%esp
f0116678:	68 7c a7 12 f0       	push   $0xf012a77c
f011667d:	e8 09 a9 fe ff       	call   f0100f8b <cprintf>
f0116682:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0116685:	e8 eb 73 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011668a:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011668d:	74 17                	je     f01166a6 <test_kmalloc+0xad0>
f011668f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116696:	83 ec 0c             	sub    $0xc,%esp
f0116699:	68 e8 a7 12 f0       	push   $0xf012a7e8
f011669e:	e8 e8 a8 fe ff       	call   f0100f8b <cprintf>
f01166a3:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01166a6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01166aa:	74 04                	je     f01166b0 <test_kmalloc+0xada>
f01166ac:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01166b0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
f01166b7:	83 ec 0c             	sub    $0xc,%esp
f01166ba:	68 2c a8 12 f0       	push   $0xf012a82c
f01166bf:	e8 c7 a8 fe ff       	call   f0100f8b <cprintf>
f01166c4:	83 c4 10             	add    $0x10,%esp
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f01166c7:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f01166cd:	05 00 40 00 00       	add    $0x4000,%eax
f01166d2:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f01166d5:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f01166dc:	eb 6a                	jmp    f0116748 <test_kmalloc+0xb72>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f01166de:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f01166e3:	83 ec 04             	sub    $0x4,%esp
f01166e6:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f01166ec:	52                   	push   %edx
f01166ed:	ff 75 ec             	pushl  -0x14(%ebp)
f01166f0:	50                   	push   %eax
f01166f1:	e8 c9 1d ff ff       	call   f01084bf <get_page_table>
f01166f6:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f01166f9:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f01166ff:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0116702:	c1 ea 0c             	shr    $0xc,%edx
f0116705:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011670b:	c1 e2 02             	shl    $0x2,%edx
f011670e:	01 d0                	add    %edx,%eax
f0116710:	8b 00                	mov    (%eax),%eax
f0116712:	25 ff 0f 00 00       	and    $0xfff,%eax
f0116717:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f011671a:	8b 45 88             	mov    -0x78(%ebp),%eax
f011671d:	83 e0 04             	and    $0x4,%eax
f0116720:	85 c0                	test   %eax,%eax
f0116722:	74 1d                	je     f0116741 <test_kmalloc+0xb6b>
			{
				if (correct)
f0116724:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116728:	74 17                	je     f0116741 <test_kmalloc+0xb6b>
				{
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
f011672a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116731:	83 ec 0c             	sub    $0xc,%esp
f0116734:	68 70 a8 12 f0       	push   $0xf012a870
f0116739:	e8 4d a8 fe ff       	call   f0100f8b <cprintf>
f011673e:	83 c4 10             	add    $0x10,%esp
	//permissions
	cprintf("\n5. Check permissions of allocated spaces in PAGE ALLOCATOR [10%]\n");
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0116741:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f0116748:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011674b:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011674e:	72 8e                	jb     f01166de <test_kmalloc+0xb08>
					correct = 0; cprintf("19 Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f0116750:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116754:	74 04                	je     f011675a <test_kmalloc+0xb84>
f0116756:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f011675a:	83 ec 08             	sub    $0x8,%esp
f011675d:	ff 75 f4             	pushl  -0xc(%ebp)
f0116760:	68 c0 a8 12 f0       	push   $0xf012a8c0
f0116765:	e8 21 a8 fe ff       	call   f0100f8b <cprintf>
f011676a:	83 c4 10             	add    $0x10,%esp

	return 1;
f011676d:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0116772:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0116775:	5b                   	pop    %ebx
f0116776:	5f                   	pop    %edi
f0116777:	5d                   	pop    %ebp
f0116778:	c3                   	ret    

f0116779 <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f0116779:	55                   	push   %ebp
f011677a:	89 e5                	mov    %esp,%ebp
f011677c:	57                   	push   %edi
f011677d:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0116780:	83 ec 0c             	sub    $0xc,%esp
f0116783:	68 08 9a 12 f0       	push   $0xf0129a08
f0116788:	e8 fe a7 fe ff       	call   f0100f8b <cprintf>
f011678d:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0116790:	83 ec 0c             	sub    $0xc,%esp
f0116793:	68 38 9a 12 f0       	push   $0xf0129a38
f0116798:	e8 ee a7 fe ff       	call   f0100f8b <cprintf>
f011679d:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01167a0:	83 ec 0c             	sub    $0xc,%esp
f01167a3:	68 08 9a 12 f0       	push   $0xf0129a08
f01167a8:	e8 de a7 fe ff       	call   f0100f8b <cprintf>
f01167ad:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f01167b0:	8d 55 98             	lea    -0x68(%ebp),%edx
f01167b3:	b9 14 00 00 00       	mov    $0x14,%ecx
f01167b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01167bd:	89 d7                	mov    %edx,%edi
f01167bf:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f01167c1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f01167c8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f01167cf:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	cprintf("\n1. Allocate spaces of different sizes in PAGE ALLOCATOR [10%]\n");
f01167d6:	83 ec 0c             	sub    $0xc,%esp
f01167d9:	68 ec a8 12 f0       	push   $0xf012a8ec
f01167de:	e8 a8 a7 fe ff       	call   f0100f8b <cprintf>
f01167e3:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01167e6:	e8 8a 72 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01167eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01167ee:	e8 16 e1 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01167f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f01167f6:	83 ec 0c             	sub    $0xc,%esp
f01167f9:	68 00 fc 0f 00       	push   $0xffc00
f01167fe:	e8 2d 26 ff ff       	call   f0108e30 <kmalloc>
f0116803:	83 c4 10             	add    $0x10,%esp
f0116806:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("1 Wrong start address for the allocated space... \n"); }
f0116809:	8b 45 98             	mov    -0x68(%ebp),%eax
f011680c:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0116811:	74 17                	je     f011682a <test_kmalloc_firstfit1+0xb1>
f0116813:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011681a:	83 ec 0c             	sub    $0xc,%esp
f011681d:	68 2c a9 12 f0       	push   $0xf012a92c
f0116822:	e8 64 a7 fe ff       	call   f0100f8b <cprintf>
f0116827:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011682a:	e8 da e0 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011682f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116832:	74 17                	je     f011684b <test_kmalloc_firstfit1+0xd2>
f0116834:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011683b:	83 ec 0c             	sub    $0xc,%esp
f011683e:	68 3c 9c 12 f0       	push   $0xf0129c3c
f0116843:	e8 43 a7 fe ff       	call   f0100f8b <cprintf>
f0116848:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("1 Wrong allocation: \n"); }
f011684b:	e8 25 72 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116850:	89 c2                	mov    %eax,%edx
f0116852:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116855:	29 d0                	sub    %edx,%eax
f0116857:	3d ff 00 00 00       	cmp    $0xff,%eax
f011685c:	7f 17                	jg     f0116875 <test_kmalloc_firstfit1+0xfc>
f011685e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116865:	83 ec 0c             	sub    $0xc,%esp
f0116868:	68 5f a9 12 f0       	push   $0xf012a95f
f011686d:	e8 19 a7 fe ff       	call   f0100f8b <cprintf>
f0116872:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116875:	e8 fb 71 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011687a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011687d:	e8 87 e0 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116882:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f0116885:	83 ec 0c             	sub    $0xc,%esp
f0116888:	68 00 fc 0f 00       	push   $0xffc00
f011688d:	e8 9e 25 ff ff       	call   f0108e30 <kmalloc>
f0116892:	83 c4 10             	add    $0x10,%esp
f0116895:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0116898:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011689b:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f01168a0:	74 17                	je     f01168b9 <test_kmalloc_firstfit1+0x140>
f01168a2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01168a9:	83 ec 0c             	sub    $0xc,%esp
f01168ac:	68 78 a9 12 f0       	push   $0xf012a978
f01168b1:	e8 d5 a6 fe ff       	call   f0100f8b <cprintf>
f01168b6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01168b9:	e8 4b e0 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01168be:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01168c1:	74 17                	je     f01168da <test_kmalloc_firstfit1+0x161>
f01168c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01168ca:	83 ec 0c             	sub    $0xc,%esp
f01168cd:	68 4c 9d 12 f0       	push   $0xf0129d4c
f01168d2:	e8 b4 a6 fe ff       	call   f0100f8b <cprintf>
f01168d7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f01168da:	e8 96 71 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01168df:	89 c2                	mov    %eax,%edx
f01168e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01168e4:	29 d0                	sub    %edx,%eax
f01168e6:	3d ff 00 00 00       	cmp    $0xff,%eax
f01168eb:	7f 17                	jg     f0116904 <test_kmalloc_firstfit1+0x18b>
f01168ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01168f4:	83 ec 0c             	sub    $0xc,%esp
f01168f7:	68 ab a9 12 f0       	push   $0xf012a9ab
f01168fc:	e8 8a a6 fe ff       	call   f0100f8b <cprintf>
f0116901:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116904:	e8 6c 71 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116909:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011690c:	e8 f8 df fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116911:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f0116914:	83 ec 0c             	sub    $0xc,%esp
f0116917:	68 00 fc 0f 00       	push   $0xffc00
f011691c:	e8 0f 25 ff ff       	call   f0108e30 <kmalloc>
f0116921:	83 c4 10             	add    $0x10,%esp
f0116924:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f0116927:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011692a:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011692f:	74 17                	je     f0116948 <test_kmalloc_firstfit1+0x1cf>
f0116931:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116938:	83 ec 0c             	sub    $0xc,%esp
f011693b:	68 c4 a9 12 f0       	push   $0xf012a9c4
f0116940:	e8 46 a6 fe ff       	call   f0100f8b <cprintf>
f0116945:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116948:	e8 bc df fe ff       	call   f0104909 <pf_calculate_free_frames>
f011694d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116950:	74 17                	je     f0116969 <test_kmalloc_firstfit1+0x1f0>
f0116952:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116959:	83 ec 0c             	sub    $0xc,%esp
f011695c:	68 88 9e 12 f0       	push   $0xf0129e88
f0116961:	e8 25 a6 fe ff       	call   f0100f8b <cprintf>
f0116966:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f0116969:	e8 07 71 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011696e:	89 c2                	mov    %eax,%edx
f0116970:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116973:	29 d0                	sub    %edx,%eax
f0116975:	3d ff 00 00 00       	cmp    $0xff,%eax
f011697a:	7f 17                	jg     f0116993 <test_kmalloc_firstfit1+0x21a>
f011697c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116983:	83 ec 0c             	sub    $0xc,%esp
f0116986:	68 f7 a9 12 f0       	push   $0xf012a9f7
f011698b:	e8 fb a5 fe ff       	call   f0100f8b <cprintf>
f0116990:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116993:	e8 dd 70 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116998:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011699b:	e8 69 df fe ff       	call   f0104909 <pf_calculate_free_frames>
f01169a0:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f01169a3:	83 ec 0c             	sub    $0xc,%esp
f01169a6:	68 00 fc 0f 00       	push   $0xffc00
f01169ab:	e8 80 24 ff ff       	call   f0108e30 <kmalloc>
f01169b0:	83 c4 10             	add    $0x10,%esp
f01169b3:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f01169b6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01169b9:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f01169be:	74 17                	je     f01169d7 <test_kmalloc_firstfit1+0x25e>
f01169c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01169c7:	83 ec 0c             	sub    $0xc,%esp
f01169ca:	68 10 aa 12 f0       	push   $0xf012aa10
f01169cf:	e8 b7 a5 fe ff       	call   f0100f8b <cprintf>
f01169d4:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01169d7:	e8 2d df fe ff       	call   f0104909 <pf_calculate_free_frames>
f01169dc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01169df:	74 17                	je     f01169f8 <test_kmalloc_firstfit1+0x27f>
f01169e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01169e8:	83 ec 0c             	sub    $0xc,%esp
f01169eb:	68 80 9f 12 f0       	push   $0xf0129f80
f01169f0:	e8 96 a5 fe ff       	call   f0100f8b <cprintf>
f01169f5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f01169f8:	e8 78 70 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01169fd:	89 c2                	mov    %eax,%edx
f01169ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116a02:	29 d0                	sub    %edx,%eax
f0116a04:	3d ff 00 00 00       	cmp    $0xff,%eax
f0116a09:	7f 17                	jg     f0116a22 <test_kmalloc_firstfit1+0x2a9>
f0116a0b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a12:	83 ec 0c             	sub    $0xc,%esp
f0116a15:	68 43 aa 12 f0       	push   $0xf012aa43
f0116a1a:	e8 6c a5 fe ff       	call   f0100f8b <cprintf>
f0116a1f:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116a22:	e8 4e 70 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116a27:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116a2a:	e8 da de fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116a2f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f0116a32:	83 ec 0c             	sub    $0xc,%esp
f0116a35:	68 00 fc 1f 00       	push   $0x1ffc00
f0116a3a:	e8 f1 23 ff ff       	call   f0108e30 <kmalloc>
f0116a3f:	83 c4 10             	add    $0x10,%esp
f0116a42:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("5 Wrong start address for the allocated space... \n"); }
f0116a45:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116a48:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0116a4d:	74 17                	je     f0116a66 <test_kmalloc_firstfit1+0x2ed>
f0116a4f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a56:	83 ec 0c             	sub    $0xc,%esp
f0116a59:	68 5c aa 12 f0       	push   $0xf012aa5c
f0116a5e:	e8 28 a5 fe ff       	call   f0100f8b <cprintf>
f0116a63:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116a66:	e8 9e de fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116a6b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116a6e:	74 17                	je     f0116a87 <test_kmalloc_firstfit1+0x30e>
f0116a70:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116a77:	83 ec 0c             	sub    $0xc,%esp
f0116a7a:	68 68 a0 12 f0       	push   $0xf012a068
f0116a7f:	e8 07 a5 fe ff       	call   f0100f8b <cprintf>
f0116a84:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("5 Wrong allocation: \n"); }
f0116a87:	e8 e9 6f ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116a8c:	89 c2                	mov    %eax,%edx
f0116a8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116a91:	29 d0                	sub    %edx,%eax
f0116a93:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116a98:	7f 17                	jg     f0116ab1 <test_kmalloc_firstfit1+0x338>
f0116a9a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116aa1:	83 ec 0c             	sub    $0xc,%esp
f0116aa4:	68 8f aa 12 f0       	push   $0xf012aa8f
f0116aa9:	e8 dd a4 fe ff       	call   f0100f8b <cprintf>
f0116aae:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116ab1:	e8 bf 6f ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116ab6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116ab9:	e8 4b de fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116abe:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f0116ac1:	83 ec 0c             	sub    $0xc,%esp
f0116ac4:	68 00 fc 1f 00       	push   $0x1ffc00
f0116ac9:	e8 62 23 ff ff       	call   f0108e30 <kmalloc>
f0116ace:	83 c4 10             	add    $0x10,%esp
f0116ad1:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0116ad4:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0116ad7:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f0116adc:	74 17                	je     f0116af5 <test_kmalloc_firstfit1+0x37c>
f0116ade:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ae5:	83 ec 0c             	sub    $0xc,%esp
f0116ae8:	68 a8 aa 12 f0       	push   $0xf012aaa8
f0116aed:	e8 99 a4 fe ff       	call   f0100f8b <cprintf>
f0116af2:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116af5:	e8 0f de fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116afa:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116afd:	74 17                	je     f0116b16 <test_kmalloc_firstfit1+0x39d>
f0116aff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b06:	83 ec 0c             	sub    $0xc,%esp
f0116b09:	68 6c a1 12 f0       	push   $0xf012a16c
f0116b0e:	e8 78 a4 fe ff       	call   f0100f8b <cprintf>
f0116b13:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0116b16:	e8 5a 6f ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116b1b:	89 c2                	mov    %eax,%edx
f0116b1d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116b20:	29 d0                	sub    %edx,%eax
f0116b22:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116b27:	7f 17                	jg     f0116b40 <test_kmalloc_firstfit1+0x3c7>
f0116b29:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b30:	83 ec 0c             	sub    $0xc,%esp
f0116b33:	68 db aa 12 f0       	push   $0xf012aadb
f0116b38:	e8 4e a4 fe ff       	call   f0100f8b <cprintf>
f0116b3d:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116b40:	e8 30 6f ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116b45:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116b48:	e8 bc dd fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116b4d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0116b50:	83 ec 0c             	sub    $0xc,%esp
f0116b53:	68 00 fc 2f 00       	push   $0x2ffc00
f0116b58:	e8 d3 22 ff ff       	call   f0108e30 <kmalloc>
f0116b5d:	83 c4 10             	add    $0x10,%esp
f0116b60:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f0116b63:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116b66:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0116b6b:	74 17                	je     f0116b84 <test_kmalloc_firstfit1+0x40b>
f0116b6d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b74:	83 ec 0c             	sub    $0xc,%esp
f0116b77:	68 f4 aa 12 f0       	push   $0xf012aaf4
f0116b7c:	e8 0a a4 fe ff       	call   f0100f8b <cprintf>
f0116b81:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116b84:	e8 80 dd fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116b89:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116b8c:	74 17                	je     f0116ba5 <test_kmalloc_firstfit1+0x42c>
f0116b8e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116b95:	83 ec 0c             	sub    $0xc,%esp
f0116b98:	68 70 a2 12 f0       	push   $0xf012a270
f0116b9d:	e8 e9 a3 fe ff       	call   f0100f8b <cprintf>
f0116ba2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0116ba5:	e8 cb 6e ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116baa:	89 c2                	mov    %eax,%edx
f0116bac:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116baf:	29 d0                	sub    %edx,%eax
f0116bb1:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0116bb6:	7f 17                	jg     f0116bcf <test_kmalloc_firstfit1+0x456>
f0116bb8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116bbf:	83 ec 0c             	sub    $0xc,%esp
f0116bc2:	68 27 ab 12 f0       	push   $0xf012ab27
f0116bc7:	e8 bf a3 fe ff       	call   f0100f8b <cprintf>
f0116bcc:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0116bcf:	e8 a1 6e ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116bd4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116bd7:	e8 2d dd fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116bdc:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f0116bdf:	83 ec 0c             	sub    $0xc,%esp
f0116be2:	68 00 fc 2f 00       	push   $0x2ffc00
f0116be7:	e8 44 22 ff ff       	call   f0108e30 <kmalloc>
f0116bec:	83 c4 10             	add    $0x10,%esp
f0116bef:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("8 Wrong start address for the allocated space... \n"); }
f0116bf2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0116bf5:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f0116bfa:	74 17                	je     f0116c13 <test_kmalloc_firstfit1+0x49a>
f0116bfc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116c03:	83 ec 0c             	sub    $0xc,%esp
f0116c06:	68 40 ab 12 f0       	push   $0xf012ab40
f0116c0b:	e8 7b a3 fe ff       	call   f0100f8b <cprintf>
f0116c10:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116c13:	e8 f1 dc fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116c18:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116c1b:	74 17                	je     f0116c34 <test_kmalloc_firstfit1+0x4bb>
f0116c1d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116c24:	83 ec 0c             	sub    $0xc,%esp
f0116c27:	68 74 a3 12 f0       	push   $0xf012a374
f0116c2c:	e8 5a a3 fe ff       	call   f0100f8b <cprintf>
f0116c31:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("8 Wrong allocation: \n"); }
f0116c34:	e8 3c 6e ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116c39:	89 c2                	mov    %eax,%edx
f0116c3b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116c3e:	29 d0                	sub    %edx,%eax
f0116c40:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0116c45:	7f 17                	jg     f0116c5e <test_kmalloc_firstfit1+0x4e5>
f0116c47:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116c4e:	83 ec 0c             	sub    $0xc,%esp
f0116c51:	68 73 ab 12 f0       	push   $0xf012ab73
f0116c56:	e8 30 a3 fe ff       	call   f0100f8b <cprintf>
f0116c5b:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0116c5e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116c62:	74 04                	je     f0116c68 <test_kmalloc_firstfit1+0x4ef>
f0116c64:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0116c68:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	cprintf("\n2. Free some to create holes [10%]\n");
f0116c6f:	83 ec 0c             	sub    $0xc,%esp
f0116c72:	68 8c ab 12 f0       	push   $0xf012ab8c
f0116c77:	e8 0f a3 fe ff       	call   f0100f8b <cprintf>
f0116c7c:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116c7f:	e8 f1 6d ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116c84:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116c87:	e8 7d dc fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116c8c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0116c8f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0116c92:	83 ec 0c             	sub    $0xc,%esp
f0116c95:	50                   	push   %eax
f0116c96:	e8 02 23 ff ff       	call   f0108f9d <kfree>
f0116c9b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116c9e:	e8 66 dc fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116ca3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116ca6:	74 17                	je     f0116cbf <test_kmalloc_firstfit1+0x546>
f0116ca8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116caf:	83 ec 0c             	sub    $0xc,%esp
f0116cb2:	68 b4 ab 12 f0       	push   $0xf012abb4
f0116cb7:	e8 cf a2 fe ff       	call   f0100f8b <cprintf>
f0116cbc:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("9 Wrong free: \n"); }
f0116cbf:	e8 b1 6d ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116cc4:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0116cc7:	3d ff 00 00 00       	cmp    $0xff,%eax
f0116ccc:	7f 17                	jg     f0116ce5 <test_kmalloc_firstfit1+0x56c>
f0116cce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116cd5:	83 ec 0c             	sub    $0xc,%esp
f0116cd8:	68 1f ac 12 f0       	push   $0xf012ac1f
f0116cdd:	e8 a9 a2 fe ff       	call   f0100f8b <cprintf>
f0116ce2:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116ce5:	e8 8b 6d ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116cea:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116ced:	e8 17 dc fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116cf2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f0116cf5:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116cf8:	83 ec 0c             	sub    $0xc,%esp
f0116cfb:	50                   	push   %eax
f0116cfc:	e8 9c 22 ff ff       	call   f0108f9d <kfree>
f0116d01:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116d04:	e8 00 dc fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116d09:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116d0c:	74 17                	je     f0116d25 <test_kmalloc_firstfit1+0x5ac>
f0116d0e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d15:	83 ec 0c             	sub    $0xc,%esp
f0116d18:	68 30 ac 12 f0       	push   $0xf012ac30
f0116d1d:	e8 69 a2 fe ff       	call   f0100f8b <cprintf>
f0116d22:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("10 Wrong free: \n"); }
f0116d25:	e8 4b 6d ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116d2a:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0116d2d:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116d32:	7f 17                	jg     f0116d4b <test_kmalloc_firstfit1+0x5d2>
f0116d34:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d3b:	83 ec 0c             	sub    $0xc,%esp
f0116d3e:	68 9c ac 12 f0       	push   $0xf012ac9c
f0116d43:	e8 43 a2 fe ff       	call   f0100f8b <cprintf>
f0116d48:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116d4b:	e8 25 6d ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116d50:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116d53:	e8 b1 db fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116d58:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0116d5b:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0116d5e:	83 ec 0c             	sub    $0xc,%esp
f0116d61:	50                   	push   %eax
f0116d62:	e8 36 22 ff ff       	call   f0108f9d <kfree>
f0116d67:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116d6a:	e8 9a db fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116d6f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116d72:	74 17                	je     f0116d8b <test_kmalloc_firstfit1+0x612>
f0116d74:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116d7b:	83 ec 0c             	sub    $0xc,%esp
f0116d7e:	68 b0 ac 12 f0       	push   $0xf012acb0
f0116d83:	e8 03 a2 fe ff       	call   f0100f8b <cprintf>
f0116d88:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("11 Wrong free: \n"); }
f0116d8b:	e8 e5 6c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116d90:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0116d93:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0116d98:	7f 17                	jg     f0116db1 <test_kmalloc_firstfit1+0x638>
f0116d9a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116da1:	83 ec 0c             	sub    $0xc,%esp
f0116da4:	68 1c ad 12 f0       	push   $0xf012ad1c
f0116da9:	e8 dd a1 fe ff       	call   f0100f8b <cprintf>
f0116dae:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0116db1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0116db5:	74 04                	je     f0116dbb <test_kmalloc_firstfit1+0x642>
f0116db7:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0116dbb:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	cprintf("\n3. Allocate again [test first fit] [40%]\n");
f0116dc2:	83 ec 0c             	sub    $0xc,%esp
f0116dc5:	68 30 ad 12 f0       	push   $0xf012ad30
f0116dca:	e8 bc a1 fe ff       	call   f0100f8b <cprintf>
f0116dcf:	83 c4 10             	add    $0x10,%esp
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116dd2:	e8 9e 6c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116dd7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116dda:	e8 2a db fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116ddf:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f0116de2:	83 ec 0c             	sub    $0xc,%esp
f0116de5:	68 00 fc 07 00       	push   $0x7fc00
f0116dea:	e8 41 20 ff ff       	call   f0108e30 <kmalloc>
f0116def:	83 c4 10             	add    $0x10,%esp
f0116df2:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("12 Wrong start address for the allocated space... \n"); }
f0116df5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0116df8:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0116dfd:	74 17                	je     f0116e16 <test_kmalloc_firstfit1+0x69d>
f0116dff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e06:	83 ec 0c             	sub    $0xc,%esp
f0116e09:	68 5c ad 12 f0       	push   $0xf012ad5c
f0116e0e:	e8 78 a1 fe ff       	call   f0100f8b <cprintf>
f0116e13:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116e16:	e8 ee da fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116e1b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116e1e:	74 17                	je     f0116e37 <test_kmalloc_firstfit1+0x6be>
f0116e20:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e27:	83 ec 0c             	sub    $0xc,%esp
f0116e2a:	68 90 ad 12 f0       	push   $0xf012ad90
f0116e2f:	e8 57 a1 fe ff       	call   f0100f8b <cprintf>
f0116e34:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("12 Wrong allocation: \n"); }
f0116e37:	e8 39 6c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116e3c:	89 c2                	mov    %eax,%edx
f0116e3e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116e41:	29 d0                	sub    %edx,%eax
f0116e43:	83 f8 7f             	cmp    $0x7f,%eax
f0116e46:	7f 17                	jg     f0116e5f <test_kmalloc_firstfit1+0x6e6>
f0116e48:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e4f:	83 ec 0c             	sub    $0xc,%esp
f0116e52:	68 fc ad 12 f0       	push   $0xf012adfc
f0116e57:	e8 2f a1 fe ff       	call   f0100f8b <cprintf>
f0116e5c:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116e5f:	e8 11 6c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116e64:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116e67:	e8 9d da fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116e6c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f0116e6f:	83 ec 0c             	sub    $0xc,%esp
f0116e72:	68 00 fc 0f 00       	push   $0xffc00
f0116e77:	e8 b4 1f ff ff       	call   f0108e30 <kmalloc>
f0116e7c:	83 c4 10             	add    $0x10,%esp
f0116e7f:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("13 Wrong start address for the allocated space... \n"); }
f0116e82:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0116e85:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0116e8a:	74 17                	je     f0116ea3 <test_kmalloc_firstfit1+0x72a>
f0116e8c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116e93:	83 ec 0c             	sub    $0xc,%esp
f0116e96:	68 14 ae 12 f0       	push   $0xf012ae14
f0116e9b:	e8 eb a0 fe ff       	call   f0100f8b <cprintf>
f0116ea0:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116ea3:	e8 61 da fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116ea8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116eab:	74 17                	je     f0116ec4 <test_kmalloc_firstfit1+0x74b>
f0116ead:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116eb4:	83 ec 0c             	sub    $0xc,%esp
f0116eb7:	68 48 ae 12 f0       	push   $0xf012ae48
f0116ebc:	e8 ca a0 fe ff       	call   f0100f8b <cprintf>
f0116ec1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("13 Wrong allocation: \n"); }
f0116ec4:	e8 ac 6b ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116ec9:	89 c2                	mov    %eax,%edx
f0116ecb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116ece:	29 d0                	sub    %edx,%eax
f0116ed0:	3d ff 00 00 00       	cmp    $0xff,%eax
f0116ed5:	7f 17                	jg     f0116eee <test_kmalloc_firstfit1+0x775>
f0116ed7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ede:	83 ec 0c             	sub    $0xc,%esp
f0116ee1:	68 b4 ae 12 f0       	push   $0xf012aeb4
f0116ee6:	e8 a0 a0 fe ff       	call   f0100f8b <cprintf>
f0116eeb:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116eee:	e8 82 6b ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116ef3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116ef6:	e8 0e da fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116efb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f0116efe:	83 ec 0c             	sub    $0xc,%esp
f0116f01:	68 00 fc 03 00       	push   $0x3fc00
f0116f06:	e8 25 1f ff ff       	call   f0108e30 <kmalloc>
f0116f0b:	83 c4 10             	add    $0x10,%esp
f0116f0e:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("14 Wrong start address for the allocated space... \n"); }
f0116f11:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116f14:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f0116f19:	74 17                	je     f0116f32 <test_kmalloc_firstfit1+0x7b9>
f0116f1b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f22:	83 ec 0c             	sub    $0xc,%esp
f0116f25:	68 cc ae 12 f0       	push   $0xf012aecc
f0116f2a:	e8 5c a0 fe ff       	call   f0100f8b <cprintf>
f0116f2f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116f32:	e8 d2 d9 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116f37:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116f3a:	74 17                	je     f0116f53 <test_kmalloc_firstfit1+0x7da>
f0116f3c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f43:	83 ec 0c             	sub    $0xc,%esp
f0116f46:	68 00 af 12 f0       	push   $0xf012af00
f0116f4b:	e8 3b a0 fe ff       	call   f0100f8b <cprintf>
f0116f50:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("14 Wrong allocation: \n"); }
f0116f53:	e8 1d 6b ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116f58:	89 c2                	mov    %eax,%edx
f0116f5a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116f5d:	29 d0                	sub    %edx,%eax
f0116f5f:	83 f8 3f             	cmp    $0x3f,%eax
f0116f62:	7f 17                	jg     f0116f7b <test_kmalloc_firstfit1+0x802>
f0116f64:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116f6b:	83 ec 0c             	sub    $0xc,%esp
f0116f6e:	68 6c af 12 f0       	push   $0xf012af6c
f0116f73:	e8 13 a0 fe ff       	call   f0100f8b <cprintf>
f0116f78:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0116f7b:	e8 f5 6a ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116f80:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0116f83:	e8 81 d9 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116f88:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f0116f8b:	83 ec 0c             	sub    $0xc,%esp
f0116f8e:	68 00 00 20 00       	push   $0x200000
f0116f93:	e8 98 1e ff ff       	call   f0108e30 <kmalloc>
f0116f98:	83 c4 10             	add    $0x10,%esp
f0116f9b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("15 Wrong start address for the allocated space... \n"); }
f0116f9e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0116fa1:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0116fa6:	74 17                	je     f0116fbf <test_kmalloc_firstfit1+0x846>
f0116fa8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116faf:	83 ec 0c             	sub    $0xc,%esp
f0116fb2:	68 84 af 12 f0       	push   $0xf012af84
f0116fb7:	e8 cf 9f fe ff       	call   f0100f8b <cprintf>
f0116fbc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("15 Wrong allocation: \n"); }
f0116fbf:	e8 b1 6a ff ff       	call   f010da75 <sys_calculate_free_frames>
f0116fc4:	89 c2                	mov    %eax,%edx
f0116fc6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116fc9:	29 d0                	sub    %edx,%eax
f0116fcb:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0116fd0:	7f 17                	jg     f0116fe9 <test_kmalloc_firstfit1+0x870>
f0116fd2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116fd9:	83 ec 0c             	sub    $0xc,%esp
f0116fdc:	68 b8 af 12 f0       	push   $0xf012afb8
f0116fe1:	e8 a5 9f fe ff       	call   f0100f8b <cprintf>
f0116fe6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0116fe9:	e8 1b d9 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0116fee:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0116ff1:	74 17                	je     f011700a <test_kmalloc_firstfit1+0x891>
f0116ff3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0116ffa:	83 ec 0c             	sub    $0xc,%esp
f0116ffd:	68 d0 af 12 f0       	push   $0xf012afd0
f0117002:	e8 84 9f fe ff       	call   f0100f8b <cprintf>
f0117007:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f011700a:	e8 66 6a ff ff       	call   f010da75 <sys_calculate_free_frames>
f011700f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117012:	e8 f2 d8 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117017:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f011701a:	83 ec 0c             	sub    $0xc,%esp
f011701d:	68 00 fc 3f 00       	push   $0x3ffc00
f0117022:	e8 09 1e ff ff       	call   f0108e30 <kmalloc>
f0117027:	83 c4 10             	add    $0x10,%esp
f011702a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("16 Wrong start address for the allocated space... \n"); }
f011702d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0117030:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f0117035:	74 17                	je     f011704e <test_kmalloc_firstfit1+0x8d5>
f0117037:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011703e:	83 ec 0c             	sub    $0xc,%esp
f0117041:	68 3c b0 12 f0       	push   $0xf012b03c
f0117046:	e8 40 9f fe ff       	call   f0100f8b <cprintf>
f011704b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011704e:	e8 b6 d8 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117053:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117056:	74 17                	je     f011706f <test_kmalloc_firstfit1+0x8f6>
f0117058:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011705f:	83 ec 0c             	sub    $0xc,%esp
f0117062:	68 70 b0 12 f0       	push   $0xf012b070
f0117067:	e8 1f 9f fe ff       	call   f0100f8b <cprintf>
f011706c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("16 Wrong allocation: \n"); }
f011706f:	e8 01 6a ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117074:	89 c2                	mov    %eax,%edx
f0117076:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117079:	29 d0                	sub    %edx,%eax
f011707b:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f0117080:	7f 17                	jg     f0117099 <test_kmalloc_firstfit1+0x920>
f0117082:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117089:	83 ec 0c             	sub    $0xc,%esp
f011708c:	68 dc b0 12 f0       	push   $0xf012b0dc
f0117091:	e8 f5 9e fe ff       	call   f0100f8b <cprintf>
f0117096:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0117099:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011709d:	74 04                	je     f01170a3 <test_kmalloc_firstfit1+0x92a>
f011709f:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f01170a3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	cprintf("\n4. Free contiguous allocations (coalescing) [10%]\n");
f01170aa:	83 ec 0c             	sub    $0xc,%esp
f01170ad:	68 f4 b0 12 f0       	push   $0xf012b0f4
f01170b2:	e8 d4 9e fe ff       	call   f0100f8b <cprintf>
f01170b7:	83 c4 10             	add    $0x10,%esp
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01170ba:	e8 b6 69 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01170bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01170c2:	e8 42 d8 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01170c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f01170ca:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01170cd:	83 ec 0c             	sub    $0xc,%esp
f01170d0:	50                   	push   %eax
f01170d1:	e8 c7 1e ff ff       	call   f0108f9d <kfree>
f01170d6:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01170d9:	e8 2b d8 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01170de:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01170e1:	74 17                	je     f01170fa <test_kmalloc_firstfit1+0x981>
f01170e3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01170ea:	83 ec 0c             	sub    $0xc,%esp
f01170ed:	68 b4 a6 12 f0       	push   $0xf012a6b4
f01170f2:	e8 94 9e fe ff       	call   f0100f8b <cprintf>
f01170f7:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("17 Wrong free: \n"); }
f01170fa:	e8 76 69 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01170ff:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117102:	3d ff 00 00 00       	cmp    $0xff,%eax
f0117107:	7f 17                	jg     f0117120 <test_kmalloc_firstfit1+0x9a7>
f0117109:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117110:	83 ec 0c             	sub    $0xc,%esp
f0117113:	68 28 b1 12 f0       	push   $0xf012b128
f0117118:	e8 6e 9e fe ff       	call   f0100f8b <cprintf>
f011711d:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f0117120:	e8 50 69 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117125:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117128:	e8 dc d7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011712d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f0117130:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117133:	83 ec 0c             	sub    $0xc,%esp
f0117136:	50                   	push   %eax
f0117137:	e8 61 1e ff ff       	call   f0108f9d <kfree>
f011713c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011713f:	e8 c5 d7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117144:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117147:	74 17                	je     f0117160 <test_kmalloc_firstfit1+0x9e7>
f0117149:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117150:	83 ec 0c             	sub    $0xc,%esp
f0117153:	68 7c a7 12 f0       	push   $0xf012a77c
f0117158:	e8 2e 9e fe ff       	call   f0100f8b <cprintf>
f011715d:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("18 Wrong free: \n"); }
f0117160:	e8 10 69 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117165:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117168:	3d ff 00 00 00       	cmp    $0xff,%eax
f011716d:	7f 17                	jg     f0117186 <test_kmalloc_firstfit1+0xa0d>
f011716f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117176:	83 ec 0c             	sub    $0xc,%esp
f0117179:	68 39 b1 12 f0       	push   $0xf012b139
f011717e:	e8 08 9e fe ff       	call   f0100f8b <cprintf>
f0117183:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0117186:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011718a:	74 04                	je     f0117190 <test_kmalloc_firstfit1+0xa17>
f011718c:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117190:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	cprintf("\n5. Allocate again [test first fit in coalesced area] [30%]\n");
f0117197:	83 ec 0c             	sub    $0xc,%esp
f011719a:	68 4c b1 12 f0       	push   $0xf012b14c
f011719f:	e8 e7 9d fe ff       	call   f0100f8b <cprintf>
f01171a4:	83 c4 10             	add    $0x10,%esp
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f01171a7:	e8 c9 68 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01171ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01171af:	e8 55 d7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01171b4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f01171b7:	83 ec 0c             	sub    $0xc,%esp
f01171ba:	68 00 00 10 00       	push   $0x100000
f01171bf:	e8 6c 1c ff ff       	call   f0108e30 <kmalloc>
f01171c4:	83 c4 10             	add    $0x10,%esp
f01171c7:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f01171ca:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01171cd:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f01171d2:	74 17                	je     f01171eb <test_kmalloc_firstfit1+0xa72>
f01171d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171db:	83 ec 0c             	sub    $0xc,%esp
f01171de:	68 8c b1 12 f0       	push   $0xf012b18c
f01171e3:	e8 a3 9d fe ff       	call   f0100f8b <cprintf>
f01171e8:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01171eb:	e8 19 d7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01171f0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01171f3:	74 17                	je     f011720c <test_kmalloc_firstfit1+0xa93>
f01171f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01171fc:	83 ec 0c             	sub    $0xc,%esp
f01171ff:	68 c0 b1 12 f0       	push   $0xf012b1c0
f0117204:	e8 82 9d fe ff       	call   f0100f8b <cprintf>
f0117209:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f011720c:	e8 64 68 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117211:	89 c2                	mov    %eax,%edx
f0117213:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117216:	29 d0                	sub    %edx,%eax
f0117218:	3d ff 00 00 00       	cmp    $0xff,%eax
f011721d:	7f 17                	jg     f0117236 <test_kmalloc_firstfit1+0xabd>
f011721f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117226:	83 ec 0c             	sub    $0xc,%esp
f0117229:	68 2c b2 12 f0       	push   $0xf012b22c
f011722e:	e8 58 9d fe ff       	call   f0100f8b <cprintf>
f0117233:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f0117236:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011723a:	74 04                	je     f0117240 <test_kmalloc_firstfit1+0xac7>
f011723c:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f0117240:	83 ec 08             	sub    $0x8,%esp
f0117243:	ff 75 f4             	pushl  -0xc(%ebp)
f0117246:	68 44 b2 12 f0       	push   $0xf012b244
f011724b:	e8 3b 9d fe ff       	call   f0100f8b <cprintf>
f0117250:	83 c4 10             	add    $0x10,%esp

	return 1;
f0117253:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0117258:	8b 7d fc             	mov    -0x4(%ebp),%edi
f011725b:	c9                   	leave  
f011725c:	c3                   	ret    

f011725d <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f011725d:	55                   	push   %ebp
f011725e:	89 e5                	mov    %esp,%ebp
f0117260:	57                   	push   %edi
f0117261:	53                   	push   %ebx
f0117262:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0117265:	83 ec 0c             	sub    $0xc,%esp
f0117268:	68 08 9a 12 f0       	push   $0xf0129a08
f011726d:	e8 19 9d fe ff       	call   f0100f8b <cprintf>
f0117272:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0117275:	83 ec 0c             	sub    $0xc,%esp
f0117278:	68 38 9a 12 f0       	push   $0xf0129a38
f011727d:	e8 09 9d fe ff       	call   f0100f8b <cprintf>
f0117282:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0117285:	83 ec 0c             	sub    $0xc,%esp
f0117288:	68 08 9a 12 f0       	push   $0xf0129a08
f011728d:	e8 f9 9c fe ff       	call   f0100f8b <cprintf>
f0117292:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0117295:	8d 55 98             	lea    -0x68(%ebp),%edx
f0117298:	b9 14 00 00 00       	mov    $0x14,%ecx
f011729d:	b8 00 00 00 00       	mov    $0x0,%eax
f01172a2:	89 d7                	mov    %edx,%edi
f01172a4:	f3 ab                	rep stos %eax,%es:(%edi)
	int freeFrames;
	int freeDiskFrames;
	int eval = 0;
f01172a6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f01172ad:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f01172b4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	cprintf("\n1. Attempt to allocate more than heap size [10%]\n");
f01172bb:	83 ec 0c             	sub    $0xc,%esp
f01172be:	68 7c b2 12 f0       	push   $0xf012b27c
f01172c3:	e8 c3 9c fe ff       	call   f0100f8b <cprintf>
f01172c8:	83 c4 10             	add    $0x10,%esp
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f01172cb:	83 ec 0c             	sub    $0xc,%esp
f01172ce:	68 01 e0 ff 07       	push   $0x7ffe001
f01172d3:	e8 58 1b ff ff       	call   f0108e30 <kmalloc>
f01172d8:	83 c4 10             	add    $0x10,%esp
f01172db:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("1 kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f01172de:	8b 45 98             	mov    -0x68(%ebp),%eax
f01172e1:	85 c0                	test   %eax,%eax
f01172e3:	74 17                	je     f01172fc <test_kmalloc_firstfit2+0x9f>
f01172e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01172ec:	83 ec 0c             	sub    $0xc,%esp
f01172ef:	68 b0 b2 12 f0       	push   $0xf012b2b0
f01172f4:	e8 92 9c fe ff       	call   f0100f8b <cprintf>
f01172f9:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01172fc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117300:	74 04                	je     f0117306 <test_kmalloc_firstfit2+0xa9>
f0117302:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0117306:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	cprintf("\n2. Allocate & Free to create fragments inside BOTH ALLOCATORS [10%]\n");
f011730d:	83 ec 0c             	sub    $0xc,%esp
f0117310:	68 f8 b2 12 f0       	push   $0xf012b2f8
f0117315:	e8 71 9c fe ff       	call   f0100f8b <cprintf>
f011731a:	83 c4 10             	add    $0x10,%esp
	{
		/*[1] PAGE ALLOCATOR PART*/

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011731d:	e8 53 67 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117322:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117325:	e8 df d5 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011732a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011732d:	83 ec 0c             	sub    $0xc,%esp
f0117330:	68 00 fc 1f 00       	push   $0x1ffc00
f0117335:	e8 f6 1a ff ff       	call   f0108e30 <kmalloc>
f011733a:	83 c4 10             	add    $0x10,%esp
f011733d:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("2 Wrong start address for the allocated space... \n"); }
f0117340:	8b 45 98             	mov    -0x68(%ebp),%eax
f0117343:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117348:	74 17                	je     f0117361 <test_kmalloc_firstfit2+0x104>
f011734a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117351:	83 ec 0c             	sub    $0xc,%esp
f0117354:	68 78 a9 12 f0       	push   $0xf012a978
f0117359:	e8 2d 9c fe ff       	call   f0100f8b <cprintf>
f011735e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117361:	e8 a3 d5 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117366:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117369:	74 17                	je     f0117382 <test_kmalloc_firstfit2+0x125>
f011736b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117372:	83 ec 0c             	sub    $0xc,%esp
f0117375:	68 4c 9d 12 f0       	push   $0xf0129d4c
f011737a:	e8 0c 9c fe ff       	call   f0100f8b <cprintf>
f011737f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("2 Wrong allocation: \n"); }
f0117382:	e8 ee 66 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117387:	89 c2                	mov    %eax,%edx
f0117389:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011738c:	29 d0                	sub    %edx,%eax
f011738e:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117393:	7f 17                	jg     f01173ac <test_kmalloc_firstfit2+0x14f>
f0117395:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011739c:	83 ec 0c             	sub    $0xc,%esp
f011739f:	68 ab a9 12 f0       	push   $0xf012a9ab
f01173a4:	e8 e2 9b fe ff       	call   f0100f8b <cprintf>
f01173a9:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01173ac:	e8 c4 66 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01173b1:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01173b4:	e8 50 d5 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01173b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f01173bc:	83 ec 0c             	sub    $0xc,%esp
f01173bf:	68 00 fc 1f 00       	push   $0x1ffc00
f01173c4:	e8 67 1a ff ff       	call   f0108e30 <kmalloc>
f01173c9:	83 c4 10             	add    $0x10,%esp
f01173cc:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("3 Wrong start address for the allocated space... \n"); }
f01173cf:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01173d2:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f01173d7:	74 17                	je     f01173f0 <test_kmalloc_firstfit2+0x193>
f01173d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01173e0:	83 ec 0c             	sub    $0xc,%esp
f01173e3:	68 c4 a9 12 f0       	push   $0xf012a9c4
f01173e8:	e8 9e 9b fe ff       	call   f0100f8b <cprintf>
f01173ed:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01173f0:	e8 14 d5 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01173f5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01173f8:	74 17                	je     f0117411 <test_kmalloc_firstfit2+0x1b4>
f01173fa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117401:	83 ec 0c             	sub    $0xc,%esp
f0117404:	68 88 9e 12 f0       	push   $0xf0129e88
f0117409:	e8 7d 9b fe ff       	call   f0100f8b <cprintf>
f011740e:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("3 Wrong allocation: \n"); }
f0117411:	e8 5f 66 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117416:	89 c2                	mov    %eax,%edx
f0117418:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011741b:	29 d0                	sub    %edx,%eax
f011741d:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117422:	7f 17                	jg     f011743b <test_kmalloc_firstfit2+0x1de>
f0117424:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011742b:	83 ec 0c             	sub    $0xc,%esp
f011742e:	68 f7 a9 12 f0       	push   $0xf012a9f7
f0117433:	e8 53 9b fe ff       	call   f0100f8b <cprintf>
f0117438:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011743b:	e8 35 66 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117440:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117443:	e8 c1 d4 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117448:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011744b:	83 ec 0c             	sub    $0xc,%esp
f011744e:	68 00 1c 00 00       	push   $0x1c00
f0117453:	e8 d8 19 ff ff       	call   f0108e30 <kmalloc>
f0117458:	83 c4 10             	add    $0x10,%esp
f011745b:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("4 Wrong start address for the allocated space... \n"); }
f011745e:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117461:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0117466:	74 17                	je     f011747f <test_kmalloc_firstfit2+0x222>
f0117468:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011746f:	83 ec 0c             	sub    $0xc,%esp
f0117472:	68 10 aa 12 f0       	push   $0xf012aa10
f0117477:	e8 0f 9b fe ff       	call   f0100f8b <cprintf>
f011747c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011747f:	e8 85 d4 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117484:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117487:	74 17                	je     f01174a0 <test_kmalloc_firstfit2+0x243>
f0117489:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117490:	83 ec 0c             	sub    $0xc,%esp
f0117493:	68 80 9f 12 f0       	push   $0xf0129f80
f0117498:	e8 ee 9a fe ff       	call   f0100f8b <cprintf>
f011749d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("4 Wrong allocation: \n"); }
f01174a0:	e8 d0 65 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01174a5:	89 c2                	mov    %eax,%edx
f01174a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01174aa:	29 d0                	sub    %edx,%eax
f01174ac:	83 f8 01             	cmp    $0x1,%eax
f01174af:	7f 17                	jg     f01174c8 <test_kmalloc_firstfit2+0x26b>
f01174b1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174b8:	83 ec 0c             	sub    $0xc,%esp
f01174bb:	68 43 aa 12 f0       	push   $0xf012aa43
f01174c0:	e8 c6 9a fe ff       	call   f0100f8b <cprintf>
f01174c5:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01174c8:	e8 a8 65 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01174cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01174d0:	e8 34 d4 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01174d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f01174d8:	8b 45 98             	mov    -0x68(%ebp),%eax
f01174db:	83 ec 0c             	sub    $0xc,%esp
f01174de:	50                   	push   %eax
f01174df:	e8 b9 1a ff ff       	call   f0108f9d <kfree>
f01174e4:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01174e7:	e8 1d d4 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01174ec:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01174ef:	74 17                	je     f0117508 <test_kmalloc_firstfit2+0x2ab>
f01174f1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01174f8:	83 ec 0c             	sub    $0xc,%esp
f01174fb:	68 68 a0 12 f0       	push   $0xf012a068
f0117500:	e8 86 9a fe ff       	call   f0100f8b <cprintf>
f0117505:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("5 Wrong free: \n"); }
f0117508:	e8 68 65 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011750d:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117510:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0117515:	7f 17                	jg     f011752e <test_kmalloc_firstfit2+0x2d1>
f0117517:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011751e:	83 ec 0c             	sub    $0xc,%esp
f0117521:	68 3e b3 12 f0       	push   $0xf012b33e
f0117526:	e8 60 9a fe ff       	call   f0100f8b <cprintf>
f011752b:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011752e:	e8 42 65 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117533:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117536:	e8 ce d3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011753b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011753e:	83 ec 0c             	sub    $0xc,%esp
f0117541:	68 00 fc 2f 00       	push   $0x2ffc00
f0117546:	e8 e5 18 ff ff       	call   f0108e30 <kmalloc>
f011754b:	83 c4 10             	add    $0x10,%esp
f011754e:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("6 Wrong start address for the allocated space... \n"); }
f0117551:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117554:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0117559:	74 17                	je     f0117572 <test_kmalloc_firstfit2+0x315>
f011755b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117562:	83 ec 0c             	sub    $0xc,%esp
f0117565:	68 a8 aa 12 f0       	push   $0xf012aaa8
f011756a:	e8 1c 9a fe ff       	call   f0100f8b <cprintf>
f011756f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117572:	e8 92 d3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117577:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011757a:	74 17                	je     f0117593 <test_kmalloc_firstfit2+0x336>
f011757c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117583:	83 ec 0c             	sub    $0xc,%esp
f0117586:	68 6c a1 12 f0       	push   $0xf012a16c
f011758b:	e8 fb 99 fe ff       	call   f0100f8b <cprintf>
f0117590:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("6 Wrong allocation: \n"); }
f0117593:	e8 dd 64 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117598:	89 c2                	mov    %eax,%edx
f011759a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011759d:	29 d0                	sub    %edx,%eax
f011759f:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01175a4:	7f 17                	jg     f01175bd <test_kmalloc_firstfit2+0x360>
f01175a6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175ad:	83 ec 0c             	sub    $0xc,%esp
f01175b0:	68 db aa 12 f0       	push   $0xf012aadb
f01175b5:	e8 d1 99 fe ff       	call   f0100f8b <cprintf>
f01175ba:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f01175bd:	e8 b3 64 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01175c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01175c5:	e8 3f d3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01175ca:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f01175cd:	83 ec 0c             	sub    $0xc,%esp
f01175d0:	68 00 18 20 00       	push   $0x201800
f01175d5:	e8 56 18 ff ff       	call   f0108e30 <kmalloc>
f01175da:	83 c4 10             	add    $0x10,%esp
f01175dd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("7 Wrong start address for the allocated space... \n"); }
f01175e0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01175e3:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f01175e8:	74 17                	je     f0117601 <test_kmalloc_firstfit2+0x3a4>
f01175ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01175f1:	83 ec 0c             	sub    $0xc,%esp
f01175f4:	68 f4 aa 12 f0       	push   $0xf012aaf4
f01175f9:	e8 8d 99 fe ff       	call   f0100f8b <cprintf>
f01175fe:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117601:	e8 03 d3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117606:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117609:	74 17                	je     f0117622 <test_kmalloc_firstfit2+0x3c5>
f011760b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117612:	83 ec 0c             	sub    $0xc,%esp
f0117615:	68 70 a2 12 f0       	push   $0xf012a270
f011761a:	e8 6c 99 fe ff       	call   f0100f8b <cprintf>
f011761f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("7 Wrong allocation: \n"); }
f0117622:	e8 4e 64 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117627:	89 c2                	mov    %eax,%edx
f0117629:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011762c:	29 d0                	sub    %edx,%eax
f011762e:	3d 01 02 00 00       	cmp    $0x201,%eax
f0117633:	7f 17                	jg     f011764c <test_kmalloc_firstfit2+0x3ef>
f0117635:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011763c:	83 ec 0c             	sub    $0xc,%esp
f011763f:	68 27 ab 12 f0       	push   $0xf012ab27
f0117644:	e8 42 99 fe ff       	call   f0100f8b <cprintf>
f0117649:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011764c:	e8 24 64 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117651:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117654:	e8 b0 d2 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117659:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f011765c:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011765f:	83 ec 0c             	sub    $0xc,%esp
f0117662:	50                   	push   %eax
f0117663:	e8 35 19 ff ff       	call   f0108f9d <kfree>
f0117668:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011766b:	e8 99 d2 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117670:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117673:	74 17                	je     f011768c <test_kmalloc_firstfit2+0x42f>
f0117675:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011767c:	83 ec 0c             	sub    $0xc,%esp
f011767f:	68 74 a3 12 f0       	push   $0xf012a374
f0117684:	e8 02 99 fe ff       	call   f0100f8b <cprintf>
f0117689:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("8 Wrong free: \n"); }
f011768c:	e8 e4 63 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117691:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0117694:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0117699:	7f 17                	jg     f01176b2 <test_kmalloc_firstfit2+0x455>
f011769b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176a2:	83 ec 0c             	sub    $0xc,%esp
f01176a5:	68 4e b3 12 f0       	push   $0xf012b34e
f01176aa:	e8 dc 98 fe ff       	call   f0100f8b <cprintf>
f01176af:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f01176b2:	e8 be 63 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01176b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01176ba:	e8 4a d2 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01176bf:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f01176c2:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01176c5:	83 ec 0c             	sub    $0xc,%esp
f01176c8:	50                   	push   %eax
f01176c9:	e8 cf 18 ff ff       	call   f0108f9d <kfree>
f01176ce:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("9 Wrong free: \n"); }
f01176d1:	e8 9f 63 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01176d6:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01176d9:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01176de:	7f 17                	jg     f01176f7 <test_kmalloc_firstfit2+0x49a>
f01176e0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01176e7:	83 ec 0c             	sub    $0xc,%esp
f01176ea:	68 1f ac 12 f0       	push   $0xf012ac1f
f01176ef:	e8 97 98 fe ff       	call   f0100f8b <cprintf>
f01176f4:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01176f7:	e8 0d d2 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01176fc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01176ff:	74 17                	je     f0117718 <test_kmalloc_firstfit2+0x4bb>
f0117701:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117708:	83 ec 0c             	sub    $0xc,%esp
f011770b:	68 b4 ab 12 f0       	push   $0xf012abb4
f0117710:	e8 76 98 fe ff       	call   f0100f8b <cprintf>
f0117715:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117718:	e8 58 63 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011771d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117720:	e8 e4 d1 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117725:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f0117728:	83 ec 0c             	sub    $0xc,%esp
f011772b:	68 00 fc 4f 00       	push   $0x4ffc00
f0117730:	e8 fb 16 ff ff       	call   f0108e30 <kmalloc>
f0117735:	83 c4 10             	add    $0x10,%esp
f0117738:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("10 Wrong start address for the allocated space... \n"); }
f011773b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011773e:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f0117743:	74 17                	je     f011775c <test_kmalloc_firstfit2+0x4ff>
f0117745:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011774c:	83 ec 0c             	sub    $0xc,%esp
f011774f:	68 60 b3 12 f0       	push   $0xf012b360
f0117754:	e8 32 98 fe ff       	call   f0100f8b <cprintf>
f0117759:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("10 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011775c:	e8 a8 d1 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117761:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117764:	74 17                	je     f011777d <test_kmalloc_firstfit2+0x520>
f0117766:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011776d:	83 ec 0c             	sub    $0xc,%esp
f0117770:	68 30 ac 12 f0       	push   $0xf012ac30
f0117775:	e8 11 98 fe ff       	call   f0100f8b <cprintf>
f011777a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("10 Wrong allocation: \n"); }
f011777d:	e8 f3 62 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117782:	89 c2                	mov    %eax,%edx
f0117784:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117787:	29 d0                	sub    %edx,%eax
f0117789:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f011778e:	7f 17                	jg     f01177a7 <test_kmalloc_firstfit2+0x54a>
f0117790:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117797:	83 ec 0c             	sub    $0xc,%esp
f011779a:	68 94 b3 12 f0       	push   $0xf012b394
f011779f:	e8 e7 97 fe ff       	call   f0100f8b <cprintf>
f01177a4:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f01177a7:	e8 c9 62 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01177ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01177af:	e8 55 d1 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01177b4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f01177b7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01177ba:	83 ec 0c             	sub    $0xc,%esp
f01177bd:	50                   	push   %eax
f01177be:	e8 da 17 ff ff       	call   f0108f9d <kfree>
f01177c3:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("11 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01177c6:	e8 3e d1 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01177cb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01177ce:	74 17                	je     f01177e7 <test_kmalloc_firstfit2+0x58a>
f01177d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177d7:	83 ec 0c             	sub    $0xc,%esp
f01177da:	68 b0 ac 12 f0       	push   $0xf012acb0
f01177df:	e8 a7 97 fe ff       	call   f0100f8b <cprintf>
f01177e4:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("11 Wrong free: \n"); }
f01177e7:	e8 89 62 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01177ec:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01177ef:	83 f8 01             	cmp    $0x1,%eax
f01177f2:	7f 17                	jg     f011780b <test_kmalloc_firstfit2+0x5ae>
f01177f4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01177fb:	83 ec 0c             	sub    $0xc,%esp
f01177fe:	68 1c ad 12 f0       	push   $0xf012ad1c
f0117803:	e8 83 97 fe ff       	call   f0100f8b <cprintf>
f0117808:	83 c4 10             	add    $0x10,%esp


		/*[2] BLOCK ALLOCATOR PART*/
		freeFrames = (int)sys_calculate_free_frames() ;
f011780b:	e8 65 62 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117810:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117813:	e8 f1 d0 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117818:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011781b:	83 ec 0c             	sub    $0xc,%esp
f011781e:	68 00 04 00 00       	push   $0x400
f0117823:	e8 08 16 ff ff       	call   f0108e30 <kmalloc>
f0117828:	83 c4 10             	add    $0x10,%esp
f011782b:	89 45 a0             	mov    %eax,-0x60(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011782e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117831:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0117836:	76 22                	jbe    f011785a <test_kmalloc_firstfit2+0x5fd>
f0117838:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f011783b:	83 ec 0c             	sub    $0xc,%esp
f011783e:	6a 00                	push   $0x0
f0117840:	e8 f0 14 ff ff       	call   f0108d35 <sbrk>
f0117845:	83 c4 10             	add    $0x10,%esp
f0117848:	39 c3                	cmp    %eax,%ebx
f011784a:	73 0e                	jae    f011785a <test_kmalloc_firstfit2+0x5fd>
f011784c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011784f:	89 c2                	mov    %eax,%edx
f0117851:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0117856:	39 c2                	cmp    %eax,%edx
f0117858:	72 17                	jb     f0117871 <test_kmalloc_firstfit2+0x614>
			{ correct = 0; cprintf("12 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011785a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117861:	83 ec 0c             	sub    $0xc,%esp
f0117864:	68 ac b3 12 f0       	push   $0xf012b3ac
f0117869:	e8 1d 97 fe ff       	call   f0100f8b <cprintf>
f011786e:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("12 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117871:	e8 93 d0 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117876:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117879:	74 17                	je     f0117892 <test_kmalloc_firstfit2+0x635>
f011787b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117882:	83 ec 0c             	sub    $0xc,%esp
f0117885:	68 90 ad 12 f0       	push   $0xf012ad90
f011788a:	e8 fc 96 fe ff       	call   f0100f8b <cprintf>
f011788f:	83 c4 10             	add    $0x10,%esp

			//2 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117892:	e8 72 d0 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117897:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011789a:	83 ec 0c             	sub    $0xc,%esp
f011789d:	68 00 08 00 00       	push   $0x800
f01178a2:	e8 89 15 ff ff       	call   f0108e30 <kmalloc>
f01178a7:	83 c4 10             	add    $0x10,%esp
f01178aa:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f01178ad:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01178b0:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01178b5:	76 22                	jbe    f01178d9 <test_kmalloc_firstfit2+0x67c>
f01178b7:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f01178ba:	83 ec 0c             	sub    $0xc,%esp
f01178bd:	6a 00                	push   $0x0
f01178bf:	e8 71 14 ff ff       	call   f0108d35 <sbrk>
f01178c4:	83 c4 10             	add    $0x10,%esp
f01178c7:	39 c3                	cmp    %eax,%ebx
f01178c9:	73 0e                	jae    f01178d9 <test_kmalloc_firstfit2+0x67c>
f01178cb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01178ce:	89 c2                	mov    %eax,%edx
f01178d0:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f01178d5:	39 c2                	cmp    %eax,%edx
f01178d7:	72 17                	jb     f01178f0 <test_kmalloc_firstfit2+0x693>
			{ correct = 0; cprintf("13 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01178d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01178e0:	83 ec 0c             	sub    $0xc,%esp
f01178e3:	68 38 b4 12 f0       	push   $0xf012b438
f01178e8:	e8 9e 96 fe ff       	call   f0100f8b <cprintf>
f01178ed:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("13 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01178f0:	e8 14 d0 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01178f5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01178f8:	74 17                	je     f0117911 <test_kmalloc_firstfit2+0x6b4>
f01178fa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117901:	83 ec 0c             	sub    $0xc,%esp
f0117904:	68 48 ae 12 f0       	push   $0xf012ae48
f0117909:	e8 7d 96 fe ff       	call   f0100f8b <cprintf>
f011790e:	83 c4 10             	add    $0x10,%esp

			//1 KB (should be allocated by dynamic allocator not page allocator)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117911:	e8 f3 cf fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117916:	89 45 e8             	mov    %eax,-0x18(%ebp)
			ptr_allocations[4] = kmalloc(1*kilo);
f0117919:	83 ec 0c             	sub    $0xc,%esp
f011791c:	68 00 04 00 00       	push   $0x400
f0117921:	e8 0a 15 ff ff       	call   f0108e30 <kmalloc>
f0117926:	83 c4 10             	add    $0x10,%esp
f0117929:	89 45 a8             	mov    %eax,-0x58(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011792c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011792f:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0117934:	76 22                	jbe    f0117958 <test_kmalloc_firstfit2+0x6fb>
f0117936:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0117939:	83 ec 0c             	sub    $0xc,%esp
f011793c:	6a 00                	push   $0x0
f011793e:	e8 f2 13 ff ff       	call   f0108d35 <sbrk>
f0117943:	83 c4 10             	add    $0x10,%esp
f0117946:	39 c3                	cmp    %eax,%ebx
f0117948:	73 0e                	jae    f0117958 <test_kmalloc_firstfit2+0x6fb>
f011794a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011794d:	89 c2                	mov    %eax,%edx
f011794f:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0117954:	39 c2                	cmp    %eax,%edx
f0117956:	72 17                	jb     f011796f <test_kmalloc_firstfit2+0x712>
			{ correct = 0; cprintf("14 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0117958:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011795f:	83 ec 0c             	sub    $0xc,%esp
f0117962:	68 c4 b4 12 f0       	push   $0xf012b4c4
f0117967:	e8 1f 96 fe ff       	call   f0100f8b <cprintf>
f011796c:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("14 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011796f:	e8 95 cf fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117974:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117977:	74 17                	je     f0117990 <test_kmalloc_firstfit2+0x733>
f0117979:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117980:	83 ec 0c             	sub    $0xc,%esp
f0117983:	68 00 af 12 f0       	push   $0xf012af00
f0117988:	e8 fe 95 fe ff       	call   f0100f8b <cprintf>
f011798d:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("14 Wrong allocation: sbrk error\n"); }
f0117990:	e8 e0 60 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117995:	89 c2                	mov    %eax,%edx
f0117997:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011799a:	29 d0                	sub    %edx,%eax
f011799c:	83 f8 01             	cmp    $0x1,%eax
f011799f:	74 17                	je     f01179b8 <test_kmalloc_firstfit2+0x75b>
f01179a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179a8:	83 ec 0c             	sub    $0xc,%esp
f01179ab:	68 50 b5 12 f0       	push   $0xf012b550
f01179b0:	e8 d6 95 fe ff       	call   f0100f8b <cprintf>
f01179b5:	83 c4 10             	add    $0x10,%esp

		{
			//1 KB Hole in Dynamic Allocator Area
			freeFrames = (int)sys_calculate_free_frames() ;
f01179b8:	e8 b8 60 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01179bd:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f01179c0:	e8 44 cf fe ff       	call   f0104909 <pf_calculate_free_frames>
f01179c5:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[2]);
f01179c8:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01179cb:	83 ec 0c             	sub    $0xc,%esp
f01179ce:	50                   	push   %eax
f01179cf:	e8 c9 15 ff ff       	call   f0108f9d <kfree>
f01179d4:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("15 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01179d7:	e8 2d cf fe ff       	call   f0104909 <pf_calculate_free_frames>
f01179dc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01179df:	74 17                	je     f01179f8 <test_kmalloc_firstfit2+0x79b>
f01179e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01179e8:	83 ec 0c             	sub    $0xc,%esp
f01179eb:	68 d0 af 12 f0       	push   $0xf012afd0
f01179f0:	e8 96 95 fe ff       	call   f0100f8b <cprintf>
f01179f5:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("15 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f01179f8:	e8 78 60 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01179fd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0117a00:	74 17                	je     f0117a19 <test_kmalloc_firstfit2+0x7bc>
f0117a02:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a09:	83 ec 0c             	sub    $0xc,%esp
f0117a0c:	68 74 b5 12 f0       	push   $0xf012b574
f0117a11:	e8 75 95 fe ff       	call   f0100f8b <cprintf>
f0117a16:	83 c4 10             	add    $0x10,%esp

			//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
			freeFrames = (int)sys_calculate_free_frames() ;
f0117a19:	e8 57 60 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117a1e:	89 45 ec             	mov    %eax,-0x14(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117a21:	e8 e3 ce fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117a26:	89 45 e8             	mov    %eax,-0x18(%ebp)
			kfree(ptr_allocations[3]);
f0117a29:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117a2c:	83 ec 0c             	sub    $0xc,%esp
f0117a2f:	50                   	push   %eax
f0117a30:	e8 68 15 ff ff       	call   f0108f9d <kfree>
f0117a35:	83 c4 10             	add    $0x10,%esp
			if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("16 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117a38:	e8 cc ce fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117a3d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117a40:	74 17                	je     f0117a59 <test_kmalloc_firstfit2+0x7fc>
f0117a42:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a49:	83 ec 0c             	sub    $0xc,%esp
f0117a4c:	68 70 b0 12 f0       	push   $0xf012b070
f0117a51:	e8 35 95 fe ff       	call   f0100f8b <cprintf>
f0117a56:	83 c4 10             	add    $0x10,%esp
			if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("16 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0117a59:	e8 17 60 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117a5e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0117a61:	74 17                	je     f0117a7a <test_kmalloc_firstfit2+0x81d>
f0117a63:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117a6a:	83 ec 0c             	sub    $0xc,%esp
f0117a6d:	68 d4 b5 12 f0       	push   $0xf012b5d4
f0117a72:	e8 14 95 fe ff       	call   f0100f8b <cprintf>
f0117a77:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=10 ;
f0117a7a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117a7e:	74 04                	je     f0117a84 <test_kmalloc_firstfit2+0x827>
f0117a80:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	/*[1] FF: BLOCK ALLOCATOR PART*/
	cprintf("\n3. [BLOCK ALLOCATOR] Test First Fit Strategy [35%]\n");
f0117a84:	83 ec 0c             	sub    $0xc,%esp
f0117a87:	68 34 b6 12 f0       	push   $0xf012b634
f0117a8c:	e8 fa 94 fe ff       	call   f0100f8b <cprintf>
f0117a91:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0117a94:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//2 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117a9b:	e8 d5 5f ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117aa0:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117aa3:	e8 61 ce fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117aa8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*kilo);
f0117aab:	83 ec 0c             	sub    $0xc,%esp
f0117aae:	68 00 08 00 00       	push   $0x800
f0117ab3:	e8 78 13 ff ff       	call   f0108e30 <kmalloc>
f0117ab8:	83 c4 10             	add    $0x10,%esp
f0117abb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (ptr_allocations[11] != ptr_allocations[2])
f0117abe:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0117ac1:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0117ac4:	39 c2                	cmp    %eax,%edx
f0117ac6:	74 17                	je     f0117adf <test_kmalloc_firstfit2+0x882>
		{ correct = 0; cprintf("17 Wrong start address for the allocated space... \n"); }
f0117ac8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117acf:	83 ec 0c             	sub    $0xc,%esp
f0117ad2:	68 6c b6 12 f0       	push   $0xf012b66c
f0117ad7:	e8 af 94 fe ff       	call   f0100f8b <cprintf>
f0117adc:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("17 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117adf:	e8 25 ce fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117ae4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ae7:	74 17                	je     f0117b00 <test_kmalloc_firstfit2+0x8a3>
f0117ae9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117af0:	83 ec 0c             	sub    $0xc,%esp
f0117af3:	68 b4 a6 12 f0       	push   $0xf012a6b4
f0117af8:	e8 8e 94 fe ff       	call   f0100f8b <cprintf>
f0117afd:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("17 Wrong allocation: \n"); }
f0117b00:	e8 70 5f ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117b05:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0117b08:	74 17                	je     f0117b21 <test_kmalloc_firstfit2+0x8c4>
f0117b0a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b11:	83 ec 0c             	sub    $0xc,%esp
f0117b14:	68 a0 b6 12 f0       	push   $0xf012b6a0
f0117b19:	e8 6d 94 fe ff       	call   f0100f8b <cprintf>
f0117b1e:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117b21:	e8 4f 5f ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117b26:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117b29:	e8 db cd fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117b2e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f0117b31:	83 ec 0c             	sub    $0xc,%esp
f0117b34:	68 00 04 00 00       	push   $0x400
f0117b39:	e8 f2 12 ff ff       	call   f0108e30 <kmalloc>
f0117b3e:	83 c4 10             	add    $0x10,%esp
f0117b41:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (ptr_allocations[12] != ptr_allocations[2] + 2*kilo + 2*sizeof(int) /*footer & next header*/)
f0117b44:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0117b47:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0117b4a:	81 c2 08 08 00 00    	add    $0x808,%edx
f0117b50:	39 d0                	cmp    %edx,%eax
f0117b52:	74 17                	je     f0117b6b <test_kmalloc_firstfit2+0x90e>
		{ correct = 0; cprintf("18 Wrong start address for the allocated space... \n"); }
f0117b54:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b5b:	83 ec 0c             	sub    $0xc,%esp
f0117b5e:	68 b8 b6 12 f0       	push   $0xf012b6b8
f0117b63:	e8 23 94 fe ff       	call   f0100f8b <cprintf>
f0117b68:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("18 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117b6b:	e8 99 cd fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117b70:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117b73:	74 17                	je     f0117b8c <test_kmalloc_firstfit2+0x92f>
f0117b75:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b7c:	83 ec 0c             	sub    $0xc,%esp
f0117b7f:	68 7c a7 12 f0       	push   $0xf012a77c
f0117b84:	e8 02 94 fe ff       	call   f0100f8b <cprintf>
f0117b89:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("18 Wrong allocation: \n"); }
f0117b8c:	e8 e4 5e ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117b91:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0117b94:	74 17                	je     f0117bad <test_kmalloc_firstfit2+0x950>
f0117b96:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117b9d:	83 ec 0c             	sub    $0xc,%esp
f0117ba0:	68 ec b6 12 f0       	push   $0xf012b6ec
f0117ba5:	e8 e1 93 fe ff       	call   f0100f8b <cprintf>
f0117baa:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f0117bad:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117bb1:	74 04                	je     f0117bb7 <test_kmalloc_firstfit2+0x95a>
f0117bb3:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	/*[2] FF: PAGE ALLOCATOR PART*/
	cprintf("\n4. [PAGE ALLOCATOR] Test First Fit Strategy [35%]\n");
f0117bb7:	83 ec 0c             	sub    $0xc,%esp
f0117bba:	68 04 b7 12 f0       	push   $0xf012b704
f0117bbf:	e8 c7 93 fe ff       	call   f0100f8b <cprintf>
f0117bc4:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
f0117bc7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117bce:	e8 a2 5e ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117bd3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117bd6:	e8 2e cd fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117bdb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f0117bde:	83 ec 0c             	sub    $0xc,%esp
f0117be1:	68 00 04 70 00       	push   $0x700400
f0117be6:	e8 45 12 ff ff       	call   f0108e30 <kmalloc>
f0117beb:	83 c4 10             	add    $0x10,%esp
f0117bee:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("19 Wrong start address for the allocated space... \n"); }
f0117bf1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117bf4:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0117bf9:	74 17                	je     f0117c12 <test_kmalloc_firstfit2+0x9b5>
f0117bfb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c02:	83 ec 0c             	sub    $0xc,%esp
f0117c05:	68 8c b1 12 f0       	push   $0xf012b18c
f0117c0a:	e8 7c 93 fe ff       	call   f0100f8b <cprintf>
f0117c0f:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("19 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117c12:	e8 f2 cc fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117c17:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117c1a:	74 17                	je     f0117c33 <test_kmalloc_firstfit2+0x9d6>
f0117c1c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c23:	83 ec 0c             	sub    $0xc,%esp
f0117c26:	68 c0 b1 12 f0       	push   $0xf012b1c0
f0117c2b:	e8 5b 93 fe ff       	call   f0100f8b <cprintf>
f0117c30:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("19 Wrong allocation: \n"); }
f0117c33:	e8 3d 5e ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117c38:	89 c2                	mov    %eax,%edx
f0117c3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117c3d:	29 d0                	sub    %edx,%eax
f0117c3f:	3d 00 07 00 00       	cmp    $0x700,%eax
f0117c44:	7f 17                	jg     f0117c5d <test_kmalloc_firstfit2+0xa00>
f0117c46:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c4d:	83 ec 0c             	sub    $0xc,%esp
f0117c50:	68 2c b2 12 f0       	push   $0xf012b22c
f0117c55:	e8 31 93 fe ff       	call   f0100f8b <cprintf>
f0117c5a:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0117c5d:	e8 13 5e ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117c62:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0117c65:	e8 9f cc fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117c6a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f0117c6d:	83 ec 0c             	sub    $0xc,%esp
f0117c70:	68 00 0c 00 00       	push   $0xc00
f0117c75:	e8 b6 11 ff ff       	call   f0108e30 <kmalloc>
f0117c7a:	83 c4 10             	add    $0x10,%esp
f0117c7d:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("20 Wrong start address for the allocated space... \n"); }
f0117c80:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117c83:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f0117c88:	74 17                	je     f0117ca1 <test_kmalloc_firstfit2+0xa44>
f0117c8a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117c91:	83 ec 0c             	sub    $0xc,%esp
f0117c94:	68 38 b7 12 f0       	push   $0xf012b738
f0117c99:	e8 ed 92 fe ff       	call   f0100f8b <cprintf>
f0117c9e:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("20 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0117ca1:	e8 63 cc fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117ca6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ca9:	74 17                	je     f0117cc2 <test_kmalloc_firstfit2+0xa65>
f0117cab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cb2:	83 ec 0c             	sub    $0xc,%esp
f0117cb5:	68 6c b7 12 f0       	push   $0xf012b76c
f0117cba:	e8 cc 92 fe ff       	call   f0100f8b <cprintf>
f0117cbf:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("20 Wrong allocation: \n"); }
f0117cc2:	e8 ae 5d ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117cc7:	89 c2                	mov    %eax,%edx
f0117cc9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117ccc:	29 d0                	sub    %edx,%eax
f0117cce:	85 c0                	test   %eax,%eax
f0117cd0:	7f 17                	jg     f0117ce9 <test_kmalloc_firstfit2+0xa8c>
f0117cd2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117cd9:	83 ec 0c             	sub    $0xc,%esp
f0117cdc:	68 d8 b7 12 f0       	push   $0xf012b7d8
f0117ce1:	e8 a5 92 fe ff       	call   f0100f8b <cprintf>
f0117ce6:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f0117ce9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117ced:	74 04                	je     f0117cf3 <test_kmalloc_firstfit2+0xa96>
f0117cef:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)


	correct = 1 ;
f0117cf3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	cprintf("\n5. Attempt to allocate large segment with no suitable fragment to fit on [10%]\n");
f0117cfa:	83 ec 0c             	sub    $0xc,%esp
f0117cfd:	68 f0 b7 12 f0       	push   $0xf012b7f0
f0117d02:	e8 84 92 fe ff       	call   f0100f8b <cprintf>
f0117d07:	83 c4 10             	add    $0x10,%esp
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f0117d0a:	83 ec 0c             	sub    $0xc,%esp
f0117d0d:	68 00 e0 1f 07       	push   $0x71fe000
f0117d12:	e8 19 11 ff ff       	call   f0108e30 <kmalloc>
f0117d17:	83 c4 10             	add    $0x10,%esp
f0117d1a:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("21 Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f0117d1d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117d20:	85 c0                	test   %eax,%eax
f0117d22:	74 17                	je     f0117d3b <test_kmalloc_firstfit2+0xade>
f0117d24:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117d2b:	83 ec 0c             	sub    $0xc,%esp
f0117d2e:	68 44 b8 12 f0       	push   $0xf012b844
f0117d33:	e8 53 92 fe ff       	call   f0100f8b <cprintf>
f0117d38:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f0117d3b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0117d3f:	74 04                	je     f0117d45 <test_kmalloc_firstfit2+0xae8>
f0117d41:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f0117d45:	83 ec 08             	sub    $0x8,%esp
f0117d48:	ff 75 f4             	pushl  -0xc(%ebp)
f0117d4b:	68 ac b8 12 f0       	push   $0xf012b8ac
f0117d50:	e8 36 92 fe ff       	call   f0100f8b <cprintf>
f0117d55:	83 c4 10             	add    $0x10,%esp

	return 1;
f0117d58:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0117d5d:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0117d60:	5b                   	pop    %ebx
f0117d61:	5f                   	pop    %edi
f0117d62:	5d                   	pop    %ebp
f0117d63:	c3                   	ret    

f0117d64 <test_fastfirstfit>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fastfirstfit()
{
f0117d64:	55                   	push   %ebp
f0117d65:	89 e5                	mov    %esp,%ebp
f0117d67:	53                   	push   %ebx
f0117d68:	83 ec 44             	sub    $0x44,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0117d6b:	83 ec 0c             	sub    $0xc,%esp
f0117d6e:	68 08 9a 12 f0       	push   $0xf0129a08
f0117d73:	e8 13 92 fe ff       	call   f0100f8b <cprintf>
f0117d78:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0117d7b:	83 ec 0c             	sub    $0xc,%esp
f0117d7e:	68 38 9a 12 f0       	push   $0xf0129a38
f0117d83:	e8 03 92 fe ff       	call   f0100f8b <cprintf>
f0117d88:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0117d8b:	83 ec 0c             	sub    $0xc,%esp
f0117d8e:	68 08 9a 12 f0       	push   $0xf0129a08
f0117d93:	e8 f3 91 fe ff       	call   f0100f8b <cprintf>
f0117d98:	83 c4 10             	add    $0x10,%esp

	// allocate pages
	int freeFrames = sys_calculate_free_frames() ;
f0117d9b:	e8 d5 5c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117da0:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int freeDiskFrames = pf_calculate_free_frames() ;
f0117da3:	e8 61 cb fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117da8:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32 allocSize = 8*kilo;
f0117dab:	c7 45 e4 00 20 00 00 	movl   $0x2000,-0x1c(%ebp)
	int i;
	cprintf("\n1\n");
f0117db2:	83 ec 0c             	sub    $0xc,%esp
f0117db5:	68 e1 b8 12 f0       	push   $0xf012b8e1
f0117dba:	e8 cc 91 fe ff       	call   f0100f8b <cprintf>
f0117dbf:	83 c4 10             	add    $0x10,%esp
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
f0117dc2:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0117dc7:	ba 00 00 00 00       	mov    $0x0,%edx
f0117dcc:	f7 75 e4             	divl   -0x1c(%ebp)
f0117dcf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for(i = 0; i < numOf2MAllocs ;i++)
f0117dd2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0117dd9:	eb 1d                	jmp    f0117df8 <test_fastfirstfit+0x94>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
f0117ddb:	83 ec 0c             	sub    $0xc,%esp
f0117dde:	ff 75 e4             	pushl  -0x1c(%ebp)
f0117de1:	e8 4a 10 ff ff       	call   f0108e30 <kmalloc>
f0117de6:	83 c4 10             	add    $0x10,%esp
f0117de9:	89 c2                	mov    %eax,%edx
f0117deb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117dee:	89 14 85 00 42 5c f0 	mov    %edx,-0xfa3be00(,%eax,4)
	uint32 allocSize = 8*kilo;
	int i;
	cprintf("\n1\n");
	//ptr_allocations[0] = kmalloc(2*Mega - KERNEL_SHARES_ARR_INIT_SIZE - KERNEL_SEMAPHORES_ARR_INIT_SIZE);
	int numOf2MAllocs = (KERNEL_HEAP_MAX - ACTUAL_START) / allocSize;
	for(i = 0; i < numOf2MAllocs ;i++)
f0117df5:	ff 45 f4             	incl   -0xc(%ebp)
f0117df8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117dfb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0117dfe:	7c db                	jl     f0117ddb <test_fastfirstfit+0x77>
	{
		ptr_fast_allocations[i] = kmalloc(allocSize);
	}
	cprintf("\n2\n");
f0117e00:	83 ec 0c             	sub    $0xc,%esp
f0117e03:	68 e5 b8 12 f0       	push   $0xf012b8e5
f0117e08:	e8 7e 91 fe ff       	call   f0100f8b <cprintf>
f0117e0d:	83 c4 10             	add    $0x10,%esp

	uint32 remainSpace = (KERNEL_HEAP_MAX - ACTUAL_START) % allocSize;
f0117e10:	b8 00 e0 ff 07       	mov    $0x7ffe000,%eax
f0117e15:	ba 00 00 00 00       	mov    $0x0,%edx
f0117e1a:	f7 75 e4             	divl   -0x1c(%ebp)
f0117e1d:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (remainSpace != 0)
f0117e20:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117e24:	74 1e                	je     f0117e44 <test_fastfirstfit+0xe0>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
f0117e26:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0117e29:	8d 43 01             	lea    0x1(%ebx),%eax
f0117e2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0117e2f:	83 ec 0c             	sub    $0xc,%esp
f0117e32:	ff 75 e0             	pushl  -0x20(%ebp)
f0117e35:	e8 f6 0f ff ff       	call   f0108e30 <kmalloc>
f0117e3a:	83 c4 10             	add    $0x10,%esp
f0117e3d:	89 04 9d 00 42 5c f0 	mov    %eax,-0xfa3be00(,%ebx,4)
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
f0117e44:	83 ec 04             	sub    $0x4,%esp
f0117e47:	ff 75 f0             	pushl  -0x10(%ebp)
f0117e4a:	ff 75 e4             	pushl  -0x1c(%ebp)
f0117e4d:	68 ec b8 12 f0       	push   $0xf012b8ec
f0117e52:	e8 34 91 fe ff       	call   f0100f8b <cprintf>
f0117e57:	83 c4 10             	add    $0x10,%esp
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0117e5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0117e61:	eb 36                	jmp    f0117e99 <test_fastfirstfit+0x135>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
f0117e63:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117e66:	8b 04 85 00 42 5c f0 	mov    -0xfa3be00(,%eax,4),%eax
f0117e6d:	89 c2                	mov    %eax,%edx
f0117e6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117e72:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0117e76:	2d 00 f0 ff 07       	sub    $0x7fff000,%eax
f0117e7b:	39 c2                	cmp    %eax,%edx
f0117e7d:	74 17                	je     f0117e96 <test_fastfirstfit+0x132>
			panic("Wrong allocation, Check next fitting strategy is working correctly");
f0117e7f:	83 ec 04             	sub    $0x4,%esp
f0117e82:	68 34 b9 12 f0       	push   $0xf012b934
f0117e87:	68 f0 02 00 00       	push   $0x2f0
f0117e8c:	68 77 b9 12 f0       	push   $0xf012b977
f0117e91:	e8 a3 84 fe ff       	call   f0100339 <_panic>
	{
		ptr_fast_allocations[numOf2MAllocs++] = kmalloc(remainSpace);
	}
	cprintf("\nNumber of %x size allocations to fill the page allocator area = %d\n",allocSize, numOf2MAllocs);
	// check the addresses of the allocation
	for(i = 0; i < numOf2MAllocs ;i++)
f0117e96:	ff 45 f4             	incl   -0xc(%ebp)
f0117e99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117e9c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0117e9f:	7c c2                	jl     f0117e63 <test_fastfirstfit+0xff>
	{
		if((uint32)ptr_fast_allocations[i] != ACTUAL_START + i*allocSize)
			panic("Wrong allocation, Check next fitting strategy is working correctly");
	}

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0117ea1:	e8 63 ca fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117ea6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117ea9:	74 17                	je     f0117ec2 <test_fastfirstfit+0x15e>
f0117eab:	83 ec 04             	sub    $0x4,%esp
f0117eae:	68 90 b9 12 f0       	push   $0xf012b990
f0117eb3:	68 f3 02 00 00       	push   $0x2f3
f0117eb8:	68 77 b9 12 f0       	push   $0xf012b977
f0117ebd:	e8 77 84 fe ff       	call   f0100339 <_panic>
	if ((freeFrames - sys_calculate_free_frames()) < (KERNEL_HEAP_MAX - ACTUAL_START)/(PAGE_SIZE) ) panic("Wrong allocation");
f0117ec2:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0117ec5:	e8 ab 5b ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117eca:	29 c3                	sub    %eax,%ebx
f0117ecc:	89 d8                	mov    %ebx,%eax
f0117ece:	3d fd 7f 00 00       	cmp    $0x7ffd,%eax
f0117ed3:	77 17                	ja     f0117eec <test_fastfirstfit+0x188>
f0117ed5:	83 ec 04             	sub    $0x4,%esp
f0117ed8:	68 f8 b9 12 f0       	push   $0xf012b9f8
f0117edd:	68 f4 02 00 00       	push   $0x2f4
f0117ee2:	68 77 b9 12 f0       	push   $0xf012b977
f0117ee7:	e8 4d 84 fe ff       	call   f0100339 <_panic>

	// Make memory holes.
	freeDiskFrames = pf_calculate_free_frames() ;
f0117eec:	e8 18 ca fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117ef1:	89 45 e8             	mov    %eax,-0x18(%ebp)
	freeFrames = sys_calculate_free_frames() ;
f0117ef4:	e8 7c 5b ff ff       	call   f010da75 <sys_calculate_free_frames>
f0117ef9:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if (numOf2MAllocs < 30)
f0117efc:	83 7d f0 1d          	cmpl   $0x1d,-0x10(%ebp)
f0117f00:	7f 17                	jg     f0117f19 <test_fastfirstfit+0x1b5>
		panic("unexpcected number of allocations! PLEASE REVISE THE STAFF");
f0117f02:	83 ec 04             	sub    $0x4,%esp
f0117f05:	68 0c ba 12 f0       	push   $0xf012ba0c
f0117f0a:	68 fb 02 00 00       	push   $0x2fb
f0117f0f:	68 77 b9 12 f0       	push   $0xf012b977
f0117f14:	e8 20 84 fe ff       	call   f0100339 <_panic>
	kfree(ptr_fast_allocations[0]);		// Hole 1 = allocSize
f0117f19:	a1 00 42 5c f0       	mov    0xf05c4200,%eax
f0117f1e:	83 ec 0c             	sub    $0xc,%esp
f0117f21:	50                   	push   %eax
f0117f22:	e8 76 10 ff ff       	call   f0108f9d <kfree>
f0117f27:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[2]);		// Hole 2 = 2*allocSize
f0117f2a:	a1 08 42 5c f0       	mov    0xf05c4208,%eax
f0117f2f:	83 ec 0c             	sub    $0xc,%esp
f0117f32:	50                   	push   %eax
f0117f33:	e8 65 10 ff ff       	call   f0108f9d <kfree>
f0117f38:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[3]);
f0117f3b:	a1 0c 42 5c f0       	mov    0xf05c420c,%eax
f0117f40:	83 ec 0c             	sub    $0xc,%esp
f0117f43:	50                   	push   %eax
f0117f44:	e8 54 10 ff ff       	call   f0108f9d <kfree>
f0117f49:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[5]);		// Hole 3 = allocSize
f0117f4c:	a1 14 42 5c f0       	mov    0xf05c4214,%eax
f0117f51:	83 ec 0c             	sub    $0xc,%esp
f0117f54:	50                   	push   %eax
f0117f55:	e8 43 10 ff ff       	call   f0108f9d <kfree>
f0117f5a:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[10]);		// Hole 4 = 3*allocSize
f0117f5d:	a1 28 42 5c f0       	mov    0xf05c4228,%eax
f0117f62:	83 ec 0c             	sub    $0xc,%esp
f0117f65:	50                   	push   %eax
f0117f66:	e8 32 10 ff ff       	call   f0108f9d <kfree>
f0117f6b:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[12]);
f0117f6e:	a1 30 42 5c f0       	mov    0xf05c4230,%eax
f0117f73:	83 ec 0c             	sub    $0xc,%esp
f0117f76:	50                   	push   %eax
f0117f77:	e8 21 10 ff ff       	call   f0108f9d <kfree>
f0117f7c:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[11]);
f0117f7f:	a1 2c 42 5c f0       	mov    0xf05c422c,%eax
f0117f84:	83 ec 0c             	sub    $0xc,%esp
f0117f87:	50                   	push   %eax
f0117f88:	e8 10 10 ff ff       	call   f0108f9d <kfree>
f0117f8d:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[20]);		// Hole 5 = allocSize
f0117f90:	a1 50 42 5c f0       	mov    0xf05c4250,%eax
f0117f95:	83 ec 0c             	sub    $0xc,%esp
f0117f98:	50                   	push   %eax
f0117f99:	e8 ff 0f ff ff       	call   f0108f9d <kfree>
f0117f9e:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[25]);		// Hole 6 = allocSize
f0117fa1:	a1 64 42 5c f0       	mov    0xf05c4264,%eax
f0117fa6:	83 ec 0c             	sub    $0xc,%esp
f0117fa9:	50                   	push   %eax
f0117faa:	e8 ee 0f ff ff       	call   f0108f9d <kfree>
f0117faf:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-2]);		// Last Hole 7 = 2*allocSize
f0117fb2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117fb5:	83 e8 02             	sub    $0x2,%eax
f0117fb8:	8b 04 85 00 42 5c f0 	mov    -0xfa3be00(,%eax,4),%eax
f0117fbf:	83 ec 0c             	sub    $0xc,%esp
f0117fc2:	50                   	push   %eax
f0117fc3:	e8 d5 0f ff ff       	call   f0108f9d <kfree>
f0117fc8:	83 c4 10             	add    $0x10,%esp
	kfree(ptr_fast_allocations[numOf2MAllocs-3]);
f0117fcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117fce:	83 e8 03             	sub    $0x3,%eax
f0117fd1:	8b 04 85 00 42 5c f0 	mov    -0xfa3be00(,%eax,4),%eax
f0117fd8:	83 ec 0c             	sub    $0xc,%esp
f0117fdb:	50                   	push   %eax
f0117fdc:	e8 bc 0f ff ff       	call   f0108f9d <kfree>
f0117fe1:	83 c4 10             	add    $0x10,%esp

	if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0117fe4:	e8 20 c9 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0117fe9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117fec:	74 17                	je     f0118005 <test_fastfirstfit+0x2a1>
f0117fee:	83 ec 04             	sub    $0x4,%esp
f0117ff1:	68 90 b9 12 f0       	push   $0xf012b990
f0117ff6:	68 08 03 00 00       	push   $0x308
f0117ffb:	68 77 b9 12 f0       	push   $0xf012b977
f0118000:	e8 34 83 fe ff       	call   f0100339 <_panic>
	if ((sys_calculate_free_frames() - freeFrames) != (11*allocSize)/PAGE_SIZE) panic("Wrong free: Extra or less pages are removed from main memory");
f0118005:	e8 6b 5a ff ff       	call   f010da75 <sys_calculate_free_frames>
f011800a:	89 c2                	mov    %eax,%edx
f011800c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011800f:	89 d1                	mov    %edx,%ecx
f0118011:	29 c1                	sub    %eax,%ecx
f0118013:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118016:	89 d0                	mov    %edx,%eax
f0118018:	c1 e0 02             	shl    $0x2,%eax
f011801b:	01 d0                	add    %edx,%eax
f011801d:	01 c0                	add    %eax,%eax
f011801f:	01 d0                	add    %edx,%eax
f0118021:	c1 e8 0c             	shr    $0xc,%eax
f0118024:	39 c1                	cmp    %eax,%ecx
f0118026:	74 17                	je     f011803f <test_fastfirstfit+0x2db>
f0118028:	83 ec 04             	sub    $0x4,%esp
f011802b:	68 48 ba 12 f0       	push   $0xf012ba48
f0118030:	68 09 03 00 00       	push   $0x309
f0118035:	68 77 b9 12 f0       	push   $0xf012b977
f011803a:	e8 fa 82 fe ff       	call   f0100339 <_panic>

	uint32 desiredSize;
	// Test first fit
	//2.5 x allocSize in Hole 4 -> Hole 4 becomes 0.5 allocSize
	{
		desiredSize = 2*allocSize + allocSize/2 ;
f011803f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118042:	01 c0                	add    %eax,%eax
f0118044:	89 c2                	mov    %eax,%edx
f0118046:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118049:	d1 e8                	shr    %eax
f011804b:	01 d0                	add    %edx,%eax
f011804d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118050:	e8 b4 c8 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118055:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118058:	e8 18 5a ff ff       	call   f010da75 <sys_calculate_free_frames>
f011805d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118060:	83 ec 0c             	sub    $0xc,%esp
f0118063:	ff 75 dc             	pushl  -0x24(%ebp)
f0118066:	e8 c5 0d ff ff       	call   f0108e30 <kmalloc>
f011806b:	83 c4 10             	add    $0x10,%esp
f011806e:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize)
f0118071:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0118074:	89 d0                	mov    %edx,%eax
f0118076:	c1 e0 02             	shl    $0x2,%eax
f0118079:	01 d0                	add    %edx,%eax
f011807b:	01 c0                	add    %eax,%eax
f011807d:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118083:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0118086:	39 c2                	cmp    %eax,%edx
f0118088:	74 17                	je     f01180a1 <test_fastfirstfit+0x33d>
			panic("First Fit not working correctly");
f011808a:	83 ec 04             	sub    $0x4,%esp
f011808d:	68 88 ba 12 f0       	push   $0xf012ba88
f0118092:	68 14 03 00 00       	push   $0x314
f0118097:	68 77 b9 12 f0       	push   $0xf012b977
f011809c:	e8 98 82 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01180a1:	e8 63 c8 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01180a6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01180a9:	74 17                	je     f01180c2 <test_fastfirstfit+0x35e>
f01180ab:	83 ec 04             	sub    $0x4,%esp
f01180ae:	68 90 b9 12 f0       	push   $0xf012b990
f01180b3:	68 15 03 00 00       	push   $0x315
f01180b8:	68 77 b9 12 f0       	push   $0xf012b977
f01180bd:	e8 77 82 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01180c2:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01180c5:	e8 ab 59 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01180ca:	29 c3                	sub    %eax,%ebx
f01180cc:	89 da                	mov    %ebx,%edx
f01180ce:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01180d1:	c1 e8 0c             	shr    $0xc,%eax
f01180d4:	39 c2                	cmp    %eax,%edx
f01180d6:	73 17                	jae    f01180ef <test_fastfirstfit+0x38b>
f01180d8:	83 ec 04             	sub    $0x4,%esp
f01180db:	68 f8 b9 12 f0       	push   $0xf012b9f8
f01180e0:	68 16 03 00 00       	push   $0x316
f01180e5:	68 77 b9 12 f0       	push   $0xf012b977
f01180ea:	e8 4a 82 fe ff       	call   f0100339 <_panic>
	}

	//2 x allocSize in Hole 2 -> Hole 2 becomes 0
	{
		desiredSize = 2*allocSize ;
f01180ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01180f2:	01 c0                	add    %eax,%eax
f01180f4:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01180f7:	e8 0d c8 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01180fc:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01180ff:	e8 71 59 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118104:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f0118107:	83 ec 0c             	sub    $0xc,%esp
f011810a:	ff 75 dc             	pushl  -0x24(%ebp)
f011810d:	e8 1e 0d ff ff       	call   f0108e30 <kmalloc>
f0118112:	83 c4 10             	add    $0x10,%esp
f0118115:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 2*allocSize)
f0118118:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011811b:	05 00 08 00 7c       	add    $0x7c000800,%eax
f0118120:	01 c0                	add    %eax,%eax
f0118122:	89 c2                	mov    %eax,%edx
f0118124:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0118127:	39 c2                	cmp    %eax,%edx
f0118129:	74 17                	je     f0118142 <test_fastfirstfit+0x3de>
			panic("First Fit not working correctly");
f011812b:	83 ec 04             	sub    $0x4,%esp
f011812e:	68 88 ba 12 f0       	push   $0xf012ba88
f0118133:	68 20 03 00 00       	push   $0x320
f0118138:	68 77 b9 12 f0       	push   $0xf012b977
f011813d:	e8 f7 81 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118142:	e8 c2 c7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118147:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011814a:	74 17                	je     f0118163 <test_fastfirstfit+0x3ff>
f011814c:	83 ec 04             	sub    $0x4,%esp
f011814f:	68 90 b9 12 f0       	push   $0xf012b990
f0118154:	68 21 03 00 00       	push   $0x321
f0118159:	68 77 b9 12 f0       	push   $0xf012b977
f011815e:	e8 d6 81 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118163:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118166:	e8 0a 59 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011816b:	29 c3                	sub    %eax,%ebx
f011816d:	89 da                	mov    %ebx,%edx
f011816f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118172:	c1 e8 0c             	shr    $0xc,%eax
f0118175:	39 c2                	cmp    %eax,%edx
f0118177:	73 17                	jae    f0118190 <test_fastfirstfit+0x42c>
f0118179:	83 ec 04             	sub    $0x4,%esp
f011817c:	68 f8 b9 12 f0       	push   $0xf012b9f8
f0118181:	68 22 03 00 00       	push   $0x322
f0118186:	68 77 b9 12 f0       	push   $0xf012b977
f011818b:	e8 a9 81 fe ff       	call   f0100339 <_panic>
	}

	//1.5 x allocSize in Hole 7 -> Hole 7 becomes 0.5 x allocSize
	{
		desiredSize = 3*allocSize/2 ;
f0118190:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118193:	89 c2                	mov    %eax,%edx
f0118195:	01 d2                	add    %edx,%edx
f0118197:	01 d0                	add    %edx,%eax
f0118199:	d1 e8                	shr    %eax
f011819b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011819e:	e8 66 c7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01181a3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01181a6:	e8 ca 58 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01181ab:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01181ae:	83 ec 0c             	sub    $0xc,%esp
f01181b1:	ff 75 dc             	pushl  -0x24(%ebp)
f01181b4:	e8 77 0c ff ff       	call   f0108e30 <kmalloc>
f01181b9:	83 c4 10             	add    $0x10,%esp
f01181bc:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize)
f01181bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01181c2:	83 e8 03             	sub    $0x3,%eax
f01181c5:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f01181c9:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01181cf:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01181d2:	39 c2                	cmp    %eax,%edx
f01181d4:	74 17                	je     f01181ed <test_fastfirstfit+0x489>
			panic("First Fit not working correctly");
f01181d6:	83 ec 04             	sub    $0x4,%esp
f01181d9:	68 88 ba 12 f0       	push   $0xf012ba88
f01181de:	68 2c 03 00 00       	push   $0x32c
f01181e3:	68 77 b9 12 f0       	push   $0xf012b977
f01181e8:	e8 4c 81 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01181ed:	e8 17 c7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01181f2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01181f5:	74 17                	je     f011820e <test_fastfirstfit+0x4aa>
f01181f7:	83 ec 04             	sub    $0x4,%esp
f01181fa:	68 90 b9 12 f0       	push   $0xf012b990
f01181ff:	68 2d 03 00 00       	push   $0x32d
f0118204:	68 77 b9 12 f0       	push   $0xf012b977
f0118209:	e8 2b 81 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f011820e:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118211:	e8 5f 58 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118216:	29 c3                	sub    %eax,%ebx
f0118218:	89 da                	mov    %ebx,%edx
f011821a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011821d:	c1 e8 0c             	shr    $0xc,%eax
f0118220:	39 c2                	cmp    %eax,%edx
f0118222:	73 17                	jae    f011823b <test_fastfirstfit+0x4d7>
f0118224:	83 ec 04             	sub    $0x4,%esp
f0118227:	68 f8 b9 12 f0       	push   $0xf012b9f8
f011822c:	68 2e 03 00 00       	push   $0x32e
f0118231:	68 77 b9 12 f0       	push   $0xf012b977
f0118236:	e8 fe 80 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 1 -> Hole 1 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f011823b:	e8 c9 c6 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118240:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118243:	e8 2d 58 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118248:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f011824b:	83 ec 0c             	sub    $0xc,%esp
f011824e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118251:	e8 da 0b ff ff       	call   f0108e30 <kmalloc>
f0118256:	83 c4 10             	add    $0x10,%esp
f0118259:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 0*allocSize)
f011825c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011825f:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118264:	74 17                	je     f011827d <test_fastfirstfit+0x519>
			panic("First Fit not working correctly");
f0118266:	83 ec 04             	sub    $0x4,%esp
f0118269:	68 88 ba 12 f0       	push   $0xf012ba88
f011826e:	68 37 03 00 00       	push   $0x337
f0118273:	68 77 b9 12 f0       	push   $0xf012b977
f0118278:	e8 bc 80 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011827d:	e8 87 c6 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118282:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118285:	74 17                	je     f011829e <test_fastfirstfit+0x53a>
f0118287:	83 ec 04             	sub    $0x4,%esp
f011828a:	68 90 b9 12 f0       	push   $0xf012b990
f011828f:	68 38 03 00 00       	push   $0x338
f0118294:	68 77 b9 12 f0       	push   $0xf012b977
f0118299:	e8 9b 80 fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f011829e:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01182a1:	e8 cf 57 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01182a6:	29 c3                	sub    %eax,%ebx
f01182a8:	89 da                	mov    %ebx,%edx
f01182aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01182ad:	c1 e8 0c             	shr    $0xc,%eax
f01182b0:	39 c2                	cmp    %eax,%edx
f01182b2:	73 17                	jae    f01182cb <test_fastfirstfit+0x567>
f01182b4:	83 ec 04             	sub    $0x4,%esp
f01182b7:	68 f8 b9 12 f0       	push   $0xf012b9f8
f01182bc:	68 39 03 00 00       	push   $0x339
f01182c1:	68 77 b9 12 f0       	push   $0xf012b977
f01182c6:	e8 6e 80 fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 3 -> Hole 3 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f01182cb:	e8 39 c6 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01182d0:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01182d3:	e8 9d 57 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01182d8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f01182db:	83 ec 0c             	sub    $0xc,%esp
f01182de:	ff 75 e4             	pushl  -0x1c(%ebp)
f01182e1:	e8 4a 0b ff ff       	call   f0108e30 <kmalloc>
f01182e6:	83 c4 10             	add    $0x10,%esp
f01182e9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 5*allocSize)
f01182ec:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01182ef:	89 d0                	mov    %edx,%eax
f01182f1:	c1 e0 02             	shl    $0x2,%eax
f01182f4:	01 d0                	add    %edx,%eax
f01182f6:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01182fc:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01182ff:	39 c2                	cmp    %eax,%edx
f0118301:	74 17                	je     f011831a <test_fastfirstfit+0x5b6>
			panic("First Fit not working correctly");
f0118303:	83 ec 04             	sub    $0x4,%esp
f0118306:	68 88 ba 12 f0       	push   $0xf012ba88
f011830b:	68 42 03 00 00       	push   $0x342
f0118310:	68 77 b9 12 f0       	push   $0xf012b977
f0118315:	e8 1f 80 fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011831a:	e8 ea c5 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011831f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118322:	74 17                	je     f011833b <test_fastfirstfit+0x5d7>
f0118324:	83 ec 04             	sub    $0x4,%esp
f0118327:	68 90 b9 12 f0       	push   $0xf012b990
f011832c:	68 43 03 00 00       	push   $0x343
f0118331:	68 77 b9 12 f0       	push   $0xf012b977
f0118336:	e8 fe 7f fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f011833b:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011833e:	e8 32 57 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118343:	29 c3                	sub    %eax,%ebx
f0118345:	89 da                	mov    %ebx,%edx
f0118347:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011834a:	c1 e8 0c             	shr    $0xc,%eax
f011834d:	39 c2                	cmp    %eax,%edx
f011834f:	73 17                	jae    f0118368 <test_fastfirstfit+0x604>
f0118351:	83 ec 04             	sub    $0x4,%esp
f0118354:	68 f8 b9 12 f0       	push   $0xf012b9f8
f0118359:	68 44 03 00 00       	push   $0x344
f011835e:	68 77 b9 12 f0       	push   $0xf012b977
f0118363:	e8 d1 7f fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 5 -> Hole 5 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118368:	e8 9c c5 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011836d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118370:	e8 00 57 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118375:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118378:	83 ec 0c             	sub    $0xc,%esp
f011837b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011837e:	e8 ad 0a ff ff       	call   f0108e30 <kmalloc>
f0118383:	83 c4 10             	add    $0x10,%esp
f0118386:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 20*allocSize)
f0118389:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011838c:	89 d0                	mov    %edx,%eax
f011838e:	c1 e0 02             	shl    $0x2,%eax
f0118391:	01 d0                	add    %edx,%eax
f0118393:	c1 e0 02             	shl    $0x2,%eax
f0118396:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f011839c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011839f:	39 c2                	cmp    %eax,%edx
f01183a1:	74 17                	je     f01183ba <test_fastfirstfit+0x656>
			panic("First Fit not working correctly");
f01183a3:	83 ec 04             	sub    $0x4,%esp
f01183a6:	68 88 ba 12 f0       	push   $0xf012ba88
f01183ab:	68 4d 03 00 00       	push   $0x34d
f01183b0:	68 77 b9 12 f0       	push   $0xf012b977
f01183b5:	e8 7f 7f fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01183ba:	e8 4a c5 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01183bf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01183c2:	74 17                	je     f01183db <test_fastfirstfit+0x677>
f01183c4:	83 ec 04             	sub    $0x4,%esp
f01183c7:	68 90 b9 12 f0       	push   $0xf012b990
f01183cc:	68 4e 03 00 00       	push   $0x34e
f01183d1:	68 77 b9 12 f0       	push   $0xf012b977
f01183d6:	e8 5e 7f fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f01183db:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01183de:	e8 92 56 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01183e3:	29 c3                	sub    %eax,%ebx
f01183e5:	89 da                	mov    %ebx,%edx
f01183e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01183ea:	c1 e8 0c             	shr    $0xc,%eax
f01183ed:	39 c2                	cmp    %eax,%edx
f01183ef:	73 17                	jae    f0118408 <test_fastfirstfit+0x6a4>
f01183f1:	83 ec 04             	sub    $0x4,%esp
f01183f4:	68 f8 b9 12 f0       	push   $0xf012b9f8
f01183f9:	68 4f 03 00 00       	push   $0x34f
f01183fe:	68 77 b9 12 f0       	push   $0xf012b977
f0118403:	e8 31 7f fe ff       	call   f0100339 <_panic>
	}

	//allocSize in Hole 6 -> Hole 6 becomes 0 M
	{
		freeDiskFrames = pf_calculate_free_frames() ;
f0118408:	e8 fc c4 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011840d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118410:	e8 60 56 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118415:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(allocSize);
f0118418:	83 ec 0c             	sub    $0xc,%esp
f011841b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011841e:	e8 0d 0a ff ff       	call   f0108e30 <kmalloc>
f0118423:	83 c4 10             	add    $0x10,%esp
f0118426:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 25*allocSize)
f0118429:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011842c:	89 d0                	mov    %edx,%eax
f011842e:	c1 e0 02             	shl    $0x2,%eax
f0118431:	01 d0                	add    %edx,%eax
f0118433:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011843a:	01 d0                	add    %edx,%eax
f011843c:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f0118442:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118445:	39 c2                	cmp    %eax,%edx
f0118447:	74 17                	je     f0118460 <test_fastfirstfit+0x6fc>
			panic("First Fit not working correctly");
f0118449:	83 ec 04             	sub    $0x4,%esp
f011844c:	68 88 ba 12 f0       	push   $0xf012ba88
f0118451:	68 58 03 00 00       	push   $0x358
f0118456:	68 77 b9 12 f0       	push   $0xf012b977
f011845b:	e8 d9 7e fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118460:	e8 a4 c4 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118465:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118468:	74 17                	je     f0118481 <test_fastfirstfit+0x71d>
f011846a:	83 ec 04             	sub    $0x4,%esp
f011846d:	68 90 b9 12 f0       	push   $0xf012b990
f0118472:	68 59 03 00 00       	push   $0x359
f0118477:	68 77 b9 12 f0       	push   $0xf012b977
f011847c:	e8 b8 7e fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (allocSize)/PAGE_SIZE) panic("Wrong allocation");
f0118481:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0118484:	e8 ec 55 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118489:	29 c3                	sub    %eax,%ebx
f011848b:	89 da                	mov    %ebx,%edx
f011848d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118490:	c1 e8 0c             	shr    $0xc,%eax
f0118493:	39 c2                	cmp    %eax,%edx
f0118495:	73 17                	jae    f01184ae <test_fastfirstfit+0x74a>
f0118497:	83 ec 04             	sub    $0x4,%esp
f011849a:	68 f8 b9 12 f0       	push   $0xf012b9f8
f011849f:	68 5a 03 00 00       	push   $0x35a
f01184a4:	68 77 b9 12 f0       	push   $0xf012b977
f01184a9:	e8 8b 7e fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 4 -> Hole 4 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f01184ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01184b1:	d1 e8                	shr    %eax
f01184b3:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01184b6:	e8 4e c4 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01184bb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f01184be:	e8 b2 55 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01184c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f01184c6:	83 ec 0c             	sub    $0xc,%esp
f01184c9:	ff 75 dc             	pushl  -0x24(%ebp)
f01184cc:	e8 5f 09 ff ff       	call   f0108e30 <kmalloc>
f01184d1:	83 c4 10             	add    $0x10,%esp
f01184d4:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if((uint32)tempAddress != ACTUAL_START + 10*allocSize + 5*allocSize/2)
f01184d7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01184da:	89 d0                	mov    %edx,%eax
f01184dc:	c1 e0 02             	shl    $0x2,%eax
f01184df:	01 d0                	add    %edx,%eax
f01184e1:	01 c0                	add    %eax,%eax
f01184e3:	89 c1                	mov    %eax,%ecx
f01184e5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01184e8:	89 d0                	mov    %edx,%eax
f01184ea:	c1 e0 02             	shl    $0x2,%eax
f01184ed:	01 d0                	add    %edx,%eax
f01184ef:	d1 e8                	shr    %eax
f01184f1:	01 c8                	add    %ecx,%eax
f01184f3:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01184f9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01184fc:	39 c2                	cmp    %eax,%edx
f01184fe:	74 17                	je     f0118517 <test_fastfirstfit+0x7b3>
			panic("First Fit not working correctly");
f0118500:	83 ec 04             	sub    $0x4,%esp
f0118503:	68 88 ba 12 f0       	push   $0xf012ba88
f0118508:	68 64 03 00 00       	push   $0x364
f011850d:	68 77 b9 12 f0       	push   $0xf012b977
f0118512:	e8 22 7e fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0118517:	e8 ed c3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011851c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011851f:	74 17                	je     f0118538 <test_fastfirstfit+0x7d4>
f0118521:	83 ec 04             	sub    $0x4,%esp
f0118524:	68 90 b9 12 f0       	push   $0xf012b990
f0118529:	68 65 03 00 00       	push   $0x365
f011852e:	68 77 b9 12 f0       	push   $0xf012b977
f0118533:	e8 01 7e fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f0118538:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f011853b:	e8 35 55 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118540:	29 c3                	sub    %eax,%ebx
f0118542:	89 da                	mov    %ebx,%edx
f0118544:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118547:	c1 e8 0c             	shr    $0xc,%eax
f011854a:	39 c2                	cmp    %eax,%edx
f011854c:	73 17                	jae    f0118565 <test_fastfirstfit+0x801>
f011854e:	83 ec 04             	sub    $0x4,%esp
f0118551:	68 f8 b9 12 f0       	push   $0xf012b9f8
f0118556:	68 66 03 00 00       	push   $0x366
f011855b:	68 77 b9 12 f0       	push   $0xf012b977
f0118560:	e8 d4 7d fe ff       	call   f0100339 <_panic>
	}

	//0.5 x allocSize in Remaining of Hole 7 -> Hole 7 becomes 0 M
	{
		desiredSize = allocSize / 2 ;
f0118565:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118568:	d1 e8                	shr    %eax
f011856a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011856d:	e8 97 c3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118572:	89 45 e8             	mov    %eax,-0x18(%ebp)
		freeFrames = sys_calculate_free_frames() ;
f0118575:	e8 fb 54 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011857a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		void* tempAddress = kmalloc(desiredSize);
f011857d:	83 ec 0c             	sub    $0xc,%esp
f0118580:	ff 75 dc             	pushl  -0x24(%ebp)
f0118583:	e8 a8 08 ff ff       	call   f0108e30 <kmalloc>
f0118588:	83 c4 10             	add    $0x10,%esp
f011858b:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if((uint32)tempAddress != ACTUAL_START + (numOf2MAllocs-3)*allocSize + 3*allocSize/2)
f011858e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118591:	83 e8 03             	sub    $0x3,%eax
f0118594:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
f0118598:	89 c2                	mov    %eax,%edx
f011859a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011859d:	89 c1                	mov    %eax,%ecx
f011859f:	01 c9                	add    %ecx,%ecx
f01185a1:	01 c8                	add    %ecx,%eax
f01185a3:	d1 e8                	shr    %eax
f01185a5:	01 d0                	add    %edx,%eax
f01185a7:	8d 90 00 10 00 f8    	lea    -0x7fff000(%eax),%edx
f01185ad:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01185b0:	39 c2                	cmp    %eax,%edx
f01185b2:	74 17                	je     f01185cb <test_fastfirstfit+0x867>
			panic("First Fit not working correctly");
f01185b4:	83 ec 04             	sub    $0x4,%esp
f01185b7:	68 88 ba 12 f0       	push   $0xf012ba88
f01185bc:	68 70 03 00 00       	push   $0x370
f01185c1:	68 77 b9 12 f0       	push   $0xf012b977
f01185c6:	e8 6e 7d fe ff       	call   f0100339 <_panic>
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f01185cb:	e8 39 c3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01185d0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01185d3:	74 17                	je     f01185ec <test_fastfirstfit+0x888>
f01185d5:	83 ec 04             	sub    $0x4,%esp
f01185d8:	68 90 b9 12 f0       	push   $0xf012b990
f01185dd:	68 71 03 00 00       	push   $0x371
f01185e2:	68 77 b9 12 f0       	push   $0xf012b977
f01185e7:	e8 4d 7d fe ff       	call   f0100339 <_panic>
		if ((freeFrames - sys_calculate_free_frames()) < (desiredSize)/PAGE_SIZE) panic("Wrong allocation");
f01185ec:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01185ef:	e8 81 54 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01185f4:	29 c3                	sub    %eax,%ebx
f01185f6:	89 da                	mov    %ebx,%edx
f01185f8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01185fb:	c1 e8 0c             	shr    $0xc,%eax
f01185fe:	39 c2                	cmp    %eax,%edx
f0118600:	73 17                	jae    f0118619 <test_fastfirstfit+0x8b5>
f0118602:	83 ec 04             	sub    $0x4,%esp
f0118605:	68 f8 b9 12 f0       	push   $0xf012b9f8
f011860a:	68 72 03 00 00       	push   $0x372
f011860f:	68 77 b9 12 f0       	push   $0xf012b977
f0118614:	e8 20 7d fe ff       	call   f0100339 <_panic>
	}
	cprintf("\nIf this test finishes in less than 5 SEC... TAKE YOUR BONUS :).\n");
f0118619:	83 ec 0c             	sub    $0xc,%esp
f011861c:	68 a8 ba 12 f0       	push   $0xf012baa8
f0118621:	e8 65 89 fe ff       	call   f0100f8b <cprintf>
f0118626:	83 c4 10             	add    $0x10,%esp
	return 1;
f0118629:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011862e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0118631:	c9                   	leave  
f0118632:	c3                   	ret    

f0118633 <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f0118633:	55                   	push   %ebp
f0118634:	89 e5                	mov    %esp,%ebp
f0118636:	57                   	push   %edi
f0118637:	53                   	push   %ebx
f0118638:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011863e:	83 ec 0c             	sub    $0xc,%esp
f0118641:	68 08 9a 12 f0       	push   $0xf0129a08
f0118646:	e8 40 89 fe ff       	call   f0100f8b <cprintf>
f011864b:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011864e:	83 ec 0c             	sub    $0xc,%esp
f0118651:	68 38 9a 12 f0       	push   $0xf0129a38
f0118656:	e8 30 89 fe ff       	call   f0100f8b <cprintf>
f011865b:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011865e:	83 ec 0c             	sub    $0xc,%esp
f0118661:	68 08 9a 12 f0       	push   $0xf0129a08
f0118666:	e8 20 89 fe ff       	call   f0100f8b <cprintf>
f011866b:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011866e:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f0118672:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f0118676:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f011867c:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f0118682:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f0118689:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f0118690:	e8 e0 53 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118695:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f0118698:	8d 95 64 ff ff ff    	lea    -0x9c(%ebp),%edx
f011869e:	b9 14 00 00 00       	mov    $0x14,%ecx
f01186a3:	b8 00 00 00 00       	mov    $0x0,%eax
f01186a8:	89 d7                	mov    %edx,%edi
f01186aa:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f01186ac:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f01186b2:	b9 14 00 00 00       	mov    $0x14,%ecx
f01186b7:	b8 00 00 00 00       	mov    $0x0,%eax
f01186bc:	89 d7                	mov    %edx,%edi
f01186be:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f01186c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f01186c7:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f01186ce:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f01186d5:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f01186db:	b9 14 00 00 00       	mov    $0x14,%ecx
f01186e0:	b8 00 00 00 00       	mov    $0x0,%eax
f01186e5:	89 d7                	mov    %edx,%edi
f01186e7:	f3 ab                	rep stos %eax,%es:(%edi)
	//Create some spaces in both BLOCK & PAGE allocators
	cprintf("\n1. Create some spaces in both BLOCK & PAGE allocators\n");
f01186e9:	83 ec 0c             	sub    $0xc,%esp
f01186ec:	68 ec ba 12 f0       	push   $0xf012baec
f01186f1:	e8 95 88 fe ff       	call   f0100f8b <cprintf>
f01186f6:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f01186f9:	e8 77 53 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01186fe:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0118701:	e8 03 c2 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118706:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0118709:	83 ec 0c             	sub    $0xc,%esp
f011870c:	68 00 fc 1f 00       	push   $0x1ffc00
f0118711:	e8 1a 07 ff ff       	call   f0108e30 <kmalloc>
f0118716:	83 c4 10             	add    $0x10,%esp
f0118719:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011871f:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f0118725:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011872a:	74 17                	je     f0118743 <test_kfree_bestfirstfit+0x110>
f011872c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118733:	83 ec 0c             	sub    $0xc,%esp
f0118736:	68 24 bb 12 f0       	push   $0xf012bb24
f011873b:	e8 4b 88 fe ff       	call   f0100f8b <cprintf>
f0118740:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118743:	e8 c1 c1 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118748:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011874b:	74 17                	je     f0118764 <test_kfree_bestfirstfit+0x131>
f011874d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118754:	83 ec 0c             	sub    $0xc,%esp
f0118757:	68 78 bb 12 f0       	push   $0xf012bb78
f011875c:	e8 2a 88 fe ff       	call   f0100f8b <cprintf>
f0118761:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118764:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118767:	e8 09 53 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011876c:	29 c3                	sub    %eax,%ebx
f011876e:	89 d8                	mov    %ebx,%eax
f0118770:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118775:	77 17                	ja     f011878e <test_kfree_bestfirstfit+0x15b>
f0118777:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011877e:	83 ec 0c             	sub    $0xc,%esp
f0118781:	68 e8 bb 12 f0       	push   $0xf012bbe8
f0118786:	e8 00 88 fe ff       	call   f0100f8b <cprintf>
f011878b:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f011878e:	c7 85 64 ff ff ff ff 	movl   $0x1ffbff,-0x9c(%ebp)
f0118795:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f0118798:	e8 d8 52 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011879d:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01187a0:	e8 64 c1 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01187a5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f01187a8:	83 ec 0c             	sub    $0xc,%esp
f01187ab:	68 00 fc 1f 00       	push   $0x1ffc00
f01187b0:	e8 7b 06 ff ff       	call   f0108e30 <kmalloc>
f01187b5:	83 c4 10             	add    $0x10,%esp
f01187b8:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01187be:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f01187c4:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f01187c9:	74 17                	je     f01187e2 <test_kfree_bestfirstfit+0x1af>
f01187cb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01187d2:	83 ec 0c             	sub    $0xc,%esp
f01187d5:	68 30 bc 12 f0       	push   $0xf012bc30
f01187da:	e8 ac 87 fe ff       	call   f0100f8b <cprintf>
f01187df:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01187e2:	e8 22 c1 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01187e7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01187ea:	74 17                	je     f0118803 <test_kfree_bestfirstfit+0x1d0>
f01187ec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01187f3:	83 ec 0c             	sub    $0xc,%esp
f01187f6:	68 84 bc 12 f0       	push   $0xf012bc84
f01187fb:	e8 8b 87 fe ff       	call   f0100f8b <cprintf>
f0118800:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118803:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118806:	e8 6a 52 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011880b:	29 c3                	sub    %eax,%ebx
f011880d:	89 d8                	mov    %ebx,%eax
f011880f:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118814:	77 17                	ja     f011882d <test_kfree_bestfirstfit+0x1fa>
f0118816:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011881d:	83 ec 0c             	sub    $0xc,%esp
f0118820:	68 f4 bc 12 f0       	push   $0xf012bcf4
f0118825:	e8 61 87 fe ff       	call   f0100f8b <cprintf>
f011882a:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f011882d:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f0118834:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f0118837:	e8 39 52 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011883c:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011883f:	e8 c5 c0 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118844:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f0118847:	83 ec 0c             	sub    $0xc,%esp
f011884a:	68 00 1c 00 00       	push   $0x1c00
f011884f:	e8 dc 05 ff ff       	call   f0108e30 <kmalloc>
f0118854:	83 c4 10             	add    $0x10,%esp
f0118857:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011885d:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0118863:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0118868:	74 17                	je     f0118881 <test_kfree_bestfirstfit+0x24e>
f011886a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118871:	83 ec 0c             	sub    $0xc,%esp
f0118874:	68 3c bd 12 f0       	push   $0xf012bd3c
f0118879:	e8 0d 87 fe ff       	call   f0100f8b <cprintf>
f011887e:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118881:	e8 83 c0 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118886:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118889:	74 17                	je     f01188a2 <test_kfree_bestfirstfit+0x26f>
f011888b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118892:	83 ec 0c             	sub    $0xc,%esp
f0118895:	68 90 bd 12 f0       	push   $0xf012bd90
f011889a:	e8 ec 86 fe ff       	call   f0100f8b <cprintf>
f011889f:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01188a2:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01188a5:	e8 cb 51 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01188aa:	29 c3                	sub    %eax,%ebx
f01188ac:	89 d8                	mov    %ebx,%eax
f01188ae:	83 f8 01             	cmp    $0x1,%eax
f01188b1:	77 17                	ja     f01188ca <test_kfree_bestfirstfit+0x297>
f01188b3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01188ba:	83 ec 0c             	sub    $0xc,%esp
f01188bd:	68 00 be 12 f0       	push   $0xf012be00
f01188c2:	e8 c4 86 fe ff       	call   f0100f8b <cprintf>
f01188c7:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f01188ca:	c7 85 74 ff ff ff ff 	movl   $0x1bff,-0x8c(%ebp)
f01188d1:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f01188d4:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f01188da:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f01188dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01188e4:	eb 0e                	jmp    f01188f4 <test_kfree_bestfirstfit+0x2c1>
			{
				ptr[i] = 4 ;
f01188e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01188e9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01188ec:	01 d0                	add    %edx,%eax
f01188ee:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("1.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f01188f1:	ff 45 f4             	incl   -0xc(%ebp)
f01188f4:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01188fa:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01188fd:	7f e7                	jg     f01188e6 <test_kfree_bestfirstfit+0x2b3>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f01188ff:	e8 71 51 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118904:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0118907:	e8 fd bf fe ff       	call   f0104909 <pf_calculate_free_frames>
f011890c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f011890f:	83 ec 0c             	sub    $0xc,%esp
f0118912:	68 00 fc 2f 00       	push   $0x2ffc00
f0118917:	e8 14 05 ff ff       	call   f0108e30 <kmalloc>
f011891c:	83 c4 10             	add    $0x10,%esp
f011891f:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0118925:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011892b:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0118930:	74 17                	je     f0118949 <test_kfree_bestfirstfit+0x316>
f0118932:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118939:	83 ec 0c             	sub    $0xc,%esp
f011893c:	68 48 be 12 f0       	push   $0xf012be48
f0118941:	e8 45 86 fe ff       	call   f0100f8b <cprintf>
f0118946:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118949:	e8 bb bf fe ff       	call   f0104909 <pf_calculate_free_frames>
f011894e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118951:	74 17                	je     f011896a <test_kfree_bestfirstfit+0x337>
f0118953:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011895a:	83 ec 0c             	sub    $0xc,%esp
f011895d:	68 9c be 12 f0       	push   $0xf012be9c
f0118962:	e8 24 86 fe ff       	call   f0100f8b <cprintf>
f0118967:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011896a:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011896d:	e8 03 51 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118972:	29 c3                	sub    %eax,%ebx
f0118974:	89 d8                	mov    %ebx,%eax
f0118976:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011897b:	77 17                	ja     f0118994 <test_kfree_bestfirstfit+0x361>
f011897d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118984:	83 ec 0c             	sub    $0xc,%esp
f0118987:	68 0c bf 12 f0       	push   $0xf012bf0c
f011898c:	e8 fa 85 fe ff       	call   f0100f8b <cprintf>
f0118991:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f0118994:	c7 85 78 ff ff ff ff 	movl   $0x2ffbff,-0x88(%ebp)
f011899b:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f011899e:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f01189a4:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f01189a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01189ae:	eb 0e                	jmp    f01189be <test_kfree_bestfirstfit+0x38b>
			{
				ptr[i] = 5 ;
f01189b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01189b3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01189b6:	01 d0                	add    %edx,%eax
f01189b8:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f01189bb:	ff 45 f4             	incl   -0xc(%ebp)
f01189be:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01189c4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01189c7:	7f e7                	jg     f01189b0 <test_kfree_bestfirstfit+0x37d>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f01189c9:	e8 a7 50 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01189ce:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01189d1:	e8 33 bf fe ff       	call   f0104909 <pf_calculate_free_frames>
f01189d6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f01189d9:	83 ec 0c             	sub    $0xc,%esp
f01189dc:	68 00 fc 5f 00       	push   $0x5ffc00
f01189e1:	e8 4a 04 ff ff       	call   f0108e30 <kmalloc>
f01189e6:	83 c4 10             	add    $0x10,%esp
f01189e9:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.5 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01189ef:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f01189f5:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f01189fa:	74 17                	je     f0118a13 <test_kfree_bestfirstfit+0x3e0>
f01189fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118a03:	83 ec 0c             	sub    $0xc,%esp
f0118a06:	68 54 bf 12 f0       	push   $0xf012bf54
f0118a0b:	e8 7b 85 fe ff       	call   f0100f8b <cprintf>
f0118a10:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118a13:	e8 f1 be fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118a18:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118a1b:	74 17                	je     f0118a34 <test_kfree_bestfirstfit+0x401>
f0118a1d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118a24:	83 ec 0c             	sub    $0xc,%esp
f0118a27:	68 a8 bf 12 f0       	push   $0xf012bfa8
f0118a2c:	e8 5a 85 fe ff       	call   f0100f8b <cprintf>
f0118a31:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.5 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118a34:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118a37:	e8 39 50 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118a3c:	29 c3                	sub    %eax,%ebx
f0118a3e:	89 d8                	mov    %ebx,%eax
f0118a40:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0118a45:	77 17                	ja     f0118a5e <test_kfree_bestfirstfit+0x42b>
f0118a47:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118a4e:	83 ec 0c             	sub    $0xc,%esp
f0118a51:	68 18 c0 12 f0       	push   $0xf012c018
f0118a56:	e8 30 85 fe ff       	call   f0100f8b <cprintf>
f0118a5b:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f0118a5e:	c7 85 7c ff ff ff ff 	movl   $0x5ffbff,-0x84(%ebp)
f0118a65:	fb 5f 00 

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f0118a68:	e8 08 50 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118a6d:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0118a70:	e8 94 be fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118a75:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f0118a78:	83 ec 0c             	sub    $0xc,%esp
f0118a7b:	68 00 38 00 00       	push   $0x3800
f0118a80:	e8 ab 03 ff ff       	call   f0108e30 <kmalloc>
f0118a85:	83 c4 10             	add    $0x10,%esp
f0118a88:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0118a8e:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0118a94:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0118a99:	74 17                	je     f0118ab2 <test_kfree_bestfirstfit+0x47f>
f0118a9b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118aa2:	83 ec 0c             	sub    $0xc,%esp
f0118aa5:	68 60 c0 12 f0       	push   $0xf012c060
f0118aaa:	e8 dc 84 fe ff       	call   f0100f8b <cprintf>
f0118aaf:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118ab2:	e8 52 be fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118ab7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118aba:	74 17                	je     f0118ad3 <test_kfree_bestfirstfit+0x4a0>
f0118abc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118ac3:	83 ec 0c             	sub    $0xc,%esp
f0118ac6:	68 b4 c0 12 f0       	push   $0xf012c0b4
f0118acb:	e8 bb 84 fe ff       	call   f0100f8b <cprintf>
f0118ad0:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118ad3:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118ad6:	e8 9a 4f ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118adb:	29 c3                	sub    %eax,%ebx
f0118add:	89 d8                	mov    %ebx,%eax
f0118adf:	83 f8 03             	cmp    $0x3,%eax
f0118ae2:	77 17                	ja     f0118afb <test_kfree_bestfirstfit+0x4c8>
f0118ae4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118aeb:	83 ec 0c             	sub    $0xc,%esp
f0118aee:	68 24 c1 12 f0       	push   $0xf012c124
f0118af3:	e8 93 84 fe ff       	call   f0100f8b <cprintf>
f0118af8:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f0118afb:	c7 45 80 ff 37 00 00 	movl   $0x37ff,-0x80(%ebp)
			ptr = (char*)ptr_allocations[7];
f0118b02:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f0118b08:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f0118b0b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118b12:	eb 0e                	jmp    f0118b22 <test_kfree_bestfirstfit+0x4ef>
			{
				ptr[i] = 7 ;
f0118b14:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118b17:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118b1a:	01 d0                	add    %edx,%eax
f0118b1c:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f0118b1f:	ff 45 f4             	incl   -0xc(%ebp)
f0118b22:	8b 45 80             	mov    -0x80(%ebp),%eax
f0118b25:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118b28:	7f ea                	jg     f0118b14 <test_kfree_bestfirstfit+0x4e1>
				ptr[i] = 7 ;
			}
		}

		/*[BLOCK ALLOCATOR]*/
		freeFrames = sys_calculate_free_frames() ;
f0118b2a:	e8 46 4f ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118b2f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		{
			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0118b32:	e8 d2 bd fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118b37:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f0118b3a:	83 ec 0c             	sub    $0xc,%esp
f0118b3d:	68 00 08 00 00       	push   $0x800
f0118b42:	e8 e9 02 ff ff       	call   f0108e30 <kmalloc>
f0118b47:	83 c4 10             	add    $0x10,%esp
f0118b4a:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0118b50:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0118b56:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118b5b:	76 28                	jbe    f0118b85 <test_kfree_bestfirstfit+0x552>
f0118b5d:	8b 9d cc fe ff ff    	mov    -0x134(%ebp),%ebx
f0118b63:	83 ec 0c             	sub    $0xc,%esp
f0118b66:	6a 00                	push   $0x0
f0118b68:	e8 c8 01 ff ff       	call   f0108d35 <sbrk>
f0118b6d:	83 c4 10             	add    $0x10,%esp
f0118b70:	39 c3                	cmp    %eax,%ebx
f0118b72:	73 11                	jae    f0118b85 <test_kfree_bestfirstfit+0x552>
f0118b74:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0118b7a:	89 c2                	mov    %eax,%edx
f0118b7c:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0118b81:	39 c2                	cmp    %eax,%edx
f0118b83:	72 17                	jb     f0118b9c <test_kfree_bestfirstfit+0x569>
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118b85:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118b8c:	83 ec 0c             	sub    $0xc,%esp
f0118b8f:	68 6c c1 12 f0       	push   $0xf012c16c
f0118b94:	e8 f2 83 fe ff       	call   f0100f8b <cprintf>
f0118b99:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118b9c:	e8 68 bd fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118ba1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118ba4:	74 17                	je     f0118bbd <test_kfree_bestfirstfit+0x58a>
f0118ba6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118bad:	83 ec 0c             	sub    $0xc,%esp
f0118bb0:	68 f8 c1 12 f0       	push   $0xf012c1f8
f0118bb5:	e8 d1 83 fe ff       	call   f0100f8b <cprintf>
f0118bba:	83 c4 10             	add    $0x10,%esp
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f0118bbd:	c7 85 6c ff ff ff ff 	movl   $0x7ff,-0x94(%ebp)
f0118bc4:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f0118bc7:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0118bcd:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f0118bd0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118bd7:	eb 0e                	jmp    f0118be7 <test_kfree_bestfirstfit+0x5b4>
			{
				ptr[i] = 2 ;
f0118bd9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118bdc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118bdf:	01 d0                	add    %edx,%eax
f0118be1:	c6 00 02             	movb   $0x2,(%eax)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
			{ correct = 0; cprintf("1.7 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f0118be4:	ff 45 f4             	incl   -0xc(%ebp)
f0118be7:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f0118bed:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118bf0:	7f e7                	jg     f0118bd9 <test_kfree_bestfirstfit+0x5a6>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeDiskFrames = pf_calculate_free_frames() ;
f0118bf2:	e8 12 bd fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118bf7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0118bfa:	83 ec 0c             	sub    $0xc,%esp
f0118bfd:	68 00 08 00 00       	push   $0x800
f0118c02:	e8 29 02 ff ff       	call   f0108e30 <kmalloc>
f0118c07:	83 c4 10             	add    $0x10,%esp
f0118c0a:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0118c10:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0118c16:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118c1b:	76 28                	jbe    f0118c45 <test_kfree_bestfirstfit+0x612>
f0118c1d:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f0118c23:	83 ec 0c             	sub    $0xc,%esp
f0118c26:	6a 00                	push   $0x0
f0118c28:	e8 08 01 ff ff       	call   f0108d35 <sbrk>
f0118c2d:	83 c4 10             	add    $0x10,%esp
f0118c30:	39 c3                	cmp    %eax,%ebx
f0118c32:	73 11                	jae    f0118c45 <test_kfree_bestfirstfit+0x612>
f0118c34:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0118c3a:	89 c2                	mov    %eax,%edx
f0118c3c:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0118c41:	39 c2                	cmp    %eax,%edx
f0118c43:	72 17                	jb     f0118c5c <test_kfree_bestfirstfit+0x629>
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118c45:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118c4c:	83 ec 0c             	sub    $0xc,%esp
f0118c4f:	68 68 c2 12 f0       	push   $0xf012c268
f0118c54:	e8 32 83 fe ff       	call   f0100f8b <cprintf>
f0118c59:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118c5c:	e8 a8 bc fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118c61:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0118c64:	74 17                	je     f0118c7d <test_kfree_bestfirstfit+0x64a>
f0118c66:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118c6d:	83 ec 0c             	sub    $0xc,%esp
f0118c70:	68 f4 c2 12 f0       	push   $0xf012c2f4
f0118c75:	e8 11 83 fe ff       	call   f0100f8b <cprintf>
f0118c7a:	83 c4 10             	add    $0x10,%esp
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f0118c7d:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f0118c84:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f0118c87:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0118c8d:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f0118c90:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118c97:	eb 0e                	jmp    f0118ca7 <test_kfree_bestfirstfit+0x674>
			{
				ptr[i] = 3 ;
f0118c99:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118c9c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118c9f:	01 d0                	add    %edx,%eax
f0118ca1:	c6 00 03             	movb   $0x3,(%eax)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
			{ correct = 0; cprintf("1.8 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f0118ca4:	ff 45 f4             	incl   -0xc(%ebp)
f0118ca7:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0118cad:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118cb0:	7f e7                	jg     f0118c99 <test_kfree_bestfirstfit+0x666>
			{
				ptr[i] = 3 ;
			}
		}
		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("1.8 Wrong allocation: sbrk error\n"); }
f0118cb2:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0118cb5:	e8 bb 4d ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118cba:	29 c3                	sub    %eax,%ebx
f0118cbc:	89 d8                	mov    %ebx,%eax
f0118cbe:	83 f8 01             	cmp    $0x1,%eax
f0118cc1:	74 17                	je     f0118cda <test_kfree_bestfirstfit+0x6a7>
f0118cc3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118cca:	83 ec 0c             	sub    $0xc,%esp
f0118ccd:	68 64 c3 12 f0       	push   $0xf012c364
f0118cd2:	e8 b4 82 fe ff       	call   f0100f8b <cprintf>
f0118cd7:	83 c4 10             	add    $0x10,%esp
	}

	//kfree some of the allocated spaces [10%]
	cprintf("\n2. kfree some of the allocated spaces [10%]\n");
f0118cda:	83 ec 0c             	sub    $0xc,%esp
f0118cdd:	68 88 c3 12 f0       	push   $0xf012c388
f0118ce2:	e8 a4 82 fe ff       	call   f0100f8b <cprintf>
f0118ce7:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f0118cea:	e8 86 4d ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118cef:	89 45 bc             	mov    %eax,-0x44(%ebp)
		cprintf("hereee done f\n");
f0118cf2:	83 ec 0c             	sub    $0xc,%esp
f0118cf5:	68 b6 c3 12 f0       	push   $0xf012c3b6
f0118cfa:	e8 8c 82 fe ff       	call   f0100f8b <cprintf>
f0118cff:	83 c4 10             	add    $0x10,%esp
		int freeDiskFrames = pf_calculate_free_frames() ;
f0118d02:	e8 02 bc fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118d07:	89 45 b8             	mov    %eax,-0x48(%ebp)
		cprintf("hereee done f\n");
f0118d0a:	83 ec 0c             	sub    $0xc,%esp
f0118d0d:	68 b6 c3 12 f0       	push   $0xf012c3b6
f0118d12:	e8 74 82 fe ff       	call   f0100f8b <cprintf>
f0118d17:	83 c4 10             	add    $0x10,%esp
		kfree(ptr_allocations[0]);
f0118d1a:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f0118d20:	83 ec 0c             	sub    $0xc,%esp
f0118d23:	50                   	push   %eax
f0118d24:	e8 74 02 ff ff       	call   f0108f9d <kfree>
f0118d29:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118d2c:	e8 d8 bb fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118d31:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0118d34:	74 17                	je     f0118d4d <test_kfree_bestfirstfit+0x71a>
f0118d36:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118d3d:	83 ec 0c             	sub    $0xc,%esp
f0118d40:	68 c8 c3 12 f0       	push   $0xf012c3c8
f0118d45:	e8 41 82 fe ff       	call   f0100f8b <cprintf>
f0118d4a:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("2.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f0118d4d:	e8 23 4d ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118d52:	89 c2                	mov    %eax,%edx
f0118d54:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118d57:	29 c2                	sub    %eax,%edx
f0118d59:	89 d0                	mov    %edx,%eax
f0118d5b:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118d60:	77 17                	ja     f0118d79 <test_kfree_bestfirstfit+0x746>
f0118d62:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118d69:	83 ec 0c             	sub    $0xc,%esp
f0118d6c:	68 38 c4 12 f0       	push   $0xf012c438
f0118d71:	e8 15 82 fe ff       	call   f0100f8b <cprintf>
f0118d76:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB from BLOCK Allocator
		freeFrames = sys_calculate_free_frames() ;
f0118d79:	e8 f7 4c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118d7e:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118d81:	e8 83 bb fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118d86:	89 45 b8             	mov    %eax,-0x48(%ebp)
		cprintf("hereee start free block\n");
f0118d89:	83 ec 0c             	sub    $0xc,%esp
f0118d8c:	68 72 c4 12 f0       	push   $0xf012c472
f0118d91:	e8 f5 81 fe ff       	call   f0100f8b <cprintf>
f0118d96:	83 c4 10             	add    $0x10,%esp
		kfree(ptr_allocations[2]);
f0118d99:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0118d9f:	83 ec 0c             	sub    $0xc,%esp
f0118da2:	50                   	push   %eax
f0118da3:	e8 f5 01 ff ff       	call   f0108f9d <kfree>
f0118da8:	83 c4 10             	add    $0x10,%esp
		cprintf("hereee start block 1\n");
f0118dab:	83 ec 0c             	sub    $0xc,%esp
f0118dae:	68 8b c4 12 f0       	push   $0xf012c48b
f0118db3:	e8 d3 81 fe ff       	call   f0100f8b <cprintf>
f0118db8:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118dbb:	e8 49 bb fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118dc0:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0118dc3:	74 17                	je     f0118ddc <test_kfree_bestfirstfit+0x7a9>
f0118dc5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118dcc:	83 ec 0c             	sub    $0xc,%esp
f0118dcf:	68 a4 c4 12 f0       	push   $0xf012c4a4
f0118dd4:	e8 b2 81 fe ff       	call   f0100f8b <cprintf>
f0118dd9:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("2.2 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0118ddc:	e8 94 4c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118de1:	89 c2                	mov    %eax,%edx
f0118de3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118de6:	39 c2                	cmp    %eax,%edx
f0118de8:	74 17                	je     f0118e01 <test_kfree_bestfirstfit+0x7ce>
f0118dea:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118df1:	83 ec 0c             	sub    $0xc,%esp
f0118df4:	68 14 c5 12 f0       	push   $0xf012c514
f0118df9:	e8 8d 81 fe ff       	call   f0100f8b <cprintf>
f0118dfe:	83 c4 10             	add    $0x10,%esp
		cprintf("hereee done block\n");
f0118e01:	83 ec 0c             	sub    $0xc,%esp
f0118e04:	68 72 c5 12 f0       	push   $0xf012c572
f0118e09:	e8 7d 81 fe ff       	call   f0100f8b <cprintf>
f0118e0e:	83 c4 10             	add    $0x10,%esp
		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f0118e11:	e8 5f 4c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118e16:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118e19:	e8 eb ba fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118e1e:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f0118e21:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f0118e27:	83 ec 0c             	sub    $0xc,%esp
f0118e2a:	50                   	push   %eax
f0118e2b:	e8 6d 01 ff ff       	call   f0108f9d <kfree>
f0118e30:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118e33:	e8 d1 ba fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118e38:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0118e3b:	74 17                	je     f0118e54 <test_kfree_bestfirstfit+0x821>
f0118e3d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118e44:	83 ec 0c             	sub    $0xc,%esp
f0118e47:	68 88 c5 12 f0       	push   $0xf012c588
f0118e4c:	e8 3a 81 fe ff       	call   f0100f8b <cprintf>
f0118e51:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("2.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f0118e54:	e8 1c 4c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118e59:	89 c2                	mov    %eax,%edx
f0118e5b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118e5e:	29 c2                	sub    %eax,%edx
f0118e60:	89 d0                	mov    %edx,%eax
f0118e62:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0118e67:	77 17                	ja     f0118e80 <test_kfree_bestfirstfit+0x84d>
f0118e69:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118e70:	83 ec 0c             	sub    $0xc,%esp
f0118e73:	68 f8 c5 12 f0       	push   $0xf012c5f8
f0118e78:	e8 0e 81 fe ff       	call   f0100f8b <cprintf>
f0118e7d:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f0118e80:	e8 f0 4b ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118e85:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0118e88:	e8 7c ba fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118e8d:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f0118e90:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f0118e96:	83 ec 0c             	sub    $0xc,%esp
f0118e99:	50                   	push   %eax
f0118e9a:	e8 fe 00 ff ff       	call   f0108f9d <kfree>
f0118e9f:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("2.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118ea2:	e8 62 ba fe ff       	call   f0104909 <pf_calculate_free_frames>
f0118ea7:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0118eaa:	74 17                	je     f0118ec3 <test_kfree_bestfirstfit+0x890>
f0118eac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118eb3:	83 ec 0c             	sub    $0xc,%esp
f0118eb6:	68 34 c6 12 f0       	push   $0xf012c634
f0118ebb:	e8 cb 80 fe ff       	call   f0100f8b <cprintf>
f0118ec0:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("2.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f0118ec3:	e8 ad 4b ff ff       	call   f010da75 <sys_calculate_free_frames>
f0118ec8:	89 c2                	mov    %eax,%edx
f0118eca:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0118ecd:	29 c2                	sub    %eax,%edx
f0118ecf:	89 d0                	mov    %edx,%eax
f0118ed1:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f0118ed6:	77 17                	ja     f0118eef <test_kfree_bestfirstfit+0x8bc>
f0118ed8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118edf:	83 ec 0c             	sub    $0xc,%esp
f0118ee2:	68 a4 c6 12 f0       	push   $0xf012c6a4
f0118ee7:	e8 9f 80 fe ff       	call   f0100f8b <cprintf>
f0118eec:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118eef:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0118ef3:	74 04                	je     f0118ef9 <test_kfree_bestfirstfit+0x8c6>
f0118ef5:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f0118ef9:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
f0118f00:	83 ec 0c             	sub    $0xc,%esp
f0118f03:	68 e0 c6 12 f0       	push   $0xf012c6e0
f0118f08:	e8 7e 80 fe ff       	call   f0100f8b <cprintf>
f0118f0d:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f0118f10:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f0118f16:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f0118f19:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118f20:	eb 1e                	jmp    f0118f40 <test_kfree_bestfirstfit+0x90d>
		{
			sums[3] += ptr[i] ;
f0118f22:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f0118f28:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0118f2b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118f2e:	01 c8                	add    %ecx,%eax
f0118f30:	8a 00                	mov    (%eax),%al
f0118f32:	0f be c0             	movsbl %al,%eax
f0118f35:	01 d0                	add    %edx,%eax
f0118f37:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%ebp)
	//Check memory access of non-freed areas in both allocators [10%]
	cprintf("\n3. Check memory access of non-freed areas in both allocators [10%]\n");
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f0118f3d:	ff 45 f4             	incl   -0xc(%ebp)
f0118f40:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0118f46:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118f49:	7f d7                	jg     f0118f22 <test_kfree_bestfirstfit+0x8ef>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }
f0118f4b:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f0118f51:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0118f57:	89 c1                	mov    %eax,%ecx
f0118f59:	01 c9                	add    %ecx,%ecx
f0118f5b:	01 c8                	add    %ecx,%eax
f0118f5d:	39 c2                	cmp    %eax,%edx
f0118f5f:	74 17                	je     f0118f78 <test_kfree_bestfirstfit+0x945>
f0118f61:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118f68:	83 ec 0c             	sub    $0xc,%esp
f0118f6b:	68 28 c7 12 f0       	push   $0xf012c728
f0118f70:	e8 16 80 fe ff       	call   f0100f8b <cprintf>
f0118f75:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f0118f78:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f0118f7e:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f0118f81:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118f88:	eb 1e                	jmp    f0118fa8 <test_kfree_bestfirstfit+0x975>
		{
			sums[4] += ptr[i] ;
f0118f8a:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f0118f90:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0118f93:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118f96:	01 c8                	add    %ecx,%eax
f0118f98:	8a 00                	mov    (%eax),%al
f0118f9a:	0f be c0             	movsbl %al,%eax
f0118f9d:	01 d0                	add    %edx,%eax
f0118f9f:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("3.1 kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f0118fa5:	ff 45 f4             	incl   -0xc(%ebp)
f0118fa8:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0118fae:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0118fb1:	7f d7                	jg     f0118f8a <test_kfree_bestfirstfit+0x957>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }
f0118fb3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0118fb9:	8b 95 74 ff ff ff    	mov    -0x8c(%ebp),%edx
f0118fbf:	c1 e2 02             	shl    $0x2,%edx
f0118fc2:	39 d0                	cmp    %edx,%eax
f0118fc4:	74 17                	je     f0118fdd <test_kfree_bestfirstfit+0x9aa>
f0118fc6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0118fcd:	83 ec 0c             	sub    $0xc,%esp
f0118fd0:	68 60 c7 12 f0       	push   $0xf012c760
f0118fd5:	e8 b1 7f fe ff       	call   f0100f8b <cprintf>
f0118fda:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f0118fdd:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f0118fe3:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f0118fe6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0118fed:	eb 1e                	jmp    f011900d <test_kfree_bestfirstfit+0x9da>
		{
			sums[5] += ptr[i] ;
f0118fef:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f0118ff5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0118ff8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118ffb:	01 c8                	add    %ecx,%eax
f0118ffd:	8a 00                	mov    (%eax),%al
f0118fff:	0f be c0             	movsbl %al,%eax
f0119002:	01 d0                	add    %edx,%eax
f0119004:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("3.2 kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f011900a:	ff 45 f4             	incl   -0xc(%ebp)
f011900d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0119013:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119016:	7f d7                	jg     f0118fef <test_kfree_bestfirstfit+0x9bc>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }
f0119018:	8b 8d 28 ff ff ff    	mov    -0xd8(%ebp),%ecx
f011901e:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0119024:	89 d0                	mov    %edx,%eax
f0119026:	c1 e0 02             	shl    $0x2,%eax
f0119029:	01 d0                	add    %edx,%eax
f011902b:	39 c1                	cmp    %eax,%ecx
f011902d:	74 17                	je     f0119046 <test_kfree_bestfirstfit+0xa13>
f011902f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119036:	83 ec 0c             	sub    $0xc,%esp
f0119039:	68 98 c7 12 f0       	push   $0xf012c798
f011903e:	e8 48 7f fe ff       	call   f0100f8b <cprintf>
f0119043:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f0119046:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011904c:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f011904f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119056:	eb 1e                	jmp    f0119076 <test_kfree_bestfirstfit+0xa43>
		{
			sums[7] += ptr[i] ;
f0119058:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f011905e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119061:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119064:	01 c8                	add    %ecx,%eax
f0119066:	8a 00                	mov    (%eax),%al
f0119068:	0f be c0             	movsbl %al,%eax
f011906b:	01 d0                	add    %edx,%eax
f011906d:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("3.3 kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f0119073:	ff 45 f4             	incl   -0xc(%ebp)
f0119076:	8b 45 80             	mov    -0x80(%ebp),%eax
f0119079:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011907c:	7f da                	jg     f0119058 <test_kfree_bestfirstfit+0xa25>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("3.4 kfree: invalid read after freeing some allocations\n"); }
f011907e:	8b 8d 30 ff ff ff    	mov    -0xd0(%ebp),%ecx
f0119084:	8b 55 80             	mov    -0x80(%ebp),%edx
f0119087:	89 d0                	mov    %edx,%eax
f0119089:	01 c0                	add    %eax,%eax
f011908b:	01 d0                	add    %edx,%eax
f011908d:	01 c0                	add    %eax,%eax
f011908f:	01 d0                	add    %edx,%eax
f0119091:	39 c1                	cmp    %eax,%ecx
f0119093:	74 17                	je     f01190ac <test_kfree_bestfirstfit+0xa79>
f0119095:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011909c:	83 ec 0c             	sub    $0xc,%esp
f011909f:	68 d0 c7 12 f0       	push   $0xf012c7d0
f01190a4:	e8 e2 7e fe ff       	call   f0100f8b <cprintf>
f01190a9:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01190ac:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01190b0:	74 04                	je     f01190b6 <test_kfree_bestfirstfit+0xa83>
f01190b2:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f01190b6:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	cprintf("\n4. Allocate after kfree [15%]\n");
f01190bd:	83 ec 0c             	sub    $0xc,%esp
f01190c0:	68 08 c8 12 f0       	push   $0xf012c808
f01190c5:	e8 c1 7e fe ff       	call   f0100f8b <cprintf>
f01190ca:	83 c4 10             	add    $0x10,%esp
	{
		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f01190cd:	e8 a3 49 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01190d2:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01190d5:	e8 2f b8 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01190da:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f01190dd:	83 ec 0c             	sub    $0xc,%esp
f01190e0:	68 00 04 00 00       	push   $0x400
f01190e5:	e8 46 fd fe ff       	call   f0108e30 <kmalloc>
f01190ea:	83 c4 10             	add    $0x10,%esp
f01190ed:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if (ptr_allocations[9] != ptr_allocations[2])
f01190f3:	8b 95 e8 fe ff ff    	mov    -0x118(%ebp),%edx
f01190f9:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f01190ff:	39 c2                	cmp    %eax,%edx
f0119101:	74 17                	je     f011911a <test_kfree_bestfirstfit+0xae7>
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119103:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011910a:	83 ec 0c             	sub    $0xc,%esp
f011910d:	68 28 c8 12 f0       	push   $0xf012c828
f0119112:	e8 74 7e fe ff       	call   f0100f8b <cprintf>
f0119117:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011911a:	e8 ea b7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011911f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119122:	74 17                	je     f011913b <test_kfree_bestfirstfit+0xb08>
f0119124:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011912b:	83 ec 0c             	sub    $0xc,%esp
f011912e:	68 7c c8 12 f0       	push   $0xf012c87c
f0119133:	e8 53 7e fe ff       	call   f0100f8b <cprintf>
f0119138:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011913b:	e8 35 49 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119140:	89 c2                	mov    %eax,%edx
f0119142:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119145:	39 c2                	cmp    %eax,%edx
f0119147:	74 17                	je     f0119160 <test_kfree_bestfirstfit+0xb2d>
f0119149:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119150:	83 ec 0c             	sub    $0xc,%esp
f0119153:	68 ec c8 12 f0       	push   $0xf012c8ec
f0119158:	e8 2e 7e fe ff       	call   f0100f8b <cprintf>
f011915d:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f0119160:	c7 45 88 ff 03 00 00 	movl   $0x3ff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[9];
f0119167:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011916d:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f0119170:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119177:	eb 0e                	jmp    f0119187 <test_kfree_bestfirstfit+0xb54>
		{
			ptr[i] = 9 ;
f0119179:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011917c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011917f:	01 d0                	add    %edx,%eax
f0119181:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("4.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f0119184:	ff 45 f4             	incl   -0xc(%ebp)
f0119187:	8b 45 88             	mov    -0x78(%ebp),%eax
f011918a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011918d:	7f ea                	jg     f0119179 <test_kfree_bestfirstfit+0xb46>
			ptr[i] = 9 ;
		}

		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011918f:	e8 e1 48 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119194:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119197:	e8 6d b7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011919c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f011919f:	83 ec 0c             	sub    $0xc,%esp
f01191a2:	68 00 00 30 00       	push   $0x300000
f01191a7:	e8 84 fc fe ff       	call   f0108e30 <kmalloc>
f01191ac:	83 c4 10             	add    $0x10,%esp
f01191af:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01191b5:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f01191bb:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01191c0:	74 17                	je     f01191d9 <test_kfree_bestfirstfit+0xba6>
f01191c2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01191c9:	83 ec 0c             	sub    $0xc,%esp
f01191cc:	68 68 c9 12 f0       	push   $0xf012c968
f01191d1:	e8 b5 7d fe ff       	call   f0100f8b <cprintf>
f01191d6:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01191d9:	e8 2b b7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01191de:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01191e1:	74 17                	je     f01191fa <test_kfree_bestfirstfit+0xbc7>
f01191e3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01191ea:	83 ec 0c             	sub    $0xc,%esp
f01191ed:	68 bc c9 12 f0       	push   $0xf012c9bc
f01191f2:	e8 94 7d fe ff       	call   f0100f8b <cprintf>
f01191f7:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01191fa:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01191fd:	e8 73 48 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119202:	29 c3                	sub    %eax,%ebx
f0119204:	89 d8                	mov    %ebx,%eax
f0119206:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011920b:	77 17                	ja     f0119224 <test_kfree_bestfirstfit+0xbf1>
f011920d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119214:	83 ec 0c             	sub    $0xc,%esp
f0119217:	68 2c ca 12 f0       	push   $0xf012ca2c
f011921c:	e8 6a 7d fe ff       	call   f0100f8b <cprintf>
f0119221:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f0119224:	c7 45 84 ff ff 2f 00 	movl   $0x2fffff,-0x7c(%ebp)
		ptr = (char*)ptr_allocations[8];
f011922b:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0119231:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f0119234:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011923b:	eb 0e                	jmp    f011924b <test_kfree_bestfirstfit+0xc18>
		{
			ptr[i] = 8 ;
f011923d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119240:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119243:	01 d0                	add    %edx,%eax
f0119245:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("4.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("4.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f0119248:	ff 45 f4             	incl   -0xc(%ebp)
f011924b:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011924e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119251:	7f ea                	jg     f011923d <test_kfree_bestfirstfit+0xc0a>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f0119253:	e8 1d 48 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119258:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011925b:	e8 a9 b6 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119260:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f0119263:	83 ec 0c             	sub    $0xc,%esp
f0119266:	68 00 00 10 00       	push   $0x100000
f011926b:	e8 c0 fb fe ff       	call   f0108e30 <kmalloc>
f0119270:	83 c4 10             	add    $0x10,%esp
f0119273:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119279:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011927f:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0119284:	74 17                	je     f011929d <test_kfree_bestfirstfit+0xc6a>
f0119286:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011928d:	83 ec 0c             	sub    $0xc,%esp
f0119290:	68 74 ca 12 f0       	push   $0xf012ca74
f0119295:	e8 f1 7c fe ff       	call   f0100f8b <cprintf>
f011929a:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011929d:	e8 67 b6 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01192a2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01192a5:	74 17                	je     f01192be <test_kfree_bestfirstfit+0xc8b>
f01192a7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01192ae:	83 ec 0c             	sub    $0xc,%esp
f01192b1:	68 c8 ca 12 f0       	push   $0xf012cac8
f01192b6:	e8 d0 7c fe ff       	call   f0100f8b <cprintf>
f01192bb:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
f01192be:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f01192c1:	e8 af 47 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01192c6:	29 c3                	sub    %eax,%ebx
f01192c8:	89 d8                	mov    %ebx,%eax
f01192ca:	3d ff 00 00 00       	cmp    $0xff,%eax
f01192cf:	77 17                	ja     f01192e8 <test_kfree_bestfirstfit+0xcb5>
f01192d1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01192d8:	83 ec 0c             	sub    $0xc,%esp
f01192db:	68 38 cb 12 f0       	push   $0xf012cb38
f01192e0:	e8 a6 7c fe ff       	call   f0100f8b <cprintf>
f01192e5:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f01192e8:	c7 45 8c ff ff 0f 00 	movl   $0xfffff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[10];
f01192ef:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f01192f5:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f01192f8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01192ff:	eb 0e                	jmp    f011930f <test_kfree_bestfirstfit+0xcdc>
		{
			ptr[i] = 10 ;
f0119301:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119304:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119307:	01 d0                	add    %edx,%eax
f0119309:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("4.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("4.3 Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011930c:	ff 45 f4             	incl   -0xc(%ebp)
f011930f:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0119312:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119315:	7f ea                	jg     f0119301 <test_kfree_bestfirstfit+0xcce>
		{
			ptr[i] = 10 ;
		}
	}
	if (correct)	eval+=15 ;
f0119317:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011931b:	74 04                	je     f0119321 <test_kfree_bestfirstfit+0xcee>
f011931d:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f0119321:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	cprintf("\n5. kfree remaining allocated spaces [15%]\n");
f0119328:	83 ec 0c             	sub    $0xc,%esp
f011932b:	68 80 cb 12 f0       	push   $0xf012cb80
f0119330:	e8 56 7c fe ff       	call   f0100f8b <cprintf>
f0119335:	83 c4 10             	add    $0x10,%esp
	{
		/*[PAGE ALLOCATOR]*/
		{
			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
			freeFrames = sys_calculate_free_frames() ;
f0119338:	e8 38 47 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011933d:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119340:	e8 c4 b5 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119345:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[5]);
f0119348:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011934e:	83 ec 0c             	sub    $0xc,%esp
f0119351:	50                   	push   %eax
f0119352:	e8 46 fc fe ff       	call   f0108f9d <kfree>
f0119357:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011935a:	e8 aa b5 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011935f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119362:	74 17                	je     f011937b <test_kfree_bestfirstfit+0xd48>
f0119364:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011936b:	83 ec 0c             	sub    $0xc,%esp
f011936e:	68 ac cb 12 f0       	push   $0xf012cbac
f0119373:	e8 13 7c fe ff       	call   f0100f8b <cprintf>
f0119378:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011937b:	e8 f5 46 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119380:	89 c2                	mov    %eax,%edx
f0119382:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119385:	29 c2                	sub    %eax,%edx
f0119387:	89 d0                	mov    %edx,%eax
f0119389:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011938e:	77 17                	ja     f01193a7 <test_kfree_bestfirstfit+0xd74>
f0119390:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119397:	83 ec 0c             	sub    $0xc,%esp
f011939a:	68 1c cc 12 f0       	push   $0xf012cc1c
f011939f:	e8 e7 7b fe ff       	call   f0100f8b <cprintf>
f01193a4:	83 c4 10             	add    $0x10,%esp

			//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
			freeFrames = sys_calculate_free_frames() ;
f01193a7:	e8 c9 46 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01193ac:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01193af:	e8 55 b5 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01193b4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[4]);
f01193b7:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f01193bd:	83 ec 0c             	sub    $0xc,%esp
f01193c0:	50                   	push   %eax
f01193c1:	e8 d7 fb fe ff       	call   f0108f9d <kfree>
f01193c6:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01193c9:	e8 3b b5 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01193ce:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01193d1:	74 17                	je     f01193ea <test_kfree_bestfirstfit+0xdb7>
f01193d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01193da:	83 ec 0c             	sub    $0xc,%esp
f01193dd:	68 58 cc 12 f0       	push   $0xf012cc58
f01193e2:	e8 a4 7b fe ff       	call   f0100f8b <cprintf>
f01193e7:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("5.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f01193ea:	e8 86 46 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01193ef:	89 c2                	mov    %eax,%edx
f01193f1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01193f4:	29 c2                	sub    %eax,%edx
f01193f6:	89 d0                	mov    %edx,%eax
f01193f8:	83 f8 01             	cmp    $0x1,%eax
f01193fb:	77 17                	ja     f0119414 <test_kfree_bestfirstfit+0xde1>
f01193fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119404:	83 ec 0c             	sub    $0xc,%esp
f0119407:	68 c8 cc 12 f0       	push   $0xf012ccc8
f011940c:	e8 7a 7b fe ff       	call   f0100f8b <cprintf>
f0119411:	83 c4 10             	add    $0x10,%esp

			//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
			freeFrames = sys_calculate_free_frames() ;
f0119414:	e8 5c 46 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119419:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011941c:	e8 e8 b4 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119421:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[7]);
f0119424:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011942a:	83 ec 0c             	sub    $0xc,%esp
f011942d:	50                   	push   %eax
f011942e:	e8 6a fb fe ff       	call   f0108f9d <kfree>
f0119433:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119436:	e8 ce b4 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011943b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011943e:	74 17                	je     f0119457 <test_kfree_bestfirstfit+0xe24>
f0119440:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119447:	83 ec 0c             	sub    $0xc,%esp
f011944a:	68 04 cd 12 f0       	push   $0xf012cd04
f011944f:	e8 37 7b fe ff       	call   f0100f8b <cprintf>
f0119454:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("5.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119457:	e8 19 46 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011945c:	89 c2                	mov    %eax,%edx
f011945e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119461:	29 c2                	sub    %eax,%edx
f0119463:	89 d0                	mov    %edx,%eax
f0119465:	83 f8 03             	cmp    $0x3,%eax
f0119468:	77 17                	ja     f0119481 <test_kfree_bestfirstfit+0xe4e>
f011946a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119471:	83 ec 0c             	sub    $0xc,%esp
f0119474:	68 74 cd 12 f0       	push   $0xf012cd74
f0119479:	e8 0d 7b fe ff       	call   f0100f8b <cprintf>
f011947e:	83 c4 10             	add    $0x10,%esp

			//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
			freeFrames = sys_calculate_free_frames() ;
f0119481:	e8 ef 45 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119486:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119489:	e8 7b b4 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011948e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[10]);
f0119491:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119497:	83 ec 0c             	sub    $0xc,%esp
f011949a:	50                   	push   %eax
f011949b:	e8 fd fa fe ff       	call   f0108f9d <kfree>
f01194a0:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01194a3:	e8 61 b4 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01194a8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01194ab:	74 17                	je     f01194c4 <test_kfree_bestfirstfit+0xe91>
f01194ad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01194b4:	83 ec 0c             	sub    $0xc,%esp
f01194b7:	68 b0 cd 12 f0       	push   $0xf012cdb0
f01194bc:	e8 ca 7a fe ff       	call   f0100f8b <cprintf>
f01194c1:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("5.4 Wrong kfree: pages in memory are not freed correctly\n"); }
f01194c4:	e8 ac 45 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01194c9:	89 c2                	mov    %eax,%edx
f01194cb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01194ce:	29 c2                	sub    %eax,%edx
f01194d0:	89 d0                	mov    %edx,%eax
f01194d2:	3d ff 00 00 00       	cmp    $0xff,%eax
f01194d7:	77 17                	ja     f01194f0 <test_kfree_bestfirstfit+0xebd>
f01194d9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01194e0:	83 ec 0c             	sub    $0xc,%esp
f01194e3:	68 20 ce 12 f0       	push   $0xf012ce20
f01194e8:	e8 9e 7a fe ff       	call   f0100f8b <cprintf>
f01194ed:	83 c4 10             	add    $0x10,%esp

			//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
			freeFrames = sys_calculate_free_frames() ;
f01194f0:	e8 80 45 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01194f5:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01194f8:	e8 0c b4 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01194fd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[8]);
f0119500:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f0119506:	83 ec 0c             	sub    $0xc,%esp
f0119509:	50                   	push   %eax
f011950a:	e8 8e fa fe ff       	call   f0108f9d <kfree>
f011950f:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119512:	e8 f2 b3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119517:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011951a:	74 17                	je     f0119533 <test_kfree_bestfirstfit+0xf00>
f011951c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119523:	83 ec 0c             	sub    $0xc,%esp
f0119526:	68 5c ce 12 f0       	push   $0xf012ce5c
f011952b:	e8 5b 7a fe ff       	call   f0100f8b <cprintf>
f0119530:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("5.5 Wrong kfree: pages in memory are not freed correctly\n"); }
f0119533:	e8 3d 45 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119538:	89 c2                	mov    %eax,%edx
f011953a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011953d:	29 c2                	sub    %eax,%edx
f011953f:	89 d0                	mov    %edx,%eax
f0119541:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119546:	77 17                	ja     f011955f <test_kfree_bestfirstfit+0xf2c>
f0119548:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011954f:	83 ec 0c             	sub    $0xc,%esp
f0119552:	68 cc ce 12 f0       	push   $0xf012cecc
f0119557:	e8 2f 7a fe ff       	call   f0100f8b <cprintf>
f011955c:	83 c4 10             	add    $0x10,%esp
		}
		/*[BLOCK ALLOCATOR]*/
		{
			//kfree 1 KB [DYNAMIC ALLOCATOR]
			freeFrames = sys_calculate_free_frames() ;
f011955f:	e8 11 45 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119564:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119567:	e8 9d b3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011956c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[9]);
f011956f:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f0119575:	83 ec 0c             	sub    $0xc,%esp
f0119578:	50                   	push   %eax
f0119579:	e8 1f fa fe ff       	call   f0108f9d <kfree>
f011957e:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119581:	e8 83 b3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119586:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119589:	74 17                	je     f01195a2 <test_kfree_bestfirstfit+0xf6f>
f011958b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119592:	83 ec 0c             	sub    $0xc,%esp
f0119595:	68 08 cf 12 f0       	push   $0xf012cf08
f011959a:	e8 ec 79 fe ff       	call   f0100f8b <cprintf>
f011959f:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.6 Wrong kfree: pages in memory are not freed correctly\n"); }
f01195a2:	e8 ce 44 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01195a7:	89 c2                	mov    %eax,%edx
f01195a9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01195ac:	39 c2                	cmp    %eax,%edx
f01195ae:	74 17                	je     f01195c7 <test_kfree_bestfirstfit+0xf94>
f01195b0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01195b7:	83 ec 0c             	sub    $0xc,%esp
f01195ba:	68 78 cf 12 f0       	push   $0xf012cf78
f01195bf:	e8 c7 79 fe ff       	call   f0100f8b <cprintf>
f01195c4:	83 c4 10             	add    $0x10,%esp

			//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
			freeFrames = sys_calculate_free_frames() ;
f01195c7:	e8 a9 44 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01195cc:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01195cf:	e8 35 b3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01195d4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			kfree(ptr_allocations[3]);
f01195d7:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f01195dd:	83 ec 0c             	sub    $0xc,%esp
f01195e0:	50                   	push   %eax
f01195e1:	e8 b7 f9 fe ff       	call   f0108f9d <kfree>
f01195e6:	83 c4 10             	add    $0x10,%esp
			if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("5.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01195e9:	e8 1b b3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01195ee:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01195f1:	74 17                	je     f011960a <test_kfree_bestfirstfit+0xfd7>
f01195f3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01195fa:	83 ec 0c             	sub    $0xc,%esp
f01195fd:	68 b4 cf 12 f0       	push   $0xf012cfb4
f0119602:	e8 84 79 fe ff       	call   f0100f8b <cprintf>
f0119607:	83 c4 10             	add    $0x10,%esp
			if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("5.7 Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011960a:	e8 66 44 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011960f:	89 c2                	mov    %eax,%edx
f0119611:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0119614:	39 c2                	cmp    %eax,%edx
f0119616:	74 17                	je     f011962f <test_kfree_bestfirstfit+0xffc>
f0119618:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011961f:	83 ec 0c             	sub    $0xc,%esp
f0119622:	68 24 d0 12 f0       	push   $0xf012d024
f0119627:	e8 5f 79 fe ff       	call   f0100f8b <cprintf>
f011962c:	83 c4 10             	add    $0x10,%esp
		}
		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f011962f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119633:	74 04                	je     f0119639 <test_kfree_bestfirstfit+0x1006>
f0119635:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f0119639:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access of FREED area in PAGE allocator [15%]
	cprintf("\n6. Check memory access of FREED area in PAGE allocator [15%]\n");
f0119640:	83 ec 0c             	sub    $0xc,%esp
f0119643:	68 84 d0 12 f0       	push   $0xf012d084
f0119648:	e8 3e 79 fe ff       	call   f0100f8b <cprintf>
f011964d:	83 c4 10             	add    $0x10,%esp
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f0119650:	83 ec 0c             	sub    $0xc,%esp
f0119653:	6a 03                	push   $0x3
f0119655:	e8 0f 48 ff ff       	call   f010de69 <sys_bypassPageFault>
f011965a:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011965d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119664:	e9 af 00 00 00       	jmp    f0119718 <test_kfree_bestfirstfit+0x10e5>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f0119669:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011966d:	0f 84 a1 00 00 00    	je     f0119714 <test_kfree_bestfirstfit+0x10e1>
f0119673:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f0119677:	0f 84 97 00 00 00    	je     f0119714 <test_kfree_bestfirstfit+0x10e1>
f011967d:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f0119681:	0f 84 8d 00 00 00    	je     f0119714 <test_kfree_bestfirstfit+0x10e1>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f0119687:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011968a:	8b 84 85 c4 fe ff ff 	mov    -0x13c(%ebp,%eax,4),%eax
f0119691:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f0119694:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119697:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f011969a:	e8 b8 47 ff ff       	call   f010de57 <sys_rcr2>
f011969f:	89 c2                	mov    %eax,%edx
f01196a1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01196a4:	39 c2                	cmp    %eax,%edx
f01196a6:	74 1d                	je     f01196c5 <test_kfree_bestfirstfit+0x1092>
				if (correct)
f01196a8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01196ac:	74 17                	je     f01196c5 <test_kfree_bestfirstfit+0x1092>
				{ correct = 0; cprintf("6.1 kfree: successful access to freed space!! it should not be succeeded\n"); }
f01196ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01196b5:	83 ec 0c             	sub    $0xc,%esp
f01196b8:	68 c4 d0 12 f0       	push   $0xf012d0c4
f01196bd:	e8 c9 78 fe ff       	call   f0100f8b <cprintf>
f01196c2:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f01196c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01196c8:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f01196cf:	89 c2                	mov    %eax,%edx
f01196d1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01196d4:	01 d0                	add    %edx,%eax
f01196d6:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f01196d9:	e8 79 47 ff ff       	call   f010de57 <sys_rcr2>
f01196de:	89 c2                	mov    %eax,%edx
f01196e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01196e3:	8b 84 85 64 ff ff ff 	mov    -0x9c(%ebp,%eax,4),%eax
f01196ea:	89 c1                	mov    %eax,%ecx
f01196ec:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01196ef:	01 c8                	add    %ecx,%eax
f01196f1:	39 c2                	cmp    %eax,%edx
f01196f3:	74 20                	je     f0119715 <test_kfree_bestfirstfit+0x10e2>
				if (correct)
f01196f5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01196f9:	74 1a                	je     f0119715 <test_kfree_bestfirstfit+0x10e2>
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
f01196fb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119702:	83 ec 0c             	sub    $0xc,%esp
f0119705:	68 10 d1 12 f0       	push   $0xf012d110
f011970a:	e8 7c 78 fe ff       	call   f0100f8b <cprintf>
f011970f:	83 c4 10             	add    $0x10,%esp
f0119712:	eb 01                	jmp    f0119715 <test_kfree_bestfirstfit+0x10e2>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f0119714:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f0119715:	ff 45 f4             	incl   -0xc(%ebp)
f0119718:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011971c:	0f 8e 47 ff ff ff    	jle    f0119669 <test_kfree_bestfirstfit+0x1036>
				if (correct)
				{ correct = 0; cprintf("6.2 kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f0119722:	83 ec 0c             	sub    $0xc,%esp
f0119725:	6a 00                	push   $0x0
f0119727:	e8 3d 47 ff ff       	call   f010de69 <sys_bypassPageFault>
f011972c:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011972f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119733:	74 04                	je     f0119739 <test_kfree_bestfirstfit+0x1106>
f0119735:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f0119739:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	void* expected;
	//Allocate after kfree ALL [30%]
	cprintf("\n7. Allocate after kfree ALL [30%]\n");
f0119740:	83 ec 0c             	sub    $0xc,%esp
f0119743:	68 5c d1 12 f0       	push   $0xf012d15c
f0119748:	e8 3e 78 fe ff       	call   f0100f8b <cprintf>
f011974d:	83 c4 10             	add    $0x10,%esp
	{
		/*[DYNAMIC ALLOCATOR] Allocate in merged freed space*/
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f0119750:	e8 20 43 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119755:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119758:	e8 ac b1 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011975d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[11] = kmalloc(1*kilo);
f0119760:	83 ec 0c             	sub    $0xc,%esp
f0119763:	68 00 04 00 00       	push   $0x400
f0119768:	e8 c3 f6 fe ff       	call   f0108e30 <kmalloc>
f011976d:	83 c4 10             	add    $0x10,%esp
f0119770:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
			if (ptr_allocations[11] != ptr_allocations[2])
f0119776:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
f011977c:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119782:	39 c2                	cmp    %eax,%edx
f0119784:	74 17                	je     f011979d <test_kfree_bestfirstfit+0x116a>
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119786:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011978d:	83 ec 0c             	sub    $0xc,%esp
f0119790:	68 80 d1 12 f0       	push   $0xf012d180
f0119795:	e8 f1 77 fe ff       	call   f0100f8b <cprintf>
f011979a:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011979d:	e8 67 b1 fe ff       	call   f0104909 <pf_calculate_free_frames>
f01197a2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01197a5:	74 17                	je     f01197be <test_kfree_bestfirstfit+0x118b>
f01197a7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01197ae:	83 ec 0c             	sub    $0xc,%esp
f01197b1:	68 d4 d1 12 f0       	push   $0xf012d1d4
f01197b6:	e8 d0 77 fe ff       	call   f0100f8b <cprintf>
f01197bb:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f01197be:	e8 b2 42 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01197c3:	89 c2                	mov    %eax,%edx
f01197c5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01197c8:	39 c2                	cmp    %eax,%edx
f01197ca:	74 17                	je     f01197e3 <test_kfree_bestfirstfit+0x11b0>
f01197cc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01197d3:	83 ec 0c             	sub    $0xc,%esp
f01197d6:	68 44 d2 12 f0       	push   $0xf012d244
f01197db:	e8 ab 77 fe ff       	call   f0100f8b <cprintf>
f01197e0:	83 c4 10             	add    $0x10,%esp
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f01197e3:	c7 45 90 ff 03 00 00 	movl   $0x3ff,-0x70(%ebp)
			ptr = (char*)ptr_allocations[11];
f01197ea:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f01197f0:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f01197f3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01197fa:	eb 0e                	jmp    f011980a <test_kfree_bestfirstfit+0x11d7>
			{
				ptr[i] = 11 ;
f01197fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01197ff:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119802:	01 d0                	add    %edx,%eax
f0119804:	c6 00 0b             	movb   $0xb,(%eax)
			{ correct = 0; cprintf("7.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.1 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[11] = (1*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f0119807:	ff 45 f4             	incl   -0xc(%ebp)
f011980a:	8b 45 90             	mov    -0x70(%ebp),%eax
f011980d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119810:	7f ea                	jg     f01197fc <test_kfree_bestfirstfit+0x11c9>
			{
				ptr[i] = 11 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f0119812:	e8 5e 42 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119817:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011981a:	e8 ea b0 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011981f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[12] = kmalloc(2*kilo);
f0119822:	83 ec 0c             	sub    $0xc,%esp
f0119825:	68 00 08 00 00       	push   $0x800
f011982a:	e8 01 f6 fe ff       	call   f0108e30 <kmalloc>
f011982f:	83 c4 10             	add    $0x10,%esp
f0119832:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int);
f0119838:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011983e:	05 08 04 00 00       	add    $0x408,%eax
f0119843:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[12] != expected)
f0119846:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011984c:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011984f:	74 35                	je     f0119886 <test_kfree_bestfirstfit+0x1253>
			{
				correct = 0;
f0119851:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				cprintf("7.2 Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f0119858:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011985e:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f0119864:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011986a:	8b 95 cc fe ff ff    	mov    -0x134(%ebp),%edx
f0119870:	81 c2 00 04 00 00    	add    $0x400,%edx
f0119876:	50                   	push   %eax
f0119877:	51                   	push   %ecx
f0119878:	52                   	push   %edx
f0119879:	68 c0 d2 12 f0       	push   $0xf012d2c0
f011987e:	e8 08 77 fe ff       	call   f0100f8b <cprintf>
f0119883:	83 c4 10             	add    $0x10,%esp
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119886:	e8 7e b0 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011988b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011988e:	74 17                	je     f01198a7 <test_kfree_bestfirstfit+0x1274>
f0119890:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119897:	83 ec 0c             	sub    $0xc,%esp
f011989a:	68 34 d3 12 f0       	push   $0xf012d334
f011989f:	e8 e7 76 fe ff       	call   f0100f8b <cprintf>
f01198a4:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f01198a7:	e8 c9 41 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01198ac:	89 c2                	mov    %eax,%edx
f01198ae:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01198b1:	39 c2                	cmp    %eax,%edx
f01198b3:	74 17                	je     f01198cc <test_kfree_bestfirstfit+0x1299>
f01198b5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01198bc:	83 ec 0c             	sub    $0xc,%esp
f01198bf:	68 a4 d3 12 f0       	push   $0xf012d3a4
f01198c4:	e8 c2 76 fe ff       	call   f0100f8b <cprintf>
f01198c9:	83 c4 10             	add    $0x10,%esp
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f01198cc:	c7 45 94 ff 07 00 00 	movl   $0x7ff,-0x6c(%ebp)
			ptr = (char*)ptr_allocations[12];
f01198d3:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f01198d9:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f01198dc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01198e3:	eb 0e                	jmp    f01198f3 <test_kfree_bestfirstfit+0x12c0>
			{
				ptr[i] = 12 ;
f01198e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01198e8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01198eb:	01 d0                	add    %edx,%eax
f01198ed:	c6 00 0c             	movb   $0xc,(%eax)
			}
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.2 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[12] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f01198f0:	ff 45 f4             	incl   -0xc(%ebp)
f01198f3:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01198f6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01198f9:	7f ea                	jg     f01198e5 <test_kfree_bestfirstfit+0x12b2>
			{
				ptr[i] = 12 ;
			}

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f01198fb:	e8 75 41 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119900:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119903:	e8 01 b0 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119908:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[13] = kmalloc(3*kilo/2);
f011990b:	83 ec 0c             	sub    $0xc,%esp
f011990e:	68 00 06 00 00       	push   $0x600
f0119913:	e8 18 f5 fe ff       	call   f0108e30 <kmalloc>
f0119918:	83 c4 10             	add    $0x10,%esp
f011991b:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
			expected = ptr_allocations[2] + 1*kilo + 2*sizeof(int) + 2*kilo + 2*sizeof(int);
f0119921:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f0119927:	05 10 0c 00 00       	add    $0xc10,%eax
f011992c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			if (ptr_allocations[13] != expected)
f011992f:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f0119935:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0119938:	74 17                	je     f0119951 <test_kfree_bestfirstfit+0x131e>
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011993a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119941:	83 ec 0c             	sub    $0xc,%esp
f0119944:	68 20 d4 12 f0       	push   $0xf012d420
f0119949:	e8 3d 76 fe ff       	call   f0100f8b <cprintf>
f011994e:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119951:	e8 b3 af fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119956:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119959:	74 17                	je     f0119972 <test_kfree_bestfirstfit+0x133f>
f011995b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119962:	83 ec 0c             	sub    $0xc,%esp
f0119965:	68 74 d4 12 f0       	push   $0xf012d474
f011996a:	e8 1c 76 fe ff       	call   f0100f8b <cprintf>
f011996f:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f0119972:	e8 fe 40 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119977:	89 c2                	mov    %eax,%edx
f0119979:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011997c:	39 c2                	cmp    %eax,%edx
f011997e:	74 17                	je     f0119997 <test_kfree_bestfirstfit+0x1364>
f0119980:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119987:	83 ec 0c             	sub    $0xc,%esp
f011998a:	68 e4 d4 12 f0       	push   $0xf012d4e4
f011998f:	e8 f7 75 fe ff       	call   f0100f8b <cprintf>
f0119994:	83 c4 10             	add    $0x10,%esp
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f0119997:	c7 45 98 ff 05 00 00 	movl   $0x5ff,-0x68(%ebp)
			ptr = (char*)ptr_allocations[13];
f011999e:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f01199a4:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f01199a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01199ae:	eb 0e                	jmp    f01199be <test_kfree_bestfirstfit+0x138b>
			{
				ptr[i] = 13 ;
f01199b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01199b3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01199b6:	01 d0                	add    %edx,%eax
f01199b8:	c6 00 0d             	movb   $0xd,(%eax)
			{ correct = 0; cprintf("7.3 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("7.3 Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
			lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f01199bb:	ff 45 f4             	incl   -0xc(%ebp)
f01199be:	8b 45 98             	mov    -0x68(%ebp),%eax
f01199c1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01199c4:	7f ea                	jg     f01199b0 <test_kfree_bestfirstfit+0x137d>
		}

		/*[PAGE ALLOCATOR] Allocate in merged freed space*/
		{
			//30 MB
			freeFrames = sys_calculate_free_frames() ;
f01199c6:	e8 aa 40 ff ff       	call   f010da75 <sys_calculate_free_frames>
f01199cb:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f01199ce:	e8 36 af fe ff       	call   f0104909 <pf_calculate_free_frames>
f01199d3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[10] = kmalloc(30*Mega);
f01199d6:	83 ec 0c             	sub    $0xc,%esp
f01199d9:	68 00 00 e0 01       	push   $0x1e00000
f01199de:	e8 4d f4 fe ff       	call   f0108e30 <kmalloc>
f01199e3:	83 c4 10             	add    $0x10,%esp
f01199e6:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01199ec:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f01199f2:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f01199f7:	74 17                	je     f0119a10 <test_kfree_bestfirstfit+0x13dd>
f01199f9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a00:	83 ec 0c             	sub    $0xc,%esp
f0119a03:	68 60 d5 12 f0       	push   $0xf012d560
f0119a08:	e8 7e 75 fe ff       	call   f0100f8b <cprintf>
f0119a0d:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119a10:	e8 f4 ae fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119a15:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0119a18:	74 17                	je     f0119a31 <test_kfree_bestfirstfit+0x13fe>
f0119a1a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a21:	83 ec 0c             	sub    $0xc,%esp
f0119a24:	68 b4 d5 12 f0       	push   $0xf012d5b4
f0119a29:	e8 5d 75 fe ff       	call   f0100f8b <cprintf>
f0119a2e:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119a31:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f0119a34:	e8 3c 40 ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119a39:	29 c3                	sub    %eax,%ebx
f0119a3b:	89 d8                	mov    %ebx,%eax
f0119a3d:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f0119a42:	77 17                	ja     f0119a5b <test_kfree_bestfirstfit+0x1428>
f0119a44:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119a4b:	83 ec 0c             	sub    $0xc,%esp
f0119a4e:	68 24 d6 12 f0       	push   $0xf012d624
f0119a53:	e8 33 75 fe ff       	call   f0100f8b <cprintf>
f0119a58:	83 c4 10             	add    $0x10,%esp
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f0119a5b:	c7 45 8c ff ff df 01 	movl   $0x1dfffff,-0x74(%ebp)
			ptr = (char*)ptr_allocations[10];
f0119a62:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119a68:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f0119a6b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119a72:	eb 0e                	jmp    f0119a82 <test_kfree_bestfirstfit+0x144f>
			{
				ptr[i] = 10 ;
f0119a74:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119a77:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119a7a:	01 d0                	add    %edx,%eax
f0119a7c:	c6 00 0a             	movb   $0xa,(%eax)
			if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("7.4 Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("7.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("7.4 Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[10] = (30*Mega)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f0119a7f:	ff 45 f4             	incl   -0xc(%ebp)
f0119a82:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0119a85:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119a88:	7f ea                	jg     f0119a74 <test_kfree_bestfirstfit+0x1441>
		}

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
f0119a8a:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f0119a90:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[10]; ++i)
f0119a93:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119a9a:	eb 1e                	jmp    f0119aba <test_kfree_bestfirstfit+0x1487>
			{
				sums[10] += ptr[i] ;
f0119a9c:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f0119aa2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119aa5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119aa8:	01 c8                	add    %ecx,%eax
f0119aaa:	8a 00                	mov    (%eax),%al
f0119aac:	0f be c0             	movsbl %al,%eax
f0119aaf:	01 d0                	add    %edx,%eax
f0119ab1:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)

		/*Check Content*/
		{
			//30 MB
			ptr = (char*)ptr_allocations[10];
			for (i = 0; i < lastIndices[10]; ++i)
f0119ab7:	ff 45 f4             	incl   -0xc(%ebp)
f0119aba:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0119abd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119ac0:	7f da                	jg     f0119a9c <test_kfree_bestfirstfit+0x1469>
			{
				sums[10] += ptr[i] ;
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }
f0119ac2:	8b 8d 3c ff ff ff    	mov    -0xc4(%ebp),%ecx
f0119ac8:	8b 55 8c             	mov    -0x74(%ebp),%edx
f0119acb:	89 d0                	mov    %edx,%eax
f0119acd:	c1 e0 02             	shl    $0x2,%eax
f0119ad0:	01 d0                	add    %edx,%eax
f0119ad2:	01 c0                	add    %eax,%eax
f0119ad4:	39 c1                	cmp    %eax,%ecx
f0119ad6:	74 17                	je     f0119aef <test_kfree_bestfirstfit+0x14bc>
f0119ad8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119adf:	83 ec 0c             	sub    $0xc,%esp
f0119ae2:	68 6c d6 12 f0       	push   $0xf012d66c
f0119ae7:	e8 9f 74 fe ff       	call   f0100f8b <cprintf>
f0119aec:	83 c4 10             	add    $0x10,%esp

			//1 KB
			ptr = (char*)ptr_allocations[11];
f0119aef:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f0119af5:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[11]; ++i)
f0119af8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119aff:	eb 1e                	jmp    f0119b1f <test_kfree_bestfirstfit+0x14ec>
			{
				sums[11] += ptr[i] ;
f0119b01:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0119b07:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119b0a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119b0d:	01 c8                	add    %ecx,%eax
f0119b0f:	8a 00                	mov    (%eax),%al
f0119b11:	0f be c0             	movsbl %al,%eax
f0119b14:	01 d0                	add    %edx,%eax
f0119b16:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
			}
			if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("7.5 kfree: invalid read - data is corrupted\n"); }

			//1 KB
			ptr = (char*)ptr_allocations[11];
			for (i = 0; i < lastIndices[11]; ++i)
f0119b1c:	ff 45 f4             	incl   -0xc(%ebp)
f0119b1f:	8b 45 90             	mov    -0x70(%ebp),%eax
f0119b22:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119b25:	7f da                	jg     f0119b01 <test_kfree_bestfirstfit+0x14ce>
			{
				sums[11] += ptr[i] ;
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }
f0119b27:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0119b2d:	8b 55 90             	mov    -0x70(%ebp),%edx
f0119b30:	89 d0                	mov    %edx,%eax
f0119b32:	c1 e0 02             	shl    $0x2,%eax
f0119b35:	01 d0                	add    %edx,%eax
f0119b37:	01 c0                	add    %eax,%eax
f0119b39:	01 d0                	add    %edx,%eax
f0119b3b:	39 c1                	cmp    %eax,%ecx
f0119b3d:	74 17                	je     f0119b56 <test_kfree_bestfirstfit+0x1523>
f0119b3f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119b46:	83 ec 0c             	sub    $0xc,%esp
f0119b49:	68 9c d6 12 f0       	push   $0xf012d69c
f0119b4e:	e8 38 74 fe ff       	call   f0100f8b <cprintf>
f0119b53:	83 c4 10             	add    $0x10,%esp

			//2 KB
			ptr = (char*)ptr_allocations[12];
f0119b56:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f0119b5c:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[12]; ++i)
f0119b5f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119b66:	eb 1e                	jmp    f0119b86 <test_kfree_bestfirstfit+0x1553>
			{
				sums[12] += ptr[i] ;
f0119b68:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f0119b6e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119b71:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119b74:	01 c8                	add    %ecx,%eax
f0119b76:	8a 00                	mov    (%eax),%al
f0119b78:	0f be c0             	movsbl %al,%eax
f0119b7b:	01 d0                	add    %edx,%eax
f0119b7d:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
			}
			if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("7.6 kfree: invalid read - data is corrupted\n"); }

			//2 KB
			ptr = (char*)ptr_allocations[12];
			for (i = 0; i < lastIndices[12]; ++i)
f0119b83:	ff 45 f4             	incl   -0xc(%ebp)
f0119b86:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0119b89:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119b8c:	7f da                	jg     f0119b68 <test_kfree_bestfirstfit+0x1535>
			{
				sums[12] += ptr[i] ;
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }
f0119b8e:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f0119b94:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0119b97:	89 d0                	mov    %edx,%eax
f0119b99:	01 c0                	add    %eax,%eax
f0119b9b:	01 d0                	add    %edx,%eax
f0119b9d:	c1 e0 02             	shl    $0x2,%eax
f0119ba0:	39 c1                	cmp    %eax,%ecx
f0119ba2:	74 17                	je     f0119bbb <test_kfree_bestfirstfit+0x1588>
f0119ba4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119bab:	83 ec 0c             	sub    $0xc,%esp
f0119bae:	68 cc d6 12 f0       	push   $0xf012d6cc
f0119bb3:	e8 d3 73 fe ff       	call   f0100f8b <cprintf>
f0119bb8:	83 c4 10             	add    $0x10,%esp

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
f0119bbb:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f0119bc1:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[13]; ++i)
f0119bc4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119bcb:	eb 1e                	jmp    f0119beb <test_kfree_bestfirstfit+0x15b8>
			{
				sums[13] += ptr[i] ;
f0119bcd:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f0119bd3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0119bd6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119bd9:	01 c8                	add    %ecx,%eax
f0119bdb:	8a 00                	mov    (%eax),%al
f0119bdd:	0f be c0             	movsbl %al,%eax
f0119be0:	01 d0                	add    %edx,%eax
f0119be2:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
			}
			if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("7.7 kfree: invalid read - data is corrupted\n"); }

			//1.5 KB
			ptr = (char*)ptr_allocations[13];
			for (i = 0; i < lastIndices[13]; ++i)
f0119be8:	ff 45 f4             	incl   -0xc(%ebp)
f0119beb:	8b 45 98             	mov    -0x68(%ebp),%eax
f0119bee:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119bf1:	7f da                	jg     f0119bcd <test_kfree_bestfirstfit+0x159a>
			{
				sums[13] += ptr[i] ;
			}
			if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("7.8 kfree: invalid read - data is corrupted\n"); }
f0119bf3:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f0119bf9:	8b 55 98             	mov    -0x68(%ebp),%edx
f0119bfc:	89 d0                	mov    %edx,%eax
f0119bfe:	01 c0                	add    %eax,%eax
f0119c00:	01 d0                	add    %edx,%eax
f0119c02:	c1 e0 02             	shl    $0x2,%eax
f0119c05:	01 d0                	add    %edx,%eax
f0119c07:	39 c1                	cmp    %eax,%ecx
f0119c09:	74 17                	je     f0119c22 <test_kfree_bestfirstfit+0x15ef>
f0119c0b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c12:	83 ec 0c             	sub    $0xc,%esp
f0119c15:	68 fc d6 12 f0       	push   $0xf012d6fc
f0119c1a:	e8 6c 73 fe ff       	call   f0100f8b <cprintf>
f0119c1f:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)	eval+=30 ;
f0119c22:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119c26:	74 04                	je     f0119c2c <test_kfree_bestfirstfit+0x15f9>
f0119c28:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f0119c2c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
f0119c33:	83 ec 0c             	sub    $0xc,%esp
f0119c36:	68 29 d7 12 f0       	push   $0xf012d729
f0119c3b:	e8 4b 73 fe ff       	call   f0100f8b <cprintf>
f0119c40:	83 c4 10             	add    $0x10,%esp
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f0119c43:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f0119c4a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0119c51:	eb 4e                	jmp    f0119ca1 <test_kfree_bestfirstfit+0x166e>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f0119c53:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0119c56:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f0119c5b:	83 ec 04             	sub    $0x4,%esp
f0119c5e:	8d 8d c0 fe ff ff    	lea    -0x140(%ebp),%ecx
f0119c64:	51                   	push   %ecx
f0119c65:	52                   	push   %edx
f0119c66:	50                   	push   %eax
f0119c67:	e8 53 e8 fe ff       	call   f01084bf <get_page_table>
f0119c6c:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f0119c6f:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
f0119c75:	85 c0                	test   %eax,%eax
f0119c77:	75 1d                	jne    f0119c96 <test_kfree_bestfirstfit+0x1663>
			{
				if (correct)
f0119c79:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119c7d:	74 17                	je     f0119c96 <test_kfree_bestfirstfit+0x1663>
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f0119c7f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119c86:	83 ec 0c             	sub    $0xc,%esp
f0119c89:	68 48 d7 12 f0       	push   $0xf012d748
f0119c8e:	e8 f8 72 fe ff       	call   f0100f8b <cprintf>
f0119c93:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//check tables	[5%]
	cprintf("\n8. check page tables [5%]\n");
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f0119c96:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f0119c9d:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f0119ca1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0119ca5:	78 ac                	js     f0119c53 <test_kfree_bestfirstfit+0x1620>
f0119ca7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0119cab:	7f 09                	jg     f0119cb6 <test_kfree_bestfirstfit+0x1683>
f0119cad:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f0119cb4:	76 9d                	jbe    f0119c53 <test_kfree_bestfirstfit+0x1620>
				if (correct)
				{ correct = 0; cprintf("8 Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f0119cb6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0119cba:	74 04                	je     f0119cc0 <test_kfree_bestfirstfit+0x168d>
f0119cbc:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f0119cc0:	83 ec 08             	sub    $0x8,%esp
f0119cc3:	ff 75 f0             	pushl  -0x10(%ebp)
f0119cc6:	68 b0 d7 12 f0       	push   $0xf012d7b0
f0119ccb:	e8 bb 72 fe ff       	call   f0100f8b <cprintf>
f0119cd0:	83 c4 10             	add    $0x10,%esp

	return 1;
f0119cd3:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0119cd8:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0119cdb:	5b                   	pop    %ebx
f0119cdc:	5f                   	pop    %edi
f0119cdd:	5d                   	pop    %ebp
f0119cde:	c3                   	ret    

f0119cdf <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f0119cdf:	55                   	push   %ebp
f0119ce0:	89 e5                	mov    %esp,%ebp
f0119ce2:	57                   	push   %edi
f0119ce3:	53                   	push   %ebx
f0119ce4:	81 ec c0 35 00 00    	sub    $0x35c0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0119cea:	83 ec 0c             	sub    $0xc,%esp
f0119ced:	68 08 9a 12 f0       	push   $0xf0129a08
f0119cf2:	e8 94 72 fe ff       	call   f0100f8b <cprintf>
f0119cf7:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0119cfa:	83 ec 0c             	sub    $0xc,%esp
f0119cfd:	68 38 9a 12 f0       	push   $0xf0129a38
f0119d02:	e8 84 72 fe ff       	call   f0100f8b <cprintf>
f0119d07:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0119d0a:	83 ec 0c             	sub    $0xc,%esp
f0119d0d:	68 08 9a 12 f0       	push   $0xf0129a08
f0119d12:	e8 74 72 fe ff       	call   f0100f8b <cprintf>
f0119d17:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0119d1a:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f0119d1e:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f0119d22:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f0119d28:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f0119d2e:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f0119d35:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f0119d3c:	e8 34 3d ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119d41:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f0119d44:	83 ec 0c             	sub    $0xc,%esp
f0119d47:	68 d4 d7 12 f0       	push   $0xf012d7d4
f0119d4c:	e8 3a 72 fe ff       	call   f0100f8b <cprintf>
f0119d51:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f0119d54:	8d 95 10 ff ff ff    	lea    -0xf0(%ebp),%edx
f0119d5a:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119d5f:	b8 00 00 00 00       	mov    $0x0,%eax
f0119d64:	89 d7                	mov    %edx,%edi
f0119d66:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f0119d68:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
f0119d6e:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119d73:	b8 00 00 00 00       	mov    $0x0,%eax
f0119d78:	89 d7                	mov    %edx,%edi
f0119d7a:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f0119d7c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f0119d83:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f0119d8a:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f0119d90:	b9 14 00 00 00       	mov    $0x14,%ecx
f0119d95:	b8 00 00 00 00       	mov    $0x0,%eax
f0119d9a:	89 d7                	mov    %edx,%edi
f0119d9c:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f0119d9e:	e8 d2 3c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119da3:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119da6:	e8 5e ab fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119dab:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f0119dae:	83 ec 0c             	sub    $0xc,%esp
f0119db1:	68 00 fc 1f 00       	push   $0x1ffc00
f0119db6:	e8 75 f0 fe ff       	call   f0108e30 <kmalloc>
f0119dbb:	83 c4 10             	add    $0x10,%esp
f0119dbe:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119dc4:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f0119dca:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119dcf:	74 17                	je     f0119de8 <test_kheap_phys_addr+0x109>
f0119dd1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119dd8:	83 ec 0c             	sub    $0xc,%esp
f0119ddb:	68 24 bb 12 f0       	push   $0xf012bb24
f0119de0:	e8 a6 71 fe ff       	call   f0100f8b <cprintf>
f0119de5:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119de8:	e8 1c ab fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119ded:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119df0:	74 17                	je     f0119e09 <test_kheap_phys_addr+0x12a>
f0119df2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119df9:	83 ec 0c             	sub    $0xc,%esp
f0119dfc:	68 78 bb 12 f0       	push   $0xf012bb78
f0119e01:	e8 85 71 fe ff       	call   f0100f8b <cprintf>
f0119e06:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119e09:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0119e0c:	e8 64 3c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119e11:	29 c3                	sub    %eax,%ebx
f0119e13:	89 d8                	mov    %ebx,%eax
f0119e15:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119e1a:	77 17                	ja     f0119e33 <test_kheap_phys_addr+0x154>
f0119e1c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e23:	83 ec 0c             	sub    $0xc,%esp
f0119e26:	68 e8 bb 12 f0       	push   $0xf012bbe8
f0119e2b:	e8 5b 71 fe ff       	call   f0100f8b <cprintf>
f0119e30:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f0119e33:	e8 3d 3c ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119e38:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0119e3b:	e8 c9 aa fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119e40:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f0119e43:	83 ec 0c             	sub    $0xc,%esp
f0119e46:	68 00 fc 1f 00       	push   $0x1ffc00
f0119e4b:	e8 e0 ef fe ff       	call   f0108e30 <kmalloc>
f0119e50:	83 c4 10             	add    $0x10,%esp
f0119e53:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0119e59:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f0119e5f:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0119e64:	74 17                	je     f0119e7d <test_kheap_phys_addr+0x19e>
f0119e66:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e6d:	83 ec 0c             	sub    $0xc,%esp
f0119e70:	68 30 bc 12 f0       	push   $0xf012bc30
f0119e75:	e8 11 71 fe ff       	call   f0100f8b <cprintf>
f0119e7a:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e7d:	e8 87 aa fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119e82:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119e85:	74 17                	je     f0119e9e <test_kheap_phys_addr+0x1bf>
f0119e87:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119e8e:	83 ec 0c             	sub    $0xc,%esp
f0119e91:	68 84 bc 12 f0       	push   $0xf012bc84
f0119e96:	e8 f0 70 fe ff       	call   f0100f8b <cprintf>
f0119e9b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f0119e9e:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0119ea1:	e8 cf 3b ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119ea6:	29 c3                	sub    %eax,%ebx
f0119ea8:	89 d8                	mov    %ebx,%eax
f0119eaa:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119eaf:	77 17                	ja     f0119ec8 <test_kheap_phys_addr+0x1e9>
f0119eb1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119eb8:	83 ec 0c             	sub    $0xc,%esp
f0119ebb:	68 f4 bc 12 f0       	push   $0xf012bcf4
f0119ec0:	e8 c6 70 fe ff       	call   f0100f8b <cprintf>
f0119ec5:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f0119ec8:	e8 a8 3b ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119ecd:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119ed0:	e8 34 aa fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119ed5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f0119ed8:	83 ec 0c             	sub    $0xc,%esp
f0119edb:	68 00 04 00 00       	push   $0x400
f0119ee0:	e8 4b ef fe ff       	call   f0108e30 <kmalloc>
f0119ee5:	83 c4 10             	add    $0x10,%esp
f0119ee8:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f0119eee:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f0119ef4:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119ef9:	76 28                	jbe    f0119f23 <test_kheap_phys_addr+0x244>
f0119efb:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f0119f01:	83 ec 0c             	sub    $0xc,%esp
f0119f04:	6a 00                	push   $0x0
f0119f06:	e8 2a ee fe ff       	call   f0108d35 <sbrk>
f0119f0b:	83 c4 10             	add    $0x10,%esp
f0119f0e:	39 c3                	cmp    %eax,%ebx
f0119f10:	73 11                	jae    f0119f23 <test_kheap_phys_addr+0x244>
f0119f12:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f0119f18:	89 c2                	mov    %eax,%edx
f0119f1a:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0119f1f:	39 c2                	cmp    %eax,%edx
f0119f21:	72 17                	jb     f0119f3a <test_kheap_phys_addr+0x25b>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119f23:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f2a:	83 ec 0c             	sub    $0xc,%esp
f0119f2d:	68 04 d8 12 f0       	push   $0xf012d804
f0119f32:	e8 54 70 fe ff       	call   f0100f8b <cprintf>
f0119f37:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119f3a:	e8 ca a9 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119f3f:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119f42:	74 17                	je     f0119f5b <test_kheap_phys_addr+0x27c>
f0119f44:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119f4b:	83 ec 0c             	sub    $0xc,%esp
f0119f4e:	68 90 bd 12 f0       	push   $0xf012bd90
f0119f53:	e8 33 70 fe ff       	call   f0100f8b <cprintf>
f0119f58:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f0119f5b:	e8 15 3b ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119f60:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119f63:	e8 a1 a9 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119f68:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f0119f6b:	83 ec 0c             	sub    $0xc,%esp
f0119f6e:	68 00 08 00 00       	push   $0x800
f0119f73:	e8 b8 ee fe ff       	call   f0108e30 <kmalloc>
f0119f78:	83 c4 10             	add    $0x10,%esp
f0119f7b:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0119f81:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f0119f87:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119f8c:	76 28                	jbe    f0119fb6 <test_kheap_phys_addr+0x2d7>
f0119f8e:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f0119f94:	83 ec 0c             	sub    $0xc,%esp
f0119f97:	6a 00                	push   $0x0
f0119f99:	e8 97 ed fe ff       	call   f0108d35 <sbrk>
f0119f9e:	83 c4 10             	add    $0x10,%esp
f0119fa1:	39 c3                	cmp    %eax,%ebx
f0119fa3:	73 11                	jae    f0119fb6 <test_kheap_phys_addr+0x2d7>
f0119fa5:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f0119fab:	89 c2                	mov    %eax,%edx
f0119fad:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f0119fb2:	39 c2                	cmp    %eax,%edx
f0119fb4:	72 17                	jb     f0119fcd <test_kheap_phys_addr+0x2ee>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119fb6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119fbd:	83 ec 0c             	sub    $0xc,%esp
f0119fc0:	68 90 d8 12 f0       	push   $0xf012d890
f0119fc5:	e8 c1 6f fe ff       	call   f0100f8b <cprintf>
f0119fca:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119fcd:	e8 37 a9 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119fd2:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0119fd5:	74 17                	je     f0119fee <test_kheap_phys_addr+0x30f>
f0119fd7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0119fde:	83 ec 0c             	sub    $0xc,%esp
f0119fe1:	68 9c be 12 f0       	push   $0xf012be9c
f0119fe6:	e8 a0 6f fe ff       	call   f0100f8b <cprintf>
f0119feb:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f0119fee:	e8 82 3a ff ff       	call   f010da75 <sys_calculate_free_frames>
f0119ff3:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f0119ff6:	e8 0e a9 fe ff       	call   f0104909 <pf_calculate_free_frames>
f0119ffb:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f0119ffe:	83 ec 0c             	sub    $0xc,%esp
f011a001:	68 00 06 00 00       	push   $0x600
f011a006:	e8 25 ee fe ff       	call   f0108e30 <kmalloc>
f011a00b:	83 c4 10             	add    $0x10,%esp
f011a00e:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011a014:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011a01a:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a01f:	76 28                	jbe    f011a049 <test_kheap_phys_addr+0x36a>
f011a021:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011a027:	83 ec 0c             	sub    $0xc,%esp
f011a02a:	6a 00                	push   $0x0
f011a02c:	e8 04 ed fe ff       	call   f0108d35 <sbrk>
f011a031:	83 c4 10             	add    $0x10,%esp
f011a034:	39 c3                	cmp    %eax,%ebx
f011a036:	73 11                	jae    f011a049 <test_kheap_phys_addr+0x36a>
f011a038:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011a03e:	89 c2                	mov    %eax,%edx
f011a040:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f011a045:	39 c2                	cmp    %eax,%edx
f011a047:	72 17                	jb     f011a060 <test_kheap_phys_addr+0x381>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a049:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a050:	83 ec 0c             	sub    $0xc,%esp
f011a053:	68 1c d9 12 f0       	push   $0xf012d91c
f011a058:	e8 2e 6f fe ff       	call   f0100f8b <cprintf>
f011a05d:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a060:	e8 a4 a8 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011a065:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a068:	74 17                	je     f011a081 <test_kheap_phys_addr+0x3a2>
f011a06a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a071:	83 ec 0c             	sub    $0xc,%esp
f011a074:	68 a8 bf 12 f0       	push   $0xf012bfa8
f011a079:	e8 0d 6f fe ff       	call   f0100f8b <cprintf>
f011a07e:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011a081:	e8 ef 39 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011a086:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a089:	e8 7b a8 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011a08e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011a091:	83 ec 0c             	sub    $0xc,%esp
f011a094:	68 00 1c 00 00       	push   $0x1c00
f011a099:	e8 92 ed fe ff       	call   f0108e30 <kmalloc>
f011a09e:	83 c4 10             	add    $0x10,%esp
f011a0a1:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\nwefound--%xinsted--%x",(uint32) ptr_allocations[5],ACTUAL_START + 4*Mega); }
f011a0a7:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011a0ad:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011a0b2:	74 23                	je     f011a0d7 <test_kheap_phys_addr+0x3f8>
f011a0b4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0bb:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011a0c1:	83 ec 04             	sub    $0x4,%esp
f011a0c4:	68 00 10 40 f8       	push   $0xf8401000
f011a0c9:	50                   	push   %eax
f011a0ca:	68 a8 d9 12 f0       	push   $0xf012d9a8
f011a0cf:	e8 b7 6e fe ff       	call   f0100f8b <cprintf>
f011a0d4:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a0d7:	e8 2d a8 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011a0dc:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a0df:	74 17                	je     f011a0f8 <test_kheap_phys_addr+0x419>
f011a0e1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a0e8:	83 ec 0c             	sub    $0xc,%esp
f011a0eb:	68 b4 c0 12 f0       	push   $0xf012c0b4
f011a0f0:	e8 96 6e fe ff       	call   f0100f8b <cprintf>
f011a0f5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a0f8:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011a0fb:	e8 75 39 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011a100:	29 c3                	sub    %eax,%ebx
f011a102:	89 d8                	mov    %ebx,%eax
f011a104:	83 f8 01             	cmp    $0x1,%eax
f011a107:	77 17                	ja     f011a120 <test_kheap_phys_addr+0x441>
f011a109:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a110:	83 ec 0c             	sub    $0xc,%esp
f011a113:	68 24 c1 12 f0       	push   $0xf012c124
f011a118:	e8 6e 6e fe ff       	call   f0100f8b <cprintf>
f011a11d:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011a120:	e8 50 39 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011a125:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a128:	e8 dc a7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011a12d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011a130:	83 ec 0c             	sub    $0xc,%esp
f011a133:	68 00 fc 2f 00       	push   $0x2ffc00
f011a138:	e8 f3 ec fe ff       	call   f0108e30 <kmalloc>
f011a13d:	83 c4 10             	add    $0x10,%esp
f011a140:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a146:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011a14c:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011a151:	74 17                	je     f011a16a <test_kheap_phys_addr+0x48b>
f011a153:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a15a:	83 ec 0c             	sub    $0xc,%esp
f011a15d:	68 14 da 12 f0       	push   $0xf012da14
f011a162:	e8 24 6e fe ff       	call   f0100f8b <cprintf>
f011a167:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a16a:	e8 9a a7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011a16f:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a172:	74 17                	je     f011a18b <test_kheap_phys_addr+0x4ac>
f011a174:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a17b:	83 ec 0c             	sub    $0xc,%esp
f011a17e:	68 f8 c1 12 f0       	push   $0xf012c1f8
f011a183:	e8 03 6e fe ff       	call   f0100f8b <cprintf>
f011a188:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a18b:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011a18e:	e8 e2 38 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011a193:	29 c3                	sub    %eax,%ebx
f011a195:	89 d8                	mov    %ebx,%eax
f011a197:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a19c:	77 17                	ja     f011a1b5 <test_kheap_phys_addr+0x4d6>
f011a19e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1a5:	83 ec 0c             	sub    $0xc,%esp
f011a1a8:	68 68 da 12 f0       	push   $0xf012da68
f011a1ad:	e8 d9 6d fe ff       	call   f0100f8b <cprintf>
f011a1b2:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011a1b5:	e8 bb 38 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011a1ba:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a1bd:	e8 47 a7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011a1c2:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011a1c5:	83 ec 0c             	sub    $0xc,%esp
f011a1c8:	68 00 fc 5f 00       	push   $0x5ffc00
f011a1cd:	e8 5e ec fe ff       	call   f0108e30 <kmalloc>
f011a1d2:	83 c4 10             	add    $0x10,%esp
f011a1d5:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a1db:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011a1e1:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011a1e6:	74 17                	je     f011a1ff <test_kheap_phys_addr+0x520>
f011a1e8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a1ef:	83 ec 0c             	sub    $0xc,%esp
f011a1f2:	68 b0 da 12 f0       	push   $0xf012dab0
f011a1f7:	e8 8f 6d fe ff       	call   f0100f8b <cprintf>
f011a1fc:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a1ff:	e8 05 a7 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011a204:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a207:	74 17                	je     f011a220 <test_kheap_phys_addr+0x541>
f011a209:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a210:	83 ec 0c             	sub    $0xc,%esp
f011a213:	68 f4 c2 12 f0       	push   $0xf012c2f4
f011a218:	e8 6e 6d fe ff       	call   f0100f8b <cprintf>
f011a21d:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a220:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011a223:	e8 4d 38 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011a228:	29 c3                	sub    %eax,%ebx
f011a22a:	89 d8                	mov    %ebx,%eax
f011a22c:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011a231:	77 17                	ja     f011a24a <test_kheap_phys_addr+0x56b>
f011a233:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a23a:	83 ec 0c             	sub    $0xc,%esp
f011a23d:	68 04 db 12 f0       	push   $0xf012db04
f011a242:	e8 44 6d fe ff       	call   f0100f8b <cprintf>
f011a247:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011a24a:	e8 26 38 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011a24f:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a252:	e8 b2 a6 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011a257:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011a25a:	83 ec 0c             	sub    $0xc,%esp
f011a25d:	68 00 38 00 00       	push   $0x3800
f011a262:	e8 c9 eb fe ff       	call   f0108e30 <kmalloc>
f011a267:	83 c4 10             	add    $0x10,%esp
f011a26a:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a270:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011a276:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011a27b:	74 17                	je     f011a294 <test_kheap_phys_addr+0x5b5>
f011a27d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a284:	83 ec 0c             	sub    $0xc,%esp
f011a287:	68 4c db 12 f0       	push   $0xf012db4c
f011a28c:	e8 fa 6c fe ff       	call   f0100f8b <cprintf>
f011a291:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a294:	e8 70 a6 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011a299:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011a29c:	74 17                	je     f011a2b5 <test_kheap_phys_addr+0x5d6>
f011a29e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2a5:	83 ec 0c             	sub    $0xc,%esp
f011a2a8:	68 a0 db 12 f0       	push   $0xf012dba0
f011a2ad:	e8 d9 6c fe ff       	call   f0100f8b <cprintf>
f011a2b2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a2b5:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011a2b8:	e8 b8 37 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011a2bd:	29 c3                	sub    %eax,%ebx
f011a2bf:	89 d8                	mov    %ebx,%eax
f011a2c1:	83 f8 03             	cmp    $0x3,%eax
f011a2c4:	77 17                	ja     f011a2dd <test_kheap_phys_addr+0x5fe>
f011a2c6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a2cd:	83 ec 0c             	sub    $0xc,%esp
f011a2d0:	68 10 dc 12 f0       	push   $0xf012dc10
f011a2d5:	e8 b1 6c fe ff       	call   f0100f8b <cprintf>
f011a2da:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]\n");
f011a2dd:	83 ec 0c             	sub    $0xc,%esp
f011a2e0:	68 58 dc 12 f0       	push   $0xf012dc58
f011a2e5:	e8 a1 6c fe ff       	call   f0100f8b <cprintf>
f011a2ea:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011a2ed:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011a2f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011a2fb:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011a302:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f011a307:	05 00 10 00 00       	add    $0x1000,%eax
f011a30c:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011a30f:	8b 45 98             	mov    -0x68(%ebp),%eax
f011a312:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011a315:	eb 2e                	jmp    f011a345 <test_kheap_phys_addr+0x666>
		{
			allPAs[i++] = kheap_physical_address(va);
f011a317:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011a31a:	8d 43 01             	lea    0x1(%ebx),%eax
f011a31d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011a320:	83 ec 0c             	sub    $0xc,%esp
f011a323:	ff 75 e8             	pushl  -0x18(%ebp)
f011a326:	e8 6b ed fe ff       	call   f0109096 <kheap_physical_address>
f011a32b:	83 c4 10             	add    $0x10,%esp
f011a32e:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011a335:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011a338:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a33b:	01 d0                	add    %edx,%eax
f011a33d:	05 00 10 00 00       	add    $0x1000,%eax
f011a342:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011a345:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a348:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011a34b:	72 ca                	jb     f011a317 <test_kheap_phys_addr+0x638>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011a34d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a350:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011a353:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011a35a:	8b 45 98             	mov    -0x68(%ebp),%eax
f011a35d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011a360:	e9 ce 00 00 00       	jmp    f011a433 <test_kheap_phys_addr+0x754>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011a365:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011a36a:	83 ec 04             	sub    $0x4,%esp
f011a36d:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011a373:	52                   	push   %edx
f011a374:	ff 75 e8             	pushl  -0x18(%ebp)
f011a377:	50                   	push   %eax
f011a378:	e8 42 e1 fe ff       	call   f01084bf <get_page_table>
f011a37d:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a380:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011a386:	85 c0                	test   %eax,%eax
f011a388:	75 1e                	jne    f011a3a8 <test_kheap_phys_addr+0x6c9>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011a38a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a391:	83 ec 04             	sub    $0x4,%esp
f011a394:	68 a4 dc 12 f0       	push   $0xf012dca4
f011a399:	68 f8 05 00 00       	push   $0x5f8
f011a39e:	68 77 b9 12 f0       	push   $0xf012b977
f011a3a3:	e8 91 5f fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011a3a8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a3ab:	c1 e8 0c             	shr    $0xc,%eax
f011a3ae:	25 ff 03 00 00       	and    $0x3ff,%eax
f011a3b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011a3b6:	eb 62                	jmp    f011a41a <test_kheap_phys_addr+0x73b>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011a3b8:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011a3be:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011a3c1:	c1 e2 02             	shl    $0x2,%edx
f011a3c4:	01 d0                	add    %edx,%eax
f011a3c6:	8b 00                	mov    (%eax),%eax
f011a3c8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a3cd:	89 c2                	mov    %eax,%edx
f011a3cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a3d2:	25 ff 0f 00 00       	and    $0xfff,%eax
f011a3d7:	01 c2                	add    %eax,%edx
f011a3d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a3dc:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011a3e3:	39 c2                	cmp    %eax,%edx
f011a3e5:	74 1d                	je     f011a404 <test_kheap_phys_addr+0x725>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011a3e7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a3eb:	74 17                	je     f011a404 <test_kheap_phys_addr+0x725>
					{ correct = 0; cprintf("2.2 Wrong kheap_physical_address\n"); }
f011a3ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3f4:	83 ec 0c             	sub    $0xc,%esp
f011a3f7:	68 04 dd 12 f0       	push   $0xf012dd04
f011a3fc:	e8 8a 6b fe ff       	call   f0100f8b <cprintf>
f011a401:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011a404:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011a407:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a40a:	01 d0                	add    %edx,%eax
f011a40c:	05 00 10 00 00       	add    $0x1000,%eax
f011a411:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011a414:	ff 45 e4             	incl   -0x1c(%ebp)
f011a417:	ff 45 f4             	incl   -0xc(%ebp)
f011a41a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a41d:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011a420:	7d 11                	jge    f011a433 <test_kheap_phys_addr+0x754>
f011a422:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011a429:	7f 08                	jg     f011a433 <test_kheap_phys_addr+0x754>
f011a42b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a42e:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011a431:	72 85                	jb     f011a3b8 <test_kheap_phys_addr+0x6d9>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011a433:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a436:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011a439:	0f 82 26 ff ff ff    	jb     f011a365 <test_kheap_phys_addr+0x686>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011a43f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a443:	74 04                	je     f011a449 <test_kheap_phys_addr+0x76a>
f011a445:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011a449:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
f011a450:	83 ec 0c             	sub    $0xc,%esp
f011a453:	68 28 dd 12 f0       	push   $0xf012dd28
f011a458:	e8 2e 6b fe ff       	call   f0100f8b <cprintf>
f011a45d:	83 c4 10             	add    $0x10,%esp
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011a460:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011a467:	e9 b0 00 00 00       	jmp    f011a51c <test_kheap_phys_addr+0x83d>
		{
			va = (uint32)ptr_allocations[i];
f011a46c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011a46f:	8b 84 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%eax
f011a476:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011a479:	83 ec 0c             	sub    $0xc,%esp
f011a47c:	ff 75 90             	pushl  -0x70(%ebp)
f011a47f:	e8 12 ec fe ff       	call   f0109096 <kheap_physical_address>
f011a484:	83 c4 10             	add    $0x10,%esp
f011a487:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011a48a:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011a48f:	83 ec 04             	sub    $0x4,%esp
f011a492:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011a498:	52                   	push   %edx
f011a499:	ff 75 90             	pushl  -0x70(%ebp)
f011a49c:	50                   	push   %eax
f011a49d:	e8 1d e0 fe ff       	call   f01084bf <get_page_table>
f011a4a2:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a4a5:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011a4ab:	85 c0                	test   %eax,%eax
f011a4ad:	75 1e                	jne    f011a4cd <test_kheap_phys_addr+0x7ee>
			{ correct = 0; panic("3.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011a4af:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4b6:	83 ec 04             	sub    $0x4,%esp
f011a4b9:	68 78 dd 12 f0       	push   $0xf012dd78
f011a4be:	68 15 06 00 00       	push   $0x615
f011a4c3:	68 77 b9 12 f0       	push   $0xf012b977
f011a4c8:	e8 6c 5e fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011a4cd:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011a4d3:	8b 55 90             	mov    -0x70(%ebp),%edx
f011a4d6:	c1 ea 0c             	shr    $0xc,%edx
f011a4d9:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011a4df:	c1 e2 02             	shl    $0x2,%edx
f011a4e2:	01 d0                	add    %edx,%eax
f011a4e4:	8b 00                	mov    (%eax),%eax
f011a4e6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a4eb:	89 c2                	mov    %eax,%edx
f011a4ed:	8b 45 90             	mov    -0x70(%ebp),%eax
f011a4f0:	25 ff 0f 00 00       	and    $0xfff,%eax
f011a4f5:	01 d0                	add    %edx,%eax
f011a4f7:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011a4fa:	74 1d                	je     f011a519 <test_kheap_phys_addr+0x83a>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011a4fc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a500:	74 17                	je     f011a519 <test_kheap_phys_addr+0x83a>
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
f011a502:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a509:	83 ec 0c             	sub    $0xc,%esp
f011a50c:	68 d8 dd 12 f0       	push   $0xf012ddd8
f011a511:	e8 75 6a fe ff       	call   f0100f8b <cprintf>
f011a516:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	cprintf("\n3. [DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]\n");
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011a519:	ff 45 e0             	incl   -0x20(%ebp)
f011a51c:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011a520:	0f 8e 46 ff ff ff    	jle    f011a46c <test_kheap_phys_addr+0x78d>
				if (correct)
				{ correct = 0; cprintf("3.2 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011a526:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a52a:	74 04                	je     f011a530 <test_kheap_phys_addr+0x851>
f011a52c:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011a530:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n4. kfree some of the allocated spaces\n");
f011a537:	83 ec 0c             	sub    $0xc,%esp
f011a53a:	68 fc dd 12 f0       	push   $0xf012ddfc
f011a53f:	e8 47 6a fe ff       	call   f0100f8b <cprintf>
f011a544:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011a547:	e8 29 35 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011a54c:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011a54f:	e8 b5 a3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011a554:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011a557:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011a55d:	83 ec 0c             	sub    $0xc,%esp
f011a560:	50                   	push   %eax
f011a561:	e8 37 ea fe ff       	call   f0108f9d <kfree>
f011a566:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a569:	e8 9b a3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011a56e:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011a571:	74 17                	je     f011a58a <test_kheap_phys_addr+0x8ab>
f011a573:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a57a:	83 ec 0c             	sub    $0xc,%esp
f011a57d:	68 7c c8 12 f0       	push   $0xf012c87c
f011a582:	e8 04 6a fe ff       	call   f0100f8b <cprintf>
f011a587:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("4.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a58a:	e8 e6 34 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011a58f:	89 c2                	mov    %eax,%edx
f011a591:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a594:	29 c2                	sub    %eax,%edx
f011a596:	89 d0                	mov    %edx,%eax
f011a598:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a59d:	77 17                	ja     f011a5b6 <test_kheap_phys_addr+0x8d7>
f011a59f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5a6:	83 ec 0c             	sub    $0xc,%esp
f011a5a9:	68 24 de 12 f0       	push   $0xf012de24
f011a5ae:	e8 d8 69 fe ff       	call   f0100f8b <cprintf>
f011a5b3:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a5b6:	e8 ba 34 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011a5bb:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a5be:	e8 46 a3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011a5c3:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011a5c6:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011a5cc:	83 ec 0c             	sub    $0xc,%esp
f011a5cf:	50                   	push   %eax
f011a5d0:	e8 c8 e9 fe ff       	call   f0108f9d <kfree>
f011a5d5:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a5d8:	e8 2c a3 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011a5dd:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011a5e0:	74 17                	je     f011a5f9 <test_kheap_phys_addr+0x91a>
f011a5e2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5e9:	83 ec 0c             	sub    $0xc,%esp
f011a5ec:	68 bc c9 12 f0       	push   $0xf012c9bc
f011a5f1:	e8 95 69 fe ff       	call   f0100f8b <cprintf>
f011a5f6:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("4.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a5f9:	e8 77 34 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011a5fe:	89 c2                	mov    %eax,%edx
f011a600:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a603:	29 c2                	sub    %eax,%edx
f011a605:	89 d0                	mov    %edx,%eax
f011a607:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a60c:	77 17                	ja     f011a625 <test_kheap_phys_addr+0x946>
f011a60e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a615:	83 ec 0c             	sub    $0xc,%esp
f011a618:	68 60 de 12 f0       	push   $0xf012de60
f011a61d:	e8 69 69 fe ff       	call   f0100f8b <cprintf>
f011a622:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011a625:	e8 4b 34 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011a62a:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a62d:	e8 d7 a2 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011a632:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011a635:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011a63b:	83 ec 0c             	sub    $0xc,%esp
f011a63e:	50                   	push   %eax
f011a63f:	e8 59 e9 fe ff       	call   f0108f9d <kfree>
f011a644:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("4.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a647:	e8 bd a2 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011a64c:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011a64f:	74 17                	je     f011a668 <test_kheap_phys_addr+0x989>
f011a651:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a658:	83 ec 0c             	sub    $0xc,%esp
f011a65b:	68 c8 ca 12 f0       	push   $0xf012cac8
f011a660:	e8 26 69 fe ff       	call   f0100f8b <cprintf>
f011a665:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("4.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011a668:	e8 08 34 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011a66d:	89 c2                	mov    %eax,%edx
f011a66f:	8b 45 88             	mov    -0x78(%ebp),%eax
f011a672:	29 c2                	sub    %eax,%edx
f011a674:	89 d0                	mov    %edx,%eax
f011a676:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011a67b:	77 17                	ja     f011a694 <test_kheap_phys_addr+0x9b5>
f011a67d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a684:	83 ec 0c             	sub    $0xc,%esp
f011a687:	68 9c de 12 f0       	push   $0xf012de9c
f011a68c:	e8 fa 68 fe ff       	call   f0100f8b <cprintf>
f011a691:	83 c4 10             	add    $0x10,%esp
	}

	uint32 expected;
	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	cprintf("\n5. [PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]\n");
f011a694:	83 ec 0c             	sub    $0xc,%esp
f011a697:	68 d8 de 12 f0       	push   $0xf012ded8
f011a69c:	e8 ea 68 fe ff       	call   f0100f8b <cprintf>
f011a6a1:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011a6a4:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011a6ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 121;
f011a6b2:	c7 85 7c ff ff ff 79 	movl   $0x79,-0x84(%ebp)
f011a6b9:	00 00 00 
		uint32 startVA = da_limit + PAGE_SIZE+offset;
f011a6bc:	8b 15 d8 bd 17 f0    	mov    0xf017bdd8,%edx
f011a6c2:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011a6c8:	01 d0                	add    %edx,%eax
f011a6ca:	05 00 10 00 00       	add    $0x1000,%eax
f011a6cf:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011a6d5:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a6db:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011a6de:	eb 25                	jmp    f011a705 <test_kheap_phys_addr+0xa26>
		{
			allPAs[i++] = kheap_physical_address(va);
f011a6e0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011a6e3:	8d 43 01             	lea    0x1(%ebx),%eax
f011a6e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011a6e9:	83 ec 0c             	sub    $0xc,%esp
f011a6ec:	ff 75 d8             	pushl  -0x28(%ebp)
f011a6ef:	e8 a2 e9 fe ff       	call   f0109096 <kheap_physical_address>
f011a6f4:	83 c4 10             	add    $0x10,%esp
f011a6f7:	89 84 9d 44 ca ff ff 	mov    %eax,-0x35bc(%ebp,%ebx,4)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 121;
		uint32 startVA = da_limit + PAGE_SIZE+offset;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011a6fe:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
f011a705:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011a708:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011a70b:	72 d3                	jb     f011a6e0 <test_kheap_phys_addr+0xa01>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011a70d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a710:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		i = 0;
f011a716:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011a71d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a723:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011a726:	e9 f4 00 00 00       	jmp    f011a81f <test_kheap_phys_addr+0xb40>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011a72b:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011a730:	83 ec 04             	sub    $0x4,%esp
f011a733:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011a739:	52                   	push   %edx
f011a73a:	ff 75 d8             	pushl  -0x28(%ebp)
f011a73d:	50                   	push   %eax
f011a73e:	e8 7c dd fe ff       	call   f01084bf <get_page_table>
f011a743:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a746:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011a74c:	85 c0                	test   %eax,%eax
f011a74e:	75 24                	jne    f011a774 <test_kheap_phys_addr+0xa95>
				if (correct)
f011a750:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a754:	74 1e                	je     f011a774 <test_kheap_phys_addr+0xa95>
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011a756:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a75d:	83 ec 04             	sub    $0x4,%esp
f011a760:	68 28 df 12 f0       	push   $0xf012df28
f011a765:	68 53 06 00 00       	push   $0x653
f011a76a:	68 77 b9 12 f0       	push   $0xf012b977
f011a76f:	e8 c5 5b fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011a774:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011a777:	c1 e8 0c             	shr    $0xc,%eax
f011a77a:	25 ff 03 00 00       	and    $0x3ff,%eax
f011a77f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011a782:	eb 7b                	jmp    f011a7ff <test_kheap_phys_addr+0xb20>
			{
				expected = 0 ;
f011a784:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if ((ptr_table[j] & PERM_PRESENT))
f011a78b:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011a791:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011a794:	c1 e2 02             	shl    $0x2,%edx
f011a797:	01 d0                	add    %edx,%eax
f011a799:	8b 00                	mov    (%eax),%eax
f011a79b:	83 e0 01             	and    $0x1,%eax
f011a79e:	85 c0                	test   %eax,%eax
f011a7a0:	74 24                	je     f011a7c6 <test_kheap_phys_addr+0xae7>
				{
					expected = (ptr_table[j] & 0xFFFFF000) + (va & 0x00000FFF);
f011a7a2:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011a7a8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011a7ab:	c1 e2 02             	shl    $0x2,%edx
f011a7ae:	01 d0                	add    %edx,%eax
f011a7b0:	8b 00                	mov    (%eax),%eax
f011a7b2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a7b7:	89 c2                	mov    %eax,%edx
f011a7b9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011a7bc:	25 ff 0f 00 00       	and    $0xfff,%eax
f011a7c1:	01 d0                	add    %edx,%eax
f011a7c3:	89 45 dc             	mov    %eax,-0x24(%ebp)
				}
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
				if (expected != allPAs[i])
f011a7c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a7c9:	8b 84 85 44 ca ff ff 	mov    -0x35bc(%ebp,%eax,4),%eax
f011a7d0:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011a7d3:	74 1d                	je     f011a7f2 <test_kheap_phys_addr+0xb13>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011a7d5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a7d9:	74 17                	je     f011a7f2 <test_kheap_phys_addr+0xb13>
					{ correct = 0; cprintf("5.2 Wrong kheap_physical_address\n"); }
f011a7db:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7e2:	83 ec 0c             	sub    $0xc,%esp
f011a7e5:	68 88 df 12 f0       	push   $0xf012df88
f011a7ea:	e8 9c 67 fe ff       	call   f0100f8b <cprintf>
f011a7ef:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011a7f2:	81 45 d8 00 10 00 00 	addl   $0x1000,-0x28(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011a7f9:	ff 45 d4             	incl   -0x2c(%ebp)
f011a7fc:	ff 45 f4             	incl   -0xc(%ebp)
f011a7ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a802:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011a808:	7d 15                	jge    f011a81f <test_kheap_phys_addr+0xb40>
f011a80a:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011a811:	7f 0c                	jg     f011a81f <test_kheap_phys_addr+0xb40>
f011a813:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011a816:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011a819:	0f 82 65 ff ff ff    	jb     f011a784 <test_kheap_phys_addr+0xaa5>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011a81f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011a822:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011a825:	0f 82 00 ff ff ff    	jb     f011a72b <test_kheap_phys_addr+0xa4c>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011a82b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a82f:	74 04                	je     f011a835 <test_kheap_phys_addr+0xb56>
f011a831:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011a835:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
f011a83c:	83 ec 0c             	sub    $0xc,%esp
f011a83f:	68 ac df 12 f0       	push   $0xf012dfac
f011a844:	e8 42 67 fe ff       	call   f0100f8b <cprintf>
f011a849:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
f011a84c:	83 ec 0c             	sub    $0xc,%esp
f011a84f:	6a 00                	push   $0x0
f011a851:	e8 df e4 fe ff       	call   f0108d35 <sbrk>
f011a856:	83 c4 10             	add    $0x10,%esp
f011a859:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011a85e:	77 17                	ja     f011a877 <test_kheap_phys_addr+0xb98>
f011a860:	83 ec 04             	sub    $0x4,%esp
f011a863:	68 04 e0 12 f0       	push   $0xf012e004
f011a868:	68 6e 06 00 00       	push   $0x66e
f011a86d:	68 77 b9 12 f0       	push   $0xf012b977
f011a872:	e8 c2 5a fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011a877:	c7 45 d0 00 00 00 f6 	movl   $0xf6000000,-0x30(%ebp)
f011a87e:	e9 af 00 00 00       	jmp    f011a932 <test_kheap_phys_addr+0xc53>
		{
			pa = kheap_physical_address(va);
f011a883:	83 ec 0c             	sub    $0xc,%esp
f011a886:	ff 75 d0             	pushl  -0x30(%ebp)
f011a889:	e8 08 e8 fe ff       	call   f0109096 <kheap_physical_address>
f011a88e:	83 c4 10             	add    $0x10,%esp
f011a891:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011a897:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011a89c:	83 ec 04             	sub    $0x4,%esp
f011a89f:	8d 95 60 fe ff ff    	lea    -0x1a0(%ebp),%edx
f011a8a5:	52                   	push   %edx
f011a8a6:	ff 75 d0             	pushl  -0x30(%ebp)
f011a8a9:	50                   	push   %eax
f011a8aa:	e8 10 dc fe ff       	call   f01084bf <get_page_table>
f011a8af:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a8b2:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011a8b8:	85 c0                	test   %eax,%eax
f011a8ba:	75 24                	jne    f011a8e0 <test_kheap_phys_addr+0xc01>
				if (correct)
f011a8bc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a8c0:	74 1e                	je     f011a8e0 <test_kheap_phys_addr+0xc01>
				{ correct = 0; panic("6.2 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011a8c2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8c9:	83 ec 04             	sub    $0x4,%esp
f011a8cc:	68 20 e0 12 f0       	push   $0xf012e020
f011a8d1:	68 76 06 00 00       	push   $0x676
f011a8d6:	68 77 b9 12 f0       	push   $0xf012b977
f011a8db:	e8 59 5a fe ff       	call   f0100339 <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011a8e0:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011a8e6:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011a8e9:	c1 ea 0c             	shr    $0xc,%edx
f011a8ec:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011a8f2:	c1 e2 02             	shl    $0x2,%edx
f011a8f5:	01 d0                	add    %edx,%eax
f011a8f7:	8b 00                	mov    (%eax),%eax
f011a8f9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a8fe:	89 c2                	mov    %eax,%edx
f011a900:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011a903:	25 ff 0f 00 00       	and    $0xfff,%eax
f011a908:	01 d0                	add    %edx,%eax
f011a90a:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011a910:	74 1d                	je     f011a92f <test_kheap_phys_addr+0xc50>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011a912:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a916:	74 17                	je     f011a92f <test_kheap_phys_addr+0xc50>
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
f011a918:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a91f:	83 ec 0c             	sub    $0xc,%esp
f011a922:	68 80 e0 12 f0       	push   $0xf012e080
f011a927:	e8 5f 66 fe ff       	call   f0100f8b <cprintf>
f011a92c:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	cprintf("\n6. [DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("6.1 unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011a92f:	ff 45 d0             	incl   -0x30(%ebp)
f011a932:	83 ec 0c             	sub    $0xc,%esp
f011a935:	6a 00                	push   $0x0
f011a937:	e8 f9 e3 fe ff       	call   f0108d35 <sbrk>
f011a93c:	83 c4 10             	add    $0x10,%esp
f011a93f:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011a942:	0f 87 3b ff ff ff    	ja     f011a883 <test_kheap_phys_addr+0xba4>
				if (correct)
				{ correct = 0; cprintf("6.3 Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011a948:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a94c:	74 04                	je     f011a952 <test_kheap_phys_addr+0xc73>
f011a94e:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011a952:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
f011a959:	83 ec 0c             	sub    $0xc,%esp
f011a95c:	68 a4 e0 12 f0       	push   $0xf012e0a4
f011a961:	e8 25 66 fe ff       	call   f0100f8b <cprintf>
f011a966:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011a969:	c7 85 6c ff ff ff 00 	movl   $0xf9001000,-0x94(%ebp)
f011a970:	10 00 f9 
		i = 0;
f011a973:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011a97a:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011a980:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011a983:	eb 0a                	jmp    f011a98f <test_kheap_phys_addr+0xcb0>
		{
			i++;
f011a985:	ff 45 f4             	incl   -0xc(%ebp)
	cprintf("\n7. test kheap_physical_address on non-mapped area [10%]\n");
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011a988:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f011a98f:	81 7d cc ff ef ff ff 	cmpl   $0xffffefff,-0x34(%ebp)
f011a996:	76 ed                	jbe    f011a985 <test_kheap_phys_addr+0xca6>
		{
			i++;
		}
		int ii = i ;
f011a998:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a99b:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
		i = 0;
f011a9a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011a9a8:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011a9ae:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011a9b1:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011a9b8:	e9 cb 00 00 00       	jmp    f011aa88 <test_kheap_phys_addr+0xda9>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011a9bd:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011a9c0:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011a9c5:	83 ec 04             	sub    $0x4,%esp
f011a9c8:	8d 8d 5c fe ff ff    	lea    -0x1a4(%ebp),%ecx
f011a9ce:	51                   	push   %ecx
f011a9cf:	52                   	push   %edx
f011a9d0:	50                   	push   %eax
f011a9d1:	e8 e9 da fe ff       	call   f01084bf <get_page_table>
f011a9d6:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011a9d9:	8b 85 5c fe ff ff    	mov    -0x1a4(%ebp),%eax
f011a9df:	85 c0                	test   %eax,%eax
f011a9e1:	75 24                	jne    f011aa07 <test_kheap_phys_addr+0xd28>
			{
				if (correct)
f011a9e3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a9e7:	74 1e                	je     f011aa07 <test_kheap_phys_addr+0xd28>
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011a9e9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9f0:	83 ec 04             	sub    $0x4,%esp
f011a9f3:	68 e0 e0 12 f0       	push   $0xf012e0e0
f011a9f8:	68 98 06 00 00       	push   $0x698
f011a9fd:	68 77 b9 12 f0       	push   $0xf012b977
f011aa02:	e8 32 59 fe ff       	call   f0100339 <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011aa07:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011aa0e:	eb 59                	jmp    f011aa69 <test_kheap_phys_addr+0xd8a>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011aa10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011aa13:	c1 e0 0c             	shl    $0xc,%eax
f011aa16:	89 c2                	mov    %eax,%edx
f011aa18:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
f011aa1e:	01 d0                	add    %edx,%eax
f011aa20:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011aa26:	83 ec 0c             	sub    $0xc,%esp
f011aa29:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011aa2f:	e8 62 e6 fe ff       	call   f0109096 <kheap_physical_address>
f011aa34:	83 c4 10             	add    $0x10,%esp
f011aa37:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
				//if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
				if (supposed_kheap_phys_add != 0)
f011aa3d:	83 bd 60 ff ff ff 00 	cmpl   $0x0,-0xa0(%ebp)
f011aa44:	74 1d                	je     f011aa63 <test_kheap_phys_addr+0xd84>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011aa46:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aa4a:	74 17                	je     f011aa63 <test_kheap_phys_addr+0xd84>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
f011aa4c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa53:	83 ec 0c             	sub    $0xc,%esp
f011aa56:	68 40 e1 12 f0       	push   $0xf012e140
f011aa5b:	e8 2b 65 fe ff       	call   f0100f8b <cprintf>
f011aa60:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("7.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011aa63:	ff 45 c8             	incl   -0x38(%ebp)
f011aa66:	ff 45 f4             	incl   -0xc(%ebp)
f011aa69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011aa6c:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011aa72:	7d 09                	jge    f011aa7d <test_kheap_phys_addr+0xd9e>
f011aa74:	81 7d c8 ff 03 00 00 	cmpl   $0x3ff,-0x38(%ebp)
f011aa7b:	7e 93                	jle    f011aa10 <test_kheap_phys_addr+0xd31>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011aa7d:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011aa84:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011aa88:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011aa8c:	0f 88 2b ff ff ff    	js     f011a9bd <test_kheap_phys_addr+0xcde>
f011aa92:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011aa96:	7f 0d                	jg     f011aaa5 <test_kheap_phys_addr+0xdc6>
f011aa98:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011aa9f:	0f 86 18 ff ff ff    	jbe    f011a9bd <test_kheap_phys_addr+0xcde>
					{ correct = 0; cprintf("7.2 Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011aaa5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aaa9:	74 04                	je     f011aaaf <test_kheap_phys_addr+0xdd0>
f011aaab:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011aaaf:	83 ec 08             	sub    $0x8,%esp
f011aab2:	ff 75 f0             	pushl  -0x10(%ebp)
f011aab5:	68 64 e1 12 f0       	push   $0xf012e164
f011aaba:	e8 cc 64 fe ff       	call   f0100f8b <cprintf>
f011aabf:	83 c4 10             	add    $0x10,%esp

	return 1;
f011aac2:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011aac7:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011aaca:	5b                   	pop    %ebx
f011aacb:	5f                   	pop    %edi
f011aacc:	5d                   	pop    %ebp
f011aacd:	c3                   	ret    

f011aace <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011aace:	55                   	push   %ebp
f011aacf:	89 e5                	mov    %esp,%ebp
f011aad1:	57                   	push   %edi
f011aad2:	56                   	push   %esi
f011aad3:	53                   	push   %ebx
f011aad4:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011aada:	89 e0                	mov    %esp,%eax
f011aadc:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011aade:	83 ec 0c             	sub    $0xc,%esp
f011aae1:	68 08 9a 12 f0       	push   $0xf0129a08
f011aae6:	e8 a0 64 fe ff       	call   f0100f8b <cprintf>
f011aaeb:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011aaee:	83 ec 0c             	sub    $0xc,%esp
f011aaf1:	68 38 9a 12 f0       	push   $0xf0129a38
f011aaf6:	e8 90 64 fe ff       	call   f0100f8b <cprintf>
f011aafb:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011aafe:	83 ec 0c             	sub    $0xc,%esp
f011ab01:	68 08 9a 12 f0       	push   $0xf0129a08
f011ab06:	e8 80 64 fe ff       	call   f0100f8b <cprintf>
f011ab0b:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011ab0e:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011ab12:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011ab16:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011ab1c:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011ab22:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011ab29:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011ab30:	e8 40 2f ff ff       	call   f010da75 <sys_calculate_free_frames>
f011ab35:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	cprintf("\n1. Allocate some spaces in both allocators \n");
f011ab38:	83 ec 0c             	sub    $0xc,%esp
f011ab3b:	68 d4 d7 12 f0       	push   $0xf012d7d4
f011ab40:	e8 46 64 fe ff       	call   f0100f8b <cprintf>
f011ab45:	83 c4 10             	add    $0x10,%esp
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011ab48:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011ab4e:	b9 14 00 00 00       	mov    $0x14,%ecx
f011ab53:	b8 00 00 00 00       	mov    $0x0,%eax
f011ab58:	89 d7                	mov    %edx,%edi
f011ab5a:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011ab5c:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011ab62:	b9 14 00 00 00       	mov    $0x14,%ecx
f011ab67:	b8 00 00 00 00       	mov    $0x0,%eax
f011ab6c:	89 d7                	mov    %edx,%edi
f011ab6e:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011ab70:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011ab77:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011ab7e:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011ab84:	b9 14 00 00 00       	mov    $0x14,%ecx
f011ab89:	b8 00 00 00 00       	mov    $0x0,%eax
f011ab8e:	89 d7                	mov    %edx,%edi
f011ab90:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011ab92:	e8 de 2e ff ff       	call   f010da75 <sys_calculate_free_frames>
f011ab97:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ab9a:	e8 6a 9d fe ff       	call   f0104909 <pf_calculate_free_frames>
f011ab9f:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011aba2:	83 ec 0c             	sub    $0xc,%esp
f011aba5:	68 00 fc 1f 00       	push   $0x1ffc00
f011abaa:	e8 81 e2 fe ff       	call   f0108e30 <kmalloc>
f011abaf:	83 c4 10             	add    $0x10,%esp
f011abb2:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("1.1 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011abb8:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011abbe:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011abc3:	74 17                	je     f011abdc <test_kheap_virt_addr+0x10e>
f011abc5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011abcc:	83 ec 0c             	sub    $0xc,%esp
f011abcf:	68 24 bb 12 f0       	push   $0xf012bb24
f011abd4:	e8 b2 63 fe ff       	call   f0100f8b <cprintf>
f011abd9:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011abdc:	e8 28 9d fe ff       	call   f0104909 <pf_calculate_free_frames>
f011abe1:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011abe4:	74 17                	je     f011abfd <test_kheap_virt_addr+0x12f>
f011abe6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011abed:	83 ec 0c             	sub    $0xc,%esp
f011abf0:	68 78 bb 12 f0       	push   $0xf012bb78
f011abf5:	e8 91 63 fe ff       	call   f0100f8b <cprintf>
f011abfa:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.1 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011abfd:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011ac00:	e8 70 2e ff ff       	call   f010da75 <sys_calculate_free_frames>
f011ac05:	29 c3                	sub    %eax,%ebx
f011ac07:	89 d8                	mov    %ebx,%eax
f011ac09:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ac0e:	77 17                	ja     f011ac27 <test_kheap_virt_addr+0x159>
f011ac10:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ac17:	83 ec 0c             	sub    $0xc,%esp
f011ac1a:	68 e8 bb 12 f0       	push   $0xf012bbe8
f011ac1f:	e8 67 63 fe ff       	call   f0100f8b <cprintf>
f011ac24:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011ac27:	e8 49 2e ff ff       	call   f010da75 <sys_calculate_free_frames>
f011ac2c:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ac2f:	e8 d5 9c fe ff       	call   f0104909 <pf_calculate_free_frames>
f011ac34:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011ac37:	83 ec 0c             	sub    $0xc,%esp
f011ac3a:	68 00 fc 1f 00       	push   $0x1ffc00
f011ac3f:	e8 ec e1 fe ff       	call   f0108e30 <kmalloc>
f011ac44:	83 c4 10             	add    $0x10,%esp
f011ac47:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("1.2 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ac4d:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011ac53:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011ac58:	74 17                	je     f011ac71 <test_kheap_virt_addr+0x1a3>
f011ac5a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ac61:	83 ec 0c             	sub    $0xc,%esp
f011ac64:	68 30 bc 12 f0       	push   $0xf012bc30
f011ac69:	e8 1d 63 fe ff       	call   f0100f8b <cprintf>
f011ac6e:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ac71:	e8 93 9c fe ff       	call   f0104909 <pf_calculate_free_frames>
f011ac76:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ac79:	74 17                	je     f011ac92 <test_kheap_virt_addr+0x1c4>
f011ac7b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ac82:	83 ec 0c             	sub    $0xc,%esp
f011ac85:	68 84 bc 12 f0       	push   $0xf012bc84
f011ac8a:	e8 fc 62 fe ff       	call   f0100f8b <cprintf>
f011ac8f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("1.2 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ac92:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011ac95:	e8 db 2d ff ff       	call   f010da75 <sys_calculate_free_frames>
f011ac9a:	29 c3                	sub    %eax,%ebx
f011ac9c:	89 d8                	mov    %ebx,%eax
f011ac9e:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011aca3:	77 17                	ja     f011acbc <test_kheap_virt_addr+0x1ee>
f011aca5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011acac:	83 ec 0c             	sub    $0xc,%esp
f011acaf:	68 f4 bc 12 f0       	push   $0xf012bcf4
f011acb4:	e8 d2 62 fe ff       	call   f0100f8b <cprintf>
f011acb9:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011acbc:	e8 b4 2d ff ff       	call   f010da75 <sys_calculate_free_frames>
f011acc1:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011acc4:	e8 40 9c fe ff       	call   f0104909 <pf_calculate_free_frames>
f011acc9:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011accc:	83 ec 0c             	sub    $0xc,%esp
f011accf:	68 00 04 00 00       	push   $0x400
f011acd4:	e8 57 e1 fe ff       	call   f0108e30 <kmalloc>
f011acd9:	83 c4 10             	add    $0x10,%esp
f011acdc:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011ace2:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011ace8:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011aced:	76 28                	jbe    f011ad17 <test_kheap_virt_addr+0x249>
f011acef:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011acf5:	83 ec 0c             	sub    $0xc,%esp
f011acf8:	6a 00                	push   $0x0
f011acfa:	e8 36 e0 fe ff       	call   f0108d35 <sbrk>
f011acff:	83 c4 10             	add    $0x10,%esp
f011ad02:	39 c3                	cmp    %eax,%ebx
f011ad04:	73 11                	jae    f011ad17 <test_kheap_virt_addr+0x249>
f011ad06:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011ad0c:	89 c2                	mov    %eax,%edx
f011ad0e:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f011ad13:	39 c2                	cmp    %eax,%edx
f011ad15:	72 17                	jb     f011ad2e <test_kheap_virt_addr+0x260>
			{ correct = 0; cprintf("1.3 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011ad17:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ad1e:	83 ec 0c             	sub    $0xc,%esp
f011ad21:	68 04 d8 12 f0       	push   $0xf012d804
f011ad26:	e8 60 62 fe ff       	call   f0100f8b <cprintf>
f011ad2b:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ad2e:	e8 d6 9b fe ff       	call   f0104909 <pf_calculate_free_frames>
f011ad33:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ad36:	74 17                	je     f011ad4f <test_kheap_virt_addr+0x281>
f011ad38:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ad3f:	83 ec 0c             	sub    $0xc,%esp
f011ad42:	68 90 bd 12 f0       	push   $0xf012bd90
f011ad47:	e8 3f 62 fe ff       	call   f0100f8b <cprintf>
f011ad4c:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011ad4f:	e8 21 2d ff ff       	call   f010da75 <sys_calculate_free_frames>
f011ad54:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011ad57:	e8 ad 9b fe ff       	call   f0104909 <pf_calculate_free_frames>
f011ad5c:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011ad5f:	83 ec 0c             	sub    $0xc,%esp
f011ad62:	68 00 08 00 00       	push   $0x800
f011ad67:	e8 c4 e0 fe ff       	call   f0108e30 <kmalloc>
f011ad6c:	83 c4 10             	add    $0x10,%esp
f011ad6f:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011ad75:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011ad7b:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011ad80:	76 28                	jbe    f011adaa <test_kheap_virt_addr+0x2dc>
f011ad82:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011ad88:	83 ec 0c             	sub    $0xc,%esp
f011ad8b:	6a 00                	push   $0x0
f011ad8d:	e8 a3 df fe ff       	call   f0108d35 <sbrk>
f011ad92:	83 c4 10             	add    $0x10,%esp
f011ad95:	39 c3                	cmp    %eax,%ebx
f011ad97:	73 11                	jae    f011adaa <test_kheap_virt_addr+0x2dc>
f011ad99:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011ad9f:	89 c2                	mov    %eax,%edx
f011ada1:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f011ada6:	39 c2                	cmp    %eax,%edx
f011ada8:	72 17                	jb     f011adc1 <test_kheap_virt_addr+0x2f3>
			{ correct = 0; cprintf("1.4 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011adaa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011adb1:	83 ec 0c             	sub    $0xc,%esp
f011adb4:	68 90 d8 12 f0       	push   $0xf012d890
f011adb9:	e8 cd 61 fe ff       	call   f0100f8b <cprintf>
f011adbe:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.4 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011adc1:	e8 43 9b fe ff       	call   f0104909 <pf_calculate_free_frames>
f011adc6:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011adc9:	74 17                	je     f011ade2 <test_kheap_virt_addr+0x314>
f011adcb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011add2:	83 ec 0c             	sub    $0xc,%esp
f011add5:	68 9c be 12 f0       	push   $0xf012be9c
f011adda:	e8 ac 61 fe ff       	call   f0100f8b <cprintf>
f011addf:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011ade2:	e8 8e 2c ff ff       	call   f010da75 <sys_calculate_free_frames>
f011ade7:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011adea:	e8 1a 9b fe ff       	call   f0104909 <pf_calculate_free_frames>
f011adef:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011adf2:	83 ec 0c             	sub    $0xc,%esp
f011adf5:	68 00 06 00 00       	push   $0x600
f011adfa:	e8 31 e0 fe ff       	call   f0108e30 <kmalloc>
f011adff:	83 c4 10             	add    $0x10,%esp
f011ae02:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011ae08:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011ae0e:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011ae13:	76 28                	jbe    f011ae3d <test_kheap_virt_addr+0x36f>
f011ae15:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011ae1b:	83 ec 0c             	sub    $0xc,%esp
f011ae1e:	6a 00                	push   $0x0
f011ae20:	e8 10 df fe ff       	call   f0108d35 <sbrk>
f011ae25:	83 c4 10             	add    $0x10,%esp
f011ae28:	39 c3                	cmp    %eax,%ebx
f011ae2a:	73 11                	jae    f011ae3d <test_kheap_virt_addr+0x36f>
f011ae2c:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011ae32:	89 c2                	mov    %eax,%edx
f011ae34:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f011ae39:	39 c2                	cmp    %eax,%edx
f011ae3b:	72 17                	jb     f011ae54 <test_kheap_virt_addr+0x386>
			{ correct = 0; cprintf("1.5 Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011ae3d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ae44:	83 ec 0c             	sub    $0xc,%esp
f011ae47:	68 1c d9 12 f0       	push   $0xf012d91c
f011ae4c:	e8 3a 61 fe ff       	call   f0100f8b <cprintf>
f011ae51:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.5 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ae54:	e8 b0 9a fe ff       	call   f0104909 <pf_calculate_free_frames>
f011ae59:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ae5c:	74 17                	je     f011ae75 <test_kheap_virt_addr+0x3a7>
f011ae5e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ae65:	83 ec 0c             	sub    $0xc,%esp
f011ae68:	68 a8 bf 12 f0       	push   $0xf012bfa8
f011ae6d:	e8 19 61 fe ff       	call   f0100f8b <cprintf>
f011ae72:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011ae75:	e8 fb 2b ff ff       	call   f010da75 <sys_calculate_free_frames>
f011ae7a:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ae7d:	e8 87 9a fe ff       	call   f0104909 <pf_calculate_free_frames>
f011ae82:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011ae85:	83 ec 0c             	sub    $0xc,%esp
f011ae88:	68 00 1c 00 00       	push   $0x1c00
f011ae8d:	e8 9e df fe ff       	call   f0108e30 <kmalloc>
f011ae92:	83 c4 10             	add    $0x10,%esp
f011ae95:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("1.6 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ae9b:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011aea1:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011aea6:	74 17                	je     f011aebf <test_kheap_virt_addr+0x3f1>
f011aea8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011aeaf:	83 ec 0c             	sub    $0xc,%esp
f011aeb2:	68 60 c0 12 f0       	push   $0xf012c060
f011aeb7:	e8 cf 60 fe ff       	call   f0100f8b <cprintf>
f011aebc:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.6 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aebf:	e8 45 9a fe ff       	call   f0104909 <pf_calculate_free_frames>
f011aec4:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011aec7:	74 17                	je     f011aee0 <test_kheap_virt_addr+0x412>
f011aec9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011aed0:	83 ec 0c             	sub    $0xc,%esp
f011aed3:	68 b4 c0 12 f0       	push   $0xf012c0b4
f011aed8:	e8 ae 60 fe ff       	call   f0100f8b <cprintf>
f011aedd:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("1.6 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011aee0:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011aee3:	e8 8d 2b ff ff       	call   f010da75 <sys_calculate_free_frames>
f011aee8:	29 c3                	sub    %eax,%ebx
f011aeea:	89 d8                	mov    %ebx,%eax
f011aeec:	83 f8 01             	cmp    $0x1,%eax
f011aeef:	77 17                	ja     f011af08 <test_kheap_virt_addr+0x43a>
f011aef1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011aef8:	83 ec 0c             	sub    $0xc,%esp
f011aefb:	68 24 c1 12 f0       	push   $0xf012c124
f011af00:	e8 86 60 fe ff       	call   f0100f8b <cprintf>
f011af05:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011af08:	e8 68 2b ff ff       	call   f010da75 <sys_calculate_free_frames>
f011af0d:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011af10:	e8 f4 99 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011af15:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011af18:	83 ec 0c             	sub    $0xc,%esp
f011af1b:	68 00 fc 2f 00       	push   $0x2ffc00
f011af20:	e8 0b df fe ff       	call   f0108e30 <kmalloc>
f011af25:	83 c4 10             	add    $0x10,%esp
f011af28:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("1.7 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011af2e:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011af34:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011af39:	74 17                	je     f011af52 <test_kheap_virt_addr+0x484>
f011af3b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011af42:	83 ec 0c             	sub    $0xc,%esp
f011af45:	68 14 da 12 f0       	push   $0xf012da14
f011af4a:	e8 3c 60 fe ff       	call   f0100f8b <cprintf>
f011af4f:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.7 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af52:	e8 b2 99 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011af57:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011af5a:	74 17                	je     f011af73 <test_kheap_virt_addr+0x4a5>
f011af5c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011af63:	83 ec 0c             	sub    $0xc,%esp
f011af66:	68 f8 c1 12 f0       	push   $0xf012c1f8
f011af6b:	e8 1b 60 fe ff       	call   f0100f8b <cprintf>
f011af70:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("1.7 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011af73:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011af76:	e8 fa 2a ff ff       	call   f010da75 <sys_calculate_free_frames>
f011af7b:	29 c3                	sub    %eax,%ebx
f011af7d:	89 d8                	mov    %ebx,%eax
f011af7f:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011af84:	77 17                	ja     f011af9d <test_kheap_virt_addr+0x4cf>
f011af86:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011af8d:	83 ec 0c             	sub    $0xc,%esp
f011af90:	68 68 da 12 f0       	push   $0xf012da68
f011af95:	e8 f1 5f fe ff       	call   f0100f8b <cprintf>
f011af9a:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011af9d:	e8 d3 2a ff ff       	call   f010da75 <sys_calculate_free_frames>
f011afa2:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011afa5:	e8 5f 99 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011afaa:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011afad:	83 ec 0c             	sub    $0xc,%esp
f011afb0:	68 00 fc 5f 00       	push   $0x5ffc00
f011afb5:	e8 76 de fe ff       	call   f0108e30 <kmalloc>
f011afba:	83 c4 10             	add    $0x10,%esp
f011afbd:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("1.8 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011afc3:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011afc9:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011afce:	74 17                	je     f011afe7 <test_kheap_virt_addr+0x519>
f011afd0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011afd7:	83 ec 0c             	sub    $0xc,%esp
f011afda:	68 b0 da 12 f0       	push   $0xf012dab0
f011afdf:	e8 a7 5f fe ff       	call   f0100f8b <cprintf>
f011afe4:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.8 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011afe7:	e8 1d 99 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011afec:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011afef:	74 17                	je     f011b008 <test_kheap_virt_addr+0x53a>
f011aff1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011aff8:	83 ec 0c             	sub    $0xc,%esp
f011affb:	68 f4 c2 12 f0       	push   $0xf012c2f4
f011b000:	e8 86 5f fe ff       	call   f0100f8b <cprintf>
f011b005:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("1.8 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b008:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b00b:	e8 65 2a ff ff       	call   f010da75 <sys_calculate_free_frames>
f011b010:	29 c3                	sub    %eax,%ebx
f011b012:	89 d8                	mov    %ebx,%eax
f011b014:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b019:	77 17                	ja     f011b032 <test_kheap_virt_addr+0x564>
f011b01b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b022:	83 ec 0c             	sub    $0xc,%esp
f011b025:	68 04 db 12 f0       	push   $0xf012db04
f011b02a:	e8 5c 5f fe ff       	call   f0100f8b <cprintf>
f011b02f:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011b032:	e8 3e 2a ff ff       	call   f010da75 <sys_calculate_free_frames>
f011b037:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b03a:	e8 ca 98 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011b03f:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011b042:	83 ec 0c             	sub    $0xc,%esp
f011b045:	68 00 38 00 00       	push   $0x3800
f011b04a:	e8 e1 dd fe ff       	call   f0108e30 <kmalloc>
f011b04f:	83 c4 10             	add    $0x10,%esp
f011b052:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("1.9 Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b058:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011b05e:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011b063:	74 17                	je     f011b07c <test_kheap_virt_addr+0x5ae>
f011b065:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b06c:	83 ec 0c             	sub    $0xc,%esp
f011b06f:	68 4c db 12 f0       	push   $0xf012db4c
f011b074:	e8 12 5f fe ff       	call   f0100f8b <cprintf>
f011b079:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("1.9 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b07c:	e8 88 98 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011b081:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011b084:	74 17                	je     f011b09d <test_kheap_virt_addr+0x5cf>
f011b086:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b08d:	83 ec 0c             	sub    $0xc,%esp
f011b090:	68 a0 db 12 f0       	push   $0xf012dba0
f011b095:	e8 f1 5e fe ff       	call   f0100f8b <cprintf>
f011b09a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("1.9 Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b09d:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011b0a0:	e8 d0 29 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011b0a5:	29 c3                	sub    %eax,%ebx
f011b0a7:	89 d8                	mov    %ebx,%eax
f011b0a9:	83 f8 03             	cmp    $0x3,%eax
f011b0ac:	77 17                	ja     f011b0c5 <test_kheap_virt_addr+0x5f7>
f011b0ae:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b0b5:	83 ec 0c             	sub    $0xc,%esp
f011b0b8:	68 10 dc 12 f0       	push   $0xf012dc10
f011b0bd:	e8 c9 5e fe ff       	call   f0100f8b <cprintf>
f011b0c2:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011b0c5:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011b0cc:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011b0cf:	c1 e8 0c             	shr    $0xc,%eax
f011b0d2:	89 c2                	mov    %eax,%edx
f011b0d4:	4a                   	dec    %edx
f011b0d5:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011b0d8:	c1 e0 02             	shl    $0x2,%eax
f011b0db:	8d 50 03             	lea    0x3(%eax),%edx
f011b0de:	b8 10 00 00 00       	mov    $0x10,%eax
f011b0e3:	48                   	dec    %eax
f011b0e4:	01 d0                	add    %edx,%eax
f011b0e6:	bf 10 00 00 00       	mov    $0x10,%edi
f011b0eb:	ba 00 00 00 00       	mov    $0x0,%edx
f011b0f0:	f7 f7                	div    %edi
f011b0f2:	6b c0 10             	imul   $0x10,%eax,%eax
f011b0f5:	29 c4                	sub    %eax,%esp
f011b0f7:	89 e0                	mov    %esp,%eax
f011b0f9:	83 c0 03             	add    $0x3,%eax
f011b0fc:	c1 e8 02             	shr    $0x2,%eax
f011b0ff:	c1 e0 02             	shl    $0x2,%eax
f011b102:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011b105:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011b108:	c1 e8 0c             	shr    $0xc,%eax
f011b10b:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	cprintf("\n2. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc only [20%]\n");
f011b10e:	83 ec 0c             	sub    $0xc,%esp
f011b111:	68 98 e1 12 f0       	push   $0xf012e198
f011b116:	e8 70 5e fe ff       	call   f0100f8b <cprintf>
f011b11b:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b11e:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011b125:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f011b12a:	05 00 10 00 00       	add    $0x1000,%eax
f011b12f:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011b132:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011b139:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011b13c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011b13f:	e9 2d 01 00 00       	jmp    f011b271 <test_kheap_virt_addr+0x7a3>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b144:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011b149:	83 ec 04             	sub    $0x4,%esp
f011b14c:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011b152:	52                   	push   %edx
f011b153:	ff 75 dc             	pushl  -0x24(%ebp)
f011b156:	50                   	push   %eax
f011b157:	e8 63 d3 fe ff       	call   f01084bf <get_page_table>
f011b15c:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b15f:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b165:	85 c0                	test   %eax,%eax
f011b167:	75 1e                	jne    f011b187 <test_kheap_virt_addr+0x6b9>
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b169:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b170:	83 ec 04             	sub    $0x4,%esp
f011b173:	68 a4 dc 12 f0       	push   $0xf012dca4
f011b178:	68 37 07 00 00       	push   $0x737
f011b17d:	68 77 b9 12 f0       	push   $0xf012b977
f011b182:	e8 b2 51 fe ff       	call   f0100339 <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011b187:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011b18a:	c1 e8 0c             	shr    $0xc,%eax
f011b18d:	25 ff 03 00 00       	and    $0x3ff,%eax
f011b192:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011b195:	e9 ba 00 00 00       	jmp    f011b254 <test_kheap_virt_addr+0x786>
			{
				uint32 offset = j;
f011b19a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011b19d:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011b1a0:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011b1a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b1a9:	c1 e2 02             	shl    $0x2,%edx
f011b1ac:	01 d0                	add    %edx,%eax
f011b1ae:	8b 00                	mov    (%eax),%eax
f011b1b0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b1b5:	89 c2                	mov    %eax,%edx
f011b1b7:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b1ba:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011b1bd:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b1c0:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011b1c3:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011b1c6:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b1c9:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011b1cc:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b1cf:	83 ec 0c             	sub    $0xc,%esp
f011b1d2:	50                   	push   %eax
f011b1d3:	e8 ff de fe ff       	call   f01090d7 <kheap_virtual_address>
f011b1d8:	83 c4 10             	add    $0x10,%esp
f011b1db:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011b1de:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011b1e1:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b1e4:	01 d0                	add    %edx,%eax
f011b1e6:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011b1e9:	74 5c                	je     f011b247 <test_kheap_virt_addr+0x779>
				{
					if (correct)
f011b1eb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b1ef:	74 56                	je     f011b247 <test_kheap_virt_addr+0x779>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011b1f1:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b1f4:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011b1f7:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b1fa:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011b200:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011b203:	c1 e1 02             	shl    $0x2,%ecx
f011b206:	01 ca                	add    %ecx,%edx
f011b208:	8b 12                	mov    (%edx),%edx
f011b20a:	89 d1                	mov    %edx,%ecx
f011b20c:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011b212:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011b215:	8b 55 90             	mov    -0x70(%ebp),%edx
f011b218:	01 da                	add    %ebx,%edx
f011b21a:	83 ec 0c             	sub    $0xc,%esp
f011b21d:	50                   	push   %eax
f011b21e:	51                   	push   %ecx
f011b21f:	52                   	push   %edx
f011b220:	ff 75 8c             	pushl  -0x74(%ebp)
f011b223:	68 e4 e1 12 f0       	push   $0xf012e1e4
f011b228:	e8 5e 5d fe ff       	call   f0100f8b <cprintf>
f011b22d:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("2.2 Wrong kheap_virtual_address\n");
f011b230:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b237:	83 ec 0c             	sub    $0xc,%esp
f011b23a:	68 28 e2 12 f0       	push   $0xf012e228
f011b23f:	e8 47 5d fe ff       	call   f0100f8b <cprintf>
f011b244:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011b247:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("2.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011b24e:	ff 45 d4             	incl   -0x2c(%ebp)
f011b251:	ff 45 d8             	incl   -0x28(%ebp)
f011b254:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011b257:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011b25a:	7d 15                	jge    f011b271 <test_kheap_virt_addr+0x7a3>
f011b25c:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011b263:	7f 0c                	jg     f011b271 <test_kheap_virt_addr+0x7a3>
f011b265:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011b268:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011b26b:	0f 82 29 ff ff ff    	jb     f011b19a <test_kheap_virt_addr+0x6cc>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011b271:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011b274:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011b277:	0f 82 c7 fe ff ff    	jb     f011b144 <test_kheap_virt_addr+0x676>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011b27d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b281:	74 04                	je     f011b287 <test_kheap_virt_addr+0x7b9>
f011b283:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011b287:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	cprintf("\n3. kfree some of the allocated spaces\n");
f011b28e:	83 ec 0c             	sub    $0xc,%esp
f011b291:	68 4c e2 12 f0       	push   $0xf012e24c
f011b296:	e8 f0 5c fe ff       	call   f0100f8b <cprintf>
f011b29b:	83 c4 10             	add    $0x10,%esp
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011b29e:	e8 d2 27 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011b2a3:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011b2a6:	e8 5e 96 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011b2ab:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011b2ae:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011b2b4:	83 ec 0c             	sub    $0xc,%esp
f011b2b7:	50                   	push   %eax
f011b2b8:	e8 e0 dc fe ff       	call   f0108f9d <kfree>
f011b2bd:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.1 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b2c0:	e8 44 96 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011b2c5:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b2c8:	74 17                	je     f011b2e1 <test_kheap_virt_addr+0x813>
f011b2ca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b2d1:	83 ec 0c             	sub    $0xc,%esp
f011b2d4:	68 74 e2 12 f0       	push   $0xf012e274
f011b2d9:	e8 ad 5c fe ff       	call   f0100f8b <cprintf>
f011b2de:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("3.1 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b2e1:	e8 8f 27 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011b2e6:	89 c2                	mov    %eax,%edx
f011b2e8:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b2eb:	29 c2                	sub    %eax,%edx
f011b2ed:	89 d0                	mov    %edx,%eax
f011b2ef:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b2f4:	77 17                	ja     f011b30d <test_kheap_virt_addr+0x83f>
f011b2f6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b2fd:	83 ec 0c             	sub    $0xc,%esp
f011b300:	68 e4 e2 12 f0       	push   $0xf012e2e4
f011b305:	e8 81 5c fe ff       	call   f0100f8b <cprintf>
f011b30a:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b30d:	e8 63 27 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011b312:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b315:	e8 ef 95 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011b31a:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011b31d:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011b323:	83 ec 0c             	sub    $0xc,%esp
f011b326:	50                   	push   %eax
f011b327:	e8 71 dc fe ff       	call   f0108f9d <kfree>
f011b32c:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.2 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b32f:	e8 d5 95 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011b334:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b337:	74 17                	je     f011b350 <test_kheap_virt_addr+0x882>
f011b339:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b340:	83 ec 0c             	sub    $0xc,%esp
f011b343:	68 20 e3 12 f0       	push   $0xf012e320
f011b348:	e8 3e 5c fe ff       	call   f0100f8b <cprintf>
f011b34d:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("3.2 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b350:	e8 20 27 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011b355:	89 c2                	mov    %eax,%edx
f011b357:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b35a:	29 c2                	sub    %eax,%edx
f011b35c:	89 d0                	mov    %edx,%eax
f011b35e:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b363:	77 17                	ja     f011b37c <test_kheap_virt_addr+0x8ae>
f011b365:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b36c:	83 ec 0c             	sub    $0xc,%esp
f011b36f:	68 90 e3 12 f0       	push   $0xf012e390
f011b374:	e8 12 5c fe ff       	call   f0100f8b <cprintf>
f011b379:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011b37c:	e8 f4 26 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011b381:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b384:	e8 80 95 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011b389:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011b38c:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011b392:	83 ec 0c             	sub    $0xc,%esp
f011b395:	50                   	push   %eax
f011b396:	e8 02 dc fe ff       	call   f0108f9d <kfree>
f011b39b:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("3.3 Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b39e:	e8 66 95 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011b3a3:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011b3a6:	74 17                	je     f011b3bf <test_kheap_virt_addr+0x8f1>
f011b3a8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b3af:	83 ec 0c             	sub    $0xc,%esp
f011b3b2:	68 cc e3 12 f0       	push   $0xf012e3cc
f011b3b7:	e8 cf 5b fe ff       	call   f0100f8b <cprintf>
f011b3bc:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("3.3 Wrong kfree: pages in memory are not freed correctly\n"); }
f011b3bf:	e8 b1 26 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011b3c4:	89 c2                	mov    %eax,%edx
f011b3c6:	8b 45 88             	mov    -0x78(%ebp),%eax
f011b3c9:	29 c2                	sub    %eax,%edx
f011b3cb:	89 d0                	mov    %edx,%eax
f011b3cd:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011b3d2:	77 17                	ja     f011b3eb <test_kheap_virt_addr+0x91d>
f011b3d4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b3db:	83 ec 0c             	sub    $0xc,%esp
f011b3de:	68 3c e4 12 f0       	push   $0xf012e43c
f011b3e3:	e8 a3 5b fe ff       	call   f0100f8b <cprintf>
f011b3e8:	83 c4 10             	add    $0x10,%esp
	}


	//test kheap_virtual_address after kmalloc and kfree [20%]
	cprintf("\n4. [PAGE ALLOCATOR] test kheap_virtual_address after kmalloc and kfree [20%]\n");
f011b3eb:	83 ec 0c             	sub    $0xc,%esp
f011b3ee:	68 78 e4 12 f0       	push   $0xf012e478
f011b3f3:	e8 93 5b fe ff       	call   f0100f8b <cprintf>
f011b3f8:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011b3fb:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011b402:	a1 d8 bd 17 f0       	mov    0xf017bdd8,%eax
f011b407:	05 00 10 00 00       	add    $0x1000,%eax
f011b40c:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011b412:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011b419:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011b420:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011b423:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b429:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011b42c:	eb 44                	jmp    f011b472 <test_kheap_virt_addr+0x9a4>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011b42e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b431:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b434:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b437:	83 ec 0c             	sub    $0xc,%esp
f011b43a:	50                   	push   %eax
f011b43b:	e8 97 dc fe ff       	call   f01090d7 <kheap_virtual_address>
f011b440:	83 c4 10             	add    $0x10,%esp
f011b443:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011b449:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011b450:	74 1d                	je     f011b46f <test_kheap_virt_addr+0x9a1>
			{
				if (correct)
f011b452:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b456:	74 17                	je     f011b46f <test_kheap_virt_addr+0x9a1>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
f011b458:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b45f:	83 ec 0c             	sub    $0xc,%esp
f011b462:	68 c8 e4 12 f0       	push   $0xf012e4c8
f011b467:	e8 1f 5b fe ff       	call   f0100f8b <cprintf>
f011b46c:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011b46f:	ff 45 d0             	incl   -0x30(%ebp)
f011b472:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b478:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011b47e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b481:	39 c2                	cmp    %eax,%edx
f011b483:	77 a9                	ja     f011b42e <test_kheap_virt_addr+0x960>
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011b485:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b48b:	05 00 04 00 00       	add    $0x400,%eax
f011b490:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011b493:	eb 64                	jmp    f011b4f9 <test_kheap_virt_addr+0xa2b>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011b495:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b498:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b49b:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b49e:	83 ec 0c             	sub    $0xc,%esp
f011b4a1:	50                   	push   %eax
f011b4a2:	e8 30 dc fe ff       	call   f01090d7 <kheap_virtual_address>
f011b4a7:	83 c4 10             	add    $0x10,%esp
f011b4aa:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011b4b0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b4b3:	c1 e0 0c             	shl    $0xc,%eax
f011b4b6:	89 c2                	mov    %eax,%edx
f011b4b8:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011b4be:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011b4c1:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b4c4:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b4c7:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b4ca:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b4cf:	01 c8                	add    %ecx,%eax
f011b4d1:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011b4d7:	74 1d                	je     f011b4f6 <test_kheap_virt_addr+0xa28>
			{
				if (correct)
f011b4d9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b4dd:	74 17                	je     f011b4f6 <test_kheap_virt_addr+0xa28>
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
f011b4df:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b4e6:	83 ec 0c             	sub    $0xc,%esp
f011b4e9:	68 ec e4 12 f0       	push   $0xf012e4ec
f011b4ee:	e8 98 5a fe ff       	call   f0100f8b <cprintf>
f011b4f3:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("4.1 Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011b4f6:	ff 45 d0             	incl   -0x30(%ebp)
f011b4f9:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b4ff:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011b505:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b508:	39 c2                	cmp    %eax,%edx
f011b50a:	77 89                	ja     f011b495 <test_kheap_virt_addr+0x9c7>
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011b50c:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b512:	05 02 07 00 00       	add    $0x702,%eax
f011b517:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011b51a:	eb 44                	jmp    f011b560 <test_kheap_virt_addr+0xa92>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011b51c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b51f:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b522:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b525:	83 ec 0c             	sub    $0xc,%esp
f011b528:	50                   	push   %eax
f011b529:	e8 a9 db fe ff       	call   f01090d7 <kheap_virtual_address>
f011b52e:	83 c4 10             	add    $0x10,%esp
f011b531:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011b537:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011b53e:	74 1d                	je     f011b55d <test_kheap_virt_addr+0xa8f>
			{
				if (correct)
f011b540:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b544:	74 17                	je     f011b55d <test_kheap_virt_addr+0xa8f>
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
f011b546:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b54d:	83 ec 0c             	sub    $0xc,%esp
f011b550:	68 10 e5 12 f0       	push   $0xf012e510
f011b555:	e8 31 5a fe ff       	call   f0100f8b <cprintf>
f011b55a:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.2 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011b55d:	ff 45 d0             	incl   -0x30(%ebp)
f011b560:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b566:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011b56c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b56f:	39 c2                	cmp    %eax,%edx
f011b571:	77 a9                	ja     f011b51c <test_kheap_virt_addr+0xa4e>
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011b573:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b579:	05 02 0d 00 00       	add    $0xd02,%eax
f011b57e:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011b581:	eb 64                	jmp    f011b5e7 <test_kheap_virt_addr+0xb19>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011b583:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b586:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b589:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b58c:	83 ec 0c             	sub    $0xc,%esp
f011b58f:	50                   	push   %eax
f011b590:	e8 42 db fe ff       	call   f01090d7 <kheap_virtual_address>
f011b595:	83 c4 10             	add    $0x10,%esp
f011b598:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011b59e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b5a1:	c1 e0 0c             	shl    $0xc,%eax
f011b5a4:	89 c2                	mov    %eax,%edx
f011b5a6:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011b5ac:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011b5af:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b5b2:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011b5b5:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011b5b8:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b5bd:	01 c8                	add    %ecx,%eax
f011b5bf:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011b5c5:	74 1d                	je     f011b5e4 <test_kheap_virt_addr+0xb16>
			{
				if (correct)
f011b5c7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b5cb:	74 17                	je     f011b5e4 <test_kheap_virt_addr+0xb16>
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
f011b5cd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b5d4:	83 ec 0c             	sub    $0xc,%esp
f011b5d7:	68 34 e5 12 f0       	push   $0xf012e534
f011b5dc:	e8 aa 59 fe ff       	call   f0100f8b <cprintf>
f011b5e1:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("4.3 Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011b5e4:	ff 45 d0             	incl   -0x30(%ebp)
f011b5e7:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011b5ed:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011b5f3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b5f6:	39 c2                	cmp    %eax,%edx
f011b5f8:	77 89                	ja     f011b583 <test_kheap_virt_addr+0xab5>
				if (correct)
				{ correct = 0; cprintf("4.4 Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011b5fa:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b5fe:	74 04                	je     f011b604 <test_kheap_virt_addr+0xb36>
f011b600:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011b604:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
f011b60b:	83 ec 0c             	sub    $0xc,%esp
f011b60e:	68 58 e5 12 f0       	push   $0xf012e558
f011b613:	e8 73 59 fe ff       	call   f0100f8b <cprintf>
f011b618:	83 c4 10             	add    $0x10,%esp
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
f011b61b:	83 ec 0c             	sub    $0xc,%esp
f011b61e:	6a 00                	push   $0x0
f011b620:	e8 10 d7 fe ff       	call   f0108d35 <sbrk>
f011b625:	83 c4 10             	add    $0x10,%esp
f011b628:	3d 00 10 00 f6       	cmp    $0xf6001000,%eax
f011b62d:	77 17                	ja     f011b646 <test_kheap_virt_addr+0xb78>
f011b62f:	83 ec 04             	sub    $0x4,%esp
f011b632:	68 9f e5 12 f0       	push   $0xf012e59f
f011b637:	68 a2 07 00 00       	push   $0x7a2
f011b63c:	68 77 b9 12 f0       	push   $0xf012b977
f011b641:	e8 f3 4c fe ff       	call   f0100339 <_panic>
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b646:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011b64d:	e9 d1 00 00 00       	jmp    f011b723 <test_kheap_virt_addr+0xc55>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011b652:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011b657:	83 ec 04             	sub    $0x4,%esp
f011b65a:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011b660:	52                   	push   %edx
f011b661:	ff 75 cc             	pushl  -0x34(%ebp)
f011b664:	50                   	push   %eax
f011b665:	e8 55 ce fe ff       	call   f01084bf <get_page_table>
f011b66a:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b66d:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b673:	85 c0                	test   %eax,%eax
f011b675:	75 1e                	jne    f011b695 <test_kheap_virt_addr+0xbc7>
			{ correct = 0; panic("5.1 one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011b677:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b67e:	83 ec 04             	sub    $0x4,%esp
f011b681:	68 28 df 12 f0       	push   $0xf012df28
f011b686:	68 a8 07 00 00       	push   $0x7a8
f011b68b:	68 77 b9 12 f0       	push   $0xf012b977
f011b690:	e8 a4 4c fe ff       	call   f0100339 <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011b695:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011b69b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011b69e:	c1 ea 0c             	shr    $0xc,%edx
f011b6a1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011b6a7:	c1 e2 02             	shl    $0x2,%edx
f011b6aa:	01 d0                	add    %edx,%eax
f011b6ac:	8b 00                	mov    (%eax),%eax
f011b6ae:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011b6b3:	89 c2                	mov    %eax,%edx
f011b6b5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011b6b8:	25 ff 0f 00 00       	and    $0xfff,%eax
f011b6bd:	01 d0                	add    %edx,%eax
f011b6bf:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011b6c5:	83 ec 0c             	sub    $0xc,%esp
f011b6c8:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011b6ce:	e8 04 da fe ff       	call   f01090d7 <kheap_virtual_address>
f011b6d3:	83 c4 10             	add    $0x10,%esp
f011b6d6:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011b6dc:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011b6e2:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011b6e5:	74 39                	je     f011b720 <test_kheap_virt_addr+0xc52>
			{
				if (correct)
f011b6e7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b6eb:	74 33                	je     f011b720 <test_kheap_virt_addr+0xc52>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011b6ed:	ff 75 cc             	pushl  -0x34(%ebp)
f011b6f0:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011b6f6:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011b6fc:	68 b8 e5 12 f0       	push   $0xf012e5b8
f011b701:	e8 85 58 fe ff       	call   f0100f8b <cprintf>
f011b706:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
f011b709:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b710:	83 ec 0c             	sub    $0xc,%esp
f011b713:	68 e4 e5 12 f0       	push   $0xf012e5e4
f011b718:	e8 6e 58 fe ff       	call   f0100f8b <cprintf>
f011b71d:	83 c4 10             	add    $0x10,%esp
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	cprintf("\n5. [DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]\n");
	{
		uint32 va, pa;
		if ((uint32)sbrk(0) <= KERNEL_HEAP_START + PAGE_SIZE) panic("unexpected sbrk value");
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011b720:	ff 45 cc             	incl   -0x34(%ebp)
f011b723:	83 ec 0c             	sub    $0xc,%esp
f011b726:	6a 00                	push   $0x0
f011b728:	e8 08 d6 fe ff       	call   f0108d35 <sbrk>
f011b72d:	83 c4 10             	add    $0x10,%esp
f011b730:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011b733:	0f 87 19 ff ff ff    	ja     f011b652 <test_kheap_virt_addr+0xb84>
					correct = 0; cprintf("5.2 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011b739:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b73d:	74 04                	je     f011b743 <test_kheap_virt_addr+0xc75>
f011b73f:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011b743:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
f011b74a:	83 ec 0c             	sub    $0xc,%esp
f011b74d:	68 08 e6 12 f0       	push   $0xf012e608
f011b752:	e8 34 58 fe ff       	call   f0100f8b <cprintf>
f011b757:	83 c4 10             	add    $0x10,%esp
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011b75a:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011b761:	eb 5a                	jmp    f011b7bd <test_kheap_virt_addr+0xcef>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011b763:	83 ec 0c             	sub    $0xc,%esp
f011b766:	ff 75 c8             	pushl  -0x38(%ebp)
f011b769:	e8 69 d9 fe ff       	call   f01090d7 <kheap_virtual_address>
f011b76e:	83 c4 10             	add    $0x10,%esp
f011b771:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011b777:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011b77e:	74 36                	je     f011b7b6 <test_kheap_virt_addr+0xce8>
			{
				if (correct)
f011b780:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b784:	74 30                	je     f011b7b6 <test_kheap_virt_addr+0xce8>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011b786:	83 ec 04             	sub    $0x4,%esp
f011b789:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011b78f:	ff 75 c8             	pushl  -0x38(%ebp)
f011b792:	68 47 e6 12 f0       	push   $0xf012e647
f011b797:	e8 ef 57 fe ff       	call   f0100f8b <cprintf>
f011b79c:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
f011b79f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b7a6:	83 ec 0c             	sub    $0xc,%esp
f011b7a9:	68 64 e6 12 f0       	push   $0xf012e664
f011b7ae:	e8 d8 57 fe ff       	call   f0100f8b <cprintf>
f011b7b3:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	cprintf("\n6. test kheap_virtual_address on frames of KERNEL CODE [20%]\n");
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011b7b6:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011b7bd:	b8 f4 f5 60 00       	mov    $0x60f5f4,%eax
f011b7c2:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011b7c5:	72 9c                	jb     f011b763 <test_kheap_virt_addr+0xc95>
					correct = 0; cprintf("6.1 Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011b7c7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011b7cb:	74 04                	je     f011b7d1 <test_kheap_virt_addr+0xd03>
f011b7cd:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011b7d1:	83 ec 08             	sub    $0x8,%esp
f011b7d4:	ff 75 e4             	pushl  -0x1c(%ebp)
f011b7d7:	68 88 e6 12 f0       	push   $0xf012e688
f011b7dc:	e8 aa 57 fe ff       	call   f0100f8b <cprintf>
f011b7e1:	83 c4 10             	add    $0x10,%esp

	return 1;
f011b7e4:	b8 01 00 00 00       	mov    $0x1,%eax
f011b7e9:	89 f4                	mov    %esi,%esp

}
f011b7eb:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011b7ee:	5b                   	pop    %ebx
f011b7ef:	5e                   	pop    %esi
f011b7f0:	5f                   	pop    %edi
f011b7f1:	5d                   	pop    %ebp
f011b7f2:	c3                   	ret    

f011b7f3 <test_ksbrk>:

// 2024
int test_ksbrk()
{
f011b7f3:	55                   	push   %ebp
f011b7f4:	89 e5                	mov    %esp,%ebp
f011b7f6:	57                   	push   %edi
f011b7f7:	56                   	push   %esi
f011b7f8:	53                   	push   %ebx
f011b7f9:	81 ec 0c 01 00 00    	sub    $0x10c,%esp
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	void *ptr_allocations[20] = {0};
f011b7ff:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011b805:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b80a:	b8 00 00 00 00       	mov    $0x0,%eax
f011b80f:	89 d7                	mov    %edx,%edi
f011b811:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 actualSize;
	const int sizeOfMetaData = 8;
f011b813:	c7 45 d0 08 00 00 00 	movl   $0x8,-0x30(%ebp)
	int eval = 0;
f011b81a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011b821:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	void* actualStart = (void*)KERNEL_HEAP_START + sizeof(int) /*BEG Block*/ + INITIAL_BLOCK_ALLOCATIONS;
f011b828:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f011b82d:	0f b6 c0             	movzbl %al,%eax
f011b830:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011b833:	c7 45 c8 08 00 00 00 	movl   $0x8,-0x38(%ebp)
f011b83a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b83d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011b840:	39 c2                	cmp    %eax,%edx
f011b842:	73 02                	jae    f011b846 <test_ksbrk+0x53>
f011b844:	89 c2                	mov    %eax,%edx
f011b846:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f011b84b:	0f b6 c0             	movzbl %al,%eax
f011b84e:	c1 e0 04             	shl    $0x4,%eax
f011b851:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011b854:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%ebp)
f011b85b:	8b 4d c0             	mov    -0x40(%ebp),%ecx
f011b85e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011b861:	39 c8                	cmp    %ecx,%eax
f011b863:	73 02                	jae    f011b867 <test_ksbrk+0x74>
f011b865:	89 c8                	mov    %ecx,%eax
f011b867:	01 d0                	add    %edx,%eax
f011b869:	83 c0 10             	add    $0x10,%eax
f011b86c:	2d fc ff ff 09       	sub    $0x9fffffc,%eax
f011b871:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32* ENDBlk ;
	void* expectedVA, *expectedSBRK;
	uint32 expectedSize;
	uint32 oldBrk, newBrk;
	cprintf("\nSTEP A: check calling sbrk() in alloc_FF() with last block is allocated [25%]\n\n");
f011b874:	83 ec 0c             	sub    $0xc,%esp
f011b877:	68 bc e6 12 f0       	push   $0xf012e6bc
f011b87c:	e8 0a 57 fe ff       	call   f0100f8b <cprintf>
f011b881:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB
		actualSize = 2*kilo;
f011b884:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b88b:	e8 e5 21 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011b890:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b893:	e8 71 90 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011b898:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011b89b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b89e:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011b8a1:	29 c2                	sub    %eax,%edx
f011b8a3:	89 d0                	mov    %edx,%eax
f011b8a5:	83 ec 0c             	sub    $0xc,%esp
f011b8a8:	50                   	push   %eax
f011b8a9:	e8 82 d5 fe ff       	call   f0108e30 <kmalloc>
f011b8ae:	83 c4 10             	add    $0x10,%esp
f011b8b1:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = actualStart + sizeOfMetaData/2 /*header*/;
f011b8b7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b8ba:	89 c2                	mov    %eax,%edx
f011b8bc:	c1 ea 1f             	shr    $0x1f,%edx
f011b8bf:	01 d0                	add    %edx,%eax
f011b8c1:	d1 f8                	sar    %eax
f011b8c3:	89 c2                	mov    %eax,%edx
f011b8c5:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011b8c8:	01 d0                	add    %edx,%eax
f011b8ca:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011b8cd:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011b8d3:	6a 01                	push   $0x1
f011b8d5:	ff 75 b8             	pushl  -0x48(%ebp)
f011b8d8:	ff 75 ac             	pushl  -0x54(%ebp)
f011b8db:	50                   	push   %eax
f011b8dc:	e8 89 43 ff ff       	call   f010fc6a <check_block>
f011b8e1:	83 c4 10             	add    $0x10,%esp
f011b8e4:	85 c0                	test   %eax,%eax
f011b8e6:	75 17                	jne    f011b8ff <test_ksbrk+0x10c>
		{ correct = 0; cprintf("A.1: Wrong block data\n"); }
f011b8e8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b8ef:	83 ec 0c             	sub    $0xc,%esp
f011b8f2:	68 0d e7 12 f0       	push   $0xf012e70d
f011b8f7:	e8 8f 56 fe ff       	call   f0100f8b <cprintf>
f011b8fc:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011b8ff:	e8 71 21 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011b904:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011b907:	74 17                	je     f011b920 <test_ksbrk+0x12d>
		{ correct = 0; cprintf("A.2: Wrong memory allocation.\n"); }
f011b909:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b910:	83 ec 0c             	sub    $0xc,%esp
f011b913:	68 24 e7 12 f0       	push   $0xf012e724
f011b918:	e8 6e 56 fe ff       	call   f0100f8b <cprintf>
f011b91d:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011b920:	e8 e4 8f fe ff       	call   f0104909 <pf_calculate_free_frames>
f011b925:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011b928:	74 17                	je     f011b941 <test_ksbrk+0x14e>
		{ correct = 0; cprintf("A.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b92a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b931:	83 ec 0c             	sub    $0xc,%esp
f011b934:	68 44 e7 12 f0       	push   $0xf012e744
f011b939:	e8 4d 56 fe ff       	call   f0100f8b <cprintf>
f011b93e:	83 c4 10             	add    $0x10,%esp

		//=> Fill 1st page
		actualSize = PAGE_SIZE - (2*kilo + 2*sizeof(int)) - INITIAL_BLOCK_ALLOCATIONS;
f011b941:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f011b946:	0f b6 c0             	movzbl %al,%eax
f011b949:	89 45 a8             	mov    %eax,-0x58(%ebp)
f011b94c:	c7 45 a4 08 00 00 00 	movl   $0x8,-0x5c(%ebp)
f011b953:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011b956:	8b 55 a8             	mov    -0x58(%ebp),%edx
f011b959:	39 c2                	cmp    %eax,%edx
f011b95b:	73 02                	jae    f011b95f <test_ksbrk+0x16c>
f011b95d:	89 c2                	mov    %eax,%edx
f011b95f:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f011b964:	0f b6 c0             	movzbl %al,%eax
f011b967:	c1 e0 04             	shl    $0x4,%eax
f011b96a:	89 45 a0             	mov    %eax,-0x60(%ebp)
f011b96d:	c7 45 9c 08 00 00 00 	movl   $0x8,-0x64(%ebp)
f011b974:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
f011b977:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011b97a:	39 c8                	cmp    %ecx,%eax
f011b97c:	73 02                	jae    f011b980 <test_ksbrk+0x18d>
f011b97e:	89 c8                	mov    %ecx,%eax
f011b980:	01 d0                	add    %edx,%eax
f011b982:	ba e8 07 00 00       	mov    $0x7e8,%edx
f011b987:	29 c2                	sub    %eax,%edx
f011b989:	89 d0                	mov    %edx,%eax
f011b98b:	89 45 b8             	mov    %eax,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011b98e:	e8 e2 20 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011b993:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011b996:	e8 6e 8f fe ff       	call   f0104909 <pf_calculate_free_frames>
f011b99b:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011b99e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b9a1:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011b9a4:	29 c2                	sub    %eax,%edx
f011b9a6:	89 d0                	mov    %edx,%eax
f011b9a8:	83 ec 0c             	sub    $0xc,%esp
f011b9ab:	50                   	push   %eax
f011b9ac:	e8 7f d4 fe ff       	call   f0108e30 <kmalloc>
f011b9b1:	83 c4 10             	add    $0x10,%esp
f011b9b4:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = actualStart + 2*kilo + sizeOfMetaData/2 /*header*/;
f011b9ba:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011b9bd:	89 c2                	mov    %eax,%edx
f011b9bf:	c1 ea 1f             	shr    $0x1f,%edx
f011b9c2:	01 d0                	add    %edx,%eax
f011b9c4:	d1 f8                	sar    %eax
f011b9c6:	8d 90 00 08 00 00    	lea    0x800(%eax),%edx
f011b9cc:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011b9cf:	01 d0                	add    %edx,%eax
f011b9d1:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011b9d4:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011b9da:	6a 01                	push   $0x1
f011b9dc:	ff 75 b8             	pushl  -0x48(%ebp)
f011b9df:	ff 75 ac             	pushl  -0x54(%ebp)
f011b9e2:	50                   	push   %eax
f011b9e3:	e8 82 42 ff ff       	call   f010fc6a <check_block>
f011b9e8:	83 c4 10             	add    $0x10,%esp
f011b9eb:	85 c0                	test   %eax,%eax
f011b9ed:	75 17                	jne    f011ba06 <test_ksbrk+0x213>
		{ correct = 0; cprintf("A.4: Wrong block data\n"); }
f011b9ef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011b9f6:	83 ec 0c             	sub    $0xc,%esp
f011b9f9:	68 b2 e7 12 f0       	push   $0xf012e7b2
f011b9fe:	e8 88 55 fe ff       	call   f0100f8b <cprintf>
f011ba03:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011ba06:	e8 6a 20 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011ba0b:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011ba0e:	74 17                	je     f011ba27 <test_ksbrk+0x234>
		{ correct = 0; cprintf("A.5: Wrong memory allocation.\n"); }
f011ba10:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ba17:	83 ec 0c             	sub    $0xc,%esp
f011ba1a:	68 cc e7 12 f0       	push   $0xf012e7cc
f011ba1f:	e8 67 55 fe ff       	call   f0100f8b <cprintf>
f011ba24:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011ba27:	e8 dd 8e fe ff       	call   f0104909 <pf_calculate_free_frames>
f011ba2c:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011ba2f:	74 17                	je     f011ba48 <test_ksbrk+0x255>
		{ correct = 0; cprintf("A.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ba31:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ba38:	83 ec 0c             	sub    $0xc,%esp
f011ba3b:	68 ec e7 12 f0       	push   $0xf012e7ec
f011ba40:	e8 46 55 fe ff       	call   f0100f8b <cprintf>
f011ba45:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is allocated
		{
			actualSize = 2*kilo;
f011ba48:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011ba4f:	e8 21 20 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011ba54:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011ba57:	e8 ad 8e fe ff       	call   f0104909 <pf_calculate_free_frames>
f011ba5c:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011ba5f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ba62:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011ba65:	29 c2                	sub    %eax,%edx
f011ba67:	89 d0                	mov    %edx,%eax
f011ba69:	83 ec 0c             	sub    $0xc,%esp
f011ba6c:	50                   	push   %eax
f011ba6d:	e8 be d3 fe ff       	call   f0108e30 <kmalloc>
f011ba72:	83 c4 10             	add    $0x10,%esp
f011ba75:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = ((void*)KERNEL_HEAP_START + PAGE_SIZE - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011ba7b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ba7e:	89 c2                	mov    %eax,%edx
f011ba80:	c1 ea 1f             	shr    $0x1f,%edx
f011ba83:	01 d0                	add    %edx,%eax
f011ba85:	d1 f8                	sar    %eax
f011ba87:	2d 04 f0 ff 09       	sub    $0x9fff004,%eax
f011ba8c:	89 45 ac             	mov    %eax,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011ba8f:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011ba95:	6a 01                	push   $0x1
f011ba97:	ff 75 b8             	pushl  -0x48(%ebp)
f011ba9a:	ff 75 ac             	pushl  -0x54(%ebp)
f011ba9d:	50                   	push   %eax
f011ba9e:	e8 c7 41 ff ff       	call   f010fc6a <check_block>
f011baa3:	83 c4 10             	add    $0x10,%esp
f011baa6:	85 c0                	test   %eax,%eax
f011baa8:	75 17                	jne    f011bac1 <test_ksbrk+0x2ce>
			{ correct = 0; cprintf("A.7: Wrong block data\n"); }
f011baaa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bab1:	83 ec 0c             	sub    $0xc,%esp
f011bab4:	68 5a e8 12 f0       	push   $0xf012e85a
f011bab9:	e8 cd 54 fe ff       	call   f0100f8b <cprintf>
f011babe:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011bac1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011bac4:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - actualSize;
f011bac7:	b8 00 10 00 00       	mov    $0x1000,%eax
f011bacc:	2b 45 b8             	sub    -0x48(%ebp),%eax
f011bacf:	89 45 98             	mov    %eax,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011bad2:	6a 00                	push   $0x0
f011bad4:	ff 75 98             	pushl  -0x68(%ebp)
f011bad7:	ff 75 ac             	pushl  -0x54(%ebp)
f011bada:	ff 75 ac             	pushl  -0x54(%ebp)
f011badd:	e8 88 41 ff ff       	call   f010fc6a <check_block>
f011bae2:	83 c4 10             	add    $0x10,%esp
f011bae5:	85 c0                	test   %eax,%eax
f011bae7:	75 17                	jne    f011bb00 <test_ksbrk+0x30d>
			{ correct = 0; cprintf("A.8: Wrong block data\n"); }
f011bae9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011baf0:	83 ec 0c             	sub    $0xc,%esp
f011baf3:	68 71 e8 12 f0       	push   $0xf012e871
f011baf8:	e8 8e 54 fe ff       	call   f0100f8b <cprintf>
f011bafd:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE - sizeof(int);
f011bb00:	c7 45 94 fc 1f 00 f6 	movl   $0xf6001ffc,-0x6c(%ebp)
			if (*ENDBlk != 0x1)
f011bb07:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011bb0a:	8b 00                	mov    (%eax),%eax
f011bb0c:	83 f8 01             	cmp    $0x1,%eax
f011bb0f:	74 1a                	je     f011bb2b <test_ksbrk+0x338>
			{ correct = 0;
f011bb11:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)



			cprintf("A.9: Wrong END block after calling sbrk()----%x\n",ENDBlk); }
f011bb18:	83 ec 08             	sub    $0x8,%esp
f011bb1b:	ff 75 94             	pushl  -0x6c(%ebp)
f011bb1e:	68 88 e8 12 f0       	push   $0xf012e888
f011bb23:	e8 63 54 fe ff       	call   f0100f8b <cprintf>
f011bb28:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011bb2b:	83 ec 0c             	sub    $0xc,%esp
f011bb2e:	6a 00                	push   $0x0
f011bb30:	e8 00 d2 fe ff       	call   f0108d35 <sbrk>
f011bb35:	83 c4 10             	add    $0x10,%esp
f011bb38:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)KERNEL_HEAP_START + 2*PAGE_SIZE ;
f011bb3b:	c7 45 8c 00 20 00 f6 	movl   $0xf6002000,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011bb42:	8b 45 90             	mov    -0x70(%ebp),%eax
f011bb45:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011bb48:	74 1d                	je     f011bb67 <test_ksbrk+0x374>
			{correct = 0; cprintf("A.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011bb4a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bb51:	83 ec 04             	sub    $0x4,%esp
f011bb54:	ff 75 90             	pushl  -0x70(%ebp)
f011bb57:	ff 75 8c             	pushl  -0x74(%ebp)
f011bb5a:	68 bc e8 12 f0       	push   $0xf012e8bc
f011bb5f:	e8 27 54 fe ff       	call   f0100f8b <cprintf>
f011bb64:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011bb67:	e8 09 1f ff ff       	call   f010da75 <sys_calculate_free_frames>
f011bb6c:	89 c2                	mov    %eax,%edx
f011bb6e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011bb71:	29 d0                	sub    %edx,%eax
f011bb73:	83 f8 01             	cmp    $0x1,%eax
f011bb76:	74 17                	je     f011bb8f <test_ksbrk+0x39c>
			{ correct = 0; cprintf("A.11: Wrong memory allocation.\n"); }
f011bb78:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bb7f:	83 ec 0c             	sub    $0xc,%esp
f011bb82:	68 f0 e8 12 f0       	push   $0xf012e8f0
f011bb87:	e8 ff 53 fe ff       	call   f0100f8b <cprintf>
f011bb8c:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011bb8f:	e8 75 8d fe ff       	call   f0104909 <pf_calculate_free_frames>
f011bb94:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011bb97:	74 17                	je     f011bbb0 <test_ksbrk+0x3bd>
			{ correct = 0; cprintf("A.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bb99:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bba0:	83 ec 0c             	sub    $0xc,%esp
f011bba3:	68 10 e9 12 f0       	push   $0xf012e910
f011bba8:	e8 de 53 fe ff       	call   f0100f8b <cprintf>
f011bbad:	83 c4 10             	add    $0x10,%esp
		}

		//=> Fill 2nd page
		actualSize = PAGE_SIZE - 2*kilo ;
f011bbb0:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011bbb7:	e8 b9 1e ff ff       	call   f010da75 <sys_calculate_free_frames>
f011bbbc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bbbf:	e8 45 8d fe ff       	call   f0104909 <pf_calculate_free_frames>
f011bbc4:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[3] = kmalloc(actualSize - sizeOfMetaData);
f011bbc7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bbca:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011bbcd:	29 c2                	sub    %eax,%edx
f011bbcf:	89 d0                	mov    %edx,%eax
f011bbd1:	83 ec 0c             	sub    $0xc,%esp
f011bbd4:	50                   	push   %eax
f011bbd5:	e8 56 d2 fe ff       	call   f0108e30 <kmalloc>
f011bbda:	83 c4 10             	add    $0x10,%esp
f011bbdd:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		expectedVA = (void*)KERNEL_HEAP_START + PAGE_SIZE + 2*kilo /*include its header*/;
f011bbe3:	c7 45 ac 00 18 00 f6 	movl   $0xf6001800,-0x54(%ebp)
		if (check_block(ptr_allocations[3], expectedVA, actualSize, 1) == 0)
f011bbea:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011bbf0:	6a 01                	push   $0x1
f011bbf2:	ff 75 b8             	pushl  -0x48(%ebp)
f011bbf5:	ff 75 ac             	pushl  -0x54(%ebp)
f011bbf8:	50                   	push   %eax
f011bbf9:	e8 6c 40 ff ff       	call   f010fc6a <check_block>
f011bbfe:	83 c4 10             	add    $0x10,%esp
f011bc01:	85 c0                	test   %eax,%eax
f011bc03:	75 17                	jne    f011bc1c <test_ksbrk+0x429>
		{ correct = 0; cprintf("A.13: Wrong block data\n"); }
f011bc05:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc0c:	83 ec 0c             	sub    $0xc,%esp
f011bc0f:	68 7f e9 12 f0       	push   $0xf012e97f
f011bc14:	e8 72 53 fe ff       	call   f0100f8b <cprintf>
f011bc19:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011bc1c:	e8 54 1e ff ff       	call   f010da75 <sys_calculate_free_frames>
f011bc21:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011bc24:	74 17                	je     f011bc3d <test_ksbrk+0x44a>
		{ correct = 0; cprintf("A.14: Wrong memory allocation.\n"); }
f011bc26:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc2d:	83 ec 0c             	sub    $0xc,%esp
f011bc30:	68 98 e9 12 f0       	push   $0xf012e998
f011bc35:	e8 51 53 fe ff       	call   f0100f8b <cprintf>
f011bc3a:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011bc3d:	e8 c7 8c fe ff       	call   f0104909 <pf_calculate_free_frames>
f011bc42:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011bc45:	74 17                	je     f011bc5e <test_ksbrk+0x46b>
		{ correct = 0; cprintf("A.15: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bc47:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bc4e:	83 ec 0c             	sub    $0xc,%esp
f011bc51:	68 b8 e9 12 f0       	push   $0xf012e9b8
f011bc56:	e8 30 53 fe ff       	call   f0100f8b <cprintf>
f011bc5b:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)
f011bc5e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bc62:	74 04                	je     f011bc68 <test_ksbrk+0x475>
		eval += 25;
f011bc64:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	cprintf("\nSTEP B: check calling sbrk() in alloc_FF() with last block is free (coalesce is expected) [25%]\n\n");
f011bc68:	83 ec 0c             	sub    $0xc,%esp
f011bc6b:	68 28 ea 12 f0       	push   $0xf012ea28
f011bc70:	e8 16 53 fe ff       	call   f0100f8b <cprintf>
f011bc75:	83 c4 10             	add    $0x10,%esp
	{
		//2 KB: sbrk is called with last block is allocated
		oldBrk = (uint32)sbrk(0);
f011bc78:	83 ec 0c             	sub    $0xc,%esp
f011bc7b:	6a 00                	push   $0x0
f011bc7d:	e8 b3 d0 fe ff       	call   f0108d35 <sbrk>
f011bc82:	83 c4 10             	add    $0x10,%esp
f011bc85:	89 45 88             	mov    %eax,-0x78(%ebp)
		actualSize = 2*kilo;
f011bc88:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011bc8f:	e8 e1 1d ff ff       	call   f010da75 <sys_calculate_free_frames>
f011bc94:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bc97:	e8 6d 8c fe ff       	call   f0104909 <pf_calculate_free_frames>
f011bc9c:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[0] = kmalloc(actualSize - sizeOfMetaData);
f011bc9f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bca2:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011bca5:	29 c2                	sub    %eax,%edx
f011bca7:	89 d0                	mov    %edx,%eax
f011bca9:	83 ec 0c             	sub    $0xc,%esp
f011bcac:	50                   	push   %eax
f011bcad:	e8 7e d1 fe ff       	call   f0108e30 <kmalloc>
f011bcb2:	83 c4 10             	add    $0x10,%esp
f011bcb5:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		expectedVA = (void*)(oldBrk - sizeof(int)) + sizeOfMetaData/2 /*header*/;
f011bcbb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bcbe:	89 c2                	mov    %eax,%edx
f011bcc0:	c1 ea 1f             	shr    $0x1f,%edx
f011bcc3:	01 d0                	add    %edx,%eax
f011bcc5:	d1 f8                	sar    %eax
f011bcc7:	89 c2                	mov    %eax,%edx
f011bcc9:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bccc:	01 d0                	add    %edx,%eax
f011bcce:	83 e8 04             	sub    $0x4,%eax
f011bcd1:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if (check_block(ptr_allocations[0], expectedVA, actualSize, 1) == 0)
f011bcd4:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011bcda:	6a 01                	push   $0x1
f011bcdc:	ff 75 b8             	pushl  -0x48(%ebp)
f011bcdf:	ff 75 ac             	pushl  -0x54(%ebp)
f011bce2:	50                   	push   %eax
f011bce3:	e8 82 3f ff ff       	call   f010fc6a <check_block>
f011bce8:	83 c4 10             	add    $0x10,%esp
f011bceb:	85 c0                	test   %eax,%eax
f011bced:	75 17                	jne    f011bd06 <test_ksbrk+0x513>
		{ correct = 0; cprintf("B.1: Wrong block data\n"); }
f011bcef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bcf6:	83 ec 0c             	sub    $0xc,%esp
f011bcf9:	68 8b ea 12 f0       	push   $0xf012ea8b
f011bcfe:	e8 88 52 fe ff       	call   f0100f8b <cprintf>
f011bd03:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011bd06:	e8 6a 1d ff ff       	call   f010da75 <sys_calculate_free_frames>
f011bd0b:	89 c2                	mov    %eax,%edx
f011bd0d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011bd10:	29 d0                	sub    %edx,%eax
f011bd12:	83 f8 01             	cmp    $0x1,%eax
f011bd15:	74 17                	je     f011bd2e <test_ksbrk+0x53b>
		{ correct = 0; cprintf("B.2: Wrong memory allocation.\n"); }
f011bd17:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd1e:	83 ec 0c             	sub    $0xc,%esp
f011bd21:	68 a4 ea 12 f0       	push   $0xf012eaa4
f011bd26:	e8 60 52 fe ff       	call   f0100f8b <cprintf>
f011bd2b:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011bd2e:	e8 d6 8b fe ff       	call   f0104909 <pf_calculate_free_frames>
f011bd33:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011bd36:	74 17                	je     f011bd4f <test_ksbrk+0x55c>
		{ correct = 0; cprintf("B.3: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bd38:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bd3f:	83 ec 0c             	sub    $0xc,%esp
f011bd42:	68 c4 ea 12 f0       	push   $0xf012eac4
f011bd47:	e8 3f 52 fe ff       	call   f0100f8b <cprintf>
f011bd4c:	83 c4 10             	add    $0x10,%esp

		//1 KB
		actualSize = 1*kilo;
f011bd4f:	c7 45 b8 00 04 00 00 	movl   $0x400,-0x48(%ebp)
		freeFrames = (int)sys_calculate_free_frames() ;
f011bd56:	e8 1a 1d ff ff       	call   f010da75 <sys_calculate_free_frames>
f011bd5b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011bd5e:	e8 a6 8b fe ff       	call   f0104909 <pf_calculate_free_frames>
f011bd63:	89 45 b0             	mov    %eax,-0x50(%ebp)
		ptr_allocations[1] = kmalloc(actualSize - sizeOfMetaData);
f011bd66:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011bd69:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011bd6c:	29 c2                	sub    %eax,%edx
f011bd6e:	89 d0                	mov    %edx,%eax
f011bd70:	83 ec 0c             	sub    $0xc,%esp
f011bd73:	50                   	push   %eax
f011bd74:	e8 b7 d0 fe ff       	call   f0108e30 <kmalloc>
f011bd79:	83 c4 10             	add    $0x10,%esp
f011bd7c:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		expectedVA = expectedVA + 2*kilo ;
f011bd82:	81 45 ac 00 08 00 00 	addl   $0x800,-0x54(%ebp)
		if (check_block(ptr_allocations[1], expectedVA, actualSize, 1) == 0)
f011bd89:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011bd8f:	6a 01                	push   $0x1
f011bd91:	ff 75 b8             	pushl  -0x48(%ebp)
f011bd94:	ff 75 ac             	pushl  -0x54(%ebp)
f011bd97:	50                   	push   %eax
f011bd98:	e8 cd 3e ff ff       	call   f010fc6a <check_block>
f011bd9d:	83 c4 10             	add    $0x10,%esp
f011bda0:	85 c0                	test   %eax,%eax
f011bda2:	75 17                	jne    f011bdbb <test_ksbrk+0x5c8>
		{ correct = 0; cprintf("B.4: Wrong block data\n"); }
f011bda4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bdab:	83 ec 0c             	sub    $0xc,%esp
f011bdae:	68 32 eb 12 f0       	push   $0xf012eb32
f011bdb3:	e8 d3 51 fe ff       	call   f0100f8b <cprintf>
f011bdb8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011bdbb:	e8 b5 1c ff ff       	call   f010da75 <sys_calculate_free_frames>
f011bdc0:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011bdc3:	74 17                	je     f011bddc <test_ksbrk+0x5e9>
		{ correct = 0; cprintf("B.5: Wrong memory allocation.\n"); }
f011bdc5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bdcc:	83 ec 0c             	sub    $0xc,%esp
f011bdcf:	68 4c eb 12 f0       	push   $0xf012eb4c
f011bdd4:	e8 b2 51 fe ff       	call   f0100f8b <cprintf>
f011bdd9:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011bddc:	e8 28 8b fe ff       	call   f0104909 <pf_calculate_free_frames>
f011bde1:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011bde4:	74 17                	je     f011bdfd <test_ksbrk+0x60a>
		{ correct = 0; cprintf("B.6: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bde6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bded:	83 ec 0c             	sub    $0xc,%esp
f011bdf0:	68 6c eb 12 f0       	push   $0xf012eb6c
f011bdf5:	e8 91 51 fe ff       	call   f0100f8b <cprintf>
f011bdfa:	83 c4 10             	add    $0x10,%esp

		//2 KB => sbrk is called while the last block is free
		{
			actualSize = 2*kilo;
f011bdfd:	c7 45 b8 00 08 00 00 	movl   $0x800,-0x48(%ebp)
			freeFrames = (int)sys_calculate_free_frames() ;
f011be04:	e8 6c 1c ff ff       	call   f010da75 <sys_calculate_free_frames>
f011be09:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames() ;
f011be0c:	e8 f8 8a fe ff       	call   f0104909 <pf_calculate_free_frames>
f011be11:	89 45 b0             	mov    %eax,-0x50(%ebp)
			ptr_allocations[2] = kmalloc(actualSize - sizeOfMetaData);
f011be14:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011be17:	8b 55 b8             	mov    -0x48(%ebp),%edx
f011be1a:	29 c2                	sub    %eax,%edx
f011be1c:	89 d0                	mov    %edx,%eax
f011be1e:	83 ec 0c             	sub    $0xc,%esp
f011be21:	50                   	push   %eax
f011be22:	e8 09 d0 fe ff       	call   f0108e30 <kmalloc>
f011be27:	83 c4 10             	add    $0x10,%esp
f011be2a:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
			//check allocated block
			expectedVA = expectedVA + 1*kilo ;
f011be30:	81 45 ac 00 04 00 00 	addl   $0x400,-0x54(%ebp)
			if (check_block(ptr_allocations[2], expectedVA, actualSize, 1) == 0)
f011be37:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011be3d:	6a 01                	push   $0x1
f011be3f:	ff 75 b8             	pushl  -0x48(%ebp)
f011be42:	ff 75 ac             	pushl  -0x54(%ebp)
f011be45:	50                   	push   %eax
f011be46:	e8 1f 3e ff ff       	call   f010fc6a <check_block>
f011be4b:	83 c4 10             	add    $0x10,%esp
f011be4e:	85 c0                	test   %eax,%eax
f011be50:	75 17                	jne    f011be69 <test_ksbrk+0x676>
			{ correct = 0; cprintf("B.7: Wrong block data\n"); }
f011be52:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be59:	83 ec 0c             	sub    $0xc,%esp
f011be5c:	68 da eb 12 f0       	push   $0xf012ebda
f011be61:	e8 25 51 fe ff       	call   f0100f8b <cprintf>
f011be66:	83 c4 10             	add    $0x10,%esp
			//check splitted free block
			expectedVA = expectedVA + actualSize ;
f011be69:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011be6c:	01 45 ac             	add    %eax,-0x54(%ebp)
			expectedSize = PAGE_SIZE - (1*kilo - sizeof(int)) - sizeof(int) /*END block*/;
f011be6f:	c7 45 98 00 0c 00 00 	movl   $0xc00,-0x68(%ebp)
			if (check_block(expectedVA, expectedVA, expectedSize, 0) == 0)
f011be76:	6a 00                	push   $0x0
f011be78:	ff 75 98             	pushl  -0x68(%ebp)
f011be7b:	ff 75 ac             	pushl  -0x54(%ebp)
f011be7e:	ff 75 ac             	pushl  -0x54(%ebp)
f011be81:	e8 e4 3d ff ff       	call   f010fc6a <check_block>
f011be86:	83 c4 10             	add    $0x10,%esp
f011be89:	85 c0                	test   %eax,%eax
f011be8b:	75 17                	jne    f011bea4 <test_ksbrk+0x6b1>
			{ correct = 0; cprintf("B.8: Wrong block data\n"); }
f011be8d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011be94:	83 ec 0c             	sub    $0xc,%esp
f011be97:	68 f1 eb 12 f0       	push   $0xf012ebf1
f011be9c:	e8 ea 50 fe ff       	call   f0100f8b <cprintf>
f011bea1:	83 c4 10             	add    $0x10,%esp
			//check END block & BREAK
			ENDBlk = (void*)oldBrk + 2*PAGE_SIZE - sizeof(int);
f011bea4:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bea7:	05 fc 1f 00 00       	add    $0x1ffc,%eax
f011beac:	89 45 94             	mov    %eax,-0x6c(%ebp)
			cprintf("end%x,br%x\n",ENDBlk,kbrk);
f011beaf:	a1 4c c9 5e f0       	mov    0xf05ec94c,%eax
f011beb4:	83 ec 04             	sub    $0x4,%esp
f011beb7:	50                   	push   %eax
f011beb8:	ff 75 94             	pushl  -0x6c(%ebp)
f011bebb:	68 08 ec 12 f0       	push   $0xf012ec08
f011bec0:	e8 c6 50 fe ff       	call   f0100f8b <cprintf>
f011bec5:	83 c4 10             	add    $0x10,%esp
			if (*ENDBlk != 0x1)
f011bec8:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011becb:	8b 00                	mov    (%eax),%eax
f011becd:	83 f8 01             	cmp    $0x1,%eax
f011bed0:	74 20                	je     f011bef2 <test_ksbrk+0x6ff>
			{ correct = 0; cprintf("B.9: Wrong END block after calling sbrk()expextec----%xfound --%x\n",ENDBlk,kbrk); }
f011bed2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bed9:	a1 4c c9 5e f0       	mov    0xf05ec94c,%eax
f011bede:	83 ec 04             	sub    $0x4,%esp
f011bee1:	50                   	push   %eax
f011bee2:	ff 75 94             	pushl  -0x6c(%ebp)
f011bee5:	68 14 ec 12 f0       	push   $0xf012ec14
f011beea:	e8 9c 50 fe ff       	call   f0100f8b <cprintf>
f011beef:	83 c4 10             	add    $0x10,%esp
			newBrk = (uint32)sbrk(0);
f011bef2:	83 ec 0c             	sub    $0xc,%esp
f011bef5:	6a 00                	push   $0x0
f011bef7:	e8 39 ce fe ff       	call   f0108d35 <sbrk>
f011befc:	83 c4 10             	add    $0x10,%esp
f011beff:	89 45 90             	mov    %eax,-0x70(%ebp)
			expectedSBRK = (void*)oldBrk + 2*PAGE_SIZE ;
f011bf02:	8b 45 88             	mov    -0x78(%ebp),%eax
f011bf05:	05 00 20 00 00       	add    $0x2000,%eax
f011bf0a:	89 45 8c             	mov    %eax,-0x74(%ebp)
			if ((void*)newBrk != expectedSBRK)
f011bf0d:	8b 45 90             	mov    -0x70(%ebp),%eax
f011bf10:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011bf13:	74 1d                	je     f011bf32 <test_ksbrk+0x73f>
			{correct = 0; cprintf("B.10: Wrong new break: Expected: %x, Actual: %x\n", expectedSBRK, newBrk);}
f011bf15:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf1c:	83 ec 04             	sub    $0x4,%esp
f011bf1f:	ff 75 90             	pushl  -0x70(%ebp)
f011bf22:	ff 75 8c             	pushl  -0x74(%ebp)
f011bf25:	68 58 ec 12 f0       	push   $0xf012ec58
f011bf2a:	e8 5c 50 fe ff       	call   f0100f8b <cprintf>
f011bf2f:	83 c4 10             	add    $0x10,%esp
			//check allocations in RAM & PAGE FILE
			if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011bf32:	e8 3e 1b ff ff       	call   f010da75 <sys_calculate_free_frames>
f011bf37:	89 c2                	mov    %eax,%edx
f011bf39:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011bf3c:	29 d0                	sub    %edx,%eax
f011bf3e:	83 f8 01             	cmp    $0x1,%eax
f011bf41:	74 17                	je     f011bf5a <test_ksbrk+0x767>
			{ correct = 0; cprintf("B.11: Wrong memory allocation.\n"); }
f011bf43:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf4a:	83 ec 0c             	sub    $0xc,%esp
f011bf4d:	68 8c ec 12 f0       	push   $0xf012ec8c
f011bf52:	e8 34 50 fe ff       	call   f0100f8b <cprintf>
f011bf57:	83 c4 10             	add    $0x10,%esp
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011bf5a:	e8 aa 89 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011bf5f:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011bf62:	74 17                	je     f011bf7b <test_ksbrk+0x788>
			{ correct = 0; cprintf("B.12: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bf64:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011bf6b:	83 ec 0c             	sub    $0xc,%esp
f011bf6e:	68 ac ec 12 f0       	push   $0xf012ecac
f011bf73:	e8 13 50 fe ff       	call   f0100f8b <cprintf>
f011bf78:	83 c4 10             	add    $0x10,%esp
		}
	}
	if (correct)
f011bf7b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011bf7f:	74 04                	je     f011bf85 <test_ksbrk+0x792>
		eval += 25;
f011bf81:	83 45 e4 19          	addl   $0x19,-0x1c(%ebp)

	uint32 numOfCases = 5;
f011bf85:	c7 45 84 05 00 00 00 	movl   $0x5,-0x7c(%ebp)
	uint32 incNumOfPages[] = {0, 1, 2, 11, DYN_ALLOC_MAX_SIZE/PAGE_SIZE - 13};
f011bf8c:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f011bf92:	bb e8 ef 12 f0       	mov    $0xf012efe8,%ebx
f011bf97:	ba 05 00 00 00       	mov    $0x5,%edx
f011bf9c:	89 c7                	mov    %eax,%edi
f011bf9e:	89 de                	mov    %ebx,%esi
f011bfa0:	89 d1                	mov    %edx,%ecx
f011bfa2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 expectedVAs[] = {
f011bfa4:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011bfaa:	bb fc ef 12 f0       	mov    $0xf012effc,%ebx
f011bfaf:	ba 05 00 00 00       	mov    $0x5,%edx
f011bfb4:	89 c7                	mov    %eax,%edi
f011bfb6:	89 de                	mov    %ebx,%esi
f011bfb8:	89 d1                	mov    %edx,%ecx
f011bfba:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1000, // 1
			KERNEL_HEAP_START + 0x2000, // 2
			KERNEL_HEAP_START + 0x4000, // 11
			0xFFFFFFFF, 				// exceed (RETURN -1)
	};
	uint32 expectedSbrks[] = {
f011bfbc:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
f011bfc2:	bb 10 f0 12 f0       	mov    $0xf012f010,%ebx
f011bfc7:	ba 05 00 00 00       	mov    $0x5,%edx
f011bfcc:	89 c7                	mov    %eax,%edi
f011bfce:	89 de                	mov    %ebx,%esi
f011bfd0:	89 d1                	mov    %edx,%ecx
f011bfd2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x4000, // 2
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f011bfd4:	83 ec 04             	sub    $0x4,%esp
f011bfd7:	68 00 00 00 f8       	push   $0xf8000000
f011bfdc:	68 00 10 00 00       	push   $0x1000
f011bfe1:	68 00 00 00 f6       	push   $0xf6000000
f011bfe6:	e8 5c cc fe ff       	call   f0108c47 <initialize_kheap_dynamic_allocator>
f011bfeb:	83 c4 10             	add    $0x10,%esp
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011bfee:	c7 45 dc 00 10 00 f6 	movl   $0xf6001000,-0x24(%ebp)
f011bff5:	eb 1b                	jmp    f011c012 <test_ksbrk+0x81f>
	{
		unmap_frame(ptr_page_directory, va);
f011bff7:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011bffc:	83 ec 08             	sub    $0x8,%esp
f011bfff:	ff 75 dc             	pushl  -0x24(%ebp)
f011c002:	50                   	push   %eax
f011c003:	e8 a7 c8 fe ff       	call   f01088af <unmap_frame>
f011c008:	83 c4 10             	add    $0x10,%esp
			KERNEL_HEAP_START + 0xF000, // 11
			KERNEL_HEAP_START + 0xF000, // exceed
	};
	//Reinitialize the kernel block allocator
	initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
	for (uint32 va = KERNEL_HEAP_START+PAGE_SIZE; va < KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE; va += PAGE_SIZE)
f011c00b:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011c012:	81 7d dc ff ff ff f7 	cmpl   $0xf7ffffff,-0x24(%ebp)
f011c019:	76 dc                	jbe    f011bff7 <test_ksbrk+0x804>
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
f011c01b:	83 ec 0c             	sub    $0xc,%esp
f011c01e:	68 1c ed 12 f0       	push   $0xf012ed1c
f011c023:	e8 63 4f fe ff       	call   f0100f8b <cprintf>
f011c028:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011c02b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011c032:	e9 21 01 00 00       	jmp    f011c158 <test_ksbrk+0x965>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011c037:	e8 39 1a ff ff       	call   f010da75 <sys_calculate_free_frames>
f011c03c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011c03f:	e8 c5 88 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011c044:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011c047:	83 ec 0c             	sub    $0xc,%esp
f011c04a:	6a 00                	push   $0x0
f011c04c:	e8 e4 cc fe ff       	call   f0108d35 <sbrk>
f011c051:	83 c4 10             	add    $0x10,%esp
f011c054:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011c057:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c05a:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011c061:	83 ec 0c             	sub    $0xc,%esp
f011c064:	50                   	push   %eax
f011c065:	e8 cb cc fe ff       	call   f0108d35 <sbrk>
f011c06a:	83 c4 10             	add    $0x10,%esp
f011c06d:	89 45 80             	mov    %eax,-0x80(%ebp)
			newBrk = (uint32)sbrk(0);
f011c070:	83 ec 0c             	sub    $0xc,%esp
f011c073:	6a 00                	push   $0x0
f011c075:	e8 bb cc fe ff       	call   f0108d35 <sbrk>
f011c07a:	83 c4 10             	add    $0x10,%esp
f011c07d:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011c080:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c087:	e8 7d 88 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011c08c:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c08f:	74 1a                	je     f011c0ab <test_ksbrk+0x8b8>
			{
				correct = 0;
f011c091:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011c098:	83 ec 08             	sub    $0x8,%esp
f011c09b:	ff 75 d8             	pushl  -0x28(%ebp)
f011c09e:	68 60 ed 12 f0       	push   $0xf012ed60
f011c0a3:	e8 e3 4e fe ff       	call   f0100f8b <cprintf>
f011c0a8:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != incNumOfPages[i])
f011c0ab:	e8 c5 19 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011c0b0:	89 c2                	mov    %eax,%edx
f011c0b2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011c0b5:	29 d0                	sub    %edx,%eax
f011c0b7:	89 c2                	mov    %eax,%edx
f011c0b9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c0bc:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011c0c3:	39 c2                	cmp    %eax,%edx
f011c0c5:	74 1a                	je     f011c0e1 <test_ksbrk+0x8ee>
			{
				correct = 0;
f011c0c7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong memory allocation\n", i);
f011c0ce:	83 ec 08             	sub    $0x8,%esp
f011c0d1:	ff 75 d8             	pushl  -0x28(%ebp)
f011c0d4:	68 d0 ed 12 f0       	push   $0xf012edd0
f011c0d9:	e8 ad 4e fe ff       	call   f0100f8b <cprintf>
f011c0de:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011c0e1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c0e4:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011c0eb:	8b 45 80             	mov    -0x80(%ebp),%eax
f011c0ee:	39 c2                	cmp    %eax,%edx
f011c0f0:	74 25                	je     f011c117 <test_ksbrk+0x924>
			{
				correct = 0;
f011c0f2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011c0f9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c0fc:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011c103:	ff 75 80             	pushl  -0x80(%ebp)
f011c106:	50                   	push   %eax
f011c107:	ff 75 d8             	pushl  -0x28(%ebp)
f011c10a:	68 f0 ed 12 f0       	push   $0xf012edf0
f011c10f:	e8 77 4e fe ff       	call   f0100f8b <cprintf>
f011c114:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011c117:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c11a:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011c121:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011c124:	74 25                	je     f011c14b <test_ksbrk+0x958>
			{
				correct = 0;
f011c126:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("C.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011c12d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c130:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011c137:	ff 75 90             	pushl  -0x70(%ebp)
f011c13a:	50                   	push   %eax
f011c13b:	ff 75 d8             	pushl  -0x28(%ebp)
f011c13e:	68 28 ee 12 f0       	push   $0xf012ee28
f011c143:	e8 43 4e fe ff       	call   f0100f8b <cprintf>
f011c148:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011c14b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c14f:	74 04                	je     f011c155 <test_ksbrk+0x962>
				eval += 10;
f011c151:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	{
		unmap_frame(ptr_page_directory, va);
	}
	cprintf("\nSTEP C: checking sbrk() increment with zero & +ve values [40%]\n\n");
	{
		for (int i = 0; i < numOfCases - 1; ++i)
f011c155:	ff 45 d8             	incl   -0x28(%ebp)
f011c158:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011c15b:	8d 50 ff             	lea    -0x1(%eax),%edx
f011c15e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011c161:	39 c2                	cmp    %eax,%edx
f011c163:	0f 87 ce fe ff ff    	ja     f011c037 <test_ksbrk+0x844>
			}
			if (correct)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
f011c169:	83 ec 0c             	sub    $0xc,%esp
f011c16c:	68 5c ee 12 f0       	push   $0xf012ee5c
f011c171:	e8 15 4e fe ff       	call   f0100f8b <cprintf>
f011c176:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011c179:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011c17c:	48                   	dec    %eax
f011c17d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011c180:	e9 18 01 00 00       	jmp    f011c29d <test_ksbrk+0xaaa>
		{
			freeFrames = (int)sys_calculate_free_frames();
f011c185:	e8 eb 18 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011c18a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
			freeDiskFrames = (int)pf_calculate_free_frames();
f011c18d:	e8 77 87 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011c192:	89 45 b0             	mov    %eax,-0x50(%ebp)
			oldBrk = (uint32)sbrk(0);
f011c195:	83 ec 0c             	sub    $0xc,%esp
f011c198:	6a 00                	push   $0x0
f011c19a:	e8 96 cb fe ff       	call   f0108d35 <sbrk>
f011c19f:	83 c4 10             	add    $0x10,%esp
f011c1a2:	89 45 88             	mov    %eax,-0x78(%ebp)
			void* VA = sbrk(incNumOfPages[i]);
f011c1a5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c1a8:	8b 84 85 18 ff ff ff 	mov    -0xe8(%ebp,%eax,4),%eax
f011c1af:	83 ec 0c             	sub    $0xc,%esp
f011c1b2:	50                   	push   %eax
f011c1b3:	e8 7d cb fe ff       	call   f0108d35 <sbrk>
f011c1b8:	83 c4 10             	add    $0x10,%esp
f011c1bb:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			newBrk = (uint32)sbrk(0);
f011c1c1:	83 ec 0c             	sub    $0xc,%esp
f011c1c4:	6a 00                	push   $0x0
f011c1c6:	e8 6a cb fe ff       	call   f0108d35 <sbrk>
f011c1cb:	83 c4 10             	add    $0x10,%esp
f011c1ce:	89 45 90             	mov    %eax,-0x70(%ebp)
			correct = 1;
f011c1d1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011c1d8:	e8 2c 87 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011c1dd:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011c1e0:	74 1a                	je     f011c1fc <test_ksbrk+0xa09>
			{
				correct = 0;
f011c1e2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n", i);
f011c1e9:	83 ec 08             	sub    $0x8,%esp
f011c1ec:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c1ef:	68 ac ee 12 f0       	push   $0xf012eeac
f011c1f4:	e8 92 4d fe ff       	call   f0100f8b <cprintf>
f011c1f9:	83 c4 10             	add    $0x10,%esp
			}
			if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011c1fc:	e8 74 18 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011c201:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011c204:	74 1a                	je     f011c220 <test_ksbrk+0xa2d>
			{
				correct = 0;
f011c206:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong memory allocation\n", i);
f011c20d:	83 ec 08             	sub    $0x8,%esp
f011c210:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c213:	68 1c ef 12 f0       	push   $0xf012ef1c
f011c218:	e8 6e 4d fe ff       	call   f0100f8b <cprintf>
f011c21d:	83 c4 10             	add    $0x10,%esp
			}
			if ((uint32)VA != expectedVAs[i])
f011c220:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c223:	8b 94 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%edx
f011c22a:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c230:	39 c2                	cmp    %eax,%edx
f011c232:	74 28                	je     f011c25c <test_ksbrk+0xa69>
			{
				correct = 0;
f011c234:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong returned break: Expected: %x, Actual: %x\n", i, expectedVAs[i], VA);
f011c23b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c23e:	8b 84 85 04 ff ff ff 	mov    -0xfc(%ebp,%eax,4),%eax
f011c245:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
f011c24b:	50                   	push   %eax
f011c24c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c24f:	68 3c ef 12 f0       	push   $0xf012ef3c
f011c254:	e8 32 4d fe ff       	call   f0100f8b <cprintf>
f011c259:	83 c4 10             	add    $0x10,%esp
			}
			if (newBrk != expectedSbrks[i])
f011c25c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c25f:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011c266:	3b 45 90             	cmp    -0x70(%ebp),%eax
f011c269:	74 25                	je     f011c290 <test_ksbrk+0xa9d>
			{
				correct = 0;
f011c26b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				cprintf("D.%d: Wrong new break: Expected: %x, Actual: %x\n", i, expectedSbrks[i], newBrk);
f011c272:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c275:	8b 84 85 f0 fe ff ff 	mov    -0x110(%ebp,%eax,4),%eax
f011c27c:	ff 75 90             	pushl  -0x70(%ebp)
f011c27f:	50                   	push   %eax
f011c280:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c283:	68 74 ef 12 f0       	push   $0xf012ef74
f011c288:	e8 fe 4c fe ff       	call   f0100f8b <cprintf>
f011c28d:	83 c4 10             	add    $0x10,%esp
			}
			if (correct)
f011c290:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c294:	74 04                	je     f011c29a <test_ksbrk+0xaa7>
				eval += 10;
f011c296:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
				eval += 10;
		}
	}
	cprintf("\nSTEP D: checking sbrk() increment with LARGE +ve value (EXCEED LIMIT) [10%]\n\n");
	{
		for (int i = numOfCases - 1; i < numOfCases ; ++i)
f011c29a:	ff 45 d4             	incl   -0x2c(%ebp)
f011c29d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c2a0:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c2a3:	0f 82 dc fe ff ff    	jb     f011c185 <test_ksbrk+0x992>
			if (correct)
				eval += 10;
		}
	}

	cprintf("\nTest kheap sbrk completed. Eval = %d%%\n\n", eval);
f011c2a9:	83 ec 08             	sub    $0x8,%esp
f011c2ac:	ff 75 e4             	pushl  -0x1c(%ebp)
f011c2af:	68 a8 ef 12 f0       	push   $0xf012efa8
f011c2b4:	e8 d2 4c fe ff       	call   f0100f8b <cprintf>
f011c2b9:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011c2bc:	83 ec 0c             	sub    $0xc,%esp
f011c2bf:	68 d2 ef 12 f0       	push   $0xf012efd2
f011c2c4:	e8 c2 4c fe ff       	call   f0100f8b <cprintf>
f011c2c9:	83 c4 10             	add    $0x10,%esp
	return 0;
f011c2cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011c2d1:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011c2d4:	5b                   	pop    %ebx
f011c2d5:	5e                   	pop    %esi
f011c2d6:	5f                   	pop    %edi
f011c2d7:	5d                   	pop    %ebp
f011c2d8:	c3                   	ret    

f011c2d9 <test_kmalloc_nextfit>:
//==============================================================================================//
//==============================================================================================//
//==============================================================================================//

int test_kmalloc_nextfit()
{
f011c2d9:	55                   	push   %ebp
f011c2da:	89 e5                	mov    %esp,%ebp
f011c2dc:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c2df:	83 ec 04             	sub    $0x4,%esp
f011c2e2:	68 24 f0 12 f0       	push   $0xf012f024
f011c2e7:	68 d7 08 00 00       	push   $0x8d7
f011c2ec:	68 77 b9 12 f0       	push   $0xf012b977
f011c2f1:	e8 43 40 fe ff       	call   f0100339 <_panic>

f011c2f6 <test_kmalloc_bestfit1>:
}

int test_kmalloc_bestfit1()
{
f011c2f6:	55                   	push   %ebp
f011c2f7:	89 e5                	mov    %esp,%ebp
f011c2f9:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c2fc:	83 ec 04             	sub    $0x4,%esp
f011c2ff:	68 24 f0 12 f0       	push   $0xf012f024
f011c304:	68 dc 08 00 00       	push   $0x8dc
f011c309:	68 77 b9 12 f0       	push   $0xf012b977
f011c30e:	e8 26 40 fe ff       	call   f0100339 <_panic>

f011c313 <test_kmalloc_bestfit2>:
}

int test_kmalloc_bestfit2()
{
f011c313:	55                   	push   %ebp
f011c314:	89 e5                	mov    %esp,%ebp
f011c316:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c319:	83 ec 04             	sub    $0x4,%esp
f011c31c:	68 24 f0 12 f0       	push   $0xf012f024
f011c321:	68 e1 08 00 00       	push   $0x8e1
f011c326:	68 77 b9 12 f0       	push   $0xf012b977
f011c32b:	e8 09 40 fe ff       	call   f0100339 <_panic>

f011c330 <test_kmalloc_worstfit>:
}

int test_kmalloc_worstfit()
{
f011c330:	55                   	push   %ebp
f011c331:	89 e5                	mov    %esp,%ebp
f011c333:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c336:	83 ec 04             	sub    $0x4,%esp
f011c339:	68 24 f0 12 f0       	push   $0xf012f024
f011c33e:	68 e6 08 00 00       	push   $0x8e6
f011c343:	68 77 b9 12 f0       	push   $0xf012b977
f011c348:	e8 ec 3f fe ff       	call   f0100339 <_panic>

f011c34d <test_kfree>:
}

int test_kfree()
{
f011c34d:	55                   	push   %ebp
f011c34e:	89 e5                	mov    %esp,%ebp
f011c350:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c353:	83 ec 04             	sub    $0x4,%esp
f011c356:	68 24 f0 12 f0       	push   $0xf012f024
f011c35b:	68 eb 08 00 00       	push   $0x8eb
f011c360:	68 77 b9 12 f0       	push   $0xf012b977
f011c365:	e8 cf 3f fe ff       	call   f0100339 <_panic>

f011c36a <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011c36a:	55                   	push   %ebp
f011c36b:	89 e5                	mov    %esp,%ebp
f011c36d:	57                   	push   %edi
f011c36e:	56                   	push   %esi
f011c36f:	53                   	push   %ebx
f011c370:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011c376:	a0 dc bd 17 f0       	mov    0xf017bddc,%al
f011c37b:	84 c0                	test   %al,%al
f011c37d:	74 56                	je     f011c3d5 <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011c37f:	c6 05 dc bd 17 f0 00 	movb   $0x0,0xf017bddc
		initFreeFrames = sys_calculate_free_frames() ;
f011c386:	e8 ea 16 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011c38b:	a3 08 f3 60 f0       	mov    %eax,0xf060f308
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011c390:	e8 74 85 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011c395:	a3 04 f3 60 f0       	mov    %eax,0xf060f304
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011c39a:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011c3a0:	bb 89 f1 12 f0       	mov    $0xf012f189,%ebx
f011c3a5:	ba 11 00 00 00       	mov    $0x11,%edx
f011c3aa:	89 c7                	mov    %eax,%edi
f011c3ac:	89 de                	mov    %ebx,%esi
f011c3ae:	89 d1                	mov    %edx,%ecx
f011c3b0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011c3b2:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011c3b8:	b9 53 00 00 00       	mov    $0x53,%ecx
f011c3bd:	b0 00                	mov    $0x0,%al
f011c3bf:	89 d7                	mov    %edx,%edi
f011c3c1:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011c3c3:	83 ec 0c             	sub    $0xc,%esp
f011c3c6:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011c3cc:	50                   	push   %eax
f011c3cd:	e8 29 5b fe ff       	call   f0101efb <execute_command>
f011c3d2:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011c3d5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011c3dc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011c3e3:	a1 e0 c4 5e f0       	mov    0xf05ec4e0,%eax
f011c3e8:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011c3eb:	eb 2b                	jmp    f011c418 <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011c3ed:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c3f0:	83 c0 20             	add    $0x20,%eax
f011c3f3:	83 ec 08             	sub    $0x8,%esp
f011c3f6:	68 34 f0 12 f0       	push   $0xf012f034
f011c3fb:	50                   	push   %eax
f011c3fc:	e8 ea 28 00 00       	call   f011eceb <strcmp>
f011c401:	83 c4 10             	add    $0x10,%esp
f011c404:	85 c0                	test   %eax,%eax
f011c406:	75 08                	jne    f011c410 <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011c408:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c40b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011c40e:	eb 2f                	jmp    f011c43f <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011c410:	a1 e8 c4 5e f0       	mov    0xf05ec4e8,%eax
f011c415:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011c418:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c41c:	74 08                	je     f011c426 <test_three_creation_functions+0xbc>
f011c41e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011c421:	8b 40 08             	mov    0x8(%eax),%eax
f011c424:	eb 05                	jmp    f011c42b <test_three_creation_functions+0xc1>
f011c426:	b8 00 00 00 00       	mov    $0x0,%eax
f011c42b:	a3 e8 c4 5e f0       	mov    %eax,0xf05ec4e8
f011c430:	a1 e8 c4 5e f0       	mov    0xf05ec4e8,%eax
f011c435:	85 c0                	test   %eax,%eax
f011c437:	75 b4                	jne    f011c3ed <test_three_creation_functions+0x83>
f011c439:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011c43d:	75 ae                	jne    f011c3ed <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011c43f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011c442:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f011c448:	85 c0                	test   %eax,%eax
f011c44a:	74 17                	je     f011c463 <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011c44c:	83 ec 04             	sub    $0x4,%esp
f011c44f:	68 3c f0 12 f0       	push   $0xf012f03c
f011c454:	68 0c 09 00 00       	push   $0x90c
f011c459:	68 77 b9 12 f0       	push   $0xf012b977
f011c45e:	e8 d6 3e fe ff       	call   f0100339 <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f011c463:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011c466:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011c46c:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011c46f:	e8 01 16 ff ff       	call   f010da75 <sys_calculate_free_frames>
f011c474:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011c477:	e8 8d 84 fe ff       	call   f0104909 <pf_calculate_free_frames>
f011c47c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011c47f:	a1 04 f3 60 f0       	mov    0xf060f304,%eax
f011c484:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011c487:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011c48a:	74 17                	je     f011c4a3 <test_three_creation_functions+0x139>
f011c48c:	83 ec 04             	sub    $0x4,%esp
f011c48f:	68 90 b9 12 f0       	push   $0xf012b990
f011c494:	68 16 09 00 00       	push   $0x916
f011c499:	68 77 b9 12 f0       	push   $0xf012b977
f011c49e:	e8 96 3e fe ff       	call   f0100339 <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011c4a3:	a1 08 f3 60 f0       	mov    0xf060f308,%eax
f011c4a8:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011c4ab:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011c4ae:	83 c2 15             	add    $0x15,%edx
f011c4b1:	39 d0                	cmp    %edx,%eax
f011c4b3:	74 17                	je     f011c4cc <test_three_creation_functions+0x162>
f011c4b5:	83 ec 04             	sub    $0x4,%esp
f011c4b8:	68 8c f0 12 f0       	push   $0xf012f08c
f011c4bd:	68 18 09 00 00       	push   $0x918
f011c4c2:	68 77 b9 12 f0       	push   $0xf012b977
f011c4c7:	e8 6d 3e fe ff       	call   f0100339 <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011c4cc:	83 ec 0c             	sub    $0xc,%esp
f011c4cf:	68 00 10 00 00       	push   $0x1000
f011c4d4:	e8 57 c9 fe ff       	call   f0108e30 <kmalloc>
f011c4d9:	83 c4 10             	add    $0x10,%esp
f011c4dc:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011c4df:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c4e2:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011c4e7:	74 17                	je     f011c500 <test_three_creation_functions+0x196>
f011c4e9:	83 ec 04             	sub    $0x4,%esp
f011c4ec:	68 cc f0 12 f0       	push   $0xf012f0cc
f011c4f1:	68 1c 09 00 00       	push   $0x91c
f011c4f6:	68 77 b9 12 f0       	push   $0xf012b977
f011c4fb:	e8 39 3e fe ff       	call   f0100339 <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011c500:	83 ec 0c             	sub    $0xc,%esp
f011c503:	68 3c f1 12 f0       	push   $0xf012f13c
f011c508:	e8 7e 4a fe ff       	call   f0100f8b <cprintf>
f011c50d:	83 c4 10             	add    $0x10,%esp

	return 1;
f011c510:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011c515:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011c518:	5b                   	pop    %ebx
f011c519:	5e                   	pop    %esi
f011c51a:	5f                   	pop    %edi
f011c51b:	5d                   	pop    %ebp
f011c51c:	c3                   	ret    

f011c51d <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011c51d:	55                   	push   %ebp
f011c51e:	89 e5                	mov    %esp,%ebp
f011c520:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c523:	83 ec 04             	sub    $0x4,%esp
f011c526:	68 24 f0 12 f0       	push   $0xf012f024
f011c52b:	68 2a 09 00 00       	push   $0x92a
f011c530:	68 77 b9 12 f0       	push   $0xf012b977
f011c535:	e8 ff 3d fe ff       	call   f0100339 <_panic>

f011c53a <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f011c53a:	55                   	push   %ebp
f011c53b:	89 e5                	mov    %esp,%ebp
f011c53d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c540:	83 ec 04             	sub    $0x4,%esp
f011c543:	68 24 f0 12 f0       	push   $0xf012f024
f011c548:	68 32 09 00 00       	push   $0x932
f011c54d:	68 77 b9 12 f0       	push   $0xf012b977
f011c552:	e8 e2 3d fe ff       	call   f0100339 <_panic>

f011c557 <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f011c557:	55                   	push   %ebp
f011c558:	89 e5                	mov    %esp,%ebp
f011c55a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c55d:	83 ec 04             	sub    $0x4,%esp
f011c560:	68 24 f0 12 f0       	push   $0xf012f024
f011c565:	68 39 09 00 00       	push   $0x939
f011c56a:	68 77 b9 12 f0       	push   $0xf012b977
f011c56f:	e8 c5 3d fe ff       	call   f0100339 <_panic>

f011c574 <test_kfreelast>:

}


int test_kfreelast()
{
f011c574:	55                   	push   %ebp
f011c575:	89 e5                	mov    %esp,%ebp
f011c577:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c57a:	83 ec 04             	sub    $0x4,%esp
f011c57d:	68 24 f0 12 f0       	push   $0xf012f024
f011c582:	68 40 09 00 00       	push   $0x940
f011c587:	68 77 b9 12 f0       	push   $0xf012b977
f011c58c:	e8 a8 3d fe ff       	call   f0100339 <_panic>

f011c591 <test_krealloc>:

}

int test_krealloc() {
f011c591:	55                   	push   %ebp
f011c592:	89 e5                	mov    %esp,%ebp
f011c594:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c597:	83 ec 04             	sub    $0x4,%esp
f011c59a:	68 24 f0 12 f0       	push   $0xf012f024
f011c59f:	68 45 09 00 00       	push   $0x945
f011c5a4:	68 77 b9 12 f0       	push   $0xf012b977
f011c5a9:	e8 8b 3d fe ff       	call   f0100339 <_panic>

f011c5ae <test_krealloc_BF>:
}


int test_krealloc_BF() {
f011c5ae:	55                   	push   %ebp
f011c5af:	89 e5                	mov    %esp,%ebp
f011c5b1:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c5b4:	83 ec 04             	sub    $0x4,%esp
f011c5b7:	68 24 f0 12 f0       	push   $0xf012f024
f011c5bc:	68 4a 09 00 00       	push   $0x94a
f011c5c1:	68 77 b9 12 f0       	push   $0xf012b977
f011c5c6:	e8 6e 3d fe ff       	call   f0100339 <_panic>

f011c5cb <test_krealloc_FF1>:

}

int test_krealloc_FF1()
{
f011c5cb:	55                   	push   %ebp
f011c5cc:	89 e5                	mov    %esp,%ebp
f011c5ce:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c5d1:	83 ec 04             	sub    $0x4,%esp
f011c5d4:	68 24 f0 12 f0       	push   $0xf012f024
f011c5d9:	68 50 09 00 00       	push   $0x950
f011c5de:	68 77 b9 12 f0       	push   $0xf012b977
f011c5e3:	e8 51 3d fe ff       	call   f0100339 <_panic>

f011c5e8 <test_krealloc_FF2>:

}
int test_krealloc_FF2()
{
f011c5e8:	55                   	push   %ebp
f011c5e9:	89 e5                	mov    %esp,%ebp
f011c5eb:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c5ee:	83 ec 04             	sub    $0x4,%esp
f011c5f1:	68 24 f0 12 f0       	push   $0xf012f024
f011c5f6:	68 55 09 00 00       	push   $0x955
f011c5fb:	68 77 b9 12 f0       	push   $0xf012b977
f011c600:	e8 34 3d fe ff       	call   f0100339 <_panic>

f011c605 <test_krealloc_FF3>:

}

int test_krealloc_FF3()
{
f011c605:	55                   	push   %ebp
f011c606:	89 e5                	mov    %esp,%ebp
f011c608:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f011c60b:	83 ec 04             	sub    $0x4,%esp
f011c60e:	68 24 f0 12 f0       	push   $0xf012f024
f011c613:	68 5b 09 00 00       	push   $0x95b
f011c618:	68 77 b9 12 f0       	push   $0xf012b977
f011c61d:	e8 17 3d fe ff       	call   f0100339 <_panic>

f011c622 <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011c622:	55                   	push   %ebp
f011c623:	89 e5                	mov    %esp,%ebp
f011c625:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011c628:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011c62f:	e9 84 00 00 00       	jmp    f011c6b8 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011c634:	83 ec 08             	sub    $0x8,%esp
f011c637:	ff 75 f4             	pushl  -0xc(%ebp)
f011c63a:	68 f0 f1 12 f0       	push   $0xf012f1f0
f011c63f:	e8 47 49 fe ff       	call   f0100f8b <cprintf>
f011c644:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011c647:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011c64e:	eb 4c                	jmp    f011c69c <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011c650:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c653:	89 d0                	mov    %edx,%eax
f011c655:	c1 e0 02             	shl    $0x2,%eax
f011c658:	01 d0                	add    %edx,%eax
f011c65a:	c1 e0 03             	shl    $0x3,%eax
f011c65d:	89 c2                	mov    %eax,%edx
f011c65f:	8b 45 08             	mov    0x8(%ebp),%eax
f011c662:	01 c2                	add    %eax,%edx
f011c664:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011c667:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011c66a:	85 c0                	test   %eax,%eax
f011c66c:	74 36                	je     f011c6a4 <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011c66e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011c671:	89 d0                	mov    %edx,%eax
f011c673:	c1 e0 02             	shl    $0x2,%eax
f011c676:	01 d0                	add    %edx,%eax
f011c678:	c1 e0 03             	shl    $0x3,%eax
f011c67b:	89 c2                	mov    %eax,%edx
f011c67d:	8b 45 08             	mov    0x8(%ebp),%eax
f011c680:	01 c2                	add    %eax,%edx
f011c682:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011c685:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011c688:	83 ec 08             	sub    $0x8,%esp
f011c68b:	50                   	push   %eax
f011c68c:	68 f8 f1 12 f0       	push   $0xf012f1f8
f011c691:	e8 f5 48 fe ff       	call   f0100f8b <cprintf>
f011c696:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011c699:	ff 45 f0             	incl   -0x10(%ebp)
f011c69c:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011c6a0:	7e ae                	jle    f011c650 <print_order+0x2e>
f011c6a2:	eb 01                	jmp    f011c6a5 <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011c6a4:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011c6a5:	83 ec 0c             	sub    $0xc,%esp
f011c6a8:	68 fd f1 12 f0       	push   $0xf012f1fd
f011c6ad:	e8 d9 48 fe ff       	call   f0100f8b <cprintf>
f011c6b2:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011c6b5:	ff 45 f4             	incl   -0xc(%ebp)
f011c6b8:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011c6bc:	0f 8e 72 ff ff ff    	jle    f011c634 <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011c6c2:	90                   	nop
f011c6c3:	c9                   	leave  
f011c6c4:	c3                   	ret    

f011c6c5 <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011c6c5:	55                   	push   %ebp
f011c6c6:	89 e5                	mov    %esp,%ebp
f011c6c8:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011c6cb:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011c6d2:	83 ec 0c             	sub    $0xc,%esp
f011c6d5:	68 60 c4 5e f0       	push   $0xf05ec460
f011c6da:	e8 e0 24 ff ff       	call   f010ebbf <acquire_spinlock>
f011c6df:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011c6e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011c6e9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c6f0:	8b 55 0c             	mov    0xc(%ebp),%edx
f011c6f3:	8b 45 10             	mov    0x10(%ebp),%eax
f011c6f6:	01 d0                	add    %edx,%eax
f011c6f8:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011c6fb:	a1 ec c4 5e f0       	mov    0xf05ec4ec,%eax
f011c700:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011c703:	a1 e4 c4 5e f0       	mov    0xf05ec4e4,%eax
f011c708:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011c70b:	ff 75 e8             	pushl  -0x18(%ebp)
f011c70e:	ff 75 0c             	pushl  0xc(%ebp)
f011c711:	ff 75 08             	pushl  0x8(%ebp)
f011c714:	68 00 f2 12 f0       	push   $0xf012f200
f011c719:	e8 6d 48 fe ff       	call   f0100f8b <cprintf>
f011c71e:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011c721:	eb 34                	jmp    f011c757 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011c723:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c726:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011c729:	7d 05                	jge    f011c730 <find_in_range+0x6b>
			{
				i++;
f011c72b:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011c72e:	eb 1e                	jmp    f011c74e <find_in_range+0x89>
			}
			if (i >= end)
f011c730:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c733:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011c736:	7d 29                	jge    f011c761 <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011c738:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011c73b:	8b 40 10             	mov    0x10(%eax),%eax
f011c73e:	3b 45 08             	cmp    0x8(%ebp),%eax
f011c741:	75 08                	jne    f011c74b <find_in_range+0x86>
			{
				ret = i;
f011c743:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c746:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011c749:	eb 17                	jmp    f011c762 <find_in_range+0x9d>
			}
			i++;
f011c74b:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011c74e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011c751:	8b 40 0c             	mov    0xc(%eax),%eax
f011c754:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011c757:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011c75a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011c75d:	7c c4                	jl     f011c723 <find_in_range+0x5e>
f011c75f:	eb 01                	jmp    f011c762 <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011c761:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011c762:	83 ec 0c             	sub    $0xc,%esp
f011c765:	68 60 c4 5e f0       	push   $0xf05ec460
f011c76a:	e8 d7 24 ff ff       	call   f010ec46 <release_spinlock>
f011c76f:	83 c4 10             	add    $0x10,%esp
	return ret;
f011c772:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011c775:	c9                   	leave  
f011c776:	c3                   	ret    

f011c777 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011c777:	55                   	push   %ebp
f011c778:	89 e5                	mov    %esp,%ebp
f011c77a:	57                   	push   %edi
f011c77b:	56                   	push   %esi
f011c77c:	53                   	push   %ebx
f011c77d:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011c780:	a0 dd bd 17 f0       	mov    0xf017bddd,%al
f011c785:	84 c0                	test   %al,%al
f011c787:	0f 84 9b 01 00 00    	je     f011c928 <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011c78d:	c6 05 dd bd 17 f0 00 	movb   $0x0,0xf017bddd
		int nice_values[] = {-10, -5, 0, 5, 10};
f011c794:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011c797:	bb 78 f3 12 f0       	mov    $0xf012f378,%ebx
f011c79c:	ba 05 00 00 00       	mov    $0x5,%edx
f011c7a1:	89 c7                	mov    %eax,%edi
f011c7a3:	89 de                	mov    %ebx,%esi
f011c7a5:	89 d1                	mov    %edx,%ecx
f011c7a7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011c7a9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011c7b0:	e9 44 01 00 00       	jmp    f011c8f9 <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011c7b5:	6a 00                	push   $0x0
f011c7b7:	6a 00                	push   $0x0
f011c7b9:	68 f4 01 00 00       	push   $0x1f4
f011c7be:	68 31 f2 12 f0       	push   $0xf012f231
f011c7c3:	e8 13 da fe ff       	call   f010a1db <env_create>
f011c7c8:	83 c4 10             	add    $0x10,%esp
f011c7cb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011c7ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011c7d1:	b9 05 00 00 00       	mov    $0x5,%ecx
f011c7d6:	99                   	cltd   
f011c7d7:	f7 f9                	idiv   %ecx
f011c7d9:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011c7dc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c7df:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011c7e3:	83 ec 08             	sub    $0x8,%esp
f011c7e6:	50                   	push   %eax
f011c7e7:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c7ea:	e8 d8 9e fe ff       	call   f01066c7 <env_set_nice>
f011c7ef:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011c7f2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011c7f6:	75 14                	jne    f011c80c <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011c7f8:	83 ec 04             	sub    $0x4,%esp
f011c7fb:	68 39 f2 12 f0       	push   $0xf012f239
f011c800:	6a 53                	push   $0x53
f011c802:	68 52 f2 12 f0       	push   $0xf012f252
f011c807:	e8 2d 3b fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 500)
f011c80c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c80f:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011c815:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011c81a:	74 14                	je     f011c830 <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011c81c:	83 ec 04             	sub    $0x4,%esp
f011c81f:	68 70 f2 12 f0       	push   $0xf012f270
f011c824:	6a 55                	push   $0x55
f011c826:	68 52 f2 12 f0       	push   $0xf012f252
f011c82b:	e8 09 3b fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011c830:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011c833:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011c837:	83 c0 0a             	add    $0xa,%eax
f011c83a:	83 f8 14             	cmp    $0x14,%eax
f011c83d:	0f 87 a5 00 00 00    	ja     f011c8e8 <test_bsd_nice_0+0x171>
f011c843:	8b 04 85 8c f3 12 f0 	mov    -0xfed0c74(,%eax,4),%eax
f011c84a:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011c84c:	a1 fc c1 5e f0       	mov    0xf05ec1fc,%eax
f011c851:	8d 50 01             	lea    0x1(%eax),%edx
f011c854:	89 15 fc c1 5e f0    	mov    %edx,0xf05ec1fc
f011c85a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c85d:	8b 52 10             	mov    0x10(%edx),%edx
f011c860:	89 14 85 20 f3 60 f0 	mov    %edx,-0xf9f0ce0(,%eax,4)
				break;
f011c867:	eb 7f                	jmp    f011c8e8 <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011c869:	a1 00 c2 5e f0       	mov    0xf05ec200,%eax
f011c86e:	8d 50 01             	lea    0x1(%eax),%edx
f011c871:	89 15 00 c2 5e f0    	mov    %edx,0xf05ec200
f011c877:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c87a:	8b 52 10             	mov    0x10(%edx),%edx
f011c87d:	83 c0 0a             	add    $0xa,%eax
f011c880:	89 14 85 20 f3 60 f0 	mov    %edx,-0xf9f0ce0(,%eax,4)
				break;
f011c887:	eb 5f                	jmp    f011c8e8 <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011c889:	a1 04 c2 5e f0       	mov    0xf05ec204,%eax
f011c88e:	8d 50 01             	lea    0x1(%eax),%edx
f011c891:	89 15 04 c2 5e f0    	mov    %edx,0xf05ec204
f011c897:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c89a:	8b 52 10             	mov    0x10(%edx),%edx
f011c89d:	83 c0 14             	add    $0x14,%eax
f011c8a0:	89 14 85 20 f3 60 f0 	mov    %edx,-0xf9f0ce0(,%eax,4)
				break;
f011c8a7:	eb 3f                	jmp    f011c8e8 <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011c8a9:	a1 08 c2 5e f0       	mov    0xf05ec208,%eax
f011c8ae:	8d 50 01             	lea    0x1(%eax),%edx
f011c8b1:	89 15 08 c2 5e f0    	mov    %edx,0xf05ec208
f011c8b7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c8ba:	8b 52 10             	mov    0x10(%edx),%edx
f011c8bd:	83 c0 1e             	add    $0x1e,%eax
f011c8c0:	89 14 85 20 f3 60 f0 	mov    %edx,-0xf9f0ce0(,%eax,4)
				break;
f011c8c7:	eb 1f                	jmp    f011c8e8 <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011c8c9:	a1 0c c2 5e f0       	mov    0xf05ec20c,%eax
f011c8ce:	8d 50 01             	lea    0x1(%eax),%edx
f011c8d1:	89 15 0c c2 5e f0    	mov    %edx,0xf05ec20c
f011c8d7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c8da:	8b 52 10             	mov    0x10(%edx),%edx
f011c8dd:	83 c0 28             	add    $0x28,%eax
f011c8e0:	89 14 85 20 f3 60 f0 	mov    %edx,-0xf9f0ce0(,%eax,4)
				break;
f011c8e7:	90                   	nop
			}
			sched_new_env(env);
f011c8e8:	83 ec 0c             	sub    $0xc,%esp
f011c8eb:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c8ee:	e8 6a 8e fe ff       	call   f010575d <sched_new_env>
f011c8f3:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011c8f6:	ff 45 e4             	incl   -0x1c(%ebp)
f011c8f9:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011c8fd:	0f 8e b2 fe ff ff    	jle    f011c7b5 <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011c903:	83 ec 0c             	sub    $0xc,%esp
f011c906:	68 a0 f2 12 f0       	push   $0xf012f2a0
f011c90b:	e8 7b 46 fe ff       	call   f0100f8b <cprintf>
f011c910:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011c913:	83 ec 0c             	sub    $0xc,%esp
f011c916:	68 ef f2 12 f0       	push   $0xf012f2ef
f011c91b:	e8 db 55 fe ff       	call   f0101efb <execute_command>
f011c920:	83 c4 10             	add    $0x10,%esp
f011c923:	e9 c0 00 00 00       	jmp    f011c9e8 <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011c928:	83 ec 0c             	sub    $0xc,%esp
f011c92b:	68 f6 f2 12 f0       	push   $0xf012f2f6
f011c930:	e8 56 46 fe ff       	call   f0100f8b <cprintf>
f011c935:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011c938:	e8 58 95 fe ff       	call   f0105e95 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011c93d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011c944:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011c94b:	e9 87 00 00 00       	jmp    f011c9d7 <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011c950:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011c957:	eb 52                	jmp    f011c9ab <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011c959:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c95c:	8b 14 85 fc c1 5e f0 	mov    -0xfa13e04(,%eax,4),%edx
f011c963:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011c966:	89 c8                	mov    %ecx,%eax
f011c968:	c1 e0 02             	shl    $0x2,%eax
f011c96b:	01 c8                	add    %ecx,%eax
f011c96d:	01 c0                	add    %eax,%eax
f011c96f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011c972:	01 c8                	add    %ecx,%eax
f011c974:	8b 04 85 20 f3 60 f0 	mov    -0xf9f0ce0(,%eax,4),%eax
f011c97b:	83 ec 04             	sub    $0x4,%esp
f011c97e:	52                   	push   %edx
f011c97f:	ff 75 e0             	pushl  -0x20(%ebp)
f011c982:	50                   	push   %eax
f011c983:	e8 3d fd ff ff       	call   f011c6c5 <find_in_range>
f011c988:	83 c4 10             	add    $0x10,%esp
f011c98b:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011c98e:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011c992:	75 14                	jne    f011c9a8 <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011c994:	83 ec 04             	sub    $0x4,%esp
f011c997:	68 08 f3 12 f0       	push   $0xf012f308
f011c99c:	6a 7b                	push   $0x7b
f011c99e:	68 52 f2 12 f0       	push   $0xf012f252
f011c9a3:	e8 91 39 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011c9a8:	ff 45 d8             	incl   -0x28(%ebp)
f011c9ab:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011c9ae:	89 d0                	mov    %edx,%eax
f011c9b0:	c1 e0 02             	shl    $0x2,%eax
f011c9b3:	01 d0                	add    %edx,%eax
f011c9b5:	01 c0                	add    %eax,%eax
f011c9b7:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c9ba:	01 d0                	add    %edx,%eax
f011c9bc:	8b 04 85 20 f3 60 f0 	mov    -0xf9f0ce0(,%eax,4),%eax
f011c9c3:	85 c0                	test   %eax,%eax
f011c9c5:	75 92                	jne    f011c959 <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011c9c7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c9ca:	8b 04 85 fc c1 5e f0 	mov    -0xfa13e04(,%eax,4),%eax
f011c9d1:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011c9d4:	ff 45 dc             	incl   -0x24(%ebp)
f011c9d7:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011c9db:	0f 8e 6f ff ff ff    	jle    f011c950 <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011c9e1:	c6 05 dd bd 17 f0 00 	movb   $0x0,0xf017bddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011c9e8:	83 ec 0c             	sub    $0xc,%esp
f011c9eb:	68 3c f3 12 f0       	push   $0xf012f33c
f011c9f0:	e8 96 45 fe ff       	call   f0100f8b <cprintf>
f011c9f5:	83 c4 10             	add    $0x10,%esp
}
f011c9f8:	90                   	nop
f011c9f9:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011c9fc:	5b                   	pop    %ebx
f011c9fd:	5e                   	pop    %esi
f011c9fe:	5f                   	pop    %edi
f011c9ff:	5d                   	pop    %ebp
f011ca00:	c3                   	ret    

f011ca01 <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011ca01:	55                   	push   %ebp
f011ca02:	89 e5                	mov    %esp,%ebp
f011ca04:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011ca07:	a0 dd bd 17 f0       	mov    0xf017bddd,%al
f011ca0c:	84 c0                	test   %al,%al
f011ca0e:	0f 84 50 01 00 00    	je     f011cb64 <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011ca14:	c6 05 dd bd 17 f0 00 	movb   $0x0,0xf017bddd
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011ca1b:	6a 00                	push   $0x0
f011ca1d:	6a 00                	push   $0x0
f011ca1f:	68 f4 01 00 00       	push   $0x1f4
f011ca24:	68 31 f2 12 f0       	push   $0xf012f231
f011ca29:	e8 ad d7 fe ff       	call   f010a1db <env_create>
f011ca2e:	83 c4 10             	add    $0x10,%esp
f011ca31:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011ca34:	6a 00                	push   $0x0
f011ca36:	6a 00                	push   $0x0
f011ca38:	68 f4 01 00 00       	push   $0x1f4
f011ca3d:	68 e0 f3 12 f0       	push   $0xf012f3e0
f011ca42:	e8 94 d7 fe ff       	call   f010a1db <env_create>
f011ca47:	83 c4 10             	add    $0x10,%esp
f011ca4a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011ca4d:	6a 00                	push   $0x0
f011ca4f:	6a 00                	push   $0x0
f011ca51:	68 f4 01 00 00       	push   $0x1f4
f011ca56:	68 ed f3 12 f0       	push   $0xf012f3ed
f011ca5b:	e8 7b d7 fe ff       	call   f010a1db <env_create>
f011ca60:	83 c4 10             	add    $0x10,%esp
f011ca63:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011ca66:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ca6a:	74 0c                	je     f011ca78 <test_bsd_nice_1+0x77>
f011ca6c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011ca70:	74 06                	je     f011ca78 <test_bsd_nice_1+0x77>
f011ca72:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ca76:	75 17                	jne    f011ca8f <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011ca78:	83 ec 04             	sub    $0x4,%esp
f011ca7b:	68 39 f2 12 f0       	push   $0xf012f239
f011ca80:	68 8e 00 00 00       	push   $0x8e
f011ca85:	68 52 f2 12 f0       	push   $0xf012f252
f011ca8a:	e8 aa 38 fe ff       	call   f0100339 <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011ca8f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011ca92:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011ca98:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011ca9d:	75 20                	jne    f011cabf <test_bsd_nice_1+0xbe>
f011ca9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011caa2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011caa8:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011caad:	75 10                	jne    f011cabf <test_bsd_nice_1+0xbe>
f011caaf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011cab2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011cab8:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011cabd:	74 35                	je     f011caf4 <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011cabf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011cac2:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f011cac8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011cacb:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f011cad1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011cad4:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011cada:	83 ec 08             	sub    $0x8,%esp
f011cadd:	51                   	push   %ecx
f011cade:	52                   	push   %edx
f011cadf:	50                   	push   %eax
f011cae0:	68 fc f3 12 f0       	push   $0xf012f3fc
f011cae5:	68 90 00 00 00       	push   $0x90
f011caea:	68 52 f2 12 f0       	push   $0xf012f252
f011caef:	e8 45 38 fe ff       	call   f0100339 <_panic>
		sched_new_env(fibEnv);
f011caf4:	83 ec 0c             	sub    $0xc,%esp
f011caf7:	ff 75 ec             	pushl  -0x14(%ebp)
f011cafa:	e8 5e 8c fe ff       	call   f010575d <sched_new_env>
f011caff:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011cb02:	83 ec 0c             	sub    $0xc,%esp
f011cb05:	ff 75 e8             	pushl  -0x18(%ebp)
f011cb08:	e8 50 8c fe ff       	call   f010575d <sched_new_env>
f011cb0d:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011cb10:	83 ec 0c             	sub    $0xc,%esp
f011cb13:	ff 75 e4             	pushl  -0x1c(%ebp)
f011cb16:	e8 42 8c fe ff       	call   f010575d <sched_new_env>
f011cb1b:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011cb1e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011cb21:	8b 40 10             	mov    0x10(%eax),%eax
f011cb24:	a3 20 f3 60 f0       	mov    %eax,0xf060f320
		prog_orders[1][0] = fibEnv->env_id;
f011cb29:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011cb2c:	8b 40 10             	mov    0x10(%eax),%eax
f011cb2f:	a3 48 f3 60 f0       	mov    %eax,0xf060f348
		prog_orders[2][0] = fibposnEnv->env_id;
f011cb34:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011cb37:	8b 40 10             	mov    0x10(%eax),%eax
f011cb3a:	a3 70 f3 60 f0       	mov    %eax,0xf060f370
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011cb3f:	83 ec 0c             	sub    $0xc,%esp
f011cb42:	68 a0 f2 12 f0       	push   $0xf012f2a0
f011cb47:	e8 3f 44 fe ff       	call   f0100f8b <cprintf>
f011cb4c:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011cb4f:	83 ec 0c             	sub    $0xc,%esp
f011cb52:	68 ef f2 12 f0       	push   $0xf012f2ef
f011cb57:	e8 9f 53 fe ff       	call   f0101efb <execute_command>
f011cb5c:	83 c4 10             	add    $0x10,%esp
f011cb5f:	e9 9e 00 00 00       	jmp    f011cc02 <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011cb64:	83 ec 0c             	sub    $0xc,%esp
f011cb67:	68 f6 f2 12 f0       	push   $0xf012f2f6
f011cb6c:	e8 1a 44 fe ff       	call   f0100f8b <cprintf>
f011cb71:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011cb74:	e8 1c 93 fe ff       	call   f0105e95 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011cb79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011cb80:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011cb87:	83 ec 0c             	sub    $0xc,%esp
f011cb8a:	68 60 c4 5e f0       	push   $0xf05ec460
f011cb8f:	e8 2b 20 ff ff       	call   f010ebbf <acquire_spinlock>
f011cb94:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011cb97:	a1 ec c4 5e f0       	mov    0xf05ec4ec,%eax
f011cb9c:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011cb9f:	a1 e4 c4 5e f0       	mov    0xf05ec4e4,%eax
f011cba4:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011cba7:	eb 41                	jmp    f011cbea <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011cba9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011cbac:	89 d0                	mov    %edx,%eax
f011cbae:	c1 e0 02             	shl    $0x2,%eax
f011cbb1:	01 d0                	add    %edx,%eax
f011cbb3:	c1 e0 03             	shl    $0x3,%eax
f011cbb6:	05 20 f3 60 f0       	add    $0xf060f320,%eax
f011cbbb:	8b 10                	mov    (%eax),%edx
f011cbbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011cbc0:	8b 40 10             	mov    0x10(%eax),%eax
f011cbc3:	39 c2                	cmp    %eax,%edx
f011cbc5:	74 17                	je     f011cbde <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011cbc7:	83 ec 04             	sub    $0x4,%esp
f011cbca:	68 08 f3 12 f0       	push   $0xf012f308
f011cbcf:	68 ab 00 00 00       	push   $0xab
f011cbd4:	68 52 f2 12 f0       	push   $0xf012f252
f011cbd9:	e8 5b 37 fe ff       	call   f0100339 <_panic>
				i++;
f011cbde:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011cbe1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011cbe4:	8b 40 0c             	mov    0xc(%eax),%eax
f011cbe7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011cbea:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011cbed:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011cbf0:	7c b7                	jl     f011cba9 <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011cbf2:	83 ec 0c             	sub    $0xc,%esp
f011cbf5:	68 60 c4 5e f0       	push   $0xf05ec460
f011cbfa:	e8 47 20 ff ff       	call   f010ec46 <release_spinlock>
f011cbff:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011cc02:	83 ec 0c             	sub    $0xc,%esp
f011cc05:	68 68 f4 12 f0       	push   $0xf012f468
f011cc0a:	e8 7c 43 fe ff       	call   f0100f8b <cprintf>
f011cc0f:	83 c4 10             	add    $0x10,%esp
}
f011cc12:	90                   	nop
f011cc13:	c9                   	leave  
f011cc14:	c3                   	ret    

f011cc15 <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011cc15:	55                   	push   %ebp
f011cc16:	89 e5                	mov    %esp,%ebp
f011cc18:	57                   	push   %edi
f011cc19:	56                   	push   %esi
f011cc1a:	53                   	push   %ebx
f011cc1b:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011cc1e:	a0 dd bd 17 f0       	mov    0xf017bddd,%al
f011cc23:	84 c0                	test   %al,%al
f011cc25:	0f 84 ae 01 00 00    	je     f011cdd9 <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011cc2b:	83 ec 0c             	sub    $0xc,%esp
f011cc2e:	6a 01                	push   $0x1
f011cc30:	e8 fe 10 00 00       	call   f011dd33 <chksch>
f011cc35:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011cc38:	c6 05 dd bd 17 f0 00 	movb   $0x0,0xf017bddd
		int nice_values[] = {15, 5, 0, -5, -15};
f011cc3f:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011cc42:	bb ec f4 12 f0       	mov    $0xf012f4ec,%ebx
f011cc47:	ba 05 00 00 00       	mov    $0x5,%edx
f011cc4c:	89 c7                	mov    %eax,%edi
f011cc4e:	89 de                	mov    %ebx,%esi
f011cc50:	89 d1                	mov    %edx,%ecx
f011cc52:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011cc54:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011cc5b:	e9 4a 01 00 00       	jmp    f011cdaa <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011cc60:	6a 00                	push   $0x0
f011cc62:	6a 00                	push   $0x0
f011cc64:	68 10 27 00 00       	push   $0x2710
f011cc69:	68 a4 f4 12 f0       	push   $0xf012f4a4
f011cc6e:	e8 68 d5 fe ff       	call   f010a1db <env_create>
f011cc73:	83 c4 10             	add    $0x10,%esp
f011cc76:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011cc79:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011cc7c:	b9 05 00 00 00       	mov    $0x5,%ecx
f011cc81:	99                   	cltd   
f011cc82:	f7 f9                	idiv   %ecx
f011cc84:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011cc87:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cc8a:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011cc8e:	83 ec 08             	sub    $0x8,%esp
f011cc91:	50                   	push   %eax
f011cc92:	ff 75 d4             	pushl  -0x2c(%ebp)
f011cc95:	e8 2d 9a fe ff       	call   f01066c7 <env_set_nice>
f011cc9a:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011cc9d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011cca1:	75 17                	jne    f011ccba <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011cca3:	83 ec 04             	sub    $0x4,%esp
f011cca6:	68 39 f2 12 f0       	push   $0xf012f239
f011ccab:	68 c1 00 00 00       	push   $0xc1
f011ccb0:	68 52 f2 12 f0       	push   $0xf012f252
f011ccb5:	e8 7f 36 fe ff       	call   f0100339 <_panic>
			if (env->page_WS_max_size != 10000)
f011ccba:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011ccbd:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011ccc3:	3d 10 27 00 00       	cmp    $0x2710,%eax
f011ccc8:	74 17                	je     f011cce1 <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f011ccca:	83 ec 04             	sub    $0x4,%esp
f011cccd:	68 70 f2 12 f0       	push   $0xf012f270
f011ccd2:	68 c3 00 00 00       	push   $0xc3
f011ccd7:	68 52 f2 12 f0       	push   $0xf012f252
f011ccdc:	e8 58 36 fe ff       	call   f0100339 <_panic>

			switch (nice_values[nice_index])
f011cce1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cce4:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011cce8:	83 c0 0f             	add    $0xf,%eax
f011cceb:	83 f8 1e             	cmp    $0x1e,%eax
f011ccee:	0f 87 a5 00 00 00    	ja     f011cd99 <test_bsd_nice_2+0x184>
f011ccf4:	8b 04 85 00 f5 12 f0 	mov    -0xfed0b00(,%eax,4),%eax
f011ccfb:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011ccfd:	a1 fc c1 5e f0       	mov    0xf05ec1fc,%eax
f011cd02:	8d 50 01             	lea    0x1(%eax),%edx
f011cd05:	89 15 fc c1 5e f0    	mov    %edx,0xf05ec1fc
f011cd0b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011cd0e:	8b 52 10             	mov    0x10(%edx),%edx
f011cd11:	89 14 85 20 f3 60 f0 	mov    %edx,-0xf9f0ce0(,%eax,4)
				break;
f011cd18:	eb 7f                	jmp    f011cd99 <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011cd1a:	a1 00 c2 5e f0       	mov    0xf05ec200,%eax
f011cd1f:	8d 50 01             	lea    0x1(%eax),%edx
f011cd22:	89 15 00 c2 5e f0    	mov    %edx,0xf05ec200
f011cd28:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011cd2b:	8b 52 10             	mov    0x10(%edx),%edx
f011cd2e:	83 c0 0a             	add    $0xa,%eax
f011cd31:	89 14 85 20 f3 60 f0 	mov    %edx,-0xf9f0ce0(,%eax,4)
				break;
f011cd38:	eb 5f                	jmp    f011cd99 <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011cd3a:	a1 04 c2 5e f0       	mov    0xf05ec204,%eax
f011cd3f:	8d 50 01             	lea    0x1(%eax),%edx
f011cd42:	89 15 04 c2 5e f0    	mov    %edx,0xf05ec204
f011cd48:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011cd4b:	8b 52 10             	mov    0x10(%edx),%edx
f011cd4e:	83 c0 14             	add    $0x14,%eax
f011cd51:	89 14 85 20 f3 60 f0 	mov    %edx,-0xf9f0ce0(,%eax,4)
				break;
f011cd58:	eb 3f                	jmp    f011cd99 <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011cd5a:	a1 08 c2 5e f0       	mov    0xf05ec208,%eax
f011cd5f:	8d 50 01             	lea    0x1(%eax),%edx
f011cd62:	89 15 08 c2 5e f0    	mov    %edx,0xf05ec208
f011cd68:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011cd6b:	8b 52 10             	mov    0x10(%edx),%edx
f011cd6e:	83 c0 1e             	add    $0x1e,%eax
f011cd71:	89 14 85 20 f3 60 f0 	mov    %edx,-0xf9f0ce0(,%eax,4)
				break;
f011cd78:	eb 1f                	jmp    f011cd99 <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011cd7a:	a1 0c c2 5e f0       	mov    0xf05ec20c,%eax
f011cd7f:	8d 50 01             	lea    0x1(%eax),%edx
f011cd82:	89 15 0c c2 5e f0    	mov    %edx,0xf05ec20c
f011cd88:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011cd8b:	8b 52 10             	mov    0x10(%edx),%edx
f011cd8e:	83 c0 28             	add    $0x28,%eax
f011cd91:	89 14 85 20 f3 60 f0 	mov    %edx,-0xf9f0ce0(,%eax,4)
				break;
f011cd98:	90                   	nop
			}
			sched_new_env(env);
f011cd99:	83 ec 0c             	sub    $0xc,%esp
f011cd9c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011cd9f:	e8 b9 89 fe ff       	call   f010575d <sched_new_env>
f011cda4:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011cda7:	ff 45 e4             	incl   -0x1c(%ebp)
f011cdaa:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f011cdae:	0f 8e ac fe ff ff    	jle    f011cc60 <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011cdb4:	83 ec 0c             	sub    $0xc,%esp
f011cdb7:	68 a0 f2 12 f0       	push   $0xf012f2a0
f011cdbc:	e8 ca 41 fe ff       	call   f0100f8b <cprintf>
f011cdc1:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011cdc4:	83 ec 0c             	sub    $0xc,%esp
f011cdc7:	68 ef f2 12 f0       	push   $0xf012f2ef
f011cdcc:	e8 2a 51 fe ff       	call   f0101efb <execute_command>
f011cdd1:	83 c4 10             	add    $0x10,%esp
f011cdd4:	e9 d0 00 00 00       	jmp    f011cea9 <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f011cdd9:	83 ec 0c             	sub    $0xc,%esp
f011cddc:	6a 00                	push   $0x0
f011cdde:	e8 50 0f 00 00       	call   f011dd33 <chksch>
f011cde3:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f011cde6:	83 ec 0c             	sub    $0xc,%esp
f011cde9:	68 f6 f2 12 f0       	push   $0xf012f2f6
f011cdee:	e8 98 41 fe ff       	call   f0100f8b <cprintf>
f011cdf3:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011cdf6:	e8 9a 90 fe ff       	call   f0105e95 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011cdfb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011ce02:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011ce09:	e9 8a 00 00 00       	jmp    f011ce98 <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011ce0e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011ce15:	eb 55                	jmp    f011ce6c <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011ce17:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ce1a:	8b 14 85 fc c1 5e f0 	mov    -0xfa13e04(,%eax,4),%edx
f011ce21:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011ce24:	89 c8                	mov    %ecx,%eax
f011ce26:	c1 e0 02             	shl    $0x2,%eax
f011ce29:	01 c8                	add    %ecx,%eax
f011ce2b:	01 c0                	add    %eax,%eax
f011ce2d:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011ce30:	01 c8                	add    %ecx,%eax
f011ce32:	8b 04 85 20 f3 60 f0 	mov    -0xf9f0ce0(,%eax,4),%eax
f011ce39:	83 ec 04             	sub    $0x4,%esp
f011ce3c:	52                   	push   %edx
f011ce3d:	ff 75 e0             	pushl  -0x20(%ebp)
f011ce40:	50                   	push   %eax
f011ce41:	e8 7f f8 ff ff       	call   f011c6c5 <find_in_range>
f011ce46:	83 c4 10             	add    $0x10,%esp
f011ce49:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011ce4c:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011ce50:	75 17                	jne    f011ce69 <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f011ce52:	83 ec 04             	sub    $0x4,%esp
f011ce55:	68 08 f3 12 f0       	push   $0xf012f308
f011ce5a:	68 ea 00 00 00       	push   $0xea
f011ce5f:	68 52 f2 12 f0       	push   $0xf012f252
f011ce64:	e8 d0 34 fe ff       	call   f0100339 <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011ce69:	ff 45 d8             	incl   -0x28(%ebp)
f011ce6c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011ce6f:	89 d0                	mov    %edx,%eax
f011ce71:	c1 e0 02             	shl    $0x2,%eax
f011ce74:	01 d0                	add    %edx,%eax
f011ce76:	01 c0                	add    %eax,%eax
f011ce78:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ce7b:	01 d0                	add    %edx,%eax
f011ce7d:	8b 04 85 20 f3 60 f0 	mov    -0xf9f0ce0(,%eax,4),%eax
f011ce84:	85 c0                	test   %eax,%eax
f011ce86:	75 8f                	jne    f011ce17 <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011ce88:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ce8b:	8b 04 85 fc c1 5e f0 	mov    -0xfa13e04(,%eax,4),%eax
f011ce92:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011ce95:	ff 45 dc             	incl   -0x24(%ebp)
f011ce98:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011ce9c:	0f 8e 6c ff ff ff    	jle    f011ce0e <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011cea2:	c6 05 dd bd 17 f0 00 	movb   $0x0,0xf017bddd
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f011cea9:	83 ec 0c             	sub    $0xc,%esp
f011ceac:	68 b0 f4 12 f0       	push   $0xf012f4b0
f011ceb1:	e8 d5 40 fe ff       	call   f0100f8b <cprintf>
f011ceb6:	83 c4 10             	add    $0x10,%esp
}
f011ceb9:	90                   	nop
f011ceba:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011cebd:	5b                   	pop    %ebx
f011cebe:	5e                   	pop    %esi
f011cebf:	5f                   	pop    %edi
f011cec0:	5d                   	pop    %ebp
f011cec1:	c3                   	ret    

f011cec2 <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f011cec2:	55                   	push   %ebp
f011cec3:	89 e5                	mov    %esp,%ebp
f011cec5:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f011cec8:	8b 45 0c             	mov    0xc(%ebp),%eax
f011cecb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011cece:	8b 45 08             	mov    0x8(%ebp),%eax
f011ced1:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ced4:	89 10                	mov    %edx,(%eax)
}
f011ced6:	8b 45 08             	mov    0x8(%ebp),%eax
f011ced9:	c9                   	leave  
f011ceda:	c2 04 00             	ret    $0x4

f011cedd <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011cedd:	55                   	push   %ebp
f011cede:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011cee0:	8b 45 08             	mov    0x8(%ebp),%eax
f011cee3:	85 c0                	test   %eax,%eax
f011cee5:	78 16                	js     f011cefd <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f011cee7:	8b 45 08             	mov    0x8(%ebp),%eax
f011ceea:	05 00 20 00 00       	add    $0x2000,%eax
f011ceef:	85 c0                	test   %eax,%eax
f011cef1:	79 05                	jns    f011cef8 <fix_round+0x1b>
f011cef3:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011cef8:	c1 f8 0e             	sar    $0xe,%eax
f011cefb:	eb 14                	jmp    f011cf11 <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011cefd:	8b 45 08             	mov    0x8(%ebp),%eax
f011cf00:	2d 00 20 00 00       	sub    $0x2000,%eax
f011cf05:	85 c0                	test   %eax,%eax
f011cf07:	79 05                	jns    f011cf0e <fix_round+0x31>
f011cf09:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011cf0e:	c1 f8 0e             	sar    $0xe,%eax
}
f011cf11:	5d                   	pop    %ebp
f011cf12:	c3                   	ret    

f011cf13 <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f011cf13:	55                   	push   %ebp
f011cf14:	89 e5                	mov    %esp,%ebp
f011cf16:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f011cf19:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011cf1d:	79 16                	jns    f011cf35 <fix_scale+0x22>
f011cf1f:	68 7c f5 12 f0       	push   $0xf012f57c
f011cf24:	68 83 f5 12 f0       	push   $0xf012f583
f011cf29:	6a 5a                	push   $0x5a
f011cf2b:	68 98 f5 12 f0       	push   $0xf012f598
f011cf30:	e8 04 34 fe ff       	call   f0100339 <_panic>
  return __mk_fix (x.f * n);
f011cf35:	8b 45 0c             	mov    0xc(%ebp),%eax
f011cf38:	0f af 45 10          	imul   0x10(%ebp),%eax
f011cf3c:	89 c2                	mov    %eax,%edx
f011cf3e:	8b 45 08             	mov    0x8(%ebp),%eax
f011cf41:	83 ec 08             	sub    $0x8,%esp
f011cf44:	52                   	push   %edx
f011cf45:	50                   	push   %eax
f011cf46:	e8 77 ff ff ff       	call   f011cec2 <__mk_fix>
f011cf4b:	83 c4 0c             	add    $0xc,%esp
}
f011cf4e:	8b 45 08             	mov    0x8(%ebp),%eax
f011cf51:	c9                   	leave  
f011cf52:	c2 04 00             	ret    $0x4

f011cf55 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f011cf55:	55                   	push   %ebp
f011cf56:	89 e5                	mov    %esp,%ebp
f011cf58:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f011cf5b:	83 ec 08             	sub    $0x8,%esp
f011cf5e:	68 ac f5 12 f0       	push   $0xf012f5ac
f011cf63:	68 40 cc 5e f0       	push   $0xf05ecc40
f011cf68:	e8 21 1c ff ff       	call   f010eb8e <init_spinlock>
f011cf6d:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f011cf70:	83 ec 0c             	sub    $0xc,%esp
f011cf73:	68 40 cc 5e f0       	push   $0xf05ecc40
f011cf78:	e8 42 1c ff ff       	call   f010ebbf <acquire_spinlock>
f011cf7d:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011cf80:	c7 05 48 c3 5e f0 00 	movl   $0x0,0xf05ec348
f011cf87:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f011cf8a:	83 ec 0c             	sub    $0xc,%esp
f011cf8d:	68 40 cc 5e f0       	push   $0xf05ecc40
f011cf92:	e8 af 1c ff ff       	call   f010ec46 <release_spinlock>
f011cf97:	83 c4 10             	add    $0x10,%esp
}
f011cf9a:	90                   	nop
f011cf9b:	c9                   	leave  
f011cf9c:	c3                   	ret    

f011cf9d <inctst>:
void inctst()
{
f011cf9d:	55                   	push   %ebp
f011cf9e:	89 e5                	mov    %esp,%ebp
f011cfa0:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f011cfa3:	83 ec 0c             	sub    $0xc,%esp
f011cfa6:	68 40 cc 5e f0       	push   $0xf05ecc40
f011cfab:	e8 0f 1c ff ff       	call   f010ebbf <acquire_spinlock>
f011cfb0:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f011cfb3:	a1 48 c3 5e f0       	mov    0xf05ec348,%eax
f011cfb8:	40                   	inc    %eax
f011cfb9:	a3 48 c3 5e f0       	mov    %eax,0xf05ec348
	}
	release_spinlock(&tstcntlock);
f011cfbe:	83 ec 0c             	sub    $0xc,%esp
f011cfc1:	68 40 cc 5e f0       	push   $0xf05ecc40
f011cfc6:	e8 7b 1c ff ff       	call   f010ec46 <release_spinlock>
f011cfcb:	83 c4 10             	add    $0x10,%esp
}
f011cfce:	90                   	nop
f011cfcf:	c9                   	leave  
f011cfd0:	c3                   	ret    

f011cfd1 <gettst>:
uint32 gettst()
{
f011cfd1:	55                   	push   %ebp
f011cfd2:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f011cfd4:	a1 48 c3 5e f0       	mov    0xf05ec348,%eax
}
f011cfd9:	5d                   	pop    %ebp
f011cfda:	c3                   	ret    

f011cfdb <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f011cfdb:	55                   	push   %ebp
f011cfdc:	89 e5                	mov    %esp,%ebp
f011cfde:	83 ec 28             	sub    $0x28,%esp
f011cfe1:	8b 45 14             	mov    0x14(%ebp),%eax
f011cfe4:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f011cfe7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f011cfee:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f011cff2:	83 f8 65             	cmp    $0x65,%eax
f011cff5:	74 5d                	je     f011d054 <tst+0x79>
f011cff7:	83 f8 65             	cmp    $0x65,%eax
f011cffa:	7f 0a                	jg     f011d006 <tst+0x2b>
f011cffc:	83 f8 62             	cmp    $0x62,%eax
f011cfff:	74 73                	je     f011d074 <tst+0x99>
f011d001:	e9 91 00 00 00       	jmp    f011d097 <tst+0xbc>
f011d006:	83 f8 67             	cmp    $0x67,%eax
f011d009:	74 29                	je     f011d034 <tst+0x59>
f011d00b:	83 f8 6c             	cmp    $0x6c,%eax
f011d00e:	0f 85 83 00 00 00    	jne    f011d097 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f011d014:	8b 45 08             	mov    0x8(%ebp),%eax
f011d017:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d01a:	73 09                	jae    f011d025 <tst+0x4a>
			chk = 1;
f011d01c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011d023:	eb 68                	jmp    f011d08d <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f011d025:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011d029:	74 62                	je     f011d08d <tst+0xb2>
			chk = 1;
f011d02b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011d032:	eb 59                	jmp    f011d08d <tst+0xb2>
	case 'g':
		if (n > v1)
f011d034:	8b 45 08             	mov    0x8(%ebp),%eax
f011d037:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d03a:	76 09                	jbe    f011d045 <tst+0x6a>
			chk = 1;
f011d03c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011d043:	eb 4b                	jmp    f011d090 <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f011d045:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011d049:	74 45                	je     f011d090 <tst+0xb5>
			chk = 1;
f011d04b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011d052:	eb 3c                	jmp    f011d090 <tst+0xb5>
	case 'e':
		if (n == v1)
f011d054:	8b 45 08             	mov    0x8(%ebp),%eax
f011d057:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d05a:	75 09                	jne    f011d065 <tst+0x8a>
			chk = 1;
f011d05c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011d063:	eb 2e                	jmp    f011d093 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f011d065:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011d069:	74 28                	je     f011d093 <tst+0xb8>
			chk = 1;
f011d06b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011d072:	eb 1f                	jmp    f011d093 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f011d074:	8b 45 08             	mov    0x8(%ebp),%eax
f011d077:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d07a:	72 1a                	jb     f011d096 <tst+0xbb>
f011d07c:	8b 45 08             	mov    0x8(%ebp),%eax
f011d07f:	3b 45 10             	cmp    0x10(%ebp),%eax
f011d082:	77 12                	ja     f011d096 <tst+0xbb>
			chk = 1;
f011d084:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011d08b:	eb 09                	jmp    f011d096 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011d08d:	90                   	nop
f011d08e:	eb 07                	jmp    f011d097 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011d090:	90                   	nop
f011d091:	eb 04                	jmp    f011d097 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011d093:	90                   	nop
f011d094:	eb 01                	jmp    f011d097 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f011d096:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f011d097:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011d09b:	75 14                	jne    f011d0b1 <tst+0xd6>
f011d09d:	83 ec 04             	sub    $0x4,%esp
f011d0a0:	68 b8 f5 12 f0       	push   $0xf012f5b8
f011d0a5:	6a 48                	push   $0x48
f011d0a7:	68 cb f5 12 f0       	push   $0xf012f5cb
f011d0ac:	e8 88 32 fe ff       	call   f0100339 <_panic>

	acquire_spinlock(&tstcntlock);
f011d0b1:	83 ec 0c             	sub    $0xc,%esp
f011d0b4:	68 40 cc 5e f0       	push   $0xf05ecc40
f011d0b9:	e8 01 1b ff ff       	call   f010ebbf <acquire_spinlock>
f011d0be:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f011d0c1:	a1 48 c3 5e f0       	mov    0xf05ec348,%eax
f011d0c6:	40                   	inc    %eax
f011d0c7:	a3 48 c3 5e f0       	mov    %eax,0xf05ec348
	}
	release_spinlock(&tstcntlock);
f011d0cc:	83 ec 0c             	sub    $0xc,%esp
f011d0cf:	68 40 cc 5e f0       	push   $0xf05ecc40
f011d0d4:	e8 6d 1b ff ff       	call   f010ec46 <release_spinlock>
f011d0d9:	83 c4 10             	add    $0x10,%esp

	return;
f011d0dc:	90                   	nop
}
f011d0dd:	c9                   	leave  
f011d0de:	c3                   	ret    

f011d0df <chktst>:

void chktst(uint32 n)
{
f011d0df:	55                   	push   %ebp
f011d0e0:	89 e5                	mov    %esp,%ebp
f011d0e2:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f011d0e5:	83 ec 0c             	sub    $0xc,%esp
f011d0e8:	68 40 cc 5e f0       	push   $0xf05ecc40
f011d0ed:	e8 cd 1a ff ff       	call   f010ebbf <acquire_spinlock>
f011d0f2:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f011d0f5:	a1 48 c3 5e f0       	mov    0xf05ec348,%eax
f011d0fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f011d0fd:	83 ec 0c             	sub    $0xc,%esp
f011d100:	68 40 cc 5e f0       	push   $0xf05ecc40
f011d105:	e8 3c 1b ff ff       	call   f010ec46 <release_spinlock>
f011d10a:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f011d10d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d110:	3b 45 08             	cmp    0x8(%ebp),%eax
f011d113:	75 12                	jne    f011d127 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f011d115:	83 ec 0c             	sub    $0xc,%esp
f011d118:	68 e4 f5 12 f0       	push   $0xf012f5e4
f011d11d:	e8 69 3e fe ff       	call   f0100f8b <cprintf>
f011d122:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f011d125:	eb 14                	jmp    f011d13b <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f011d127:	83 ec 04             	sub    $0x4,%esp
f011d12a:	68 10 f6 12 f0       	push   $0xf012f610
f011d12f:	6a 5e                	push   $0x5e
f011d131:	68 cb f5 12 f0       	push   $0xf012f5cb
f011d136:	e8 fe 31 fe ff       	call   f0100339 <_panic>
}
f011d13b:	c9                   	leave  
f011d13c:	c3                   	ret    

f011d13d <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f011d13d:	55                   	push   %ebp
f011d13e:	89 e5                	mov    %esp,%ebp
f011d140:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011d143:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011d147:	77 07                	ja     f011d150 <nearest_pow2_ceil+0x13>
f011d149:	b8 01 00 00 00       	mov    $0x1,%eax
f011d14e:	eb 20                	jmp    f011d170 <nearest_pow2_ceil+0x33>
	int power = 2;
f011d150:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011d157:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011d15a:	eb 08                	jmp    f011d164 <nearest_pow2_ceil+0x27>
		power <<= 1;
f011d15c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011d15f:	01 c0                	add    %eax,%eax
f011d161:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f011d164:	d1 6d 08             	shrl   0x8(%ebp)
f011d167:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011d16b:	75 ef                	jne    f011d15c <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f011d16d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011d170:	c9                   	leave  
f011d171:	c3                   	ret    

f011d172 <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f011d172:	55                   	push   %ebp
f011d173:	89 e5                	mov    %esp,%ebp
f011d175:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011d178:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011d17c:	77 07                	ja     f011d185 <log2_ceil+0x13>
f011d17e:	b8 01 00 00 00       	mov    $0x1,%eax
f011d183:	eb 1b                	jmp    f011d1a0 <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f011d185:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011d18c:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011d18f:	eb 03                	jmp    f011d194 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f011d191:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f011d194:	d1 6d 08             	shrl   0x8(%ebp)
f011d197:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011d19b:	75 f4                	jne    f011d191 <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f011d19d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011d1a0:	c9                   	leave  
f011d1a1:	c3                   	ret    

f011d1a2 <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f011d1a2:	55                   	push   %ebp
f011d1a3:	89 e5                	mov    %esp,%ebp
f011d1a5:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f011d1a8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f011d1af:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011d1b6:	eb 12                	jmp    f011d1ca <fixedPt2Str+0x28>
		mulFactor *= 10;
f011d1b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011d1bb:	89 d0                	mov    %edx,%eax
f011d1bd:	c1 e0 02             	shl    $0x2,%eax
f011d1c0:	01 d0                	add    %edx,%eax
f011d1c2:	01 c0                	add    %eax,%eax
f011d1c4:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f011d1c7:	ff 45 f0             	incl   -0x10(%ebp)
f011d1ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d1cd:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011d1d0:	7c e6                	jl     f011d1b8 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f011d1d2:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011d1d5:	83 ec 04             	sub    $0x4,%esp
f011d1d8:	ff 75 f4             	pushl  -0xc(%ebp)
f011d1db:	ff 75 08             	pushl  0x8(%ebp)
f011d1de:	50                   	push   %eax
f011d1df:	e8 2f fd ff ff       	call   f011cf13 <fix_scale>
f011d1e4:	83 c4 0c             	add    $0xc,%esp
f011d1e7:	83 ec 0c             	sub    $0xc,%esp
f011d1ea:	ff 75 dc             	pushl  -0x24(%ebp)
f011d1ed:	e8 eb fc ff ff       	call   f011cedd <fix_round>
f011d1f2:	83 c4 10             	add    $0x10,%esp
f011d1f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f011d1f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d1fb:	99                   	cltd   
f011d1fc:	f7 7d f4             	idivl  -0xc(%ebp)
f011d1ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f011d202:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011d205:	99                   	cltd   
f011d206:	f7 7d f4             	idivl  -0xc(%ebp)
f011d209:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f011d20c:	83 ec 08             	sub    $0x8,%esp
f011d20f:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011d212:	50                   	push   %eax
f011d213:	ff 75 e4             	pushl  -0x1c(%ebp)
f011d216:	e8 6a 1e 00 00       	call   f011f085 <ltostr>
f011d21b:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f011d21e:	83 ec 08             	sub    $0x8,%esp
f011d221:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011d224:	50                   	push   %eax
f011d225:	ff 75 e0             	pushl  -0x20(%ebp)
f011d228:	e8 58 1e 00 00       	call   f011f085 <ltostr>
f011d22d:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f011d230:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011d233:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011d238:	f7 e9                	imul   %ecx
f011d23a:	c1 fa 02             	sar    $0x2,%edx
f011d23d:	89 c8                	mov    %ecx,%eax
f011d23f:	c1 f8 1f             	sar    $0x1f,%eax
f011d242:	29 c2                	sub    %eax,%edx
f011d244:	89 d0                	mov    %edx,%eax
f011d246:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f011d249:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f011d250:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f011d257:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f011d25d:	eb 31                	jmp    f011d290 <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f011d25f:	83 ec 04             	sub    $0x4,%esp
f011d262:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011d265:	50                   	push   %eax
f011d266:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011d269:	50                   	push   %eax
f011d26a:	68 2c f6 12 f0       	push   $0xf012f62c
f011d26f:	e8 ea 1e 00 00       	call   f011f15e <strcconcat>
f011d274:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f011d277:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f011d27a:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011d27f:	f7 e9                	imul   %ecx
f011d281:	c1 fa 02             	sar    $0x2,%edx
f011d284:	89 c8                	mov    %ecx,%eax
f011d286:	c1 f8 1f             	sar    $0x1f,%eax
f011d289:	29 c2                	sub    %eax,%edx
f011d28b:	89 d0                	mov    %edx,%eax
f011d28d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f011d290:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011d293:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011d296:	7c c7                	jl     f011d25f <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f011d298:	83 ec 04             	sub    $0x4,%esp
f011d29b:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011d29e:	50                   	push   %eax
f011d29f:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011d2a2:	50                   	push   %eax
f011d2a3:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011d2a6:	50                   	push   %eax
f011d2a7:	e8 b2 1e 00 00       	call   f011f15e <strcconcat>
f011d2ac:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f011d2af:	83 ec 04             	sub    $0x4,%esp
f011d2b2:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011d2b5:	50                   	push   %eax
f011d2b6:	68 2e f6 12 f0       	push   $0xf012f62e
f011d2bb:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011d2be:	50                   	push   %eax
f011d2bf:	e8 9a 1e 00 00       	call   f011f15e <strcconcat>
f011d2c4:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f011d2c7:	83 ec 04             	sub    $0x4,%esp
f011d2ca:	ff 75 10             	pushl  0x10(%ebp)
f011d2cd:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011d2d0:	50                   	push   %eax
f011d2d1:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011d2d4:	50                   	push   %eax
f011d2d5:	e8 84 1e 00 00       	call   f011f15e <strcconcat>
f011d2da:	83 c4 10             	add    $0x10,%esp

}
f011d2dd:	90                   	nop
f011d2de:	c9                   	leave  
f011d2df:	c3                   	ret    

f011d2e0 <sys_utilities>:
struct spinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f011d2e0:	55                   	push   %ebp
f011d2e1:	89 e5                	mov    %esp,%ebp
f011d2e3:	81 ec 98 00 00 00    	sub    $0x98,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f011d2e9:	83 ec 0c             	sub    $0xc,%esp
f011d2ec:	68 30 f6 12 f0       	push   $0xf012f630
f011d2f1:	e8 e9 18 00 00       	call   f011ebdf <strlen>
f011d2f6:	83 c4 10             	add    $0x10,%esp
f011d2f9:	83 ec 04             	sub    $0x4,%esp
f011d2fc:	50                   	push   %eax
f011d2fd:	68 30 f6 12 f0       	push   $0xf012f630
f011d302:	ff 75 08             	pushl  0x8(%ebp)
f011d305:	e8 19 1a 00 00       	call   f011ed23 <strncmp>
f011d30a:	83 c4 10             	add    $0x10,%esp
f011d30d:	85 c0                	test   %eax,%eax
f011d30f:	0f 85 8a 00 00 00    	jne    f011d39f <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011d315:	8d 45 bc             	lea    -0x44(%ebp),%eax
f011d318:	50                   	push   %eax
f011d319:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011d31f:	50                   	push   %eax
f011d320:	68 3e f6 12 f0       	push   $0xf012f63e
f011d325:	ff 75 08             	pushl  0x8(%ebp)
f011d328:	e8 c7 1e 00 00       	call   f011f1f4 <strsplit>
f011d32d:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f011d330:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d336:	83 ec 04             	sub    $0x4,%esp
f011d339:	6a 0a                	push   $0xa
f011d33b:	6a 00                	push   $0x0
f011d33d:	50                   	push   %eax
f011d33e:	e8 fc 1b 00 00       	call   f011ef3f <strtol>
f011d343:	83 c4 10             	add    $0x10,%esp
f011d346:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f011d349:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
		envid2env(envID, &env, 0);
f011d350:	83 ec 04             	sub    $0x4,%esp
f011d353:	6a 00                	push   $0x0
f011d355:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011d358:	50                   	push   %eax
f011d359:	ff 75 e0             	pushl  -0x20(%ebp)
f011d35c:	e8 48 d9 fe ff       	call   f010aca9 <envid2env>
f011d361:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f011d364:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d367:	8b 40 10             	mov    0x10(%eax),%eax
f011d36a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011d36d:	74 19                	je     f011d388 <sys_utilities+0xa8>
f011d36f:	68 40 f6 12 f0       	push   $0xf012f640
f011d374:	68 83 f5 12 f0       	push   $0xf012f583
f011d379:	68 a4 00 00 00       	push   $0xa4
f011d37e:	68 cb f5 12 f0       	push   $0xf012f5cb
f011d383:	e8 b1 2f fe ff       	call   f0100339 <_panic>
		env_set_nice(env, value);
f011d388:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011d38b:	83 ec 08             	sub    $0x8,%esp
f011d38e:	ff 75 0c             	pushl  0xc(%ebp)
f011d391:	50                   	push   %eax
f011d392:	e8 30 93 fe ff       	call   f01066c7 <env_set_nice>
f011d397:	83 c4 10             	add    $0x10,%esp
f011d39a:	e9 12 04 00 00       	jmp    f011d7b1 <sys_utilities+0x4d1>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f011d39f:	83 ec 0c             	sub    $0xc,%esp
f011d3a2:	68 55 f6 12 f0       	push   $0xf012f655
f011d3a7:	e8 33 18 00 00       	call   f011ebdf <strlen>
f011d3ac:	83 c4 10             	add    $0x10,%esp
f011d3af:	83 ec 04             	sub    $0x4,%esp
f011d3b2:	50                   	push   %eax
f011d3b3:	68 55 f6 12 f0       	push   $0xf012f655
f011d3b8:	ff 75 08             	pushl  0x8(%ebp)
f011d3bb:	e8 63 19 00 00       	call   f011ed23 <strncmp>
f011d3c0:	83 c4 10             	add    $0x10,%esp
f011d3c3:	85 c0                	test   %eax,%eax
f011d3c5:	0f 85 a6 01 00 00    	jne    f011d571 <sys_utilities+0x291>
	{
		int* numOfInstances = (int*) value ;
f011d3cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d3ce:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011d3d1:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011d3d4:	50                   	push   %eax
f011d3d5:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f011d3db:	50                   	push   %eax
f011d3dc:	68 3e f6 12 f0       	push   $0xf012f63e
f011d3e1:	ff 75 08             	pushl  0x8(%ebp)
f011d3e4:	e8 0b 1e 00 00       	call   f011f1f4 <strsplit>
f011d3e9:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f011d3ec:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d3f2:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f011d3f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f011d3fc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f011d403:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f011d40a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d40d:	8b 00                	mov    (%eax),%eax
f011d40f:	85 c0                	test   %eax,%eax
f011d411:	79 1c                	jns    f011d42f <sys_utilities+0x14f>
		{
			chkAscending = 0;
f011d413:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f011d41a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d41d:	8b 00                	mov    (%eax),%eax
f011d41f:	f7 d8                	neg    %eax
f011d421:	89 c2                	mov    %eax,%edx
f011d423:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d426:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f011d428:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f011d42f:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f011d436:	83 ec 0c             	sub    $0xc,%esp
f011d439:	68 60 c4 5e f0       	push   $0xf05ec460
f011d43e:	e8 7c 17 ff ff       	call   f010ebbf <acquire_spinlock>
f011d443:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011d446:	a1 ec c4 5e f0       	mov    0xf05ec4ec,%eax
f011d44b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011d44e:	a1 e4 c4 5e f0       	mov    0xf05ec4e4,%eax
f011d453:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011d456:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011d459:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011d45c:	eb 6c                	jmp    f011d4ca <sys_utilities+0x1ea>
			{
				if (strcmp(env->prog_name, progName) != 0)
f011d45e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d461:	83 c0 20             	add    $0x20,%eax
f011d464:	83 ec 08             	sub    $0x8,%esp
f011d467:	ff 75 d8             	pushl  -0x28(%ebp)
f011d46a:	50                   	push   %eax
f011d46b:	e8 7b 18 00 00       	call   f011eceb <strcmp>
f011d470:	83 c4 10             	add    $0x10,%esp
f011d473:	85 c0                	test   %eax,%eax
f011d475:	75 46                	jne    f011d4bd <sys_utilities+0x1dd>
					continue;
				(*numOfInstances)-- ;
f011d477:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d47a:	8b 00                	mov    (%eax),%eax
f011d47c:	8d 50 ff             	lea    -0x1(%eax),%edx
f011d47f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d482:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f011d484:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011d488:	74 14                	je     f011d49e <sys_utilities+0x1be>
				{
					if (prevEnvID > env->env_id)
f011d48a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d48d:	8b 40 10             	mov    0x10(%eax),%eax
f011d490:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011d493:	7d 1d                	jge    f011d4b2 <sys_utilities+0x1d2>
					{
						success = 0;
f011d495:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011d49c:	eb 32                	jmp    f011d4d0 <sys_utilities+0x1f0>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f011d49e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d4a1:	8b 40 10             	mov    0x10(%eax),%eax
f011d4a4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011d4a7:	7e 09                	jle    f011d4b2 <sys_utilities+0x1d2>
					{
						success = 0;
f011d4a9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011d4b0:	eb 1e                	jmp    f011d4d0 <sys_utilities+0x1f0>
					}
				}
				prevEnvID = env->env_id;
f011d4b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d4b5:	8b 40 10             	mov    0x10(%eax),%eax
f011d4b8:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011d4bb:	eb 01                	jmp    f011d4be <sys_utilities+0x1de>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f011d4bd:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011d4be:	ff 4d e4             	decl   -0x1c(%ebp)
f011d4c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d4c4:	8b 40 0c             	mov    0xc(%eax),%eax
f011d4c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011d4ca:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011d4ce:	7f 8e                	jg     f011d45e <sys_utilities+0x17e>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011d4d0:	83 ec 0c             	sub    $0xc,%esp
f011d4d3:	68 60 c4 5e f0       	push   $0xf05ec460
f011d4d8:	e8 69 17 ff ff       	call   f010ec46 <release_spinlock>
f011d4dd:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f011d4e0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d4e3:	8b 00                	mov    (%eax),%eax
f011d4e5:	85 c0                	test   %eax,%eax
f011d4e7:	75 06                	jne    f011d4ef <sys_utilities+0x20f>
f011d4e9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011d4ed:	75 41                	jne    f011d530 <sys_utilities+0x250>
		{
			cprintf("###########################################\n");
f011d4ef:	83 ec 0c             	sub    $0xc,%esp
f011d4f2:	68 68 f6 12 f0       	push   $0xf012f668
f011d4f7:	e8 8f 3a fe ff       	call   f0100f8b <cprintf>
f011d4fc:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f011d4ff:	83 ec 08             	sub    $0x8,%esp
f011d502:	ff 75 d8             	pushl  -0x28(%ebp)
f011d505:	68 98 f6 12 f0       	push   $0xf012f698
f011d50a:	e8 7c 3a fe ff       	call   f0100f8b <cprintf>
f011d50f:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f011d512:	83 ec 0c             	sub    $0xc,%esp
f011d515:	68 68 f6 12 f0       	push   $0xf012f668
f011d51a:	e8 6c 3a fe ff       	call   f0100f8b <cprintf>
f011d51f:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f011d522:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d525:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011d52b:	e9 81 02 00 00       	jmp    f011d7b1 <sys_utilities+0x4d1>
		}
		else
		{
			cprintf("####################################################\n");
f011d530:	83 ec 0c             	sub    $0xc,%esp
f011d533:	68 b8 f6 12 f0       	push   $0xf012f6b8
f011d538:	e8 4e 3a fe ff       	call   f0100f8b <cprintf>
f011d53d:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f011d540:	83 ec 08             	sub    $0x8,%esp
f011d543:	ff 75 d8             	pushl  -0x28(%ebp)
f011d546:	68 f0 f6 12 f0       	push   $0xf012f6f0
f011d54b:	e8 3b 3a fe ff       	call   f0100f8b <cprintf>
f011d550:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f011d553:	83 ec 0c             	sub    $0xc,%esp
f011d556:	68 b8 f6 12 f0       	push   $0xf012f6b8
f011d55b:	e8 2b 3a fe ff       	call   f0100f8b <cprintf>
f011d560:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f011d563:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d566:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f011d56c:	e9 40 02 00 00       	jmp    f011d7b1 <sys_utilities+0x4d1>
		}
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f011d571:	83 ec 08             	sub    $0x8,%esp
f011d574:	68 13 f7 12 f0       	push   $0xf012f713
f011d579:	ff 75 08             	pushl  0x8(%ebp)
f011d57c:	e8 6a 17 00 00       	call   f011eceb <strcmp>
f011d581:	83 c4 10             	add    $0x10,%esp
f011d584:	85 c0                	test   %eax,%eax
f011d586:	75 77                	jne    f011d5ff <sys_utilities+0x31f>
	{
		if (__firstTimeSleep)
f011d588:	a1 e0 bd 17 f0       	mov    0xf017bde0,%eax
f011d58d:	85 c0                	test   %eax,%eax
f011d58f:	74 34                	je     f011d5c5 <sys_utilities+0x2e5>
		{
			__firstTimeSleep = 0;
f011d591:	c7 05 e0 bd 17 f0 00 	movl   $0x0,0xf017bde0
f011d598:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f011d59b:	83 ec 08             	sub    $0x8,%esp
f011d59e:	68 1d f7 12 f0       	push   $0xf012f71d
f011d5a3:	68 00 f4 60 f0       	push   $0xf060f400
f011d5a8:	e8 e0 19 ff ff       	call   f010ef8d <init_channel>
f011d5ad:	83 c4 10             	add    $0x10,%esp
			init_spinlock(&__tstchan_lk__, "Test Channel Lock");
f011d5b0:	83 ec 08             	sub    $0x8,%esp
f011d5b3:	68 2a f7 12 f0       	push   $0xf012f72a
f011d5b8:	68 80 f5 60 f0       	push   $0xf060f580
f011d5bd:	e8 cc 15 ff ff       	call   f010eb8e <init_spinlock>
f011d5c2:	83 c4 10             	add    $0x10,%esp
		}
		acquire_spinlock(&__tstchan_lk__);
f011d5c5:	83 ec 0c             	sub    $0xc,%esp
f011d5c8:	68 80 f5 60 f0       	push   $0xf060f580
f011d5cd:	e8 ed 15 ff ff       	call   f010ebbf <acquire_spinlock>
f011d5d2:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011d5d5:	83 ec 08             	sub    $0x8,%esp
f011d5d8:	68 80 f5 60 f0       	push   $0xf060f580
f011d5dd:	68 00 f4 60 f0       	push   $0xf060f400
f011d5e2:	e8 d3 19 ff ff       	call   f010efba <sleep>
f011d5e7:	83 c4 10             	add    $0x10,%esp
		release_spinlock(&__tstchan_lk__);
f011d5ea:	83 ec 0c             	sub    $0xc,%esp
f011d5ed:	68 80 f5 60 f0       	push   $0xf060f580
f011d5f2:	e8 4f 16 ff ff       	call   f010ec46 <release_spinlock>
f011d5f7:	83 c4 10             	add    $0x10,%esp
f011d5fa:	e9 b2 01 00 00       	jmp    f011d7b1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f011d5ff:	83 ec 08             	sub    $0x8,%esp
f011d602:	68 3c f7 12 f0       	push   $0xf012f73c
f011d607:	ff 75 08             	pushl  0x8(%ebp)
f011d60a:	e8 dc 16 00 00       	call   f011eceb <strcmp>
f011d60f:	83 c4 10             	add    $0x10,%esp
f011d612:	85 c0                	test   %eax,%eax
f011d614:	75 15                	jne    f011d62b <sys_utilities+0x34b>
	{
		wakeup_one(&__tstchan__);
f011d616:	83 ec 0c             	sub    $0xc,%esp
f011d619:	68 00 f4 60 f0       	push   $0xf060f400
f011d61e:	e8 05 1a ff ff       	call   f010f028 <wakeup_one>
f011d623:	83 c4 10             	add    $0x10,%esp
f011d626:	e9 86 01 00 00       	jmp    f011d7b1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f011d62b:	83 ec 08             	sub    $0x8,%esp
f011d62e:	68 4a f7 12 f0       	push   $0xf012f74a
f011d633:	ff 75 08             	pushl  0x8(%ebp)
f011d636:	e8 b0 16 00 00       	call   f011eceb <strcmp>
f011d63b:	83 c4 10             	add    $0x10,%esp
f011d63e:	85 c0                	test   %eax,%eax
f011d640:	75 15                	jne    f011d657 <sys_utilities+0x377>
	{
		wakeup_all(&__tstchan__);
f011d642:	83 ec 0c             	sub    $0xc,%esp
f011d645:	68 00 f4 60 f0       	push   $0xf060f400
f011d64a:	e8 36 1a ff ff       	call   f010f085 <wakeup_all>
f011d64f:	83 c4 10             	add    $0x10,%esp
f011d652:	e9 5a 01 00 00       	jmp    f011d7b1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011d657:	83 ec 08             	sub    $0x8,%esp
f011d65a:	68 58 f7 12 f0       	push   $0xf012f758
f011d65f:	ff 75 08             	pushl  0x8(%ebp)
f011d662:	e8 84 16 00 00       	call   f011eceb <strcmp>
f011d667:	83 c4 10             	add    $0x10,%esp
f011d66a:	85 c0                	test   %eax,%eax
f011d66c:	75 17                	jne    f011d685 <sys_utilities+0x3a5>
	{
		int* numOfProcesses = (int*) value ;
f011d66e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d671:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f011d674:	a1 0c f4 60 f0       	mov    0xf060f40c,%eax
f011d679:	89 c2                	mov    %eax,%edx
f011d67b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d67e:	89 10                	mov    %edx,(%eax)
f011d680:	e9 2c 01 00 00       	jmp    f011d7b1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f011d685:	83 ec 08             	sub    $0x8,%esp
f011d688:	68 6d f7 12 f0       	push   $0xf012f76d
f011d68d:	ff 75 08             	pushl  0x8(%ebp)
f011d690:	e8 56 16 00 00       	call   f011eceb <strcmp>
f011d695:	83 c4 10             	add    $0x10,%esp
f011d698:	85 c0                	test   %eax,%eax
f011d69a:	75 1a                	jne    f011d6b6 <sys_utilities+0x3d6>
	{
		int* numOfProcesses = (int*) value ;
f011d69c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d69f:	89 45 cc             	mov    %eax,-0x34(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f011d6a2:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f011d6a7:	8b 40 0c             	mov    0xc(%eax),%eax
f011d6aa:	89 c2                	mov    %eax,%edx
f011d6ac:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011d6af:	89 10                	mov    %edx,(%eax)
f011d6b1:	e9 fb 00 00 00       	jmp    f011d7b1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f011d6b6:	83 ec 08             	sub    $0x8,%esp
f011d6b9:	68 83 f7 12 f0       	push   $0xf012f783
f011d6be:	ff 75 08             	pushl  0x8(%ebp)
f011d6c1:	e8 25 16 00 00       	call   f011eceb <strcmp>
f011d6c6:	83 c4 10             	add    $0x10,%esp
f011d6c9:	85 c0                	test   %eax,%eax
f011d6cb:	75 3d                	jne    f011d70a <sys_utilities+0x42a>
	{
		if (__firstTimeSleepLock)
f011d6cd:	a1 e4 bd 17 f0       	mov    0xf017bde4,%eax
f011d6d2:	85 c0                	test   %eax,%eax
f011d6d4:	74 1f                	je     f011d6f5 <sys_utilities+0x415>
		{
			__firstTimeSleepLock = 0;
f011d6d6:	c7 05 e4 bd 17 f0 00 	movl   $0x0,0xf017bde4
f011d6dd:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f011d6e0:	83 ec 08             	sub    $0x8,%esp
f011d6e3:	68 98 f7 12 f0       	push   $0xf012f798
f011d6e8:	68 60 f4 60 f0       	push   $0xf060f460
f011d6ed:	e8 27 17 ff ff       	call   f010ee19 <init_sleeplock>
f011d6f2:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011d6f5:	83 ec 0c             	sub    $0xc,%esp
f011d6f8:	68 60 f4 60 f0       	push   $0xf060f460
f011d6fd:	e8 db 17 ff ff       	call   f010eedd <acquire_sleeplock>
f011d702:	83 c4 10             	add    $0x10,%esp
f011d705:	e9 a7 00 00 00       	jmp    f011d7b1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f011d70a:	83 ec 08             	sub    $0x8,%esp
f011d70d:	68 a8 f7 12 f0       	push   $0xf012f7a8
f011d712:	ff 75 08             	pushl  0x8(%ebp)
f011d715:	e8 d1 15 00 00       	call   f011eceb <strcmp>
f011d71a:	83 c4 10             	add    $0x10,%esp
f011d71d:	85 c0                	test   %eax,%eax
f011d71f:	75 12                	jne    f011d733 <sys_utilities+0x453>
	{
		release_sleeplock(&__tstslplk__);
f011d721:	83 ec 0c             	sub    $0xc,%esp
f011d724:	68 60 f4 60 f0       	push   $0xf060f460
f011d729:	e8 0a 18 ff ff       	call   f010ef38 <release_sleeplock>
f011d72e:	83 c4 10             	add    $0x10,%esp
f011d731:	eb 7e                	jmp    f011d7b1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011d733:	83 ec 08             	sub    $0x8,%esp
f011d736:	68 bd f7 12 f0       	push   $0xf012f7bd
f011d73b:	ff 75 08             	pushl  0x8(%ebp)
f011d73e:	e8 a8 15 00 00       	call   f011eceb <strcmp>
f011d743:	83 c4 10             	add    $0x10,%esp
f011d746:	85 c0                	test   %eax,%eax
f011d748:	75 14                	jne    f011d75e <sys_utilities+0x47e>
	{
		int* numOfProcesses = (int*) value ;
f011d74a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d74d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f011d750:	a1 e0 f4 60 f0       	mov    0xf060f4e0,%eax
f011d755:	89 c2                	mov    %eax,%edx
f011d757:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011d75a:	89 10                	mov    %edx,(%eax)
f011d75c:	eb 53                	jmp    f011d7b1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f011d75e:	83 ec 08             	sub    $0x8,%esp
f011d761:	68 d2 f7 12 f0       	push   $0xf012f7d2
f011d766:	ff 75 08             	pushl  0x8(%ebp)
f011d769:	e8 7d 15 00 00       	call   f011eceb <strcmp>
f011d76e:	83 c4 10             	add    $0x10,%esp
f011d771:	85 c0                	test   %eax,%eax
f011d773:	75 13                	jne    f011d788 <sys_utilities+0x4a8>
	{
		int* lockVal = (int*) value ;
f011d775:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d778:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*lockVal =__tstslplk__.locked;
f011d77b:	8b 15 60 f4 60 f0    	mov    0xf060f460,%edx
f011d781:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011d784:	89 10                	mov    %edx,(%eax)
f011d786:	eb 29                	jmp    f011d7b1 <sys_utilities+0x4d1>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f011d788:	83 ec 08             	sub    $0x8,%esp
f011d78b:	68 e3 f7 12 f0       	push   $0xf012f7e3
f011d790:	ff 75 08             	pushl  0x8(%ebp)
f011d793:	e8 53 15 00 00       	call   f011eceb <strcmp>
f011d798:	83 c4 10             	add    $0x10,%esp
f011d79b:	85 c0                	test   %eax,%eax
f011d79d:	75 12                	jne    f011d7b1 <sys_utilities+0x4d1>
	{
		uint32* lockOwnerID = (uint32*) value ;
f011d79f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d7a2:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f011d7a5:	a1 64 f5 60 f0       	mov    0xf060f564,%eax
f011d7aa:	89 c2                	mov    %eax,%edx
f011d7ac:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011d7af:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011d7b1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011d7b5:	79 5b                	jns    f011d812 <sys_utilities+0x532>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f011d7b7:	83 ec 08             	sub    $0x8,%esp
f011d7ba:	68 f4 f7 12 f0       	push   $0xf012f7f4
f011d7bf:	ff 75 08             	pushl  0x8(%ebp)
f011d7c2:	e8 24 15 00 00       	call   f011eceb <strcmp>
f011d7c7:	83 c4 10             	add    $0x10,%esp
f011d7ca:	85 c0                	test   %eax,%eax
f011d7cc:	75 44                	jne    f011d812 <sys_utilities+0x532>
		{
			switch (value)
f011d7ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f011d7d1:	83 f8 fc             	cmp    $0xfffffffc,%eax
f011d7d4:	74 07                	je     f011d7dd <sys_utilities+0x4fd>
f011d7d6:	83 f8 fe             	cmp    $0xfffffffe,%eax
f011d7d9:	74 19                	je     f011d7f4 <sys_utilities+0x514>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f011d7db:	eb 35                	jmp    f011d812 <sys_utilities+0x532>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f011d7dd:	83 ec 0c             	sub    $0xc,%esp
f011d7e0:	68 04 f8 12 f0       	push   $0xf012f804
f011d7e5:	e8 a1 37 fe ff       	call   f0100f8b <cprintf>
f011d7ea:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f011d7ed:	e8 24 0f ff ff       	call   f010e716 <setPageReplacmentAlgorithmFIFO>
				break;
f011d7f2:	eb 1e                	jmp    f011d812 <sys_utilities+0x532>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f011d7f4:	83 ec 0c             	sub    $0xc,%esp
f011d7f7:	68 74 f8 12 f0       	push   $0xf012f874
f011d7fc:	e8 8a 37 fe ff       	call   f0100f8b <cprintf>
f011d801:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f011d804:	83 ec 0c             	sub    $0xc,%esp
f011d807:	6a 02                	push   $0x2
f011d809:	e8 c5 0e ff ff       	call   f010e6d3 <setPageReplacmentAlgorithmLRU>
f011d80e:	83 c4 10             	add    $0x10,%esp
				break;
f011d811:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f011d812:	90                   	nop
f011d813:	c9                   	leave  
f011d814:	c3                   	ret    

f011d815 <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011d815:	55                   	push   %ebp
f011d816:	89 e5                	mov    %esp,%ebp
f011d818:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011d81b:	8b 45 08             	mov    0x8(%ebp),%eax
f011d81e:	8b 00                	mov    (%eax),%eax
f011d820:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f011d823:	8b 45 08             	mov    0x8(%ebp),%eax
f011d826:	8b 00                	mov    (%eax),%eax
f011d828:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011d82b:	eb 52                	jmp    f011d87f <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f011d82d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d830:	8b 00                	mov    (%eax),%eax
f011d832:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011d835:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d838:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d83b:	75 12                	jne    f011d84f <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f011d83d:	83 ec 0c             	sub    $0xc,%esp
f011d840:	68 e8 f8 12 f0       	push   $0xf012f8e8
f011d845:	e8 41 37 fe ff       	call   f0100f8b <cprintf>
f011d84a:	83 c4 10             	add    $0x10,%esp
			break;
f011d84d:	eb 3f                	jmp    f011d88e <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f011d84f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011d853:	74 38                	je     f011d88d <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011d855:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d858:	8b 00                	mov    (%eax),%eax
f011d85a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f011d85d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d860:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011d863:	75 12                	jne    f011d877 <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011d865:	83 ec 0c             	sub    $0xc,%esp
f011d868:	68 04 f9 12 f0       	push   $0xf012f904
f011d86d:	e8 19 37 fe ff       	call   f0100f8b <cprintf>
f011d872:	83 c4 10             	add    $0x10,%esp
			break;
f011d875:	eb 17                	jmp    f011d88e <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011d877:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d87a:	8b 00                	mov    (%eax),%eax
f011d87c:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f011d87f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011d883:	74 09                	je     f011d88e <detect_loop_in_FrameInfo_list+0x79>
f011d885:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011d889:	75 a2                	jne    f011d82d <detect_loop_in_FrameInfo_list+0x18>
f011d88b:	eb 01                	jmp    f011d88e <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f011d88d:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f011d88e:	83 ec 0c             	sub    $0xc,%esp
f011d891:	68 1b f9 12 f0       	push   $0xf012f91b
f011d896:	e8 f0 36 fe ff       	call   f0100f8b <cprintf>
f011d89b:	83 c4 10             	add    $0x10,%esp
}
f011d89e:	90                   	nop
f011d89f:	c9                   	leave  
f011d8a0:	c3                   	ret    

f011d8a1 <scarce_memory>:

void scarce_memory()
{
f011d8a1:	55                   	push   %ebp
f011d8a2:	89 e5                	mov    %esp,%ebp
f011d8a4:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011d8a7:	a1 30 c6 5e f0       	mov    0xf05ec630,%eax
f011d8ac:	ba 64 00 00 00       	mov    $0x64,%edx
f011d8b1:	29 c2                	sub    %eax,%edx
f011d8b3:	a1 f8 c6 5e f0       	mov    0xf05ec6f8,%eax
f011d8b8:	0f af c2             	imul   %edx,%eax
f011d8bb:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011d8c0:	f7 e2                	mul    %edx
f011d8c2:	89 d0                	mov    %edx,%eax
f011d8c4:	c1 e8 05             	shr    $0x5,%eax
f011d8c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f011d8ca:	a1 30 c6 5e f0       	mov    0xf05ec630,%eax
f011d8cf:	ba 64 00 00 00       	mov    $0x64,%edx
f011d8d4:	29 c2                	sub    %eax,%edx
f011d8d6:	a1 f8 c6 5e f0       	mov    0xf05ec6f8,%eax
f011d8db:	89 d1                	mov    %edx,%ecx
f011d8dd:	0f af c8             	imul   %eax,%ecx
f011d8e0:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011d8e5:	f7 e1                	mul    %ecx
f011d8e7:	c1 ea 05             	shr    $0x5,%edx
f011d8ea:	89 d0                	mov    %edx,%eax
f011d8ec:	c1 e0 02             	shl    $0x2,%eax
f011d8ef:	01 d0                	add    %edx,%eax
f011d8f1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011d8f8:	01 d0                	add    %edx,%eax
f011d8fa:	c1 e0 02             	shl    $0x2,%eax
f011d8fd:	29 c1                	sub    %eax,%ecx
f011d8ff:	89 ca                	mov    %ecx,%edx
f011d901:	85 d2                	test   %edx,%edx
f011d903:	74 03                	je     f011d908 <scarce_memory+0x67>
		total_size_tobe_allocated++;
f011d905:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f011d908:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f011d90f:	83 ec 0c             	sub    $0xc,%esp
f011d912:	68 20 c5 5e f0       	push   $0xf05ec520
f011d917:	e8 a3 12 ff ff       	call   f010ebbf <acquire_spinlock>
f011d91c:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f011d91f:	a1 0c c5 5e f0       	mov    0xf05ec50c,%eax
f011d924:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011d927:	8b 15 f8 c6 5e f0    	mov    0xf05ec6f8,%edx
f011d92d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011d930:	29 c2                	sub    %eax,%edx
f011d932:	89 d0                	mov    %edx,%eax
f011d934:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011d937:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011d93a:	2b 45 e8             	sub    -0x18(%ebp),%eax
f011d93d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f011d940:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011d947:	eb 12                	jmp    f011d95b <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011d949:	83 ec 0c             	sub    $0xc,%esp
f011d94c:	8d 45 e0             	lea    -0x20(%ebp),%eax
f011d94f:	50                   	push   %eax
f011d950:	e8 2d a9 fe ff       	call   f0108282 <allocate_frame>
f011d955:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011d958:	ff 45 f0             	incl   -0x10(%ebp)
f011d95b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011d95e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011d961:	76 e6                	jbe    f011d949 <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f011d963:	83 ec 0c             	sub    $0xc,%esp
f011d966:	68 20 c5 5e f0       	push   $0xf05ec520
f011d96b:	e8 d6 12 ff ff       	call   f010ec46 <release_spinlock>
f011d970:	83 c4 10             	add    $0x10,%esp

}
f011d973:	90                   	nop
f011d974:	c9                   	leave  
f011d975:	c3                   	ret    

f011d976 <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011d976:	55                   	push   %ebp
f011d977:	89 e5                	mov    %esp,%ebp
f011d979:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f011d97c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f011d983:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011d98a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f011d991:	e8 c3 d2 fe ff       	call   f010ac59 <get_cpu_proc>
f011d996:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011d999:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011d99d:	75 19                	jne    f011d9b8 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f011d99f:	68 35 f9 12 f0       	push   $0xf012f935
f011d9a4:	68 83 f5 12 f0       	push   $0xf012f583
f011d9a9:	68 79 01 00 00       	push   $0x179
f011d9ae:	68 cb f5 12 f0       	push   $0xf012f5cb
f011d9b3:	e8 81 29 fe ff       	call   f0100339 <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f011d9b8:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011d9bc:	0f 85 d6 01 00 00    	jne    f011db98 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f011d9c2:	83 ec 0c             	sub    $0xc,%esp
f011d9c5:	68 60 c4 5e f0       	push   $0xf05ec460
f011d9ca:	e8 f0 11 ff ff       	call   f010ebbf <acquire_spinlock>
f011d9cf:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011d9d2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011d9d9:	e9 d2 00 00 00       	jmp    f011dab0 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f011d9de:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011d9e5:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f011d9ea:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011d9ed:	c1 e2 04             	shl    $0x4,%edx
f011d9f0:	01 d0                	add    %edx,%eax
f011d9f2:	8b 00                	mov    (%eax),%eax
f011d9f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011d9f7:	eb 7c                	jmp    f011da75 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f011d9f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011d9fc:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011da02:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011da05:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011da08:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011da0e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011da11:	0f af c2             	imul   %edx,%eax
f011da14:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011da19:	f7 e2                	mul    %edx
f011da1b:	89 d0                	mov    %edx,%eax
f011da1d:	c1 e8 05             	shr    $0x5,%eax
f011da20:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011da23:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011da26:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011da2c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011da2f:	89 d1                	mov    %edx,%ecx
f011da31:	0f af c8             	imul   %eax,%ecx
f011da34:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011da39:	f7 e1                	mul    %ecx
f011da3b:	c1 ea 05             	shr    $0x5,%edx
f011da3e:	89 d0                	mov    %edx,%eax
f011da40:	c1 e0 02             	shl    $0x2,%eax
f011da43:	01 d0                	add    %edx,%eax
f011da45:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011da4c:	01 d0                	add    %edx,%eax
f011da4e:	c1 e0 02             	shl    $0x2,%eax
f011da51:	29 c1                	sub    %eax,%ecx
f011da53:	89 ca                	mov    %ecx,%edx
f011da55:	85 d2                	test   %edx,%edx
f011da57:	74 03                	je     f011da5c <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011da59:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f011da5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011da5f:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011da62:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f011da67:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011da6a:	c1 e2 04             	shl    $0x4,%edx
f011da6d:	01 d0                	add    %edx,%eax
f011da6f:	8b 40 08             	mov    0x8(%eax),%eax
f011da72:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011da75:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f011da7a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011da7d:	c1 e2 04             	shl    $0x4,%edx
f011da80:	01 d0                	add    %edx,%eax
f011da82:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011da86:	74 08                	je     f011da90 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011da88:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011da8b:	8b 52 08             	mov    0x8(%edx),%edx
f011da8e:	eb 05                	jmp    f011da95 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f011da90:	ba 00 00 00 00       	mov    $0x0,%edx
f011da95:	89 50 08             	mov    %edx,0x8(%eax)
f011da98:	8b 40 08             	mov    0x8(%eax),%eax
f011da9b:	85 c0                	test   %eax,%eax
f011da9d:	0f 85 56 ff ff ff    	jne    f011d9f9 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f011daa3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011daa7:	0f 85 4c ff ff ff    	jne    f011d9f9 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011daad:	ff 45 e8             	incl   -0x18(%ebp)
f011dab0:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f011dab5:	0f b6 c0             	movzbl %al,%eax
f011dab8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011dabb:	0f 8f 1d ff ff ff    	jg     f011d9de <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f011dac1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011dac8:	a1 e0 c4 5e f0       	mov    0xf05ec4e0,%eax
f011dacd:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011dad0:	eb 1a                	jmp    f011daec <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f011dad2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dad5:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011dadb:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f011dade:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011dae1:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011dae4:	a1 e8 c4 5e f0       	mov    0xf05ec4e8,%eax
f011dae9:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011daec:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011daf0:	74 08                	je     f011dafa <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f011daf2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011daf5:	8b 40 08             	mov    0x8(%eax),%eax
f011daf8:	eb 05                	jmp    f011daff <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f011dafa:	b8 00 00 00 00       	mov    $0x0,%eax
f011daff:	a3 e8 c4 5e f0       	mov    %eax,0xf05ec4e8
f011db04:	a1 e8 c4 5e f0       	mov    0xf05ec4e8,%eax
f011db09:	85 c0                	test   %eax,%eax
f011db0b:	75 c5                	jne    f011dad2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f011db0d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011db11:	75 bf                	jne    f011dad2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011db13:	83 ec 0c             	sub    $0xc,%esp
f011db16:	68 60 c4 5e f0       	push   $0xf05ec460
f011db1b:	e8 26 11 ff ff       	call   f010ec46 <release_spinlock>
f011db20:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f011db23:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011db27:	0f 84 d4 00 00 00    	je     f011dc01 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011db2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011db30:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011db36:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011db39:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011db3c:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011db42:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011db45:	0f af c2             	imul   %edx,%eax
f011db48:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011db4d:	f7 e2                	mul    %edx
f011db4f:	89 d0                	mov    %edx,%eax
f011db51:	c1 e8 05             	shr    $0x5,%eax
f011db54:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011db57:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011db5a:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011db60:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011db63:	89 d1                	mov    %edx,%ecx
f011db65:	0f af c8             	imul   %eax,%ecx
f011db68:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011db6d:	f7 e1                	mul    %ecx
f011db6f:	c1 ea 05             	shr    $0x5,%edx
f011db72:	89 d0                	mov    %edx,%eax
f011db74:	c1 e0 02             	shl    $0x2,%eax
f011db77:	01 d0                	add    %edx,%eax
f011db79:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011db80:	01 d0                	add    %edx,%eax
f011db82:	c1 e0 02             	shl    $0x2,%eax
f011db85:	29 c1                	sub    %eax,%ecx
f011db87:	89 ca                	mov    %ecx,%edx
f011db89:	85 d2                	test   %edx,%edx
f011db8b:	74 03                	je     f011db90 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f011db8d:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011db90:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011db93:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011db96:	eb 69                	jmp    f011dc01 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011db98:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011db9b:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011dba1:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011dba4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011dba7:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011dbad:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011dbb0:	0f af c2             	imul   %edx,%eax
f011dbb3:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011dbb8:	f7 e2                	mul    %edx
f011dbba:	89 d0                	mov    %edx,%eax
f011dbbc:	c1 e8 05             	shr    $0x5,%eax
f011dbbf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011dbc2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011dbc5:	8b 90 80 05 00 00    	mov    0x580(%eax),%edx
f011dbcb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011dbce:	89 d1                	mov    %edx,%ecx
f011dbd0:	0f af c8             	imul   %eax,%ecx
f011dbd3:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011dbd8:	f7 e1                	mul    %ecx
f011dbda:	c1 ea 05             	shr    $0x5,%edx
f011dbdd:	89 d0                	mov    %edx,%eax
f011dbdf:	c1 e0 02             	shl    $0x2,%eax
f011dbe2:	01 d0                	add    %edx,%eax
f011dbe4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011dbeb:	01 d0                	add    %edx,%eax
f011dbed:	c1 e0 02             	shl    $0x2,%eax
f011dbf0:	29 c1                	sub    %eax,%ecx
f011dbf2:	89 ca                	mov    %ecx,%edx
f011dbf4:	85 d2                	test   %edx,%edx
f011dbf6:	74 03                	je     f011dbfb <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f011dbf8:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011dbfb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011dbfe:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f011dc01:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011dc04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dc07:	01 c2                	add    %eax,%edx
f011dc09:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dc0c:	01 d0                	add    %edx,%eax
}
f011dc0e:	c9                   	leave  
f011dc0f:	c3                   	ret    

f011dc10 <schenv>:


void schenv()
{
f011dc10:	55                   	push   %ebp
f011dc11:	89 e5                	mov    %esp,%ebp
f011dc13:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f011dc16:	c6 05 20 cc 5e f0 00 	movb   $0x0,0xf05ecc20
	__ne = NULL;
f011dc1d:	c7 05 50 c9 5e f0 00 	movl   $0x0,0xf05ec950
f011dc24:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f011dc27:	83 ec 0c             	sub    $0xc,%esp
f011dc2a:	68 60 c4 5e f0       	push   $0xf05ec460
f011dc2f:	e8 8b 0f ff ff       	call   f010ebbf <acquire_spinlock>
f011dc34:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011dc37:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011dc3e:	eb 3f                	jmp    f011dc7f <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f011dc40:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f011dc45:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011dc48:	c1 e2 04             	shl    $0x4,%edx
f011dc4b:	01 d0                	add    %edx,%eax
f011dc4d:	83 ec 0c             	sub    $0xc,%esp
f011dc50:	50                   	push   %eax
f011dc51:	e8 7d 73 fe ff       	call   f0104fd3 <queue_size>
f011dc56:	83 c4 10             	add    $0x10,%esp
f011dc59:	85 c0                	test   %eax,%eax
f011dc5b:	74 1f                	je     f011dc7c <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f011dc5d:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f011dc62:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011dc65:	c1 e2 04             	shl    $0x4,%edx
f011dc68:	01 d0                	add    %edx,%eax
f011dc6a:	8b 40 04             	mov    0x4(%eax),%eax
f011dc6d:	a3 50 c9 5e f0       	mov    %eax,0xf05ec950
				__nl = i;
f011dc72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011dc75:	a2 20 cc 5e f0       	mov    %al,0xf05ecc20
				break;
f011dc7a:	eb 10                	jmp    f011dc8c <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011dc7c:	ff 45 f4             	incl   -0xc(%ebp)
f011dc7f:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f011dc84:	0f b6 c0             	movzbl %al,%eax
f011dc87:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011dc8a:	7f b4                	jg     f011dc40 <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011dc8c:	83 ec 0c             	sub    $0xc,%esp
f011dc8f:	68 60 c4 5e f0       	push   $0xf05ec460
f011dc94:	e8 ad 0f ff ff       	call   f010ec46 <release_spinlock>
f011dc99:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f011dc9c:	e8 b8 cf fe ff       	call   f010ac59 <get_cpu_proc>
f011dca1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f011dca4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011dca8:	0f 84 82 00 00 00    	je     f011dd30 <schenv+0x120>
	{
		if (__ne != NULL)
f011dcae:	a1 50 c9 5e f0       	mov    0xf05ec950,%eax
f011dcb3:	85 c0                	test   %eax,%eax
f011dcb5:	74 49                	je     f011dd00 <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f011dcb7:	a0 41 c4 5e f0       	mov    0xf05ec441,%al
f011dcbc:	0f b6 c0             	movzbl %al,%eax
f011dcbf:	8d 50 01             	lea    0x1(%eax),%edx
f011dcc2:	a0 20 cc 5e f0       	mov    0xf05ecc20,%al
f011dcc7:	0f b6 c0             	movzbl %al,%eax
f011dcca:	39 c2                	cmp    %eax,%edx
f011dccc:	7d 62                	jge    f011dd30 <schenv+0x120>
			{
				__ne = cur_env;
f011dcce:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dcd1:	a3 50 c9 5e f0       	mov    %eax,0xf05ec950
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011dcd6:	a0 41 c4 5e f0       	mov    0xf05ec441,%al
f011dcdb:	0f b6 c0             	movzbl %al,%eax
f011dcde:	8a 15 a0 cb 5e f0    	mov    0xf05ecba0,%dl
f011dce4:	0f b6 d2             	movzbl %dl,%edx
f011dce7:	4a                   	dec    %edx
f011dce8:	39 d0                	cmp    %edx,%eax
f011dcea:	7d 08                	jge    f011dcf4 <schenv+0xe4>
f011dcec:	a0 41 c4 5e f0       	mov    0xf05ec441,%al
f011dcf1:	40                   	inc    %eax
f011dcf2:	eb 05                	jmp    f011dcf9 <schenv+0xe9>
f011dcf4:	a0 41 c4 5e f0       	mov    0xf05ec441,%al
f011dcf9:	a2 20 cc 5e f0       	mov    %al,0xf05ecc20
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f011dcfe:	eb 30                	jmp    f011dd30 <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f011dd00:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011dd03:	a3 50 c9 5e f0       	mov    %eax,0xf05ec950
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011dd08:	a0 41 c4 5e f0       	mov    0xf05ec441,%al
f011dd0d:	0f b6 c0             	movzbl %al,%eax
f011dd10:	8a 15 a0 cb 5e f0    	mov    0xf05ecba0,%dl
f011dd16:	0f b6 d2             	movzbl %dl,%edx
f011dd19:	4a                   	dec    %edx
f011dd1a:	39 d0                	cmp    %edx,%eax
f011dd1c:	7d 08                	jge    f011dd26 <schenv+0x116>
f011dd1e:	a0 41 c4 5e f0       	mov    0xf05ec441,%al
f011dd23:	40                   	inc    %eax
f011dd24:	eb 05                	jmp    f011dd2b <schenv+0x11b>
f011dd26:	a0 41 c4 5e f0       	mov    0xf05ec441,%al
f011dd2b:	a2 20 cc 5e f0       	mov    %al,0xf05ecc20
		}
	}
}
f011dd30:	90                   	nop
f011dd31:	c9                   	leave  
f011dd32:	c3                   	ret    

f011dd33 <chksch>:

void chksch(uint8 onoff)
{
f011dd33:	55                   	push   %ebp
f011dd34:	89 e5                	mov    %esp,%ebp
f011dd36:	83 ec 18             	sub    $0x18,%esp
f011dd39:	8b 45 08             	mov    0x8(%ebp),%eax
f011dd3c:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011dd3f:	e8 0f 8a fe ff       	call   f0106753 <isSchedMethodBSD>
f011dd44:	85 c0                	test   %eax,%eax
f011dd46:	74 48                	je     f011dd90 <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f011dd48:	e8 b4 89 fe ff       	call   f0106701 <get_load_average>
f011dd4d:	a3 bc cb 5e f0       	mov    %eax,0xf05ecbbc
f011dd52:	a1 bc cb 5e f0       	mov    0xf05ecbbc,%eax
f011dd57:	a3 fc c6 5e f0       	mov    %eax,0xf05ec6fc
		acquire_spinlock(&ProcessQueues.qlock);
f011dd5c:	83 ec 0c             	sub    $0xc,%esp
f011dd5f:	68 60 c4 5e f0       	push   $0xf05ec460
f011dd64:	e8 56 0e ff ff       	call   f010ebbf <acquire_spinlock>
f011dd69:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f011dd6c:	a1 ec c4 5e f0       	mov    0xf05ec4ec,%eax
f011dd71:	a3 a0 c5 5e f0       	mov    %eax,0xf05ec5a0
		}
		release_spinlock(&ProcessQueues.qlock);
f011dd76:	83 ec 0c             	sub    $0xc,%esp
f011dd79:	68 60 c4 5e f0       	push   $0xf05ec460
f011dd7e:	e8 c3 0e ff ff       	call   f010ec46 <release_spinlock>
f011dd83:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f011dd86:	c7 05 64 c9 5e f0 01 	movl   $0x1,0xf05ec964
f011dd8d:	00 00 00 
	}
	__chkstatus = onoff;
f011dd90:	8a 45 f4             	mov    -0xc(%ebp),%al
f011dd93:	a2 48 c9 5e f0       	mov    %al,0xf05ec948
}
f011dd98:	90                   	nop
f011dd99:	c9                   	leave  
f011dd9a:	c3                   	ret    

f011dd9b <chk1>:
void chk1()
{
f011dd9b:	55                   	push   %ebp
f011dd9c:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f011dd9e:	90                   	nop
f011dd9f:	5d                   	pop    %ebp
f011dda0:	c3                   	ret    

f011dda1 <chk2>:
void chk2(struct Env* __se)
{
f011dda1:	55                   	push   %ebp
f011dda2:	89 e5                	mov    %esp,%ebp
f011dda4:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f011dda7:	a0 48 c9 5e f0       	mov    0xf05ec948,%al
f011ddac:	84 c0                	test   %al,%al
f011ddae:	0f 84 59 03 00 00    	je     f011e10d <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011ddb4:	e8 9a 89 fe ff       	call   f0106753 <isSchedMethodBSD>
f011ddb9:	85 c0                	test   %eax,%eax
f011ddbb:	0f 84 4d 03 00 00    	je     f011e10e <chk2+0x36d>
	{
		__nla = get_load_average();
f011ddc1:	e8 3b 89 fe ff       	call   f0106701 <get_load_average>
f011ddc6:	a3 34 c6 5e f0       	mov    %eax,0xf05ec634
		acquire_spinlock(&ProcessQueues.qlock);
f011ddcb:	83 ec 0c             	sub    $0xc,%esp
f011ddce:	68 60 c4 5e f0       	push   $0xf05ec460
f011ddd3:	e8 e7 0d ff ff       	call   f010ebbf <acquire_spinlock>
f011ddd8:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011dddb:	a1 ec c4 5e f0       	mov    0xf05ec4ec,%eax
f011dde0:	a3 54 c9 5e f0       	mov    %eax,0xf05ec954
		}
		release_spinlock(&ProcessQueues.qlock);
f011dde5:	83 ec 0c             	sub    $0xc,%esp
f011dde8:	68 60 c4 5e f0       	push   $0xf05ec460
f011dded:	e8 54 0e ff ff       	call   f010ec46 <release_spinlock>
f011ddf2:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f011ddf5:	a1 64 c9 5e f0       	mov    0xf05ec964,%eax
f011ddfa:	85 c0                	test   %eax,%eax
f011ddfc:	74 72                	je     f011de70 <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f011ddfe:	83 ec 0c             	sub    $0xc,%esp
f011de01:	68 60 c4 5e f0       	push   $0xf05ec460
f011de06:	e8 b4 0d ff ff       	call   f010ebbf <acquire_spinlock>
f011de0b:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f011de0e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011de12:	0f 95 c0             	setne  %al
f011de15:	0f b6 c0             	movzbl %al,%eax
f011de18:	a3 14 cb 5e f0       	mov    %eax,0xf05ecb14
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011de1d:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f011de22:	0f b6 c0             	movzbl %al,%eax
f011de25:	48                   	dec    %eax
f011de26:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011de29:	eb 20                	jmp    f011de4b <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011de2b:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f011de30:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011de33:	c1 e2 04             	shl    $0x4,%edx
f011de36:	01 d0                	add    %edx,%eax
f011de38:	8b 40 0c             	mov    0xc(%eax),%eax
f011de3b:	8b 15 14 cb 5e f0    	mov    0xf05ecb14,%edx
f011de41:	01 d0                	add    %edx,%eax
f011de43:	a3 14 cb 5e f0       	mov    %eax,0xf05ecb14
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011de48:	ff 4d f4             	decl   -0xc(%ebp)
f011de4b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011de4f:	79 da                	jns    f011de2b <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f011de51:	c7 05 64 c9 5e f0 00 	movl   $0x0,0xf05ec964
f011de58:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f011de5b:	83 ec 0c             	sub    $0xc,%esp
f011de5e:	68 60 c4 5e f0       	push   $0xf05ec460
f011de63:	e8 de 0d ff ff       	call   f010ec46 <release_spinlock>
f011de68:	83 c4 10             	add    $0x10,%esp
f011de6b:	e9 91 02 00 00       	jmp    f011e101 <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f011de70:	8b 15 a0 c5 5e f0    	mov    0xf05ec5a0,%edx
f011de76:	a1 54 c9 5e f0       	mov    0xf05ec954,%eax
f011de7b:	39 c2                	cmp    %eax,%edx
f011de7d:	74 63                	je     f011dee2 <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f011de7f:	83 ec 0c             	sub    $0xc,%esp
f011de82:	68 60 c4 5e f0       	push   $0xf05ec460
f011de87:	e8 33 0d ff ff       	call   f010ebbf <acquire_spinlock>
f011de8c:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f011de8f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011de93:	0f 95 c0             	setne  %al
f011de96:	0f b6 c0             	movzbl %al,%eax
f011de99:	a3 14 cb 5e f0       	mov    %eax,0xf05ecb14
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011de9e:	a0 a0 cb 5e f0       	mov    0xf05ecba0,%al
f011dea3:	0f b6 c0             	movzbl %al,%eax
f011dea6:	48                   	dec    %eax
f011dea7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011deaa:	eb 20                	jmp    f011decc <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011deac:	a1 f0 c4 5e f0       	mov    0xf05ec4f0,%eax
f011deb1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011deb4:	c1 e2 04             	shl    $0x4,%edx
f011deb7:	01 d0                	add    %edx,%eax
f011deb9:	8b 40 0c             	mov    0xc(%eax),%eax
f011debc:	8b 15 14 cb 5e f0    	mov    0xf05ecb14,%edx
f011dec2:	01 d0                	add    %edx,%eax
f011dec4:	a3 14 cb 5e f0       	mov    %eax,0xf05ecb14
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011dec9:	ff 4d f0             	decl   -0x10(%ebp)
f011decc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ded0:	79 da                	jns    f011deac <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f011ded2:	83 ec 0c             	sub    $0xc,%esp
f011ded5:	68 60 c4 5e f0       	push   $0xf05ec460
f011deda:	e8 67 0d ff ff       	call   f010ec46 <release_spinlock>
f011dedf:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f011dee2:	e8 b3 87 fe ff       	call   f010669a <timer_ticks>
f011dee7:	6a 00                	push   $0x0
f011dee9:	68 e8 03 00 00       	push   $0x3e8
f011deee:	52                   	push   %edx
f011deef:	50                   	push   %eax
f011def0:	e8 c7 2b 00 00       	call   f0120abc <__moddi3>
f011def5:	83 c4 10             	add    $0x10,%esp
f011def8:	09 d0                	or     %edx,%eax
f011defa:	85 c0                	test   %eax,%eax
f011defc:	75 32                	jne    f011df30 <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f011defe:	8b 15 fc c6 5e f0    	mov    0xf05ec6fc,%edx
f011df04:	a1 34 c6 5e f0       	mov    0xf05ec634,%eax
f011df09:	39 c2                	cmp    %eax,%edx
f011df0b:	75 19                	jne    f011df26 <chk2+0x185>
f011df0d:	68 45 f9 12 f0       	push   $0xf012f945
f011df12:	68 83 f5 12 f0       	push   $0xf012f583
f011df17:	68 35 02 00 00       	push   $0x235
f011df1c:	68 cb f5 12 f0       	push   $0xf012f5cb
f011df21:	e8 a3 24 fe ff       	call   f01003c9 <_panic_all>
				__histla = __nla;
f011df26:	a1 34 c6 5e f0       	mov    0xf05ec634,%eax
f011df2b:	a3 fc c6 5e f0       	mov    %eax,0xf05ec6fc
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f011df30:	e8 65 87 fe ff       	call   f010669a <timer_ticks>
f011df35:	6a 00                	push   $0x0
f011df37:	6a 64                	push   $0x64
f011df39:	52                   	push   %edx
f011df3a:	50                   	push   %eax
f011df3b:	e8 7c 2b 00 00       	call   f0120abc <__moddi3>
f011df40:	83 c4 10             	add    $0x10,%esp
f011df43:	09 d0                	or     %edx,%eax
f011df45:	85 c0                	test   %eax,%eax
f011df47:	0f 85 b4 01 00 00    	jne    f011e101 <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f011df4d:	8b 0d bc cb 5e f0    	mov    0xf05ecbbc,%ecx
f011df53:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011df58:	f7 e9                	imul   %ecx
f011df5a:	c1 fa 05             	sar    $0x5,%edx
f011df5d:	89 c8                	mov    %ecx,%eax
f011df5f:	c1 f8 1f             	sar    $0x1f,%eax
f011df62:	29 c2                	sub    %eax,%edx
f011df64:	89 d0                	mov    %edx,%eax
f011df66:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f011df69:	8b 0d bc cb 5e f0    	mov    0xf05ecbbc,%ecx
f011df6f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011df74:	f7 e9                	imul   %ecx
f011df76:	c1 fa 05             	sar    $0x5,%edx
f011df79:	89 c8                	mov    %ecx,%eax
f011df7b:	c1 f8 1f             	sar    $0x1f,%eax
f011df7e:	29 c2                	sub    %eax,%edx
f011df80:	89 d0                	mov    %edx,%eax
f011df82:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011df85:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011df88:	89 d0                	mov    %edx,%eax
f011df8a:	c1 e0 02             	shl    $0x2,%eax
f011df8d:	01 d0                	add    %edx,%eax
f011df8f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011df96:	01 d0                	add    %edx,%eax
f011df98:	c1 e0 02             	shl    $0x2,%eax
f011df9b:	29 c1                	sub    %eax,%ecx
f011df9d:	89 c8                	mov    %ecx,%eax
f011df9f:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f011dfa2:	8b 0d 34 c6 5e f0    	mov    0xf05ec634,%ecx
f011dfa8:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011dfad:	f7 e9                	imul   %ecx
f011dfaf:	c1 fa 05             	sar    $0x5,%edx
f011dfb2:	89 c8                	mov    %ecx,%eax
f011dfb4:	c1 f8 1f             	sar    $0x1f,%eax
f011dfb7:	29 c2                	sub    %eax,%edx
f011dfb9:	89 d0                	mov    %edx,%eax
f011dfbb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f011dfbe:	8b 0d 34 c6 5e f0    	mov    0xf05ec634,%ecx
f011dfc4:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011dfc9:	f7 e9                	imul   %ecx
f011dfcb:	c1 fa 05             	sar    $0x5,%edx
f011dfce:	89 c8                	mov    %ecx,%eax
f011dfd0:	c1 f8 1f             	sar    $0x1f,%eax
f011dfd3:	29 c2                	sub    %eax,%edx
f011dfd5:	89 d0                	mov    %edx,%eax
f011dfd7:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011dfda:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011dfdd:	89 d0                	mov    %edx,%eax
f011dfdf:	c1 e0 02             	shl    $0x2,%eax
f011dfe2:	01 d0                	add    %edx,%eax
f011dfe4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011dfeb:	01 d0                	add    %edx,%eax
f011dfed:	c1 e0 02             	shl    $0x2,%eax
f011dff0:	29 c1                	sub    %eax,%ecx
f011dff2:	89 c8                	mov    %ecx,%eax
f011dff4:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f011dff7:	8b 15 54 c9 5e f0    	mov    0xf05ec954,%edx
f011dffd:	a1 a0 c5 5e f0       	mov    0xf05ec5a0,%eax
f011e002:	39 c2                	cmp    %eax,%edx
f011e004:	0f 85 ed 00 00 00    	jne    f011e0f7 <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f011e00a:	a1 14 cb 5e f0       	mov    0xf05ecb14,%eax
f011e00f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e012:	7e 5b                	jle    f011e06f <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011e014:	a1 14 cb 5e f0       	mov    0xf05ecb14,%eax
f011e019:	83 ec 08             	sub    $0x8,%esp
f011e01c:	ff 75 e0             	pushl  -0x20(%ebp)
f011e01f:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e022:	ff 75 e8             	pushl  -0x18(%ebp)
f011e025:	ff 75 ec             	pushl  -0x14(%ebp)
f011e028:	50                   	push   %eax
f011e029:	68 58 f9 12 f0       	push   $0xf012f958
f011e02e:	e8 58 2f fe ff       	call   f0100f8b <cprintf>
f011e033:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f011e036:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e039:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e03c:	0f 8f b5 00 00 00    	jg     f011e0f7 <chk2+0x356>
f011e042:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e045:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e048:	75 0c                	jne    f011e056 <chk2+0x2b5>
f011e04a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e04d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011e050:	0f 8d a1 00 00 00    	jge    f011e0f7 <chk2+0x356>
f011e056:	68 a0 f9 12 f0       	push   $0xf012f9a0
f011e05b:	68 83 f5 12 f0       	push   $0xf012f583
f011e060:	68 4a 02 00 00       	push   $0x24a
f011e065:	68 cb f5 12 f0       	push   $0xf012f5cb
f011e06a:	e8 5a 23 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc < plaint)
f011e06f:	a1 14 cb 5e f0       	mov    0xf05ecb14,%eax
f011e074:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e077:	7d 53                	jge    f011e0cc <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011e079:	a1 14 cb 5e f0       	mov    0xf05ecb14,%eax
f011e07e:	83 ec 08             	sub    $0x8,%esp
f011e081:	ff 75 e0             	pushl  -0x20(%ebp)
f011e084:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e087:	ff 75 e8             	pushl  -0x18(%ebp)
f011e08a:	ff 75 ec             	pushl  -0x14(%ebp)
f011e08d:	50                   	push   %eax
f011e08e:	68 e0 f9 12 f0       	push   $0xf012f9e0
f011e093:	e8 f3 2e fe ff       	call   f0100f8b <cprintf>
f011e098:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f011e09b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e09e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e0a1:	7c 54                	jl     f011e0f7 <chk2+0x356>
f011e0a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e0a6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e0a9:	75 08                	jne    f011e0b3 <chk2+0x312>
f011e0ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e0ae:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011e0b1:	7e 44                	jle    f011e0f7 <chk2+0x356>
f011e0b3:	68 28 fa 12 f0       	push   $0xf012fa28
f011e0b8:	68 83 f5 12 f0       	push   $0xf012f583
f011e0bd:	68 50 02 00 00       	push   $0x250
f011e0c2:	68 cb f5 12 f0       	push   $0xf012f5cb
f011e0c7:	e8 fd 22 fe ff       	call   f01003c9 <_panic_all>
					}
					else if (__nproc == plaint)
f011e0cc:	a1 14 cb 5e f0       	mov    0xf05ecb14,%eax
f011e0d1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e0d4:	75 21                	jne    f011e0f7 <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f011e0d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e0d9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011e0dc:	74 19                	je     f011e0f7 <chk2+0x356>
f011e0de:	68 68 fa 12 f0       	push   $0xf012fa68
f011e0e3:	68 83 f5 12 f0       	push   $0xf012f583
f011e0e8:	68 54 02 00 00       	push   $0x254
f011e0ed:	68 cb f5 12 f0       	push   $0xf012f5cb
f011e0f2:	e8 d2 22 fe ff       	call   f01003c9 <_panic_all>
					}
				}
				__pla = __nla;
f011e0f7:	a1 34 c6 5e f0       	mov    0xf05ec634,%eax
f011e0fc:	a3 bc cb 5e f0       	mov    %eax,0xf05ecbbc
			}
		}
		__pnexit = __nnexit;
f011e101:	a1 54 c9 5e f0       	mov    0xf05ec954,%eax
f011e106:	a3 a0 c5 5e f0       	mov    %eax,0xf05ec5a0
f011e10b:	eb 01                	jmp    f011e10e <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011e10d:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011e10e:	c9                   	leave  
f011e10f:	c3                   	ret    

f011e110 <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011e110:	55                   	push   %ebp
f011e111:	89 e5                	mov    %esp,%ebp
f011e113:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011e116:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e11d:	eb 40                	jmp    f011e15f <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011e11f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e122:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011e128:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011e12d:	83 ec 08             	sub    $0x8,%esp
f011e130:	52                   	push   %edx
f011e131:	50                   	push   %eax
f011e132:	e8 af 01 00 00       	call   f011e2e6 <check_va2pa>
f011e137:	83 c4 10             	add    $0x10,%esp
f011e13a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011e13d:	74 19                	je     f011e158 <check_boot_pgdir+0x48>
f011e13f:	68 7c fa 12 f0       	push   $0xf012fa7c
f011e144:	68 83 f5 12 f0       	push   $0xf012f583
f011e149:	68 9b 02 00 00       	push   $0x29b
f011e14e:	68 cb f5 12 f0       	push   $0xf012f5cb
f011e153:	e8 e1 21 fe ff       	call   f0100339 <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011e158:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011e15f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e162:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011e168:	a1 18 cb 5e f0       	mov    0xf05ecb18,%eax
f011e16d:	39 c2                	cmp    %eax,%edx
f011e16f:	72 ae                	jb     f011e11f <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011e171:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e178:	e9 81 00 00 00       	jmp    f011e1fe <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011e17d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e180:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011e185:	85 c0                	test   %eax,%eax
f011e187:	74 6d                	je     f011e1f6 <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011e189:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e18c:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011e192:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011e197:	83 ec 08             	sub    $0x8,%esp
f011e19a:	52                   	push   %edx
f011e19b:	50                   	push   %eax
f011e19c:	e8 45 01 00 00       	call   f011e2e6 <check_va2pa>
f011e1a1:	83 c4 10             	add    $0x10,%esp
f011e1a4:	c7 45 f0 00 30 17 f0 	movl   $0xf0173000,-0x10(%ebp)
f011e1ab:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011e1b2:	77 17                	ja     f011e1cb <check_boot_pgdir+0xbb>
f011e1b4:	ff 75 f0             	pushl  -0x10(%ebp)
f011e1b7:	68 b4 fa 12 f0       	push   $0xf012fab4
f011e1bc:	68 a9 02 00 00       	push   $0x2a9
f011e1c1:	68 cb f5 12 f0       	push   $0xf012f5cb
f011e1c6:	e8 6e 21 fe ff       	call   f0100339 <_panic>
f011e1cb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011e1ce:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011e1d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e1d7:	01 ca                	add    %ecx,%edx
f011e1d9:	39 d0                	cmp    %edx,%eax
f011e1db:	74 1a                	je     f011e1f7 <check_boot_pgdir+0xe7>
f011e1dd:	68 e8 fa 12 f0       	push   $0xf012fae8
f011e1e2:	68 83 f5 12 f0       	push   $0xf012f583
f011e1e7:	68 a9 02 00 00       	push   $0x2a9
f011e1ec:	68 cb f5 12 f0       	push   $0xf012f5cb
f011e1f1:	e8 43 21 fe ff       	call   f0100339 <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011e1f6:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011e1f7:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011e1fe:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011e205:	0f 86 72 ff ff ff    	jbe    f011e17d <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011e20b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e212:	e9 af 00 00 00       	jmp    f011e2c6 <check_boot_pgdir+0x1b6>
		switch (i) {
f011e217:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e21a:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011e21f:	74 11                	je     f011e232 <check_boot_pgdir+0x122>
f011e221:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011e226:	72 36                	jb     f011e25e <check_boot_pgdir+0x14e>
f011e228:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011e22d:	83 f8 02             	cmp    $0x2,%eax
f011e230:	77 2c                	ja     f011e25e <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011e232:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011e237:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e23a:	c1 e2 02             	shl    $0x2,%edx
f011e23d:	01 d0                	add    %edx,%eax
f011e23f:	8b 00                	mov    (%eax),%eax
f011e241:	85 c0                	test   %eax,%eax
f011e243:	75 7a                	jne    f011e2bf <check_boot_pgdir+0x1af>
f011e245:	68 6e fb 12 f0       	push   $0xf012fb6e
f011e24a:	68 83 f5 12 f0       	push   $0xf012f583
f011e24f:	68 b4 02 00 00       	push   $0x2b4
f011e254:	68 cb f5 12 f0       	push   $0xf012f5cb
f011e259:	e8 db 20 fe ff       	call   f0100339 <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011e25e:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011e265:	76 2c                	jbe    f011e293 <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011e267:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011e26c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e26f:	c1 e2 02             	shl    $0x2,%edx
f011e272:	01 d0                	add    %edx,%eax
f011e274:	8b 00                	mov    (%eax),%eax
f011e276:	85 c0                	test   %eax,%eax
f011e278:	75 48                	jne    f011e2c2 <check_boot_pgdir+0x1b2>
f011e27a:	68 6e fb 12 f0       	push   $0xf012fb6e
f011e27f:	68 83 f5 12 f0       	push   $0xf012f583
f011e284:	68 b8 02 00 00       	push   $0x2b8
f011e289:	68 cb f5 12 f0       	push   $0xf012f5cb
f011e28e:	e8 a6 20 fe ff       	call   f0100339 <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011e293:	a1 1c cb 5e f0       	mov    0xf05ecb1c,%eax
f011e298:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e29b:	c1 e2 02             	shl    $0x2,%edx
f011e29e:	01 d0                	add    %edx,%eax
f011e2a0:	8b 00                	mov    (%eax),%eax
f011e2a2:	85 c0                	test   %eax,%eax
f011e2a4:	74 1c                	je     f011e2c2 <check_boot_pgdir+0x1b2>
f011e2a6:	68 84 fb 12 f0       	push   $0xf012fb84
f011e2ab:	68 83 f5 12 f0       	push   $0xf012f583
f011e2b0:	68 ba 02 00 00       	push   $0x2ba
f011e2b5:	68 cb f5 12 f0       	push   $0xf012f5cb
f011e2ba:	e8 7a 20 fe ff       	call   f0100339 <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011e2bf:	90                   	nop
f011e2c0:	eb 01                	jmp    f011e2c3 <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011e2c2:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011e2c3:	ff 45 f4             	incl   -0xc(%ebp)
f011e2c6:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011e2cd:	0f 86 44 ff ff ff    	jbe    f011e217 <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011e2d3:	83 ec 0c             	sub    $0xc,%esp
f011e2d6:	68 a0 fb 12 f0       	push   $0xf012fba0
f011e2db:	e8 ab 2c fe ff       	call   f0100f8b <cprintf>
f011e2e0:	83 c4 10             	add    $0x10,%esp
}
f011e2e3:	90                   	nop
f011e2e4:	c9                   	leave  
f011e2e5:	c3                   	ret    

f011e2e6 <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011e2e6:	55                   	push   %ebp
f011e2e7:	89 e5                	mov    %esp,%ebp
f011e2e9:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011e2ec:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e2ef:	c1 e8 16             	shr    $0x16,%eax
f011e2f2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e2f9:	8b 45 08             	mov    0x8(%ebp),%eax
f011e2fc:	01 d0                	add    %edx,%eax
f011e2fe:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011e301:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e304:	8b 00                	mov    (%eax),%eax
f011e306:	83 e0 01             	and    $0x1,%eax
f011e309:	85 c0                	test   %eax,%eax
f011e30b:	75 0a                	jne    f011e317 <check_va2pa+0x31>
		return ~0;
f011e30d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011e312:	e9 87 00 00 00       	jmp    f011e39e <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011e317:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e31a:	8b 00                	mov    (%eax),%eax
f011e31c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011e321:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e324:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e327:	c1 e8 0c             	shr    $0xc,%eax
f011e32a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011e32d:	a1 f8 c6 5e f0       	mov    0xf05ec6f8,%eax
f011e332:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011e335:	72 17                	jb     f011e34e <check_va2pa+0x68>
f011e337:	ff 75 f0             	pushl  -0x10(%ebp)
f011e33a:	68 c4 fb 12 f0       	push   $0xf012fbc4
f011e33f:	68 d0 02 00 00       	push   $0x2d0
f011e344:	68 cb f5 12 f0       	push   $0xf012f5cb
f011e349:	e8 eb 1f fe ff       	call   f0100339 <_panic>
f011e34e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e351:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011e356:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011e359:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e35c:	c1 e8 0c             	shr    $0xc,%eax
f011e35f:	25 ff 03 00 00       	and    $0x3ff,%eax
f011e364:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e36b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e36e:	01 d0                	add    %edx,%eax
f011e370:	8b 00                	mov    (%eax),%eax
f011e372:	83 e0 01             	and    $0x1,%eax
f011e375:	85 c0                	test   %eax,%eax
f011e377:	75 07                	jne    f011e380 <check_va2pa+0x9a>
		return ~0;
f011e379:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011e37e:	eb 1e                	jmp    f011e39e <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011e380:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e383:	c1 e8 0c             	shr    $0xc,%eax
f011e386:	25 ff 03 00 00       	and    $0x3ff,%eax
f011e38b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011e392:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e395:	01 d0                	add    %edx,%eax
f011e397:	8b 00                	mov    (%eax),%eax
f011e399:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011e39e:	c9                   	leave  
f011e39f:	c3                   	ret    

f011e3a0 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011e3a0:	55                   	push   %ebp
f011e3a1:	89 e5                	mov    %esp,%ebp
f011e3a3:	53                   	push   %ebx
f011e3a4:	83 ec 14             	sub    $0x14,%esp
f011e3a7:	8b 45 10             	mov    0x10(%ebp),%eax
f011e3aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e3ad:	8b 45 14             	mov    0x14(%ebp),%eax
f011e3b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011e3b3:	8b 45 18             	mov    0x18(%ebp),%eax
f011e3b6:	ba 00 00 00 00       	mov    $0x0,%edx
f011e3bb:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011e3be:	77 55                	ja     f011e415 <printnum+0x75>
f011e3c0:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011e3c3:	72 05                	jb     f011e3ca <printnum+0x2a>
f011e3c5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011e3c8:	77 4b                	ja     f011e415 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011e3ca:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011e3cd:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011e3d0:	8b 45 18             	mov    0x18(%ebp),%eax
f011e3d3:	ba 00 00 00 00       	mov    $0x0,%edx
f011e3d8:	52                   	push   %edx
f011e3d9:	50                   	push   %eax
f011e3da:	ff 75 f4             	pushl  -0xc(%ebp)
f011e3dd:	ff 75 f0             	pushl  -0x10(%ebp)
f011e3e0:	e8 6f 28 00 00       	call   f0120c54 <__udivdi3>
f011e3e5:	83 c4 10             	add    $0x10,%esp
f011e3e8:	83 ec 04             	sub    $0x4,%esp
f011e3eb:	ff 75 20             	pushl  0x20(%ebp)
f011e3ee:	53                   	push   %ebx
f011e3ef:	ff 75 18             	pushl  0x18(%ebp)
f011e3f2:	52                   	push   %edx
f011e3f3:	50                   	push   %eax
f011e3f4:	ff 75 0c             	pushl  0xc(%ebp)
f011e3f7:	ff 75 08             	pushl  0x8(%ebp)
f011e3fa:	e8 a1 ff ff ff       	call   f011e3a0 <printnum>
f011e3ff:	83 c4 20             	add    $0x20,%esp
f011e402:	eb 1a                	jmp    f011e41e <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011e404:	83 ec 08             	sub    $0x8,%esp
f011e407:	ff 75 0c             	pushl  0xc(%ebp)
f011e40a:	ff 75 20             	pushl  0x20(%ebp)
f011e40d:	8b 45 08             	mov    0x8(%ebp),%eax
f011e410:	ff d0                	call   *%eax
f011e412:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011e415:	ff 4d 1c             	decl   0x1c(%ebp)
f011e418:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011e41c:	7f e6                	jg     f011e404 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011e41e:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011e421:	bb 00 00 00 00       	mov    $0x0,%ebx
f011e426:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e429:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e42c:	53                   	push   %ebx
f011e42d:	51                   	push   %ecx
f011e42e:	52                   	push   %edx
f011e42f:	50                   	push   %eax
f011e430:	e8 2f 29 00 00       	call   f0120d64 <__umoddi3>
f011e435:	83 c4 10             	add    $0x10,%esp
f011e438:	05 14 fe 12 f0       	add    $0xf012fe14,%eax
f011e43d:	8a 00                	mov    (%eax),%al
f011e43f:	0f be c0             	movsbl %al,%eax
f011e442:	83 ec 08             	sub    $0x8,%esp
f011e445:	ff 75 0c             	pushl  0xc(%ebp)
f011e448:	50                   	push   %eax
f011e449:	8b 45 08             	mov    0x8(%ebp),%eax
f011e44c:	ff d0                	call   *%eax
f011e44e:	83 c4 10             	add    $0x10,%esp
}
f011e451:	90                   	nop
f011e452:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011e455:	c9                   	leave  
f011e456:	c3                   	ret    

f011e457 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011e457:	55                   	push   %ebp
f011e458:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011e45a:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011e45e:	7e 1c                	jle    f011e47c <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011e460:	8b 45 08             	mov    0x8(%ebp),%eax
f011e463:	8b 00                	mov    (%eax),%eax
f011e465:	8d 50 08             	lea    0x8(%eax),%edx
f011e468:	8b 45 08             	mov    0x8(%ebp),%eax
f011e46b:	89 10                	mov    %edx,(%eax)
f011e46d:	8b 45 08             	mov    0x8(%ebp),%eax
f011e470:	8b 00                	mov    (%eax),%eax
f011e472:	83 e8 08             	sub    $0x8,%eax
f011e475:	8b 50 04             	mov    0x4(%eax),%edx
f011e478:	8b 00                	mov    (%eax),%eax
f011e47a:	eb 40                	jmp    f011e4bc <getuint+0x65>
	else if (lflag)
f011e47c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e480:	74 1e                	je     f011e4a0 <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011e482:	8b 45 08             	mov    0x8(%ebp),%eax
f011e485:	8b 00                	mov    (%eax),%eax
f011e487:	8d 50 04             	lea    0x4(%eax),%edx
f011e48a:	8b 45 08             	mov    0x8(%ebp),%eax
f011e48d:	89 10                	mov    %edx,(%eax)
f011e48f:	8b 45 08             	mov    0x8(%ebp),%eax
f011e492:	8b 00                	mov    (%eax),%eax
f011e494:	83 e8 04             	sub    $0x4,%eax
f011e497:	8b 00                	mov    (%eax),%eax
f011e499:	ba 00 00 00 00       	mov    $0x0,%edx
f011e49e:	eb 1c                	jmp    f011e4bc <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011e4a0:	8b 45 08             	mov    0x8(%ebp),%eax
f011e4a3:	8b 00                	mov    (%eax),%eax
f011e4a5:	8d 50 04             	lea    0x4(%eax),%edx
f011e4a8:	8b 45 08             	mov    0x8(%ebp),%eax
f011e4ab:	89 10                	mov    %edx,(%eax)
f011e4ad:	8b 45 08             	mov    0x8(%ebp),%eax
f011e4b0:	8b 00                	mov    (%eax),%eax
f011e4b2:	83 e8 04             	sub    $0x4,%eax
f011e4b5:	8b 00                	mov    (%eax),%eax
f011e4b7:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011e4bc:	5d                   	pop    %ebp
f011e4bd:	c3                   	ret    

f011e4be <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011e4be:	55                   	push   %ebp
f011e4bf:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011e4c1:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011e4c5:	7e 1c                	jle    f011e4e3 <getint+0x25>
		return va_arg(*ap, long long);
f011e4c7:	8b 45 08             	mov    0x8(%ebp),%eax
f011e4ca:	8b 00                	mov    (%eax),%eax
f011e4cc:	8d 50 08             	lea    0x8(%eax),%edx
f011e4cf:	8b 45 08             	mov    0x8(%ebp),%eax
f011e4d2:	89 10                	mov    %edx,(%eax)
f011e4d4:	8b 45 08             	mov    0x8(%ebp),%eax
f011e4d7:	8b 00                	mov    (%eax),%eax
f011e4d9:	83 e8 08             	sub    $0x8,%eax
f011e4dc:	8b 50 04             	mov    0x4(%eax),%edx
f011e4df:	8b 00                	mov    (%eax),%eax
f011e4e1:	eb 38                	jmp    f011e51b <getint+0x5d>
	else if (lflag)
f011e4e3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e4e7:	74 1a                	je     f011e503 <getint+0x45>
		return va_arg(*ap, long);
f011e4e9:	8b 45 08             	mov    0x8(%ebp),%eax
f011e4ec:	8b 00                	mov    (%eax),%eax
f011e4ee:	8d 50 04             	lea    0x4(%eax),%edx
f011e4f1:	8b 45 08             	mov    0x8(%ebp),%eax
f011e4f4:	89 10                	mov    %edx,(%eax)
f011e4f6:	8b 45 08             	mov    0x8(%ebp),%eax
f011e4f9:	8b 00                	mov    (%eax),%eax
f011e4fb:	83 e8 04             	sub    $0x4,%eax
f011e4fe:	8b 00                	mov    (%eax),%eax
f011e500:	99                   	cltd   
f011e501:	eb 18                	jmp    f011e51b <getint+0x5d>
	else
		return va_arg(*ap, int);
f011e503:	8b 45 08             	mov    0x8(%ebp),%eax
f011e506:	8b 00                	mov    (%eax),%eax
f011e508:	8d 50 04             	lea    0x4(%eax),%edx
f011e50b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e50e:	89 10                	mov    %edx,(%eax)
f011e510:	8b 45 08             	mov    0x8(%ebp),%eax
f011e513:	8b 00                	mov    (%eax),%eax
f011e515:	83 e8 04             	sub    $0x4,%eax
f011e518:	8b 00                	mov    (%eax),%eax
f011e51a:	99                   	cltd   
}
f011e51b:	5d                   	pop    %ebp
f011e51c:	c3                   	ret    

f011e51d <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011e51d:	55                   	push   %ebp
f011e51e:	89 e5                	mov    %esp,%ebp
f011e520:	56                   	push   %esi
f011e521:	53                   	push   %ebx
f011e522:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011e525:	eb 17                	jmp    f011e53e <vprintfmt+0x21>
			if (ch == '\0')
f011e527:	85 db                	test   %ebx,%ebx
f011e529:	0f 84 c1 03 00 00    	je     f011e8f0 <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011e52f:	83 ec 08             	sub    $0x8,%esp
f011e532:	ff 75 0c             	pushl  0xc(%ebp)
f011e535:	53                   	push   %ebx
f011e536:	8b 45 08             	mov    0x8(%ebp),%eax
f011e539:	ff d0                	call   *%eax
f011e53b:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011e53e:	8b 45 10             	mov    0x10(%ebp),%eax
f011e541:	8d 50 01             	lea    0x1(%eax),%edx
f011e544:	89 55 10             	mov    %edx,0x10(%ebp)
f011e547:	8a 00                	mov    (%eax),%al
f011e549:	0f b6 d8             	movzbl %al,%ebx
f011e54c:	83 fb 25             	cmp    $0x25,%ebx
f011e54f:	75 d6                	jne    f011e527 <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011e551:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011e555:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011e55c:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011e563:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011e56a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011e571:	8b 45 10             	mov    0x10(%ebp),%eax
f011e574:	8d 50 01             	lea    0x1(%eax),%edx
f011e577:	89 55 10             	mov    %edx,0x10(%ebp)
f011e57a:	8a 00                	mov    (%eax),%al
f011e57c:	0f b6 d8             	movzbl %al,%ebx
f011e57f:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011e582:	83 f8 5b             	cmp    $0x5b,%eax
f011e585:	0f 87 3d 03 00 00    	ja     f011e8c8 <vprintfmt+0x3ab>
f011e58b:	8b 04 85 38 fe 12 f0 	mov    -0xfed01c8(,%eax,4),%eax
f011e592:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011e594:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011e598:	eb d7                	jmp    f011e571 <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011e59a:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011e59e:	eb d1                	jmp    f011e571 <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011e5a0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011e5a7:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011e5aa:	89 d0                	mov    %edx,%eax
f011e5ac:	c1 e0 02             	shl    $0x2,%eax
f011e5af:	01 d0                	add    %edx,%eax
f011e5b1:	01 c0                	add    %eax,%eax
f011e5b3:	01 d8                	add    %ebx,%eax
f011e5b5:	83 e8 30             	sub    $0x30,%eax
f011e5b8:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011e5bb:	8b 45 10             	mov    0x10(%ebp),%eax
f011e5be:	8a 00                	mov    (%eax),%al
f011e5c0:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011e5c3:	83 fb 2f             	cmp    $0x2f,%ebx
f011e5c6:	7e 3e                	jle    f011e606 <vprintfmt+0xe9>
f011e5c8:	83 fb 39             	cmp    $0x39,%ebx
f011e5cb:	7f 39                	jg     f011e606 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011e5cd:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011e5d0:	eb d5                	jmp    f011e5a7 <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011e5d2:	8b 45 14             	mov    0x14(%ebp),%eax
f011e5d5:	83 c0 04             	add    $0x4,%eax
f011e5d8:	89 45 14             	mov    %eax,0x14(%ebp)
f011e5db:	8b 45 14             	mov    0x14(%ebp),%eax
f011e5de:	83 e8 04             	sub    $0x4,%eax
f011e5e1:	8b 00                	mov    (%eax),%eax
f011e5e3:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011e5e6:	eb 1f                	jmp    f011e607 <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011e5e8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e5ec:	79 83                	jns    f011e571 <vprintfmt+0x54>
				width = 0;
f011e5ee:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011e5f5:	e9 77 ff ff ff       	jmp    f011e571 <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011e5fa:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011e601:	e9 6b ff ff ff       	jmp    f011e571 <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011e606:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011e607:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e60b:	0f 89 60 ff ff ff    	jns    f011e571 <vprintfmt+0x54>
				width = precision, precision = -1;
f011e611:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e614:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011e617:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011e61e:	e9 4e ff ff ff       	jmp    f011e571 <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011e623:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011e626:	e9 46 ff ff ff       	jmp    f011e571 <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011e62b:	8b 45 14             	mov    0x14(%ebp),%eax
f011e62e:	83 c0 04             	add    $0x4,%eax
f011e631:	89 45 14             	mov    %eax,0x14(%ebp)
f011e634:	8b 45 14             	mov    0x14(%ebp),%eax
f011e637:	83 e8 04             	sub    $0x4,%eax
f011e63a:	8b 00                	mov    (%eax),%eax
f011e63c:	83 ec 08             	sub    $0x8,%esp
f011e63f:	ff 75 0c             	pushl  0xc(%ebp)
f011e642:	50                   	push   %eax
f011e643:	8b 45 08             	mov    0x8(%ebp),%eax
f011e646:	ff d0                	call   *%eax
f011e648:	83 c4 10             	add    $0x10,%esp
			break;
f011e64b:	e9 9b 02 00 00       	jmp    f011e8eb <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011e650:	8b 45 14             	mov    0x14(%ebp),%eax
f011e653:	83 c0 04             	add    $0x4,%eax
f011e656:	89 45 14             	mov    %eax,0x14(%ebp)
f011e659:	8b 45 14             	mov    0x14(%ebp),%eax
f011e65c:	83 e8 04             	sub    $0x4,%eax
f011e65f:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011e661:	85 db                	test   %ebx,%ebx
f011e663:	79 02                	jns    f011e667 <vprintfmt+0x14a>
				err = -err;
f011e665:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011e667:	83 fb 64             	cmp    $0x64,%ebx
f011e66a:	7f 0b                	jg     f011e677 <vprintfmt+0x15a>
f011e66c:	8b 34 9d 80 fc 12 f0 	mov    -0xfed0380(,%ebx,4),%esi
f011e673:	85 f6                	test   %esi,%esi
f011e675:	75 19                	jne    f011e690 <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011e677:	53                   	push   %ebx
f011e678:	68 25 fe 12 f0       	push   $0xf012fe25
f011e67d:	ff 75 0c             	pushl  0xc(%ebp)
f011e680:	ff 75 08             	pushl  0x8(%ebp)
f011e683:	e8 70 02 00 00       	call   f011e8f8 <printfmt>
f011e688:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011e68b:	e9 5b 02 00 00       	jmp    f011e8eb <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011e690:	56                   	push   %esi
f011e691:	68 2e fe 12 f0       	push   $0xf012fe2e
f011e696:	ff 75 0c             	pushl  0xc(%ebp)
f011e699:	ff 75 08             	pushl  0x8(%ebp)
f011e69c:	e8 57 02 00 00       	call   f011e8f8 <printfmt>
f011e6a1:	83 c4 10             	add    $0x10,%esp
			break;
f011e6a4:	e9 42 02 00 00       	jmp    f011e8eb <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011e6a9:	8b 45 14             	mov    0x14(%ebp),%eax
f011e6ac:	83 c0 04             	add    $0x4,%eax
f011e6af:	89 45 14             	mov    %eax,0x14(%ebp)
f011e6b2:	8b 45 14             	mov    0x14(%ebp),%eax
f011e6b5:	83 e8 04             	sub    $0x4,%eax
f011e6b8:	8b 30                	mov    (%eax),%esi
f011e6ba:	85 f6                	test   %esi,%esi
f011e6bc:	75 05                	jne    f011e6c3 <vprintfmt+0x1a6>
				p = "(null)";
f011e6be:	be 31 fe 12 f0       	mov    $0xf012fe31,%esi
			if (width > 0 && padc != '-')
f011e6c3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e6c7:	7e 6d                	jle    f011e736 <vprintfmt+0x219>
f011e6c9:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011e6cd:	74 67                	je     f011e736 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011e6cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011e6d2:	83 ec 08             	sub    $0x8,%esp
f011e6d5:	50                   	push   %eax
f011e6d6:	56                   	push   %esi
f011e6d7:	e8 26 05 00 00       	call   f011ec02 <strnlen>
f011e6dc:	83 c4 10             	add    $0x10,%esp
f011e6df:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011e6e2:	eb 16                	jmp    f011e6fa <vprintfmt+0x1dd>
					putch(padc, putdat);
f011e6e4:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011e6e8:	83 ec 08             	sub    $0x8,%esp
f011e6eb:	ff 75 0c             	pushl  0xc(%ebp)
f011e6ee:	50                   	push   %eax
f011e6ef:	8b 45 08             	mov    0x8(%ebp),%eax
f011e6f2:	ff d0                	call   *%eax
f011e6f4:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011e6f7:	ff 4d e4             	decl   -0x1c(%ebp)
f011e6fa:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e6fe:	7f e4                	jg     f011e6e4 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011e700:	eb 34                	jmp    f011e736 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011e702:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011e706:	74 1c                	je     f011e724 <vprintfmt+0x207>
f011e708:	83 fb 1f             	cmp    $0x1f,%ebx
f011e70b:	7e 05                	jle    f011e712 <vprintfmt+0x1f5>
f011e70d:	83 fb 7e             	cmp    $0x7e,%ebx
f011e710:	7e 12                	jle    f011e724 <vprintfmt+0x207>
					putch('?', putdat);
f011e712:	83 ec 08             	sub    $0x8,%esp
f011e715:	ff 75 0c             	pushl  0xc(%ebp)
f011e718:	6a 3f                	push   $0x3f
f011e71a:	8b 45 08             	mov    0x8(%ebp),%eax
f011e71d:	ff d0                	call   *%eax
f011e71f:	83 c4 10             	add    $0x10,%esp
f011e722:	eb 0f                	jmp    f011e733 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011e724:	83 ec 08             	sub    $0x8,%esp
f011e727:	ff 75 0c             	pushl  0xc(%ebp)
f011e72a:	53                   	push   %ebx
f011e72b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e72e:	ff d0                	call   *%eax
f011e730:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011e733:	ff 4d e4             	decl   -0x1c(%ebp)
f011e736:	89 f0                	mov    %esi,%eax
f011e738:	8d 70 01             	lea    0x1(%eax),%esi
f011e73b:	8a 00                	mov    (%eax),%al
f011e73d:	0f be d8             	movsbl %al,%ebx
f011e740:	85 db                	test   %ebx,%ebx
f011e742:	74 24                	je     f011e768 <vprintfmt+0x24b>
f011e744:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011e748:	78 b8                	js     f011e702 <vprintfmt+0x1e5>
f011e74a:	ff 4d e0             	decl   -0x20(%ebp)
f011e74d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011e751:	79 af                	jns    f011e702 <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011e753:	eb 13                	jmp    f011e768 <vprintfmt+0x24b>
				putch(' ', putdat);
f011e755:	83 ec 08             	sub    $0x8,%esp
f011e758:	ff 75 0c             	pushl  0xc(%ebp)
f011e75b:	6a 20                	push   $0x20
f011e75d:	8b 45 08             	mov    0x8(%ebp),%eax
f011e760:	ff d0                	call   *%eax
f011e762:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011e765:	ff 4d e4             	decl   -0x1c(%ebp)
f011e768:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e76c:	7f e7                	jg     f011e755 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011e76e:	e9 78 01 00 00       	jmp    f011e8eb <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011e773:	83 ec 08             	sub    $0x8,%esp
f011e776:	ff 75 e8             	pushl  -0x18(%ebp)
f011e779:	8d 45 14             	lea    0x14(%ebp),%eax
f011e77c:	50                   	push   %eax
f011e77d:	e8 3c fd ff ff       	call   f011e4be <getint>
f011e782:	83 c4 10             	add    $0x10,%esp
f011e785:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e788:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011e78b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e78e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e791:	85 d2                	test   %edx,%edx
f011e793:	79 23                	jns    f011e7b8 <vprintfmt+0x29b>
				putch('-', putdat);
f011e795:	83 ec 08             	sub    $0x8,%esp
f011e798:	ff 75 0c             	pushl  0xc(%ebp)
f011e79b:	6a 2d                	push   $0x2d
f011e79d:	8b 45 08             	mov    0x8(%ebp),%eax
f011e7a0:	ff d0                	call   *%eax
f011e7a2:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011e7a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e7a8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e7ab:	f7 d8                	neg    %eax
f011e7ad:	83 d2 00             	adc    $0x0,%edx
f011e7b0:	f7 da                	neg    %edx
f011e7b2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e7b5:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011e7b8:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011e7bf:	e9 bc 00 00 00       	jmp    f011e880 <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011e7c4:	83 ec 08             	sub    $0x8,%esp
f011e7c7:	ff 75 e8             	pushl  -0x18(%ebp)
f011e7ca:	8d 45 14             	lea    0x14(%ebp),%eax
f011e7cd:	50                   	push   %eax
f011e7ce:	e8 84 fc ff ff       	call   f011e457 <getuint>
f011e7d3:	83 c4 10             	add    $0x10,%esp
f011e7d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e7d9:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011e7dc:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011e7e3:	e9 98 00 00 00       	jmp    f011e880 <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011e7e8:	83 ec 08             	sub    $0x8,%esp
f011e7eb:	ff 75 0c             	pushl  0xc(%ebp)
f011e7ee:	6a 58                	push   $0x58
f011e7f0:	8b 45 08             	mov    0x8(%ebp),%eax
f011e7f3:	ff d0                	call   *%eax
f011e7f5:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011e7f8:	83 ec 08             	sub    $0x8,%esp
f011e7fb:	ff 75 0c             	pushl  0xc(%ebp)
f011e7fe:	6a 58                	push   $0x58
f011e800:	8b 45 08             	mov    0x8(%ebp),%eax
f011e803:	ff d0                	call   *%eax
f011e805:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011e808:	83 ec 08             	sub    $0x8,%esp
f011e80b:	ff 75 0c             	pushl  0xc(%ebp)
f011e80e:	6a 58                	push   $0x58
f011e810:	8b 45 08             	mov    0x8(%ebp),%eax
f011e813:	ff d0                	call   *%eax
f011e815:	83 c4 10             	add    $0x10,%esp
			break;
f011e818:	e9 ce 00 00 00       	jmp    f011e8eb <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011e81d:	83 ec 08             	sub    $0x8,%esp
f011e820:	ff 75 0c             	pushl  0xc(%ebp)
f011e823:	6a 30                	push   $0x30
f011e825:	8b 45 08             	mov    0x8(%ebp),%eax
f011e828:	ff d0                	call   *%eax
f011e82a:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011e82d:	83 ec 08             	sub    $0x8,%esp
f011e830:	ff 75 0c             	pushl  0xc(%ebp)
f011e833:	6a 78                	push   $0x78
f011e835:	8b 45 08             	mov    0x8(%ebp),%eax
f011e838:	ff d0                	call   *%eax
f011e83a:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011e83d:	8b 45 14             	mov    0x14(%ebp),%eax
f011e840:	83 c0 04             	add    $0x4,%eax
f011e843:	89 45 14             	mov    %eax,0x14(%ebp)
f011e846:	8b 45 14             	mov    0x14(%ebp),%eax
f011e849:	83 e8 04             	sub    $0x4,%eax
f011e84c:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011e84e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e851:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011e858:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011e85f:	eb 1f                	jmp    f011e880 <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011e861:	83 ec 08             	sub    $0x8,%esp
f011e864:	ff 75 e8             	pushl  -0x18(%ebp)
f011e867:	8d 45 14             	lea    0x14(%ebp),%eax
f011e86a:	50                   	push   %eax
f011e86b:	e8 e7 fb ff ff       	call   f011e457 <getuint>
f011e870:	83 c4 10             	add    $0x10,%esp
f011e873:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e876:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011e879:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011e880:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011e884:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e887:	83 ec 04             	sub    $0x4,%esp
f011e88a:	52                   	push   %edx
f011e88b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e88e:	50                   	push   %eax
f011e88f:	ff 75 f4             	pushl  -0xc(%ebp)
f011e892:	ff 75 f0             	pushl  -0x10(%ebp)
f011e895:	ff 75 0c             	pushl  0xc(%ebp)
f011e898:	ff 75 08             	pushl  0x8(%ebp)
f011e89b:	e8 00 fb ff ff       	call   f011e3a0 <printnum>
f011e8a0:	83 c4 20             	add    $0x20,%esp
			break;
f011e8a3:	eb 46                	jmp    f011e8eb <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011e8a5:	83 ec 08             	sub    $0x8,%esp
f011e8a8:	ff 75 0c             	pushl  0xc(%ebp)
f011e8ab:	53                   	push   %ebx
f011e8ac:	8b 45 08             	mov    0x8(%ebp),%eax
f011e8af:	ff d0                	call   *%eax
f011e8b1:	83 c4 10             	add    $0x10,%esp
			break;
f011e8b4:	eb 35                	jmp    f011e8eb <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011e8b6:	c6 05 40 c4 5e f0 00 	movb   $0x0,0xf05ec440
			break;
f011e8bd:	eb 2c                	jmp    f011e8eb <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011e8bf:	c6 05 40 c4 5e f0 01 	movb   $0x1,0xf05ec440
			break;
f011e8c6:	eb 23                	jmp    f011e8eb <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011e8c8:	83 ec 08             	sub    $0x8,%esp
f011e8cb:	ff 75 0c             	pushl  0xc(%ebp)
f011e8ce:	6a 25                	push   $0x25
f011e8d0:	8b 45 08             	mov    0x8(%ebp),%eax
f011e8d3:	ff d0                	call   *%eax
f011e8d5:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011e8d8:	ff 4d 10             	decl   0x10(%ebp)
f011e8db:	eb 03                	jmp    f011e8e0 <vprintfmt+0x3c3>
f011e8dd:	ff 4d 10             	decl   0x10(%ebp)
f011e8e0:	8b 45 10             	mov    0x10(%ebp),%eax
f011e8e3:	48                   	dec    %eax
f011e8e4:	8a 00                	mov    (%eax),%al
f011e8e6:	3c 25                	cmp    $0x25,%al
f011e8e8:	75 f3                	jne    f011e8dd <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011e8ea:	90                   	nop
		}
	}
f011e8eb:	e9 35 fc ff ff       	jmp    f011e525 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011e8f0:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011e8f1:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011e8f4:	5b                   	pop    %ebx
f011e8f5:	5e                   	pop    %esi
f011e8f6:	5d                   	pop    %ebp
f011e8f7:	c3                   	ret    

f011e8f8 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011e8f8:	55                   	push   %ebp
f011e8f9:	89 e5                	mov    %esp,%ebp
f011e8fb:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011e8fe:	8d 45 10             	lea    0x10(%ebp),%eax
f011e901:	83 c0 04             	add    $0x4,%eax
f011e904:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011e907:	8b 45 10             	mov    0x10(%ebp),%eax
f011e90a:	ff 75 f4             	pushl  -0xc(%ebp)
f011e90d:	50                   	push   %eax
f011e90e:	ff 75 0c             	pushl  0xc(%ebp)
f011e911:	ff 75 08             	pushl  0x8(%ebp)
f011e914:	e8 04 fc ff ff       	call   f011e51d <vprintfmt>
f011e919:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011e91c:	90                   	nop
f011e91d:	c9                   	leave  
f011e91e:	c3                   	ret    

f011e91f <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011e91f:	55                   	push   %ebp
f011e920:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011e922:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e925:	8b 40 08             	mov    0x8(%eax),%eax
f011e928:	8d 50 01             	lea    0x1(%eax),%edx
f011e92b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e92e:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011e931:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e934:	8b 10                	mov    (%eax),%edx
f011e936:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e939:	8b 40 04             	mov    0x4(%eax),%eax
f011e93c:	39 c2                	cmp    %eax,%edx
f011e93e:	73 12                	jae    f011e952 <sprintputch+0x33>
		*b->buf++ = ch;
f011e940:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e943:	8b 00                	mov    (%eax),%eax
f011e945:	8d 48 01             	lea    0x1(%eax),%ecx
f011e948:	8b 55 0c             	mov    0xc(%ebp),%edx
f011e94b:	89 0a                	mov    %ecx,(%edx)
f011e94d:	8b 55 08             	mov    0x8(%ebp),%edx
f011e950:	88 10                	mov    %dl,(%eax)
}
f011e952:	90                   	nop
f011e953:	5d                   	pop    %ebp
f011e954:	c3                   	ret    

f011e955 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011e955:	55                   	push   %ebp
f011e956:	89 e5                	mov    %esp,%ebp
f011e958:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011e95b:	8b 45 08             	mov    0x8(%ebp),%eax
f011e95e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011e961:	8b 45 0c             	mov    0xc(%ebp),%eax
f011e964:	8d 50 ff             	lea    -0x1(%eax),%edx
f011e967:	8b 45 08             	mov    0x8(%ebp),%eax
f011e96a:	01 d0                	add    %edx,%eax
f011e96c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e96f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011e976:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e97a:	74 06                	je     f011e982 <vsnprintf+0x2d>
f011e97c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011e980:	7f 07                	jg     f011e989 <vsnprintf+0x34>
		return -E_INVAL;
f011e982:	b8 03 00 00 00       	mov    $0x3,%eax
f011e987:	eb 20                	jmp    f011e9a9 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011e989:	ff 75 14             	pushl  0x14(%ebp)
f011e98c:	ff 75 10             	pushl  0x10(%ebp)
f011e98f:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011e992:	50                   	push   %eax
f011e993:	68 1f e9 11 f0       	push   $0xf011e91f
f011e998:	e8 80 fb ff ff       	call   f011e51d <vprintfmt>
f011e99d:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011e9a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e9a3:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011e9a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011e9a9:	c9                   	leave  
f011e9aa:	c3                   	ret    

f011e9ab <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011e9ab:	55                   	push   %ebp
f011e9ac:	89 e5                	mov    %esp,%ebp
f011e9ae:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011e9b1:	8d 45 10             	lea    0x10(%ebp),%eax
f011e9b4:	83 c0 04             	add    $0x4,%eax
f011e9b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011e9ba:	8b 45 10             	mov    0x10(%ebp),%eax
f011e9bd:	ff 75 f4             	pushl  -0xc(%ebp)
f011e9c0:	50                   	push   %eax
f011e9c1:	ff 75 0c             	pushl  0xc(%ebp)
f011e9c4:	ff 75 08             	pushl  0x8(%ebp)
f011e9c7:	e8 89 ff ff ff       	call   f011e955 <vsnprintf>
f011e9cc:	83 c4 10             	add    $0x10,%esp
f011e9cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011e9d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011e9d5:	c9                   	leave  
f011e9d6:	c3                   	ret    

f011e9d7 <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011e9d7:	55                   	push   %ebp
f011e9d8:	89 e5                	mov    %esp,%ebp
f011e9da:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011e9dd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011e9e1:	74 13                	je     f011e9f6 <readline+0x1f>
		cprintf("%s", prompt);
f011e9e3:	83 ec 08             	sub    $0x8,%esp
f011e9e6:	ff 75 08             	pushl  0x8(%ebp)
f011e9e9:	68 a8 ff 12 f0       	push   $0xf012ffa8
f011e9ee:	e8 98 25 fe ff       	call   f0100f8b <cprintf>
f011e9f3:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011e9f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011e9fd:	83 ec 0c             	sub    $0xc,%esp
f011ea00:	6a 00                	push   $0x0
f011ea02:	e8 91 24 fe ff       	call   f0100e98 <iscons>
f011ea07:	83 c4 10             	add    $0x10,%esp
f011ea0a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011ea0d:	e8 6d 24 fe ff       	call   f0100e7f <getchar>
f011ea12:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011ea15:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ea19:	79 22                	jns    f011ea3d <readline+0x66>
			if (c != -E_EOF)
f011ea1b:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011ea1f:	0f 84 ad 00 00 00    	je     f011ead2 <readline+0xfb>
				cprintf("read error: %e\n", c);
f011ea25:	83 ec 08             	sub    $0x8,%esp
f011ea28:	ff 75 ec             	pushl  -0x14(%ebp)
f011ea2b:	68 ab ff 12 f0       	push   $0xf012ffab
f011ea30:	e8 56 25 fe ff       	call   f0100f8b <cprintf>
f011ea35:	83 c4 10             	add    $0x10,%esp
			break;
f011ea38:	e9 95 00 00 00       	jmp    f011ead2 <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011ea3d:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011ea41:	7e 34                	jle    f011ea77 <readline+0xa0>
f011ea43:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011ea4a:	7f 2b                	jg     f011ea77 <readline+0xa0>
			if (echoing)
f011ea4c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ea50:	74 0e                	je     f011ea60 <readline+0x89>
				cputchar(c);
f011ea52:	83 ec 0c             	sub    $0xc,%esp
f011ea55:	ff 75 ec             	pushl  -0x14(%ebp)
f011ea58:	e8 0b 24 fe ff       	call   f0100e68 <cputchar>
f011ea5d:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011ea60:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ea63:	8d 50 01             	lea    0x1(%eax),%edx
f011ea66:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011ea69:	89 c2                	mov    %eax,%edx
f011ea6b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ea6e:	01 d0                	add    %edx,%eax
f011ea70:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ea73:	88 10                	mov    %dl,(%eax)
f011ea75:	eb 56                	jmp    f011eacd <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011ea77:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011ea7b:	75 1f                	jne    f011ea9c <readline+0xc5>
f011ea7d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ea81:	7e 19                	jle    f011ea9c <readline+0xc5>
			if (echoing)
f011ea83:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ea87:	74 0e                	je     f011ea97 <readline+0xc0>
				cputchar(c);
f011ea89:	83 ec 0c             	sub    $0xc,%esp
f011ea8c:	ff 75 ec             	pushl  -0x14(%ebp)
f011ea8f:	e8 d4 23 fe ff       	call   f0100e68 <cputchar>
f011ea94:	83 c4 10             	add    $0x10,%esp

			i--;
f011ea97:	ff 4d f4             	decl   -0xc(%ebp)
f011ea9a:	eb 31                	jmp    f011eacd <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011ea9c:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011eaa0:	74 0a                	je     f011eaac <readline+0xd5>
f011eaa2:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011eaa6:	0f 85 61 ff ff ff    	jne    f011ea0d <readline+0x36>
			if (echoing)
f011eaac:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011eab0:	74 0e                	je     f011eac0 <readline+0xe9>
				cputchar(c);
f011eab2:	83 ec 0c             	sub    $0xc,%esp
f011eab5:	ff 75 ec             	pushl  -0x14(%ebp)
f011eab8:	e8 ab 23 fe ff       	call   f0100e68 <cputchar>
f011eabd:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011eac0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011eac3:	8b 45 0c             	mov    0xc(%ebp),%eax
f011eac6:	01 d0                	add    %edx,%eax
f011eac8:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011eacb:	eb 06                	jmp    f011ead3 <readline+0xfc>
		}
	}
f011eacd:	e9 3b ff ff ff       	jmp    f011ea0d <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011ead2:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011ead3:	90                   	nop
f011ead4:	c9                   	leave  
f011ead5:	c3                   	ret    

f011ead6 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011ead6:	55                   	push   %ebp
f011ead7:	89 e5                	mov    %esp,%ebp
f011ead9:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011eadc:	e8 03 ee fe ff       	call   f010d8e4 <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011eae1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011eae5:	74 13                	je     f011eafa <atomic_readline+0x24>
			cprintf("%s", prompt);
f011eae7:	83 ec 08             	sub    $0x8,%esp
f011eaea:	ff 75 08             	pushl  0x8(%ebp)
f011eaed:	68 a8 ff 12 f0       	push   $0xf012ffa8
f011eaf2:	e8 94 24 fe ff       	call   f0100f8b <cprintf>
f011eaf7:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011eafa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011eb01:	83 ec 0c             	sub    $0xc,%esp
f011eb04:	6a 00                	push   $0x0
f011eb06:	e8 8d 23 fe ff       	call   f0100e98 <iscons>
f011eb0b:	83 c4 10             	add    $0x10,%esp
f011eb0e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011eb11:	e8 69 23 fe ff       	call   f0100e7f <getchar>
f011eb16:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011eb19:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011eb1d:	79 22                	jns    f011eb41 <atomic_readline+0x6b>
				if (c != -E_EOF)
f011eb1f:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011eb23:	0f 84 ad 00 00 00    	je     f011ebd6 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011eb29:	83 ec 08             	sub    $0x8,%esp
f011eb2c:	ff 75 ec             	pushl  -0x14(%ebp)
f011eb2f:	68 ab ff 12 f0       	push   $0xf012ffab
f011eb34:	e8 52 24 fe ff       	call   f0100f8b <cprintf>
f011eb39:	83 c4 10             	add    $0x10,%esp
				break;
f011eb3c:	e9 95 00 00 00       	jmp    f011ebd6 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011eb41:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011eb45:	7e 34                	jle    f011eb7b <atomic_readline+0xa5>
f011eb47:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011eb4e:	7f 2b                	jg     f011eb7b <atomic_readline+0xa5>
				if (echoing)
f011eb50:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011eb54:	74 0e                	je     f011eb64 <atomic_readline+0x8e>
					cputchar(c);
f011eb56:	83 ec 0c             	sub    $0xc,%esp
f011eb59:	ff 75 ec             	pushl  -0x14(%ebp)
f011eb5c:	e8 07 23 fe ff       	call   f0100e68 <cputchar>
f011eb61:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011eb64:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011eb67:	8d 50 01             	lea    0x1(%eax),%edx
f011eb6a:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011eb6d:	89 c2                	mov    %eax,%edx
f011eb6f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011eb72:	01 d0                	add    %edx,%eax
f011eb74:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011eb77:	88 10                	mov    %dl,(%eax)
f011eb79:	eb 56                	jmp    f011ebd1 <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011eb7b:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011eb7f:	75 1f                	jne    f011eba0 <atomic_readline+0xca>
f011eb81:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011eb85:	7e 19                	jle    f011eba0 <atomic_readline+0xca>
				if (echoing)
f011eb87:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011eb8b:	74 0e                	je     f011eb9b <atomic_readline+0xc5>
					cputchar(c);
f011eb8d:	83 ec 0c             	sub    $0xc,%esp
f011eb90:	ff 75 ec             	pushl  -0x14(%ebp)
f011eb93:	e8 d0 22 fe ff       	call   f0100e68 <cputchar>
f011eb98:	83 c4 10             	add    $0x10,%esp
				i--;
f011eb9b:	ff 4d f4             	decl   -0xc(%ebp)
f011eb9e:	eb 31                	jmp    f011ebd1 <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011eba0:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011eba4:	74 0a                	je     f011ebb0 <atomic_readline+0xda>
f011eba6:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011ebaa:	0f 85 61 ff ff ff    	jne    f011eb11 <atomic_readline+0x3b>
				if (echoing)
f011ebb0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ebb4:	74 0e                	je     f011ebc4 <atomic_readline+0xee>
					cputchar(c);
f011ebb6:	83 ec 0c             	sub    $0xc,%esp
f011ebb9:	ff 75 ec             	pushl  -0x14(%ebp)
f011ebbc:	e8 a7 22 fe ff       	call   f0100e68 <cputchar>
f011ebc1:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f011ebc4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ebc7:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ebca:	01 d0                	add    %edx,%eax
f011ebcc:	c6 00 00             	movb   $0x0,(%eax)
				break;
f011ebcf:	eb 06                	jmp    f011ebd7 <atomic_readline+0x101>
			}
		}
f011ebd1:	e9 3b ff ff ff       	jmp    f011eb11 <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f011ebd6:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f011ebd7:	e8 16 ed fe ff       	call   f010d8f2 <sys_unlock_cons>
}
f011ebdc:	90                   	nop
f011ebdd:	c9                   	leave  
f011ebde:	c3                   	ret    

f011ebdf <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f011ebdf:	55                   	push   %ebp
f011ebe0:	89 e5                	mov    %esp,%ebp
f011ebe2:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f011ebe5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011ebec:	eb 06                	jmp    f011ebf4 <strlen+0x15>
		n++;
f011ebee:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f011ebf1:	ff 45 08             	incl   0x8(%ebp)
f011ebf4:	8b 45 08             	mov    0x8(%ebp),%eax
f011ebf7:	8a 00                	mov    (%eax),%al
f011ebf9:	84 c0                	test   %al,%al
f011ebfb:	75 f1                	jne    f011ebee <strlen+0xf>
		n++;
	return n;
f011ebfd:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011ec00:	c9                   	leave  
f011ec01:	c3                   	ret    

f011ec02 <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f011ec02:	55                   	push   %ebp
f011ec03:	89 e5                	mov    %esp,%ebp
f011ec05:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011ec08:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011ec0f:	eb 09                	jmp    f011ec1a <strnlen+0x18>
		n++;
f011ec11:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011ec14:	ff 45 08             	incl   0x8(%ebp)
f011ec17:	ff 4d 0c             	decl   0xc(%ebp)
f011ec1a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011ec1e:	74 09                	je     f011ec29 <strnlen+0x27>
f011ec20:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec23:	8a 00                	mov    (%eax),%al
f011ec25:	84 c0                	test   %al,%al
f011ec27:	75 e8                	jne    f011ec11 <strnlen+0xf>
		n++;
	return n;
f011ec29:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011ec2c:	c9                   	leave  
f011ec2d:	c3                   	ret    

f011ec2e <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f011ec2e:	55                   	push   %ebp
f011ec2f:	89 e5                	mov    %esp,%ebp
f011ec31:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f011ec34:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec37:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f011ec3a:	90                   	nop
f011ec3b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec3e:	8d 50 01             	lea    0x1(%eax),%edx
f011ec41:	89 55 08             	mov    %edx,0x8(%ebp)
f011ec44:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ec47:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ec4a:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011ec4d:	8a 12                	mov    (%edx),%dl
f011ec4f:	88 10                	mov    %dl,(%eax)
f011ec51:	8a 00                	mov    (%eax),%al
f011ec53:	84 c0                	test   %al,%al
f011ec55:	75 e4                	jne    f011ec3b <strcpy+0xd>
		/* do nothing */;
	return ret;
f011ec57:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011ec5a:	c9                   	leave  
f011ec5b:	c3                   	ret    

f011ec5c <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f011ec5c:	55                   	push   %ebp
f011ec5d:	89 e5                	mov    %esp,%ebp
f011ec5f:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f011ec62:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec65:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f011ec68:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011ec6f:	eb 1f                	jmp    f011ec90 <strncpy+0x34>
		*dst++ = *src;
f011ec71:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec74:	8d 50 01             	lea    0x1(%eax),%edx
f011ec77:	89 55 08             	mov    %edx,0x8(%ebp)
f011ec7a:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ec7d:	8a 12                	mov    (%edx),%dl
f011ec7f:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f011ec81:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ec84:	8a 00                	mov    (%eax),%al
f011ec86:	84 c0                	test   %al,%al
f011ec88:	74 03                	je     f011ec8d <strncpy+0x31>
			src++;
f011ec8a:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f011ec8d:	ff 45 fc             	incl   -0x4(%ebp)
f011ec90:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ec93:	3b 45 10             	cmp    0x10(%ebp),%eax
f011ec96:	72 d9                	jb     f011ec71 <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f011ec98:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011ec9b:	c9                   	leave  
f011ec9c:	c3                   	ret    

f011ec9d <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f011ec9d:	55                   	push   %ebp
f011ec9e:	89 e5                	mov    %esp,%ebp
f011eca0:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f011eca3:	8b 45 08             	mov    0x8(%ebp),%eax
f011eca6:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f011eca9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ecad:	74 30                	je     f011ecdf <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f011ecaf:	eb 16                	jmp    f011ecc7 <strlcpy+0x2a>
			*dst++ = *src++;
f011ecb1:	8b 45 08             	mov    0x8(%ebp),%eax
f011ecb4:	8d 50 01             	lea    0x1(%eax),%edx
f011ecb7:	89 55 08             	mov    %edx,0x8(%ebp)
f011ecba:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ecbd:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ecc0:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011ecc3:	8a 12                	mov    (%edx),%dl
f011ecc5:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f011ecc7:	ff 4d 10             	decl   0x10(%ebp)
f011ecca:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ecce:	74 09                	je     f011ecd9 <strlcpy+0x3c>
f011ecd0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ecd3:	8a 00                	mov    (%eax),%al
f011ecd5:	84 c0                	test   %al,%al
f011ecd7:	75 d8                	jne    f011ecb1 <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f011ecd9:	8b 45 08             	mov    0x8(%ebp),%eax
f011ecdc:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f011ecdf:	8b 55 08             	mov    0x8(%ebp),%edx
f011ece2:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ece5:	29 c2                	sub    %eax,%edx
f011ece7:	89 d0                	mov    %edx,%eax
}
f011ece9:	c9                   	leave  
f011ecea:	c3                   	ret    

f011eceb <strcmp>:

int
strcmp(const char *p, const char *q)
{
f011eceb:	55                   	push   %ebp
f011ecec:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f011ecee:	eb 06                	jmp    f011ecf6 <strcmp+0xb>
		p++, q++;
f011ecf0:	ff 45 08             	incl   0x8(%ebp)
f011ecf3:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f011ecf6:	8b 45 08             	mov    0x8(%ebp),%eax
f011ecf9:	8a 00                	mov    (%eax),%al
f011ecfb:	84 c0                	test   %al,%al
f011ecfd:	74 0e                	je     f011ed0d <strcmp+0x22>
f011ecff:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed02:	8a 10                	mov    (%eax),%dl
f011ed04:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed07:	8a 00                	mov    (%eax),%al
f011ed09:	38 c2                	cmp    %al,%dl
f011ed0b:	74 e3                	je     f011ecf0 <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f011ed0d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed10:	8a 00                	mov    (%eax),%al
f011ed12:	0f b6 d0             	movzbl %al,%edx
f011ed15:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed18:	8a 00                	mov    (%eax),%al
f011ed1a:	0f b6 c0             	movzbl %al,%eax
f011ed1d:	29 c2                	sub    %eax,%edx
f011ed1f:	89 d0                	mov    %edx,%eax
}
f011ed21:	5d                   	pop    %ebp
f011ed22:	c3                   	ret    

f011ed23 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f011ed23:	55                   	push   %ebp
f011ed24:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f011ed26:	eb 09                	jmp    f011ed31 <strncmp+0xe>
		n--, p++, q++;
f011ed28:	ff 4d 10             	decl   0x10(%ebp)
f011ed2b:	ff 45 08             	incl   0x8(%ebp)
f011ed2e:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f011ed31:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ed35:	74 17                	je     f011ed4e <strncmp+0x2b>
f011ed37:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed3a:	8a 00                	mov    (%eax),%al
f011ed3c:	84 c0                	test   %al,%al
f011ed3e:	74 0e                	je     f011ed4e <strncmp+0x2b>
f011ed40:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed43:	8a 10                	mov    (%eax),%dl
f011ed45:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed48:	8a 00                	mov    (%eax),%al
f011ed4a:	38 c2                	cmp    %al,%dl
f011ed4c:	74 da                	je     f011ed28 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f011ed4e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ed52:	75 07                	jne    f011ed5b <strncmp+0x38>
		return 0;
f011ed54:	b8 00 00 00 00       	mov    $0x0,%eax
f011ed59:	eb 14                	jmp    f011ed6f <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f011ed5b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed5e:	8a 00                	mov    (%eax),%al
f011ed60:	0f b6 d0             	movzbl %al,%edx
f011ed63:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed66:	8a 00                	mov    (%eax),%al
f011ed68:	0f b6 c0             	movzbl %al,%eax
f011ed6b:	29 c2                	sub    %eax,%edx
f011ed6d:	89 d0                	mov    %edx,%eax
}
f011ed6f:	5d                   	pop    %ebp
f011ed70:	c3                   	ret    

f011ed71 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f011ed71:	55                   	push   %ebp
f011ed72:	89 e5                	mov    %esp,%ebp
f011ed74:	83 ec 04             	sub    $0x4,%esp
f011ed77:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ed7a:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011ed7d:	eb 12                	jmp    f011ed91 <strchr+0x20>
		if (*s == c)
f011ed7f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed82:	8a 00                	mov    (%eax),%al
f011ed84:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011ed87:	75 05                	jne    f011ed8e <strchr+0x1d>
			return (char *) s;
f011ed89:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed8c:	eb 11                	jmp    f011ed9f <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f011ed8e:	ff 45 08             	incl   0x8(%ebp)
f011ed91:	8b 45 08             	mov    0x8(%ebp),%eax
f011ed94:	8a 00                	mov    (%eax),%al
f011ed96:	84 c0                	test   %al,%al
f011ed98:	75 e5                	jne    f011ed7f <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f011ed9a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011ed9f:	c9                   	leave  
f011eda0:	c3                   	ret    

f011eda1 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f011eda1:	55                   	push   %ebp
f011eda2:	89 e5                	mov    %esp,%ebp
f011eda4:	83 ec 04             	sub    $0x4,%esp
f011eda7:	8b 45 0c             	mov    0xc(%ebp),%eax
f011edaa:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011edad:	eb 0d                	jmp    f011edbc <strfind+0x1b>
		if (*s == c)
f011edaf:	8b 45 08             	mov    0x8(%ebp),%eax
f011edb2:	8a 00                	mov    (%eax),%al
f011edb4:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011edb7:	74 0e                	je     f011edc7 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f011edb9:	ff 45 08             	incl   0x8(%ebp)
f011edbc:	8b 45 08             	mov    0x8(%ebp),%eax
f011edbf:	8a 00                	mov    (%eax),%al
f011edc1:	84 c0                	test   %al,%al
f011edc3:	75 ea                	jne    f011edaf <strfind+0xe>
f011edc5:	eb 01                	jmp    f011edc8 <strfind+0x27>
		if (*s == c)
			break;
f011edc7:	90                   	nop
	return (char *) s;
f011edc8:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011edcb:	c9                   	leave  
f011edcc:	c3                   	ret    

f011edcd <memset>:


void *
memset(void *v, int c, uint32 n)
{
f011edcd:	55                   	push   %ebp
f011edce:	89 e5                	mov    %esp,%ebp
f011edd0:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f011edd3:	8b 45 08             	mov    0x8(%ebp),%eax
f011edd6:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f011edd9:	8b 45 10             	mov    0x10(%ebp),%eax
f011eddc:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f011eddf:	eb 0e                	jmp    f011edef <memset+0x22>
		*p++ = c;
f011ede1:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ede4:	8d 50 01             	lea    0x1(%eax),%edx
f011ede7:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011edea:	8b 55 0c             	mov    0xc(%ebp),%edx
f011eded:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f011edef:	ff 4d f8             	decl   -0x8(%ebp)
f011edf2:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f011edf6:	79 e9                	jns    f011ede1 <memset+0x14>
		*p++ = c;

	return v;
f011edf8:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011edfb:	c9                   	leave  
f011edfc:	c3                   	ret    

f011edfd <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f011edfd:	55                   	push   %ebp
f011edfe:	89 e5                	mov    %esp,%ebp
f011ee00:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011ee03:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ee06:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011ee09:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee0c:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f011ee0f:	eb 16                	jmp    f011ee27 <memcpy+0x2a>
		*d++ = *s++;
f011ee11:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ee14:	8d 50 01             	lea    0x1(%eax),%edx
f011ee17:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011ee1a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ee1d:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ee20:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011ee23:	8a 12                	mov    (%edx),%dl
f011ee25:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f011ee27:	8b 45 10             	mov    0x10(%ebp),%eax
f011ee2a:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ee2d:	89 55 10             	mov    %edx,0x10(%ebp)
f011ee30:	85 c0                	test   %eax,%eax
f011ee32:	75 dd                	jne    f011ee11 <memcpy+0x14>
		*d++ = *s++;

	return dst;
f011ee34:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ee37:	c9                   	leave  
f011ee38:	c3                   	ret    

f011ee39 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f011ee39:	55                   	push   %ebp
f011ee3a:	89 e5                	mov    %esp,%ebp
f011ee3c:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011ee3f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ee42:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011ee45:	8b 45 08             	mov    0x8(%ebp),%eax
f011ee48:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f011ee4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ee4e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011ee51:	73 50                	jae    f011eea3 <memmove+0x6a>
f011ee53:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ee56:	8b 45 10             	mov    0x10(%ebp),%eax
f011ee59:	01 d0                	add    %edx,%eax
f011ee5b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011ee5e:	76 43                	jbe    f011eea3 <memmove+0x6a>
		s += n;
f011ee60:	8b 45 10             	mov    0x10(%ebp),%eax
f011ee63:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f011ee66:	8b 45 10             	mov    0x10(%ebp),%eax
f011ee69:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f011ee6c:	eb 10                	jmp    f011ee7e <memmove+0x45>
			*--d = *--s;
f011ee6e:	ff 4d f8             	decl   -0x8(%ebp)
f011ee71:	ff 4d fc             	decl   -0x4(%ebp)
f011ee74:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ee77:	8a 10                	mov    (%eax),%dl
f011ee79:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ee7c:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f011ee7e:	8b 45 10             	mov    0x10(%ebp),%eax
f011ee81:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ee84:	89 55 10             	mov    %edx,0x10(%ebp)
f011ee87:	85 c0                	test   %eax,%eax
f011ee89:	75 e3                	jne    f011ee6e <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f011ee8b:	eb 23                	jmp    f011eeb0 <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f011ee8d:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ee90:	8d 50 01             	lea    0x1(%eax),%edx
f011ee93:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011ee96:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ee99:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ee9c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011ee9f:	8a 12                	mov    (%edx),%dl
f011eea1:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f011eea3:	8b 45 10             	mov    0x10(%ebp),%eax
f011eea6:	8d 50 ff             	lea    -0x1(%eax),%edx
f011eea9:	89 55 10             	mov    %edx,0x10(%ebp)
f011eeac:	85 c0                	test   %eax,%eax
f011eeae:	75 dd                	jne    f011ee8d <memmove+0x54>
			*d++ = *s++;

	return dst;
f011eeb0:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011eeb3:	c9                   	leave  
f011eeb4:	c3                   	ret    

f011eeb5 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f011eeb5:	55                   	push   %ebp
f011eeb6:	89 e5                	mov    %esp,%ebp
f011eeb8:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f011eebb:	8b 45 08             	mov    0x8(%ebp),%eax
f011eebe:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f011eec1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011eec4:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f011eec7:	eb 2a                	jmp    f011eef3 <memcmp+0x3e>
		if (*s1 != *s2)
f011eec9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011eecc:	8a 10                	mov    (%eax),%dl
f011eece:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011eed1:	8a 00                	mov    (%eax),%al
f011eed3:	38 c2                	cmp    %al,%dl
f011eed5:	74 16                	je     f011eeed <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f011eed7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011eeda:	8a 00                	mov    (%eax),%al
f011eedc:	0f b6 d0             	movzbl %al,%edx
f011eedf:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011eee2:	8a 00                	mov    (%eax),%al
f011eee4:	0f b6 c0             	movzbl %al,%eax
f011eee7:	29 c2                	sub    %eax,%edx
f011eee9:	89 d0                	mov    %edx,%eax
f011eeeb:	eb 18                	jmp    f011ef05 <memcmp+0x50>
		s1++, s2++;
f011eeed:	ff 45 fc             	incl   -0x4(%ebp)
f011eef0:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f011eef3:	8b 45 10             	mov    0x10(%ebp),%eax
f011eef6:	8d 50 ff             	lea    -0x1(%eax),%edx
f011eef9:	89 55 10             	mov    %edx,0x10(%ebp)
f011eefc:	85 c0                	test   %eax,%eax
f011eefe:	75 c9                	jne    f011eec9 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f011ef00:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011ef05:	c9                   	leave  
f011ef06:	c3                   	ret    

f011ef07 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f011ef07:	55                   	push   %ebp
f011ef08:	89 e5                	mov    %esp,%ebp
f011ef0a:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f011ef0d:	8b 55 08             	mov    0x8(%ebp),%edx
f011ef10:	8b 45 10             	mov    0x10(%ebp),%eax
f011ef13:	01 d0                	add    %edx,%eax
f011ef15:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f011ef18:	eb 15                	jmp    f011ef2f <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f011ef1a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef1d:	8a 00                	mov    (%eax),%al
f011ef1f:	0f b6 d0             	movzbl %al,%edx
f011ef22:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ef25:	0f b6 c0             	movzbl %al,%eax
f011ef28:	39 c2                	cmp    %eax,%edx
f011ef2a:	74 0d                	je     f011ef39 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f011ef2c:	ff 45 08             	incl   0x8(%ebp)
f011ef2f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef32:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011ef35:	72 e3                	jb     f011ef1a <memfind+0x13>
f011ef37:	eb 01                	jmp    f011ef3a <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f011ef39:	90                   	nop
	return (void *) s;
f011ef3a:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ef3d:	c9                   	leave  
f011ef3e:	c3                   	ret    

f011ef3f <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f011ef3f:	55                   	push   %ebp
f011ef40:	89 e5                	mov    %esp,%ebp
f011ef42:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f011ef45:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f011ef4c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011ef53:	eb 03                	jmp    f011ef58 <strtol+0x19>
		s++;
f011ef55:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011ef58:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef5b:	8a 00                	mov    (%eax),%al
f011ef5d:	3c 20                	cmp    $0x20,%al
f011ef5f:	74 f4                	je     f011ef55 <strtol+0x16>
f011ef61:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef64:	8a 00                	mov    (%eax),%al
f011ef66:	3c 09                	cmp    $0x9,%al
f011ef68:	74 eb                	je     f011ef55 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f011ef6a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef6d:	8a 00                	mov    (%eax),%al
f011ef6f:	3c 2b                	cmp    $0x2b,%al
f011ef71:	75 05                	jne    f011ef78 <strtol+0x39>
		s++;
f011ef73:	ff 45 08             	incl   0x8(%ebp)
f011ef76:	eb 13                	jmp    f011ef8b <strtol+0x4c>
	else if (*s == '-')
f011ef78:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef7b:	8a 00                	mov    (%eax),%al
f011ef7d:	3c 2d                	cmp    $0x2d,%al
f011ef7f:	75 0a                	jne    f011ef8b <strtol+0x4c>
		s++, neg = 1;
f011ef81:	ff 45 08             	incl   0x8(%ebp)
f011ef84:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f011ef8b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ef8f:	74 06                	je     f011ef97 <strtol+0x58>
f011ef91:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f011ef95:	75 20                	jne    f011efb7 <strtol+0x78>
f011ef97:	8b 45 08             	mov    0x8(%ebp),%eax
f011ef9a:	8a 00                	mov    (%eax),%al
f011ef9c:	3c 30                	cmp    $0x30,%al
f011ef9e:	75 17                	jne    f011efb7 <strtol+0x78>
f011efa0:	8b 45 08             	mov    0x8(%ebp),%eax
f011efa3:	40                   	inc    %eax
f011efa4:	8a 00                	mov    (%eax),%al
f011efa6:	3c 78                	cmp    $0x78,%al
f011efa8:	75 0d                	jne    f011efb7 <strtol+0x78>
		s += 2, base = 16;
f011efaa:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f011efae:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f011efb5:	eb 28                	jmp    f011efdf <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f011efb7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011efbb:	75 15                	jne    f011efd2 <strtol+0x93>
f011efbd:	8b 45 08             	mov    0x8(%ebp),%eax
f011efc0:	8a 00                	mov    (%eax),%al
f011efc2:	3c 30                	cmp    $0x30,%al
f011efc4:	75 0c                	jne    f011efd2 <strtol+0x93>
		s++, base = 8;
f011efc6:	ff 45 08             	incl   0x8(%ebp)
f011efc9:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f011efd0:	eb 0d                	jmp    f011efdf <strtol+0xa0>
	else if (base == 0)
f011efd2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011efd6:	75 07                	jne    f011efdf <strtol+0xa0>
		base = 10;
f011efd8:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f011efdf:	8b 45 08             	mov    0x8(%ebp),%eax
f011efe2:	8a 00                	mov    (%eax),%al
f011efe4:	3c 2f                	cmp    $0x2f,%al
f011efe6:	7e 19                	jle    f011f001 <strtol+0xc2>
f011efe8:	8b 45 08             	mov    0x8(%ebp),%eax
f011efeb:	8a 00                	mov    (%eax),%al
f011efed:	3c 39                	cmp    $0x39,%al
f011efef:	7f 10                	jg     f011f001 <strtol+0xc2>
			dig = *s - '0';
f011eff1:	8b 45 08             	mov    0x8(%ebp),%eax
f011eff4:	8a 00                	mov    (%eax),%al
f011eff6:	0f be c0             	movsbl %al,%eax
f011eff9:	83 e8 30             	sub    $0x30,%eax
f011effc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011efff:	eb 42                	jmp    f011f043 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f011f001:	8b 45 08             	mov    0x8(%ebp),%eax
f011f004:	8a 00                	mov    (%eax),%al
f011f006:	3c 60                	cmp    $0x60,%al
f011f008:	7e 19                	jle    f011f023 <strtol+0xe4>
f011f00a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f00d:	8a 00                	mov    (%eax),%al
f011f00f:	3c 7a                	cmp    $0x7a,%al
f011f011:	7f 10                	jg     f011f023 <strtol+0xe4>
			dig = *s - 'a' + 10;
f011f013:	8b 45 08             	mov    0x8(%ebp),%eax
f011f016:	8a 00                	mov    (%eax),%al
f011f018:	0f be c0             	movsbl %al,%eax
f011f01b:	83 e8 57             	sub    $0x57,%eax
f011f01e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f021:	eb 20                	jmp    f011f043 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f011f023:	8b 45 08             	mov    0x8(%ebp),%eax
f011f026:	8a 00                	mov    (%eax),%al
f011f028:	3c 40                	cmp    $0x40,%al
f011f02a:	7e 39                	jle    f011f065 <strtol+0x126>
f011f02c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f02f:	8a 00                	mov    (%eax),%al
f011f031:	3c 5a                	cmp    $0x5a,%al
f011f033:	7f 30                	jg     f011f065 <strtol+0x126>
			dig = *s - 'A' + 10;
f011f035:	8b 45 08             	mov    0x8(%ebp),%eax
f011f038:	8a 00                	mov    (%eax),%al
f011f03a:	0f be c0             	movsbl %al,%eax
f011f03d:	83 e8 37             	sub    $0x37,%eax
f011f040:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f011f043:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f046:	3b 45 10             	cmp    0x10(%ebp),%eax
f011f049:	7d 19                	jge    f011f064 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f011f04b:	ff 45 08             	incl   0x8(%ebp)
f011f04e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f051:	0f af 45 10          	imul   0x10(%ebp),%eax
f011f055:	89 c2                	mov    %eax,%edx
f011f057:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f05a:	01 d0                	add    %edx,%eax
f011f05c:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f011f05f:	e9 7b ff ff ff       	jmp    f011efdf <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f011f064:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f011f065:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f069:	74 08                	je     f011f073 <strtol+0x134>
		*endptr = (char *) s;
f011f06b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f06e:	8b 55 08             	mov    0x8(%ebp),%edx
f011f071:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f011f073:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011f077:	74 07                	je     f011f080 <strtol+0x141>
f011f079:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f07c:	f7 d8                	neg    %eax
f011f07e:	eb 03                	jmp    f011f083 <strtol+0x144>
f011f080:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011f083:	c9                   	leave  
f011f084:	c3                   	ret    

f011f085 <ltostr>:

void
ltostr(long value, char *str)
{
f011f085:	55                   	push   %ebp
f011f086:	89 e5                	mov    %esp,%ebp
f011f088:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f011f08b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f011f092:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f011f099:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f09d:	79 13                	jns    f011f0b2 <ltostr+0x2d>
	{
		neg = 1;
f011f09f:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f011f0a6:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f0a9:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f011f0ac:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f011f0af:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f011f0b2:	8b 45 08             	mov    0x8(%ebp),%eax
f011f0b5:	b9 0a 00 00 00       	mov    $0xa,%ecx
f011f0ba:	99                   	cltd   
f011f0bb:	f7 f9                	idiv   %ecx
f011f0bd:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f011f0c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f0c3:	8d 50 01             	lea    0x1(%eax),%edx
f011f0c6:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011f0c9:	89 c2                	mov    %eax,%edx
f011f0cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f0ce:	01 d0                	add    %edx,%eax
f011f0d0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f0d3:	83 c2 30             	add    $0x30,%edx
f011f0d6:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f011f0d8:	8b 4d 08             	mov    0x8(%ebp),%ecx
f011f0db:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011f0e0:	f7 e9                	imul   %ecx
f011f0e2:	c1 fa 02             	sar    $0x2,%edx
f011f0e5:	89 c8                	mov    %ecx,%eax
f011f0e7:	c1 f8 1f             	sar    $0x1f,%eax
f011f0ea:	29 c2                	sub    %eax,%edx
f011f0ec:	89 d0                	mov    %edx,%eax
f011f0ee:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f011f0f1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f0f5:	75 bb                	jne    f011f0b2 <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f011f0f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f011f0fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f101:	48                   	dec    %eax
f011f102:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f011f105:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011f109:	74 3d                	je     f011f148 <ltostr+0xc3>
		start = 1 ;
f011f10b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f011f112:	eb 34                	jmp    f011f148 <ltostr+0xc3>
	{
		char tmp = str[start] ;
f011f114:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f117:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f11a:	01 d0                	add    %edx,%eax
f011f11c:	8a 00                	mov    (%eax),%al
f011f11e:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f011f121:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f124:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f127:	01 c2                	add    %eax,%edx
f011f129:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f011f12c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f12f:	01 c8                	add    %ecx,%eax
f011f131:	8a 00                	mov    (%eax),%al
f011f133:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f011f135:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f138:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f13b:	01 c2                	add    %eax,%edx
f011f13d:	8a 45 eb             	mov    -0x15(%ebp),%al
f011f140:	88 02                	mov    %al,(%edx)
		start++ ;
f011f142:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f011f145:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f011f148:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f14b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011f14e:	7c c4                	jl     f011f114 <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f011f150:	8b 55 f8             	mov    -0x8(%ebp),%edx
f011f153:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f156:	01 d0                	add    %edx,%eax
f011f158:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f011f15b:	90                   	nop
f011f15c:	c9                   	leave  
f011f15d:	c3                   	ret    

f011f15e <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f011f15e:	55                   	push   %ebp
f011f15f:	89 e5                	mov    %esp,%ebp
f011f161:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f011f164:	ff 75 08             	pushl  0x8(%ebp)
f011f167:	e8 73 fa ff ff       	call   f011ebdf <strlen>
f011f16c:	83 c4 04             	add    $0x4,%esp
f011f16f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f011f172:	ff 75 0c             	pushl  0xc(%ebp)
f011f175:	e8 65 fa ff ff       	call   f011ebdf <strlen>
f011f17a:	83 c4 04             	add    $0x4,%esp
f011f17d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f011f180:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f011f187:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011f18e:	eb 17                	jmp    f011f1a7 <strcconcat+0x49>
		final[s] = str1[s] ;
f011f190:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011f193:	8b 45 10             	mov    0x10(%ebp),%eax
f011f196:	01 c2                	add    %eax,%edx
f011f198:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011f19b:	8b 45 08             	mov    0x8(%ebp),%eax
f011f19e:	01 c8                	add    %ecx,%eax
f011f1a0:	8a 00                	mov    (%eax),%al
f011f1a2:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f011f1a4:	ff 45 fc             	incl   -0x4(%ebp)
f011f1a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f1aa:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f1ad:	7c e1                	jl     f011f190 <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f011f1af:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f011f1b6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f011f1bd:	eb 1f                	jmp    f011f1de <strcconcat+0x80>
		final[s++] = str2[i] ;
f011f1bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f1c2:	8d 50 01             	lea    0x1(%eax),%edx
f011f1c5:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011f1c8:	89 c2                	mov    %eax,%edx
f011f1ca:	8b 45 10             	mov    0x10(%ebp),%eax
f011f1cd:	01 c2                	add    %eax,%edx
f011f1cf:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f011f1d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f1d5:	01 c8                	add    %ecx,%eax
f011f1d7:	8a 00                	mov    (%eax),%al
f011f1d9:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f011f1db:	ff 45 f8             	incl   -0x8(%ebp)
f011f1de:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f1e1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011f1e4:	7c d9                	jl     f011f1bf <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f011f1e6:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011f1e9:	8b 45 10             	mov    0x10(%ebp),%eax
f011f1ec:	01 d0                	add    %edx,%eax
f011f1ee:	c6 00 00             	movb   $0x0,(%eax)
}
f011f1f1:	90                   	nop
f011f1f2:	c9                   	leave  
f011f1f3:	c3                   	ret    

f011f1f4 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f011f1f4:	55                   	push   %ebp
f011f1f5:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f011f1f7:	8b 45 14             	mov    0x14(%ebp),%eax
f011f1fa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f011f200:	8b 45 14             	mov    0x14(%ebp),%eax
f011f203:	8b 00                	mov    (%eax),%eax
f011f205:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f20c:	8b 45 10             	mov    0x10(%ebp),%eax
f011f20f:	01 d0                	add    %edx,%eax
f011f211:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011f217:	eb 0c                	jmp    f011f225 <strsplit+0x31>
			*string++ = 0;
f011f219:	8b 45 08             	mov    0x8(%ebp),%eax
f011f21c:	8d 50 01             	lea    0x1(%eax),%edx
f011f21f:	89 55 08             	mov    %edx,0x8(%ebp)
f011f222:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011f225:	8b 45 08             	mov    0x8(%ebp),%eax
f011f228:	8a 00                	mov    (%eax),%al
f011f22a:	84 c0                	test   %al,%al
f011f22c:	74 18                	je     f011f246 <strsplit+0x52>
f011f22e:	8b 45 08             	mov    0x8(%ebp),%eax
f011f231:	8a 00                	mov    (%eax),%al
f011f233:	0f be c0             	movsbl %al,%eax
f011f236:	50                   	push   %eax
f011f237:	ff 75 0c             	pushl  0xc(%ebp)
f011f23a:	e8 32 fb ff ff       	call   f011ed71 <strchr>
f011f23f:	83 c4 08             	add    $0x8,%esp
f011f242:	85 c0                	test   %eax,%eax
f011f244:	75 d3                	jne    f011f219 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f011f246:	8b 45 08             	mov    0x8(%ebp),%eax
f011f249:	8a 00                	mov    (%eax),%al
f011f24b:	84 c0                	test   %al,%al
f011f24d:	74 5a                	je     f011f2a9 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f011f24f:	8b 45 14             	mov    0x14(%ebp),%eax
f011f252:	8b 00                	mov    (%eax),%eax
f011f254:	83 f8 0f             	cmp    $0xf,%eax
f011f257:	75 07                	jne    f011f260 <strsplit+0x6c>
		{
			return 0;
f011f259:	b8 00 00 00 00       	mov    $0x0,%eax
f011f25e:	eb 66                	jmp    f011f2c6 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f011f260:	8b 45 14             	mov    0x14(%ebp),%eax
f011f263:	8b 00                	mov    (%eax),%eax
f011f265:	8d 48 01             	lea    0x1(%eax),%ecx
f011f268:	8b 55 14             	mov    0x14(%ebp),%edx
f011f26b:	89 0a                	mov    %ecx,(%edx)
f011f26d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f274:	8b 45 10             	mov    0x10(%ebp),%eax
f011f277:	01 c2                	add    %eax,%edx
f011f279:	8b 45 08             	mov    0x8(%ebp),%eax
f011f27c:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f011f27e:	eb 03                	jmp    f011f283 <strsplit+0x8f>
			string++;
f011f280:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f011f283:	8b 45 08             	mov    0x8(%ebp),%eax
f011f286:	8a 00                	mov    (%eax),%al
f011f288:	84 c0                	test   %al,%al
f011f28a:	74 8b                	je     f011f217 <strsplit+0x23>
f011f28c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f28f:	8a 00                	mov    (%eax),%al
f011f291:	0f be c0             	movsbl %al,%eax
f011f294:	50                   	push   %eax
f011f295:	ff 75 0c             	pushl  0xc(%ebp)
f011f298:	e8 d4 fa ff ff       	call   f011ed71 <strchr>
f011f29d:	83 c4 08             	add    $0x8,%esp
f011f2a0:	85 c0                	test   %eax,%eax
f011f2a2:	74 dc                	je     f011f280 <strsplit+0x8c>
			string++;
	}
f011f2a4:	e9 6e ff ff ff       	jmp    f011f217 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f011f2a9:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f011f2aa:	8b 45 14             	mov    0x14(%ebp),%eax
f011f2ad:	8b 00                	mov    (%eax),%eax
f011f2af:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f2b6:	8b 45 10             	mov    0x10(%ebp),%eax
f011f2b9:	01 d0                	add    %edx,%eax
f011f2bb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f011f2c1:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011f2c6:	c9                   	leave  
f011f2c7:	c3                   	ret    

f011f2c8 <str2lower>:


char* str2lower(char *dst, const char *src)
{
f011f2c8:	55                   	push   %ebp
f011f2c9:	89 e5                	mov    %esp,%ebp
f011f2cb:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f011f2ce:	83 ec 04             	sub    $0x4,%esp
f011f2d1:	68 bc ff 12 f0       	push   $0xf012ffbc
f011f2d6:	68 3f 01 00 00       	push   $0x13f
f011f2db:	68 de ff 12 f0       	push   $0xf012ffde
f011f2e0:	e8 54 10 fe ff       	call   f0100339 <_panic>

f011f2e5 <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f011f2e5:	55                   	push   %ebp
f011f2e6:	89 e5                	mov    %esp,%ebp
f011f2e8:	83 ec 18             	sub    $0x18,%esp
f011f2eb:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011f2f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f2f5:	89 c2                	mov    %eax,%edx
f011f2f7:	ec                   	in     (%dx),%al
f011f2f8:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011f2fb:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011f2fe:	0f b6 c0             	movzbl %al,%eax
f011f301:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f304:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f307:	25 c0 00 00 00       	and    $0xc0,%eax
f011f30c:	83 f8 40             	cmp    $0x40,%eax
f011f30f:	75 10                	jne    f011f321 <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f011f311:	83 ec 0c             	sub    $0xc,%esp
f011f314:	68 60 c3 5e f0       	push   $0xf05ec360
f011f319:	e8 0a fd fe ff       	call   f010f028 <wakeup_one>
f011f31e:	83 c4 10             	add    $0x10,%esp
	}

}
f011f321:	90                   	nop
f011f322:	c9                   	leave  
f011f323:	c3                   	ret    

f011f324 <ide_init>:

void ide_init()
{
f011f324:	55                   	push   %ebp
f011f325:	89 e5                	mov    %esp,%ebp
f011f327:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f011f32a:	83 ec 08             	sub    $0x8,%esp
f011f32d:	68 e5 f2 11 f0       	push   $0xf011f2e5
f011f332:	6a 0e                	push   $0xe
f011f334:	e8 b1 e0 fe ff       	call   f010d3ea <irq_install_handler>
f011f339:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f011f33c:	83 ec 08             	sub    $0x8,%esp
f011f33f:	68 ec ff 12 f0       	push   $0xf012ffec
f011f344:	68 60 c3 5e f0       	push   $0xf05ec360
f011f349:	e8 3f fc fe ff       	call   f010ef8d <init_channel>
f011f34e:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f011f351:	83 ec 08             	sub    $0x8,%esp
f011f354:	68 f9 ff 12 f0       	push   $0xf012fff9
f011f359:	68 80 c9 5e f0       	push   $0xf05ec980
f011f35e:	e8 2b f8 fe ff       	call   f010eb8e <init_spinlock>
f011f363:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f011f366:	90                   	nop
f011f367:	c9                   	leave  
f011f368:	c3                   	ret    

f011f369 <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f011f369:	55                   	push   %ebp
f011f36a:	89 e5                	mov    %esp,%ebp
f011f36c:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011f36f:	90                   	nop
f011f370:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011f377:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f37a:	89 c2                	mov    %eax,%edx
f011f37c:	ec                   	in     (%dx),%al
f011f37d:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011f380:	8a 45 ef             	mov    -0x11(%ebp),%al
f011f383:	0f b6 c0             	movzbl %al,%eax
f011f386:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f389:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f38c:	25 c0 00 00 00       	and    $0xc0,%eax
f011f391:	83 f8 40             	cmp    $0x40,%eax
f011f394:	75 da                	jne    f011f370 <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f011f396:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f39a:	74 24                	je     f011f3c0 <ide_wait_ready+0x57>
f011f39c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f39f:	83 e0 21             	and    $0x21,%eax
f011f3a2:	85 c0                	test   %eax,%eax
f011f3a4:	74 1a                	je     f011f3c0 <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f011f3a6:	83 ec 0c             	sub    $0xc,%esp
f011f3a9:	ff 75 f4             	pushl  -0xc(%ebp)
f011f3ac:	ff 75 f4             	pushl  -0xc(%ebp)
f011f3af:	68 0c 00 13 f0       	push   $0xf013000c
f011f3b4:	6a 5d                	push   $0x5d
f011f3b6:	68 2f 00 13 f0       	push   $0xf013002f
f011f3bb:	e8 79 0f fe ff       	call   f0100339 <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f011f3c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011f3c5:	c9                   	leave  
f011f3c6:	c3                   	ret    

f011f3c7 <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f011f3c7:	55                   	push   %ebp
f011f3c8:	89 e5                	mov    %esp,%ebp
f011f3ca:	57                   	push   %edi
f011f3cb:	53                   	push   %ebx
f011f3cc:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f011f3cf:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011f3d6:	76 16                	jbe    f011f3ee <ide_read+0x27>
f011f3d8:	68 3a 00 13 f0       	push   $0xf013003a
f011f3dd:	68 47 00 13 f0       	push   $0xf0130047
f011f3e2:	6a 68                	push   $0x68
f011f3e4:	68 2f 00 13 f0       	push   $0xf013002f
f011f3e9:	e8 4b 0f fe ff       	call   f0100339 <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f011f3ee:	83 ec 0c             	sub    $0xc,%esp
f011f3f1:	6a 00                	push   $0x0
f011f3f3:	e8 71 ff ff ff       	call   f011f369 <ide_wait_ready>
f011f3f8:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f011f3fb:	8b 45 10             	mov    0x10(%ebp),%eax
f011f3fe:	0f b6 c0             	movzbl %al,%eax
f011f401:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f011f408:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011f40b:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011f40e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f411:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f011f412:	8b 45 08             	mov    0x8(%ebp),%eax
f011f415:	0f b6 c0             	movzbl %al,%eax
f011f418:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f011f41f:	88 45 d3             	mov    %al,-0x2d(%ebp)
f011f422:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011f425:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f428:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f011f429:	8b 45 08             	mov    0x8(%ebp),%eax
f011f42c:	c1 e8 08             	shr    $0x8,%eax
f011f42f:	0f b6 c0             	movzbl %al,%eax
f011f432:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f011f439:	88 45 d4             	mov    %al,-0x2c(%ebp)
f011f43c:	8a 45 d4             	mov    -0x2c(%ebp),%al
f011f43f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f442:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f011f443:	8b 45 08             	mov    0x8(%ebp),%eax
f011f446:	c1 e8 10             	shr    $0x10,%eax
f011f449:	0f b6 c0             	movzbl %al,%eax
f011f44c:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f011f453:	88 45 d5             	mov    %al,-0x2b(%ebp)
f011f456:	8a 45 d5             	mov    -0x2b(%ebp),%al
f011f459:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011f45c:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011f45d:	a1 10 c2 5e f0       	mov    0xf05ec210,%eax
f011f462:	83 e0 01             	and    $0x1,%eax
f011f465:	c1 e0 04             	shl    $0x4,%eax
f011f468:	88 c2                	mov    %al,%dl
f011f46a:	8b 45 08             	mov    0x8(%ebp),%eax
f011f46d:	c1 e8 18             	shr    $0x18,%eax
f011f470:	83 e0 0f             	and    $0xf,%eax
f011f473:	09 d0                	or     %edx,%eax
f011f475:	83 c8 e0             	or     $0xffffffe0,%eax
f011f478:	0f b6 c0             	movzbl %al,%eax
f011f47b:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f011f482:	88 45 d6             	mov    %al,-0x2a(%ebp)
f011f485:	8a 45 d6             	mov    -0x2a(%ebp),%al
f011f488:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f48b:	ee                   	out    %al,(%dx)
f011f48c:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f011f493:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f011f497:	8a 45 d7             	mov    -0x29(%ebp),%al
f011f49a:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011f49d:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011f49e:	eb 55                	jmp    f011f4f5 <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f011f4a0:	83 ec 0c             	sub    $0xc,%esp
f011f4a3:	6a 01                	push   $0x1
f011f4a5:	e8 bf fe ff ff       	call   f011f369 <ide_wait_ready>
f011f4aa:	83 c4 10             	add    $0x10,%esp
f011f4ad:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011f4b0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f4b4:	79 05                	jns    f011f4bb <ide_read+0xf4>
			return r;
f011f4b6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f4b9:	eb 45                	jmp    f011f500 <ide_read+0x139>
f011f4bb:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f011f4c2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f4c5:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011f4c8:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f011f4cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f4d2:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f011f4d5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011f4d8:	89 cb                	mov    %ecx,%ebx
f011f4da:	89 df                	mov    %ebx,%edi
f011f4dc:	89 c1                	mov    %eax,%ecx
f011f4de:	fc                   	cld    
f011f4df:	f2 6d                	repnz insl (%dx),%es:(%edi)
f011f4e1:	89 c8                	mov    %ecx,%eax
f011f4e3:	89 fb                	mov    %edi,%ebx
f011f4e5:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f011f4e8:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011f4eb:	ff 4d 10             	decl   0x10(%ebp)
f011f4ee:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011f4f5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f4f9:	75 a5                	jne    f011f4a0 <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f011f4fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011f500:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011f503:	5b                   	pop    %ebx
f011f504:	5f                   	pop    %edi
f011f505:	5d                   	pop    %ebp
f011f506:	c3                   	ret    

f011f507 <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f011f507:	55                   	push   %ebp
f011f508:	89 e5                	mov    %esp,%ebp
f011f50a:	56                   	push   %esi
f011f50b:	53                   	push   %ebx
f011f50c:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f011f50f:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011f516:	76 19                	jbe    f011f531 <ide_write+0x2a>
f011f518:	68 3a 00 13 f0       	push   $0xf013003a
f011f51d:	68 47 00 13 f0       	push   $0xf0130047
f011f522:	68 82 00 00 00       	push   $0x82
f011f527:	68 2f 00 13 f0       	push   $0xf013002f
f011f52c:	e8 08 0e fe ff       	call   f0100339 <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f011f531:	83 ec 0c             	sub    $0xc,%esp
f011f534:	6a 00                	push   $0x0
f011f536:	e8 2e fe ff ff       	call   f011f369 <ide_wait_ready>
f011f53b:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f011f53e:	8b 45 10             	mov    0x10(%ebp),%eax
f011f541:	0f b6 c0             	movzbl %al,%eax
f011f544:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f011f54b:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011f54e:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011f551:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f554:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f011f555:	8b 45 08             	mov    0x8(%ebp),%eax
f011f558:	0f b6 c0             	movzbl %al,%eax
f011f55b:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f011f562:	88 45 d3             	mov    %al,-0x2d(%ebp)
f011f565:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011f568:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f56b:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f011f56c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f56f:	c1 e8 08             	shr    $0x8,%eax
f011f572:	0f b6 c0             	movzbl %al,%eax
f011f575:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f011f57c:	88 45 d4             	mov    %al,-0x2c(%ebp)
f011f57f:	8a 45 d4             	mov    -0x2c(%ebp),%al
f011f582:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f585:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f011f586:	8b 45 08             	mov    0x8(%ebp),%eax
f011f589:	c1 e8 10             	shr    $0x10,%eax
f011f58c:	0f b6 c0             	movzbl %al,%eax
f011f58f:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f011f596:	88 45 d5             	mov    %al,-0x2b(%ebp)
f011f599:	8a 45 d5             	mov    -0x2b(%ebp),%al
f011f59c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011f59f:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011f5a0:	a1 10 c2 5e f0       	mov    0xf05ec210,%eax
f011f5a5:	83 e0 01             	and    $0x1,%eax
f011f5a8:	c1 e0 04             	shl    $0x4,%eax
f011f5ab:	88 c2                	mov    %al,%dl
f011f5ad:	8b 45 08             	mov    0x8(%ebp),%eax
f011f5b0:	c1 e8 18             	shr    $0x18,%eax
f011f5b3:	83 e0 0f             	and    $0xf,%eax
f011f5b6:	09 d0                	or     %edx,%eax
f011f5b8:	83 c8 e0             	or     $0xffffffe0,%eax
f011f5bb:	0f b6 c0             	movzbl %al,%eax
f011f5be:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f011f5c5:	88 45 d6             	mov    %al,-0x2a(%ebp)
f011f5c8:	8a 45 d6             	mov    -0x2a(%ebp),%al
f011f5cb:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f5ce:	ee                   	out    %al,(%dx)
f011f5cf:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f011f5d6:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f011f5da:	8a 45 d7             	mov    -0x29(%ebp),%al
f011f5dd:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011f5e0:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f011f5e1:	eb 55                	jmp    f011f638 <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f011f5e3:	83 ec 0c             	sub    $0xc,%esp
f011f5e6:	6a 01                	push   $0x1
f011f5e8:	e8 7c fd ff ff       	call   f011f369 <ide_wait_ready>
f011f5ed:	83 c4 10             	add    $0x10,%esp
f011f5f0:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011f5f3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f5f7:	79 05                	jns    f011f5fe <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f011f5f9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f5fc:	eb 45                	jmp    f011f643 <ide_write+0x13c>
f011f5fe:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f011f605:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f608:	89 45 cc             	mov    %eax,-0x34(%ebp)
f011f60b:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f011f612:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011f615:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f011f618:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011f61b:	89 cb                	mov    %ecx,%ebx
f011f61d:	89 de                	mov    %ebx,%esi
f011f61f:	89 c1                	mov    %eax,%ecx
f011f621:	fc                   	cld    
f011f622:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f011f624:	89 c8                	mov    %ecx,%eax
f011f626:	89 f3                	mov    %esi,%ebx
f011f628:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f011f62b:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f011f62e:	ff 4d 10             	decl   0x10(%ebp)
f011f631:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011f638:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f63c:	75 a5                	jne    f011f5e3 <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f011f63e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011f643:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011f646:	5b                   	pop    %ebx
f011f647:	5e                   	pop    %esi
f011f648:	5d                   	pop    %ebp
f011f649:	c3                   	ret    

f011f64a <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f011f64a:	55                   	push   %ebp
f011f64b:	89 e5                	mov    %esp,%ebp
f011f64d:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f011f650:	8b 45 08             	mov    0x8(%ebp),%eax
f011f653:	83 e8 04             	sub    $0x4,%eax
f011f656:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f011f659:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f65c:	8b 00                	mov    (%eax),%eax
f011f65e:	83 e0 fe             	and    $0xfffffffe,%eax
}
f011f661:	c9                   	leave  
f011f662:	c3                   	ret    

f011f663 <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f011f663:	55                   	push   %ebp
f011f664:	89 e5                	mov    %esp,%ebp
f011f666:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f011f669:	8b 45 08             	mov    0x8(%ebp),%eax
f011f66c:	83 e8 04             	sub    $0x4,%eax
f011f66f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f011f672:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011f675:	8b 00                	mov    (%eax),%eax
f011f677:	83 e0 01             	and    $0x1,%eax
f011f67a:	85 c0                	test   %eax,%eax
f011f67c:	0f 94 c0             	sete   %al
}
f011f67f:	c9                   	leave  
f011f680:	c3                   	ret    

f011f681 <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f011f681:	55                   	push   %ebp
f011f682:	89 e5                	mov    %esp,%ebp
f011f684:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f011f687:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f011f68e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f691:	83 f8 02             	cmp    $0x2,%eax
f011f694:	74 2b                	je     f011f6c1 <alloc_block+0x40>
f011f696:	83 f8 02             	cmp    $0x2,%eax
f011f699:	7f 07                	jg     f011f6a2 <alloc_block+0x21>
f011f69b:	83 f8 01             	cmp    $0x1,%eax
f011f69e:	74 0e                	je     f011f6ae <alloc_block+0x2d>
f011f6a0:	eb 58                	jmp    f011f6fa <alloc_block+0x79>
f011f6a2:	83 f8 03             	cmp    $0x3,%eax
f011f6a5:	74 2d                	je     f011f6d4 <alloc_block+0x53>
f011f6a7:	83 f8 04             	cmp    $0x4,%eax
f011f6aa:	74 3b                	je     f011f6e7 <alloc_block+0x66>
f011f6ac:	eb 4c                	jmp    f011f6fa <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f011f6ae:	83 ec 0c             	sub    $0xc,%esp
f011f6b1:	ff 75 08             	pushl  0x8(%ebp)
f011f6b4:	e8 5f 02 00 00       	call   f011f918 <alloc_block_FF>
f011f6b9:	83 c4 10             	add    $0x10,%esp
f011f6bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011f6bf:	eb 4a                	jmp    f011f70b <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f011f6c1:	83 ec 0c             	sub    $0xc,%esp
f011f6c4:	ff 75 08             	pushl  0x8(%ebp)
f011f6c7:	e8 d3 13 00 00       	call   f0120a9f <alloc_block_NF>
f011f6cc:	83 c4 10             	add    $0x10,%esp
f011f6cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011f6d2:	eb 37                	jmp    f011f70b <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f011f6d4:	83 ec 0c             	sub    $0xc,%esp
f011f6d7:	ff 75 08             	pushl  0x8(%ebp)
f011f6da:	e8 f2 07 00 00       	call   f011fed1 <alloc_block_BF>
f011f6df:	83 c4 10             	add    $0x10,%esp
f011f6e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011f6e5:	eb 24                	jmp    f011f70b <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f011f6e7:	83 ec 0c             	sub    $0xc,%esp
f011f6ea:	ff 75 08             	pushl  0x8(%ebp)
f011f6ed:	e8 90 13 00 00       	call   f0120a82 <alloc_block_WF>
f011f6f2:	83 c4 10             	add    $0x10,%esp
f011f6f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f011f6f8:	eb 11                	jmp    f011f70b <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f011f6fa:	83 ec 0c             	sub    $0xc,%esp
f011f6fd:	68 5c 00 13 f0       	push   $0xf013005c
f011f702:	e8 84 18 fe ff       	call   f0100f8b <cprintf>
f011f707:	83 c4 10             	add    $0x10,%esp
		break;
f011f70a:	90                   	nop
	}
	return va;
f011f70b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011f70e:	c9                   	leave  
f011f70f:	c3                   	ret    

f011f710 <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f011f710:	55                   	push   %ebp
f011f711:	89 e5                	mov    %esp,%ebp
f011f713:	53                   	push   %ebx
f011f714:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f011f717:	83 ec 0c             	sub    $0xc,%esp
f011f71a:	68 7c 00 13 f0       	push   $0xf013007c
f011f71f:	e8 67 18 fe ff       	call   f0100f8b <cprintf>
f011f724:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f011f727:	83 ec 0c             	sub    $0xc,%esp
f011f72a:	68 a7 00 13 f0       	push   $0xf01300a7
f011f72f:	e8 57 18 fe ff       	call   f0100f8b <cprintf>
f011f734:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f011f737:	8b 45 08             	mov    0x8(%ebp),%eax
f011f73a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f73d:	eb 37                	jmp    f011f776 <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f011f73f:	83 ec 0c             	sub    $0xc,%esp
f011f742:	ff 75 f4             	pushl  -0xc(%ebp)
f011f745:	e8 19 ff ff ff       	call   f011f663 <is_free_block>
f011f74a:	83 c4 10             	add    $0x10,%esp
f011f74d:	0f be d8             	movsbl %al,%ebx
f011f750:	83 ec 0c             	sub    $0xc,%esp
f011f753:	ff 75 f4             	pushl  -0xc(%ebp)
f011f756:	e8 ef fe ff ff       	call   f011f64a <get_block_size>
f011f75b:	83 c4 10             	add    $0x10,%esp
f011f75e:	83 ec 04             	sub    $0x4,%esp
f011f761:	53                   	push   %ebx
f011f762:	50                   	push   %eax
f011f763:	68 bf 00 13 f0       	push   $0xf01300bf
f011f768:	e8 1e 18 fe ff       	call   f0100f8b <cprintf>
f011f76d:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f011f770:	8b 45 10             	mov    0x10(%ebp),%eax
f011f773:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f776:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f77a:	74 07                	je     f011f783 <print_blocks_list+0x73>
f011f77c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f77f:	8b 00                	mov    (%eax),%eax
f011f781:	eb 05                	jmp    f011f788 <print_blocks_list+0x78>
f011f783:	b8 00 00 00 00       	mov    $0x0,%eax
f011f788:	89 45 10             	mov    %eax,0x10(%ebp)
f011f78b:	8b 45 10             	mov    0x10(%ebp),%eax
f011f78e:	85 c0                	test   %eax,%eax
f011f790:	75 ad                	jne    f011f73f <print_blocks_list+0x2f>
f011f792:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f796:	75 a7                	jne    f011f73f <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f011f798:	83 ec 0c             	sub    $0xc,%esp
f011f79b:	68 7c 00 13 f0       	push   $0xf013007c
f011f7a0:	e8 e6 17 fe ff       	call   f0100f8b <cprintf>
f011f7a5:	83 c4 10             	add    $0x10,%esp

}
f011f7a8:	90                   	nop
f011f7a9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011f7ac:	c9                   	leave  
f011f7ad:	c3                   	ret    

f011f7ae <initialize_dynamic_allocator>:
//==================================
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================
uint32 *dend;
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f011f7ae:	55                   	push   %ebp
f011f7af:	89 e5                	mov    %esp,%ebp
f011f7b1:	83 ec 18             	sub    $0x18,%esp

		//==================================================================================
		//DON'T CHANGE THESE LINES==========================================================
		//==================================================================================
		{
			if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f011f7b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f7b7:	83 e0 01             	and    $0x1,%eax
f011f7ba:	85 c0                	test   %eax,%eax
f011f7bc:	74 03                	je     f011f7c1 <initialize_dynamic_allocator+0x13>
f011f7be:	ff 45 0c             	incl   0xc(%ebp)
			if (initSizeOfAllocatedSpace == 0)
f011f7c1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f7c5:	0f 84 fd 00 00 00    	je     f011f8c8 <initialize_dynamic_allocator+0x11a>
				return ;
			is_initialized = 1;
f011f7cb:	c7 05 14 c2 5e f0 01 	movl   $0x1,0xf05ec214
f011f7d2:	00 00 00 
		// (uint32)LIST_INIT(deStart);
		//(uint32)LIST_INIT(head)=daStart;
	 //(uint32)LIST_SIZE(&freeBlocksList);
	 //  print_blocks_list(freeBlocksList) ;//	(uint32)LIST_FIRST(&freeBlocksList)=daStart;
	 //print_block_list(freeBlocksList);
		uint32* dbeg=(uint32*)daStart ;
f011f7d5:	8b 45 08             	mov    0x8(%ebp),%eax
f011f7d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
		 dend=(uint32*)(daStart+initSizeOfAllocatedSpace-sizeof(int));
f011f7db:	8b 55 08             	mov    0x8(%ebp),%edx
f011f7de:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f7e1:	01 d0                	add    %edx,%eax
f011f7e3:	83 e8 04             	sub    $0x4,%eax
f011f7e6:	a3 f0 f5 60 f0       	mov    %eax,0xf060f5f0
		*dbeg=1;
f011f7eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f7ee:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		*dend=1;
f011f7f4:	a1 f0 f5 60 f0       	mov    0xf060f5f0,%eax
f011f7f9:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		uint32* Header = (uint32*) (daStart + sizeof(int));
f011f7ff:	8b 45 08             	mov    0x8(%ebp),%eax
f011f802:	83 c0 04             	add    $0x4,%eax
f011f805:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    uint32* Footer = (uint32*) (daStart + initSizeOfAllocatedSpace -2*sizeof(int));
f011f808:	8b 55 08             	mov    0x8(%ebp),%edx
f011f80b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f80e:	01 d0                	add    %edx,%eax
f011f810:	83 e8 08             	sub    $0x8,%eax
f011f813:	89 45 ec             	mov    %eax,-0x14(%ebp)
		*Header =initSizeOfAllocatedSpace - 2 * sizeof(int);
f011f816:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f819:	8d 50 f8             	lea    -0x8(%eax),%edx
f011f81c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f81f:	89 10                	mov    %edx,(%eax)
		*Footer =initSizeOfAllocatedSpace - 2 * sizeof(int) ;
f011f821:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f824:	8d 50 f8             	lea    -0x8(%eax),%edx
f011f827:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f82a:	89 10                	mov    %edx,(%eax)

		struct BlockElement *FreeBlock = (struct BlockElement * )( daStart + 2*sizeof(int));
f011f82c:	8b 45 08             	mov    0x8(%ebp),%eax
f011f82f:	83 c0 08             	add    $0x8,%eax
f011f832:	89 45 e8             	mov    %eax,-0x18(%ebp)
		FreeBlock->prev_next_info.le_next=NULL;
f011f835:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f838:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		FreeBlock->prev_next_info.le_prev=NULL;
f011f83e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f841:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		LIST_INIT(&freeBlocksList) ;
f011f848:	c7 05 90 c5 5e f0 00 	movl   $0x0,0xf05ec590
f011f84f:	00 00 00 
f011f852:	c7 05 94 c5 5e f0 00 	movl   $0x0,0xf05ec594
f011f859:	00 00 00 
f011f85c:	c7 05 9c c5 5e f0 00 	movl   $0x0,0xf05ec59c
f011f863:	00 00 00 
		LIST_INSERT_HEAD(&freeBlocksList,FreeBlock);
f011f866:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011f86a:	75 14                	jne    f011f880 <initialize_dynamic_allocator+0xd2>
f011f86c:	83 ec 04             	sub    $0x4,%esp
f011f86f:	68 d8 00 13 f0       	push   $0xf01300d8
f011f874:	6a 7e                	push   $0x7e
f011f876:	68 fb 00 13 f0       	push   $0xf01300fb
f011f87b:	e8 b9 0a fe ff       	call   f0100339 <_panic>
f011f880:	8b 15 90 c5 5e f0    	mov    0xf05ec590,%edx
f011f886:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f889:	89 10                	mov    %edx,(%eax)
f011f88b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f88e:	8b 00                	mov    (%eax),%eax
f011f890:	85 c0                	test   %eax,%eax
f011f892:	74 0d                	je     f011f8a1 <initialize_dynamic_allocator+0xf3>
f011f894:	a1 90 c5 5e f0       	mov    0xf05ec590,%eax
f011f899:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f89c:	89 50 04             	mov    %edx,0x4(%eax)
f011f89f:	eb 08                	jmp    f011f8a9 <initialize_dynamic_allocator+0xfb>
f011f8a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f8a4:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f011f8a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f8ac:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f011f8b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f8b4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011f8bb:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f011f8c0:	40                   	inc    %eax
f011f8c1:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
f011f8c6:	eb 01                	jmp    f011f8c9 <initialize_dynamic_allocator+0x11b>
		//DON'T CHANGE THESE LINES==========================================================
		//==================================================================================
		{
			if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
			if (initSizeOfAllocatedSpace == 0)
				return ;
f011f8c8:	90                   	nop
		LIST_INSERT_HEAD(&freeBlocksList,FreeBlock);
	    //panic("initialize_dynamic_allocator is not implemented yet");
	//set_block_data((struct BlockElement *)( daStart + 2*sizeof(int)), 65,1);
	//print_blocks_list(freeBlocksList);

}
f011f8c9:	c9                   	leave  
f011f8ca:	c3                   	ret    

f011f8cb <set_block_data>:
//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f011f8cb:	55                   	push   %ebp
f011f8cc:	89 e5                	mov    %esp,%ebp
f011f8ce:	83 ec 10             	sub    $0x10,%esp

		//struct BlockElement *FreeBlock = (struct BlockElement * )( va );
		uint32 val= (uint32)totalSize ;
f011f8d1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f8d4:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if(isAllocated){
f011f8d7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011f8db:	74 04                	je     f011f8e1 <set_block_data+0x16>
			val|=1;
f011f8dd:	83 4d fc 01          	orl    $0x1,-0x4(%ebp)
		}

		if(totalSize%2!=0){
f011f8e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f8e4:	83 e0 01             	and    $0x1,%eax
f011f8e7:	85 c0                	test   %eax,%eax
f011f8e9:	74 03                	je     f011f8ee <set_block_data+0x23>
			val++	;
f011f8eb:	ff 45 fc             	incl   -0x4(%ebp)
			}

		uint32* Header = (uint32*) (va -sizeof(int) );
f011f8ee:	8b 45 08             	mov    0x8(%ebp),%eax
f011f8f1:	83 e8 04             	sub    $0x4,%eax
f011f8f4:	89 45 f8             	mov    %eax,-0x8(%ebp)
		uint32* Footer = (uint32*) (va+totalSize-(2*sizeof(int)));
f011f8f7:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f8fa:	8d 50 f8             	lea    -0x8(%eax),%edx
f011f8fd:	8b 45 08             	mov    0x8(%ebp),%eax
f011f900:	01 d0                	add    %edx,%eax
f011f902:	89 45 f4             	mov    %eax,-0xc(%ebp)
			*Header =(uint32)val ;
f011f905:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011f908:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011f90b:	89 10                	mov    %edx,(%eax)
			*Footer =(uint32)val  ;
f011f90d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f910:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011f913:	89 10                	mov    %edx,(%eax)
		//TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
		//COMMENT THE FOLLOWING LINE BEFORE START CODING
		//panic("set_block_data is not implemented yet");
		//Your Code is Here...

}
f011f915:	90                   	nop
f011f916:	c9                   	leave  
f011f917:	c3                   	ret    

f011f918 <alloc_block_FF>:
//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================

void *alloc_block_FF(uint32 size)
{
f011f918:	55                   	push   %ebp
f011f919:	89 e5                	mov    %esp,%ebp
f011f91b:	83 ec 68             	sub    $0x68,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f011f91e:	8b 45 08             	mov    0x8(%ebp),%eax
f011f921:	83 e0 01             	and    $0x1,%eax
f011f924:	85 c0                	test   %eax,%eax
f011f926:	74 03                	je     f011f92b <alloc_block_FF+0x13>
f011f928:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f011f92b:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f011f92f:	77 07                	ja     f011f938 <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f011f931:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f011f938:	a1 14 c2 5e f0       	mov    0xf05ec214,%eax
f011f93d:	85 c0                	test   %eax,%eax
f011f93f:	75 63                	jne    f011f9a4 <alloc_block_FF+0x8c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f011f941:	8b 45 08             	mov    0x8(%ebp),%eax
f011f944:	83 c0 10             	add    $0x10,%eax
f011f947:	89 45 f0             	mov    %eax,-0x10(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f011f94a:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
f011f951:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011f954:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f957:	01 d0                	add    %edx,%eax
f011f959:	48                   	dec    %eax
f011f95a:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011f95d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f960:	ba 00 00 00 00       	mov    $0x0,%edx
f011f965:	f7 75 ec             	divl   -0x14(%ebp)
f011f968:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f96b:	29 d0                	sub    %edx,%eax
f011f96d:	c1 e8 0c             	shr    $0xc,%eax
f011f970:	83 ec 0c             	sub    $0xc,%esp
f011f973:	50                   	push   %eax
f011f974:	e8 bc 93 fe ff       	call   f0108d35 <sbrk>
f011f979:	83 c4 10             	add    $0x10,%esp
f011f97c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f011f97f:	83 ec 0c             	sub    $0xc,%esp
f011f982:	6a 00                	push   $0x0
f011f984:	e8 ac 93 fe ff       	call   f0108d35 <sbrk>
f011f989:	83 c4 10             	add    $0x10,%esp
f011f98c:	89 45 e0             	mov    %eax,-0x20(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f011f98f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f992:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f011f995:	83 ec 08             	sub    $0x8,%esp
f011f998:	50                   	push   %eax
f011f999:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f99c:	e8 0d fe ff ff       	call   f011f7ae <initialize_dynamic_allocator>
f011f9a1:	83 c4 10             	add    $0x10,%esp

	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("alloc_block_FF is not implemented yet");
	//Your Code is Here...
	uint32 compsize =size+2*sizeof(int);
f011f9a4:	8b 45 08             	mov    0x8(%ebp),%eax
f011f9a7:	83 c0 08             	add    $0x8,%eax
f011f9aa:	89 45 dc             	mov    %eax,-0x24(%ebp)
	struct BlockElement *moblock;
	struct BlockElement *newblock;

    LIST_FOREACH(moblock,&freeBlocksList){
f011f9ad:	a1 90 c5 5e f0       	mov    0xf05ec590,%eax
f011f9b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f9b5:	e9 c8 02 00 00       	jmp    f011fc82 <alloc_block_FF+0x36a>
    	uint32 sizeofblock=get_block_size(moblock);
f011f9ba:	83 ec 0c             	sub    $0xc,%esp
f011f9bd:	ff 75 f4             	pushl  -0xc(%ebp)
f011f9c0:	e8 85 fc ff ff       	call   f011f64a <get_block_size>
f011f9c5:	83 c4 10             	add    $0x10,%esp
f011f9c8:	89 45 a8             	mov    %eax,-0x58(%ebp)
    	if (size==0)return NULL;
f011f9cb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f9cf:	75 0a                	jne    f011f9db <alloc_block_FF+0xc3>
f011f9d1:	b8 00 00 00 00       	mov    $0x0,%eax
f011f9d6:	e9 f4 04 00 00       	jmp    f011fecf <alloc_block_FF+0x5b7>
    	if(compsize<=sizeofblock)
f011f9db:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f9de:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f011f9e1:	0f 87 93 02 00 00    	ja     f011fc7a <alloc_block_FF+0x362>
    	{


    		if (compsize==sizeofblock)
f011f9e7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f9ea:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f011f9ed:	0f 85 9d 00 00 00    	jne    f011fa90 <alloc_block_FF+0x178>
    		{

    			 	 	 	 set_block_data(moblock, compsize, 1);
f011f9f3:	83 ec 04             	sub    $0x4,%esp
f011f9f6:	6a 01                	push   $0x1
f011f9f8:	ff 75 dc             	pushl  -0x24(%ebp)
f011f9fb:	ff 75 f4             	pushl  -0xc(%ebp)
f011f9fe:	e8 c8 fe ff ff       	call   f011f8cb <set_block_data>
f011fa03:	83 c4 10             	add    $0x10,%esp
    			                LIST_REMOVE(&freeBlocksList, moblock);
f011fa06:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fa0a:	75 17                	jne    f011fa23 <alloc_block_FF+0x10b>
f011fa0c:	83 ec 04             	sub    $0x4,%esp
f011fa0f:	68 13 01 13 f0       	push   $0xf0130113
f011fa14:	68 cf 00 00 00       	push   $0xcf
f011fa19:	68 fb 00 13 f0       	push   $0xf01300fb
f011fa1e:	e8 16 09 fe ff       	call   f0100339 <_panic>
f011fa23:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa26:	8b 00                	mov    (%eax),%eax
f011fa28:	85 c0                	test   %eax,%eax
f011fa2a:	74 10                	je     f011fa3c <alloc_block_FF+0x124>
f011fa2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa2f:	8b 00                	mov    (%eax),%eax
f011fa31:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fa34:	8b 52 04             	mov    0x4(%edx),%edx
f011fa37:	89 50 04             	mov    %edx,0x4(%eax)
f011fa3a:	eb 0b                	jmp    f011fa47 <alloc_block_FF+0x12f>
f011fa3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa3f:	8b 40 04             	mov    0x4(%eax),%eax
f011fa42:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f011fa47:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa4a:	8b 40 04             	mov    0x4(%eax),%eax
f011fa4d:	85 c0                	test   %eax,%eax
f011fa4f:	74 0f                	je     f011fa60 <alloc_block_FF+0x148>
f011fa51:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa54:	8b 40 04             	mov    0x4(%eax),%eax
f011fa57:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fa5a:	8b 12                	mov    (%edx),%edx
f011fa5c:	89 10                	mov    %edx,(%eax)
f011fa5e:	eb 0a                	jmp    f011fa6a <alloc_block_FF+0x152>
f011fa60:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa63:	8b 00                	mov    (%eax),%eax
f011fa65:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f011fa6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa6d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011fa73:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa76:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011fa7d:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f011fa82:	48                   	dec    %eax
f011fa83:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c

    			                return (void*)(moblock );
f011fa88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa8b:	e9 3f 04 00 00       	jmp    f011fecf <alloc_block_FF+0x5b7>

    		}


    			uint32 diff =sizeofblock-compsize;
f011fa90:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011fa93:	2b 45 dc             	sub    -0x24(%ebp),%eax
f011fa96:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    			//split
    			//struct BlockElement *
    			if (diff>=4*sizeof(int)){
f011fa99:	83 7d a4 0f          	cmpl   $0xf,-0x5c(%ebp)
f011fa9d:	0f 86 3a 01 00 00    	jbe    f011fbdd <alloc_block_FF+0x2c5>
				newblock = (struct BlockElement*)((char*)moblock + compsize);
f011faa3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011faa6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011faa9:	01 d0                	add    %edx,%eax
f011faab:	89 45 a0             	mov    %eax,-0x60(%ebp)
    			uint32 compblock =get_block_size(moblock);
f011faae:	83 ec 0c             	sub    $0xc,%esp
f011fab1:	ff 75 f4             	pushl  -0xc(%ebp)
f011fab4:	e8 91 fb ff ff       	call   f011f64a <get_block_size>
f011fab9:	83 c4 10             	add    $0x10,%esp
f011fabc:	89 45 9c             	mov    %eax,-0x64(%ebp)
    			set_block_data(moblock,compsize,1);
f011fabf:	83 ec 04             	sub    $0x4,%esp
f011fac2:	6a 01                	push   $0x1
f011fac4:	ff 75 dc             	pushl  -0x24(%ebp)
f011fac7:	ff 75 f4             	pushl  -0xc(%ebp)
f011faca:	e8 fc fd ff ff       	call   f011f8cb <set_block_data>
f011facf:	83 c4 10             	add    $0x10,%esp
    			set_block_data(newblock,diff,0);
f011fad2:	83 ec 04             	sub    $0x4,%esp
f011fad5:	6a 00                	push   $0x0
f011fad7:	ff 75 a4             	pushl  -0x5c(%ebp)
f011fada:	ff 75 a0             	pushl  -0x60(%ebp)
f011fadd:	e8 e9 fd ff ff       	call   f011f8cb <set_block_data>
f011fae2:	83 c4 10             	add    $0x10,%esp
    			LIST_INSERT_AFTER(&freeBlocksList,moblock,newblock);
f011fae5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fae9:	74 06                	je     f011faf1 <alloc_block_FF+0x1d9>
f011faeb:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f011faef:	75 17                	jne    f011fb08 <alloc_block_FF+0x1f0>
f011faf1:	83 ec 04             	sub    $0x4,%esp
f011faf4:	68 34 01 13 f0       	push   $0xf0130134
f011faf9:	68 de 00 00 00       	push   $0xde
f011fafe:	68 fb 00 13 f0       	push   $0xf01300fb
f011fb03:	e8 31 08 fe ff       	call   f0100339 <_panic>
f011fb08:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb0b:	8b 10                	mov    (%eax),%edx
f011fb0d:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011fb10:	89 10                	mov    %edx,(%eax)
f011fb12:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011fb15:	8b 00                	mov    (%eax),%eax
f011fb17:	85 c0                	test   %eax,%eax
f011fb19:	74 0b                	je     f011fb26 <alloc_block_FF+0x20e>
f011fb1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb1e:	8b 00                	mov    (%eax),%eax
f011fb20:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011fb23:	89 50 04             	mov    %edx,0x4(%eax)
f011fb26:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb29:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011fb2c:	89 10                	mov    %edx,(%eax)
f011fb2e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011fb31:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fb34:	89 50 04             	mov    %edx,0x4(%eax)
f011fb37:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011fb3a:	8b 00                	mov    (%eax),%eax
f011fb3c:	85 c0                	test   %eax,%eax
f011fb3e:	75 08                	jne    f011fb48 <alloc_block_FF+0x230>
f011fb40:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011fb43:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f011fb48:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f011fb4d:	40                   	inc    %eax
f011fb4e:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
    			 LIST_REMOVE(&freeBlocksList,moblock);
f011fb53:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fb57:	75 17                	jne    f011fb70 <alloc_block_FF+0x258>
f011fb59:	83 ec 04             	sub    $0x4,%esp
f011fb5c:	68 13 01 13 f0       	push   $0xf0130113
f011fb61:	68 df 00 00 00       	push   $0xdf
f011fb66:	68 fb 00 13 f0       	push   $0xf01300fb
f011fb6b:	e8 c9 07 fe ff       	call   f0100339 <_panic>
f011fb70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb73:	8b 00                	mov    (%eax),%eax
f011fb75:	85 c0                	test   %eax,%eax
f011fb77:	74 10                	je     f011fb89 <alloc_block_FF+0x271>
f011fb79:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb7c:	8b 00                	mov    (%eax),%eax
f011fb7e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fb81:	8b 52 04             	mov    0x4(%edx),%edx
f011fb84:	89 50 04             	mov    %edx,0x4(%eax)
f011fb87:	eb 0b                	jmp    f011fb94 <alloc_block_FF+0x27c>
f011fb89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb8c:	8b 40 04             	mov    0x4(%eax),%eax
f011fb8f:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f011fb94:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb97:	8b 40 04             	mov    0x4(%eax),%eax
f011fb9a:	85 c0                	test   %eax,%eax
f011fb9c:	74 0f                	je     f011fbad <alloc_block_FF+0x295>
f011fb9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fba1:	8b 40 04             	mov    0x4(%eax),%eax
f011fba4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fba7:	8b 12                	mov    (%edx),%edx
f011fba9:	89 10                	mov    %edx,(%eax)
f011fbab:	eb 0a                	jmp    f011fbb7 <alloc_block_FF+0x29f>
f011fbad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fbb0:	8b 00                	mov    (%eax),%eax
f011fbb2:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f011fbb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fbba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011fbc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fbc3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011fbca:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f011fbcf:	48                   	dec    %eax
f011fbd0:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c

    			return (void*)(moblock);
f011fbd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fbd8:	e9 f2 02 00 00       	jmp    f011fecf <alloc_block_FF+0x5b7>
    			}
    			else {
    				set_block_data(moblock,sizeofblock,1);
f011fbdd:	83 ec 04             	sub    $0x4,%esp
f011fbe0:	6a 01                	push   $0x1
f011fbe2:	ff 75 a8             	pushl  -0x58(%ebp)
f011fbe5:	ff 75 f4             	pushl  -0xc(%ebp)
f011fbe8:	e8 de fc ff ff       	call   f011f8cb <set_block_data>
f011fbed:	83 c4 10             	add    $0x10,%esp
    				LIST_REMOVE(&freeBlocksList,moblock);
f011fbf0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fbf4:	75 17                	jne    f011fc0d <alloc_block_FF+0x2f5>
f011fbf6:	83 ec 04             	sub    $0x4,%esp
f011fbf9:	68 13 01 13 f0       	push   $0xf0130113
f011fbfe:	68 e5 00 00 00       	push   $0xe5
f011fc03:	68 fb 00 13 f0       	push   $0xf01300fb
f011fc08:	e8 2c 07 fe ff       	call   f0100339 <_panic>
f011fc0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc10:	8b 00                	mov    (%eax),%eax
f011fc12:	85 c0                	test   %eax,%eax
f011fc14:	74 10                	je     f011fc26 <alloc_block_FF+0x30e>
f011fc16:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc19:	8b 00                	mov    (%eax),%eax
f011fc1b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fc1e:	8b 52 04             	mov    0x4(%edx),%edx
f011fc21:	89 50 04             	mov    %edx,0x4(%eax)
f011fc24:	eb 0b                	jmp    f011fc31 <alloc_block_FF+0x319>
f011fc26:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc29:	8b 40 04             	mov    0x4(%eax),%eax
f011fc2c:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f011fc31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc34:	8b 40 04             	mov    0x4(%eax),%eax
f011fc37:	85 c0                	test   %eax,%eax
f011fc39:	74 0f                	je     f011fc4a <alloc_block_FF+0x332>
f011fc3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc3e:	8b 40 04             	mov    0x4(%eax),%eax
f011fc41:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fc44:	8b 12                	mov    (%edx),%edx
f011fc46:	89 10                	mov    %edx,(%eax)
f011fc48:	eb 0a                	jmp    f011fc54 <alloc_block_FF+0x33c>
f011fc4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc4d:	8b 00                	mov    (%eax),%eax
f011fc4f:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f011fc54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc57:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011fc5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc60:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011fc67:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f011fc6c:	48                   	dec    %eax
f011fc6d:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
    				return(void*)(moblock);
f011fc72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc75:	e9 55 02 00 00       	jmp    f011fecf <alloc_block_FF+0x5b7>
	//Your Code is Here...
	uint32 compsize =size+2*sizeof(int);
	struct BlockElement *moblock;
	struct BlockElement *newblock;

    LIST_FOREACH(moblock,&freeBlocksList){
f011fc7a:	a1 98 c5 5e f0       	mov    0xf05ec598,%eax
f011fc7f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011fc82:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fc86:	74 07                	je     f011fc8f <alloc_block_FF+0x377>
f011fc88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc8b:	8b 00                	mov    (%eax),%eax
f011fc8d:	eb 05                	jmp    f011fc94 <alloc_block_FF+0x37c>
f011fc8f:	b8 00 00 00 00       	mov    $0x0,%eax
f011fc94:	a3 98 c5 5e f0       	mov    %eax,0xf05ec598
f011fc99:	a1 98 c5 5e f0       	mov    0xf05ec598,%eax
f011fc9e:	85 c0                	test   %eax,%eax
f011fca0:	0f 85 14 fd ff ff    	jne    f011f9ba <alloc_block_FF+0xa2>
f011fca6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011fcaa:	0f 85 0a fd ff ff    	jne    f011f9ba <alloc_block_FF+0xa2>





    uint32 num=ROUNDUP(size,4*1024)/(4*1024);
f011fcb0:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
f011fcb7:	8b 55 08             	mov    0x8(%ebp),%edx
f011fcba:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011fcbd:	01 d0                	add    %edx,%eax
f011fcbf:	48                   	dec    %eax
f011fcc0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011fcc3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011fcc6:	ba 00 00 00 00       	mov    $0x0,%edx
f011fccb:	f7 75 d8             	divl   -0x28(%ebp)
f011fcce:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011fcd1:	29 d0                	sub    %edx,%eax
f011fcd3:	c1 e8 0c             	shr    $0xc,%eax
f011fcd6:	89 45 d0             	mov    %eax,-0x30(%ebp)
   void* brk = (struct BlockElement*)sbrk(num);
f011fcd9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011fcdc:	83 ec 0c             	sub    $0xc,%esp
f011fcdf:	50                   	push   %eax
f011fce0:	e8 50 90 fe ff       	call   f0108d35 <sbrk>
f011fce5:	83 c4 10             	add    $0x10,%esp
f011fce8:	89 45 cc             	mov    %eax,-0x34(%ebp)
           if (brk == (void*)-1) {
f011fceb:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011fcef:	75 0a                	jne    f011fcfb <alloc_block_FF+0x3e3>

               return NULL;  // sbrk failed
f011fcf1:	b8 00 00 00 00       	mov    $0x0,%eax
f011fcf6:	e9 d4 01 00 00       	jmp    f011fecf <alloc_block_FF+0x5b7>
               }

          // cprintf("here %d----%d\n",num,size);

           struct BlockElement* new_free_block = (struct BlockElement*)(brk);
f011fcfb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011fcfe:	89 45 c8             	mov    %eax,-0x38(%ebp)
           set_block_data(new_free_block, (num*4*1024), 0);
f011fd01:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011fd04:	c1 e0 0c             	shl    $0xc,%eax
f011fd07:	83 ec 04             	sub    $0x4,%esp
f011fd0a:	6a 00                	push   $0x0
f011fd0c:	50                   	push   %eax
f011fd0d:	ff 75 c8             	pushl  -0x38(%ebp)
f011fd10:	e8 b6 fb ff ff       	call   f011f8cb <set_block_data>
f011fd15:	83 c4 10             	add    $0x10,%esp

           LIST_INSERT_TAIL(&freeBlocksList,new_free_block);
f011fd18:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f011fd1c:	75 17                	jne    f011fd35 <alloc_block_FF+0x41d>
f011fd1e:	83 ec 04             	sub    $0x4,%esp
f011fd21:	68 68 01 13 f0       	push   $0xf0130168
f011fd26:	68 0a 01 00 00       	push   $0x10a
f011fd2b:	68 fb 00 13 f0       	push   $0xf01300fb
f011fd30:	e8 04 06 fe ff       	call   f0100339 <_panic>
f011fd35:	8b 15 94 c5 5e f0    	mov    0xf05ec594,%edx
f011fd3b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fd3e:	89 50 04             	mov    %edx,0x4(%eax)
f011fd41:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fd44:	8b 40 04             	mov    0x4(%eax),%eax
f011fd47:	85 c0                	test   %eax,%eax
f011fd49:	74 0c                	je     f011fd57 <alloc_block_FF+0x43f>
f011fd4b:	a1 94 c5 5e f0       	mov    0xf05ec594,%eax
f011fd50:	8b 55 c8             	mov    -0x38(%ebp),%edx
f011fd53:	89 10                	mov    %edx,(%eax)
f011fd55:	eb 08                	jmp    f011fd5f <alloc_block_FF+0x447>
f011fd57:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fd5a:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f011fd5f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fd62:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f011fd67:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fd6a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011fd70:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f011fd75:	40                   	inc    %eax
f011fd76:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
           struct BlockElement*prev;
           //long diff_next = (char*)(va_block->prev_next_info.le_next) - (char*)((char*)va_block+size);
           prev=new_free_block->prev_next_info.le_prev;
f011fd7b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fd7e:	8b 40 04             	mov    0x4(%eax),%eax
f011fd81:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          // print_blocks_list(freeBlocksList);
         if(prev!=NULL&&is_free_block(prev)==1){
f011fd84:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011fd88:	0f 84 04 01 00 00    	je     f011fe92 <alloc_block_FF+0x57a>
f011fd8e:	83 ec 0c             	sub    $0xc,%esp
f011fd91:	ff 75 c4             	pushl  -0x3c(%ebp)
f011fd94:	e8 ca f8 ff ff       	call   f011f663 <is_free_block>
f011fd99:	83 c4 10             	add    $0x10,%esp
f011fd9c:	3c 01                	cmp    $0x1,%al
f011fd9e:	0f 85 ee 00 00 00    	jne    f011fe92 <alloc_block_FF+0x57a>
          // print_blocks_list(freeBlocksList);
        	uint32 size_prev= get_block_size(prev);
f011fda4:	83 ec 0c             	sub    $0xc,%esp
f011fda7:	ff 75 c4             	pushl  -0x3c(%ebp)
f011fdaa:	e8 9b f8 ff ff       	call   f011f64a <get_block_size>
f011fdaf:	83 c4 10             	add    $0x10,%esp
f011fdb2:	89 45 c0             	mov    %eax,-0x40(%ebp)
        	char* prev_end = (char*)prev + size_prev;
f011fdb5:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011fdb8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011fdbb:	01 d0                	add    %edx,%eax
f011fdbd:	89 45 bc             	mov    %eax,-0x44(%ebp)
           long diff = ((char*)(new_free_block)-prev_end);
f011fdc0:	8b 55 c8             	mov    -0x38(%ebp),%edx
f011fdc3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011fdc6:	29 c2                	sub    %eax,%edx
f011fdc8:	89 d0                	mov    %edx,%eax
f011fdca:	89 45 b8             	mov    %eax,-0x48(%ebp)
          // cprintf("prev--%x - prev+size ---%x ---diff%d/n",diff);
         if(diff<4*sizeof(int)&&diff>=0){
f011fdcd:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011fdd0:	83 f8 0f             	cmp    $0xf,%eax
f011fdd3:	0f 87 b9 00 00 00    	ja     f011fe92 <alloc_block_FF+0x57a>
f011fdd9:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f011fddd:	0f 88 af 00 00 00    	js     f011fe92 <alloc_block_FF+0x57a>
        	 	 //	 cprintf("merginggggggg\n");
        	uint32 size_new=get_block_size(new_free_block);
f011fde3:	83 ec 0c             	sub    $0xc,%esp
f011fde6:	ff 75 c8             	pushl  -0x38(%ebp)
f011fde9:	e8 5c f8 ff ff       	call   f011f64a <get_block_size>
f011fdee:	83 c4 10             	add    $0x10,%esp
f011fdf1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        	size_prev+=(num*4*1024);
f011fdf4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011fdf7:	c1 e0 0c             	shl    $0xc,%eax
f011fdfa:	01 45 c0             	add    %eax,-0x40(%ebp)
        	   set_block_data(prev,size_prev,0);
f011fdfd:	83 ec 04             	sub    $0x4,%esp
f011fe00:	6a 00                	push   $0x0
f011fe02:	ff 75 c0             	pushl  -0x40(%ebp)
f011fe05:	ff 75 c4             	pushl  -0x3c(%ebp)
f011fe08:	e8 be fa ff ff       	call   f011f8cb <set_block_data>
f011fe0d:	83 c4 10             	add    $0x10,%esp
        	   LIST_REMOVE(&freeBlocksList,new_free_block);
f011fe10:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f011fe14:	75 17                	jne    f011fe2d <alloc_block_FF+0x515>
f011fe16:	83 ec 04             	sub    $0x4,%esp
f011fe19:	68 13 01 13 f0       	push   $0xf0130113
f011fe1e:	68 1a 01 00 00       	push   $0x11a
f011fe23:	68 fb 00 13 f0       	push   $0xf01300fb
f011fe28:	e8 0c 05 fe ff       	call   f0100339 <_panic>
f011fe2d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fe30:	8b 00                	mov    (%eax),%eax
f011fe32:	85 c0                	test   %eax,%eax
f011fe34:	74 10                	je     f011fe46 <alloc_block_FF+0x52e>
f011fe36:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fe39:	8b 00                	mov    (%eax),%eax
f011fe3b:	8b 55 c8             	mov    -0x38(%ebp),%edx
f011fe3e:	8b 52 04             	mov    0x4(%edx),%edx
f011fe41:	89 50 04             	mov    %edx,0x4(%eax)
f011fe44:	eb 0b                	jmp    f011fe51 <alloc_block_FF+0x539>
f011fe46:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fe49:	8b 40 04             	mov    0x4(%eax),%eax
f011fe4c:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f011fe51:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fe54:	8b 40 04             	mov    0x4(%eax),%eax
f011fe57:	85 c0                	test   %eax,%eax
f011fe59:	74 0f                	je     f011fe6a <alloc_block_FF+0x552>
f011fe5b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fe5e:	8b 40 04             	mov    0x4(%eax),%eax
f011fe61:	8b 55 c8             	mov    -0x38(%ebp),%edx
f011fe64:	8b 12                	mov    (%edx),%edx
f011fe66:	89 10                	mov    %edx,(%eax)
f011fe68:	eb 0a                	jmp    f011fe74 <alloc_block_FF+0x55c>
f011fe6a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fe6d:	8b 00                	mov    (%eax),%eax
f011fe6f:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f011fe74:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fe77:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011fe7d:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011fe80:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f011fe87:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f011fe8c:	48                   	dec    %eax
f011fe8d:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
        	   //set_block_data(new_free_block,0,1);
        	   	   //print_blocks_list(freeBlocksList);
           }}

         struct BlockElement*oldend=(struct BlockElement*)((char*)(sbrk(0)-sizeof(int)));
f011fe92:	83 ec 0c             	sub    $0xc,%esp
f011fe95:	6a 00                	push   $0x0
f011fe97:	e8 99 8e fe ff       	call   f0108d35 <sbrk>
f011fe9c:	83 c4 10             	add    $0x10,%esp
f011fe9f:	83 e8 04             	sub    $0x4,%eax
f011fea2:	89 45 b0             	mov    %eax,-0x50(%ebp)
           	   uint32*new_end=sbrk(0)-sizeof(int);
f011fea5:	83 ec 0c             	sub    $0xc,%esp
f011fea8:	6a 00                	push   $0x0
f011feaa:	e8 86 8e fe ff       	call   f0108d35 <sbrk>
f011feaf:	83 c4 10             	add    $0x10,%esp
f011feb2:	83 e8 04             	sub    $0x4,%eax
f011feb5:	89 45 ac             	mov    %eax,-0x54(%ebp)
           	     *new_end =0x1;
f011feb8:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011febb:	c7 00 01 00 00 00    	movl   $0x1,(%eax)





           return alloc_block_FF(size);
f011fec1:	83 ec 0c             	sub    $0xc,%esp
f011fec4:	ff 75 08             	pushl  0x8(%ebp)
f011fec7:	e8 4c fa ff ff       	call   f011f918 <alloc_block_FF>
f011fecc:	83 c4 10             	add    $0x10,%esp


}
f011fecf:	c9                   	leave  
f011fed0:	c3                   	ret    

f011fed1 <alloc_block_BF>:
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f011fed1:	55                   	push   %ebp
f011fed2:	89 e5                	mov    %esp,%ebp
f011fed4:	83 ec 48             	sub    $0x48,%esp

	    //==================================================================================
	    // DON'T CHANGE THESE LINES ========================================================
	    //==================================================================================
	    {
	        if (size % 2 != 0) size++;
f011fed7:	8b 45 08             	mov    0x8(%ebp),%eax
f011feda:	83 e0 01             	and    $0x1,%eax
f011fedd:	85 c0                	test   %eax,%eax
f011fedf:	74 03                	je     f011fee4 <alloc_block_BF+0x13>
f011fee1:	ff 45 08             	incl   0x8(%ebp)
	        if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f011fee4:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f011fee8:	77 07                	ja     f011fef1 <alloc_block_BF+0x20>
	            size = DYN_ALLOC_MIN_BLOCK_SIZE;
f011feea:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
	        if (!is_initialized) {
f011fef1:	a1 14 c2 5e f0       	mov    0xf05ec214,%eax
f011fef6:	85 c0                	test   %eax,%eax
f011fef8:	75 63                	jne    f011ff5d <alloc_block_BF+0x8c>
	            uint32 required_size = size + 2 * sizeof(int) + 2 * sizeof(int);
f011fefa:	8b 45 08             	mov    0x8(%ebp),%eax
f011fefd:	83 c0 10             	add    $0x10,%eax
f011ff00:	89 45 e8             	mov    %eax,-0x18(%ebp)
	            uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE) / PAGE_SIZE);
f011ff03:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f011ff0a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011ff0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011ff10:	01 d0                	add    %edx,%eax
f011ff12:	48                   	dec    %eax
f011ff13:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011ff16:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ff19:	ba 00 00 00 00       	mov    $0x0,%edx
f011ff1e:	f7 75 e4             	divl   -0x1c(%ebp)
f011ff21:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ff24:	29 d0                	sub    %edx,%eax
f011ff26:	c1 e8 0c             	shr    $0xc,%eax
f011ff29:	83 ec 0c             	sub    $0xc,%esp
f011ff2c:	50                   	push   %eax
f011ff2d:	e8 03 8e fe ff       	call   f0108d35 <sbrk>
f011ff32:	83 c4 10             	add    $0x10,%esp
f011ff35:	89 45 dc             	mov    %eax,-0x24(%ebp)
	            uint32 da_break = (uint32)sbrk(0);
f011ff38:	83 ec 0c             	sub    $0xc,%esp
f011ff3b:	6a 00                	push   $0x0
f011ff3d:	e8 f3 8d fe ff       	call   f0108d35 <sbrk>
f011ff42:	83 c4 10             	add    $0x10,%esp
f011ff45:	89 45 d8             	mov    %eax,-0x28(%ebp)
	            initialize_dynamic_allocator(da_start, da_break - da_start);
f011ff48:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011ff4b:	2b 45 dc             	sub    -0x24(%ebp),%eax
f011ff4e:	83 ec 08             	sub    $0x8,%esp
f011ff51:	50                   	push   %eax
f011ff52:	ff 75 dc             	pushl  -0x24(%ebp)
f011ff55:	e8 54 f8 ff ff       	call   f011f7ae <initialize_dynamic_allocator>
f011ff5a:	83 c4 10             	add    $0x10,%esp
	        }
	    }
	    //==================================================================================
	    //==================================================================================

	    uint32 compsize = size + 2 * sizeof(int);
f011ff5d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff60:	83 c0 08             	add    $0x8,%eax
f011ff63:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	    struct BlockElement* best_fit_block = NULL;
f011ff66:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	    struct BlockElement* current_block;
	    uint32 min_diff = 1e9;
f011ff6d:	c7 45 ec 00 ca 9a 3b 	movl   $0x3b9aca00,-0x14(%ebp)


	    LIST_FOREACH(current_block, &freeBlocksList) {
f011ff74:	a1 90 c5 5e f0       	mov    0xf05ec590,%eax
f011ff79:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011ff7c:	eb 3e                	jmp    f011ffbc <alloc_block_BF+0xeb>
	        uint32 block_size = get_block_size(current_block);
f011ff7e:	83 ec 0c             	sub    $0xc,%esp
f011ff81:	ff 75 f0             	pushl  -0x10(%ebp)
f011ff84:	e8 c1 f6 ff ff       	call   f011f64a <get_block_size>
f011ff89:	83 c4 10             	add    $0x10,%esp
f011ff8c:	89 45 d0             	mov    %eax,-0x30(%ebp)
	        if (block_size >= compsize) {
f011ff8f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ff92:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011ff95:	72 1d                	jb     f011ffb4 <alloc_block_BF+0xe3>
	            uint32 diff = block_size - compsize;
f011ff97:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011ff9a:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011ff9d:	89 45 cc             	mov    %eax,-0x34(%ebp)
	            if (diff < min_diff) {
f011ffa0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ffa3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011ffa6:	73 0c                	jae    f011ffb4 <alloc_block_BF+0xe3>
	                min_diff = diff;
f011ffa8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ffab:	89 45 ec             	mov    %eax,-0x14(%ebp)
	                best_fit_block = current_block;
f011ffae:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ffb1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    struct BlockElement* best_fit_block = NULL;
	    struct BlockElement* current_block;
	    uint32 min_diff = 1e9;


	    LIST_FOREACH(current_block, &freeBlocksList) {
f011ffb4:	a1 98 c5 5e f0       	mov    0xf05ec598,%eax
f011ffb9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011ffbc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ffc0:	74 07                	je     f011ffc9 <alloc_block_BF+0xf8>
f011ffc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ffc5:	8b 00                	mov    (%eax),%eax
f011ffc7:	eb 05                	jmp    f011ffce <alloc_block_BF+0xfd>
f011ffc9:	b8 00 00 00 00       	mov    $0x0,%eax
f011ffce:	a3 98 c5 5e f0       	mov    %eax,0xf05ec598
f011ffd3:	a1 98 c5 5e f0       	mov    0xf05ec598,%eax
f011ffd8:	85 c0                	test   %eax,%eax
f011ffda:	75 a2                	jne    f011ff7e <alloc_block_BF+0xad>
f011ffdc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ffe0:	75 9c                	jne    f011ff7e <alloc_block_BF+0xad>
	            }
	        }
	    }


	    if (best_fit_block == NULL) {
f011ffe2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ffe6:	75 43                	jne    f012002b <alloc_block_BF+0x15a>
	        void* new_mem = (struct BlockElement*)sbrk(compsize);
f011ffe8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011ffeb:	83 ec 0c             	sub    $0xc,%esp
f011ffee:	50                   	push   %eax
f011ffef:	e8 41 8d fe ff       	call   f0108d35 <sbrk>
f011fff4:	83 c4 10             	add    $0x10,%esp
f011fff7:	89 45 c8             	mov    %eax,-0x38(%ebp)
	        if (new_mem == (void*)-1) {
f011fffa:	83 7d c8 ff          	cmpl   $0xffffffff,-0x38(%ebp)
f011fffe:	75 0a                	jne    f012000a <alloc_block_BF+0x139>
	            return NULL;
f0120000:	b8 00 00 00 00       	mov    $0x0,%eax
f0120005:	e9 17 02 00 00       	jmp    f0120221 <alloc_block_BF+0x350>
	        }
	        struct BlockElement* new_block = (struct BlockElement*)new_mem;
f012000a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f012000d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	        set_block_data(new_block, compsize, 1);
f0120010:	83 ec 04             	sub    $0x4,%esp
f0120013:	6a 01                	push   $0x1
f0120015:	ff 75 d4             	pushl  -0x2c(%ebp)
f0120018:	ff 75 c4             	pushl  -0x3c(%ebp)
f012001b:	e8 ab f8 ff ff       	call   f011f8cb <set_block_data>
f0120020:	83 c4 10             	add    $0x10,%esp
	        return (void*)new_block;
f0120023:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0120026:	e9 f6 01 00 00       	jmp    f0120221 <alloc_block_BF+0x350>
	    }


	    if (min_diff == 0) {
f012002b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f012002f:	0f 85 9d 00 00 00    	jne    f01200d2 <alloc_block_BF+0x201>
	        set_block_data(best_fit_block, compsize, 1);
f0120035:	83 ec 04             	sub    $0x4,%esp
f0120038:	6a 01                	push   $0x1
f012003a:	ff 75 d4             	pushl  -0x2c(%ebp)
f012003d:	ff 75 f4             	pushl  -0xc(%ebp)
f0120040:	e8 86 f8 ff ff       	call   f011f8cb <set_block_data>
f0120045:	83 c4 10             	add    $0x10,%esp
	        LIST_REMOVE(&freeBlocksList, best_fit_block);
f0120048:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f012004c:	75 17                	jne    f0120065 <alloc_block_BF+0x194>
f012004e:	83 ec 04             	sub    $0x4,%esp
f0120051:	68 13 01 13 f0       	push   $0xf0130113
f0120056:	68 65 01 00 00       	push   $0x165
f012005b:	68 fb 00 13 f0       	push   $0xf01300fb
f0120060:	e8 d4 02 fe ff       	call   f0100339 <_panic>
f0120065:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120068:	8b 00                	mov    (%eax),%eax
f012006a:	85 c0                	test   %eax,%eax
f012006c:	74 10                	je     f012007e <alloc_block_BF+0x1ad>
f012006e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120071:	8b 00                	mov    (%eax),%eax
f0120073:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120076:	8b 52 04             	mov    0x4(%edx),%edx
f0120079:	89 50 04             	mov    %edx,0x4(%eax)
f012007c:	eb 0b                	jmp    f0120089 <alloc_block_BF+0x1b8>
f012007e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120081:	8b 40 04             	mov    0x4(%eax),%eax
f0120084:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f0120089:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012008c:	8b 40 04             	mov    0x4(%eax),%eax
f012008f:	85 c0                	test   %eax,%eax
f0120091:	74 0f                	je     f01200a2 <alloc_block_BF+0x1d1>
f0120093:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120096:	8b 40 04             	mov    0x4(%eax),%eax
f0120099:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012009c:	8b 12                	mov    (%edx),%edx
f012009e:	89 10                	mov    %edx,(%eax)
f01200a0:	eb 0a                	jmp    f01200ac <alloc_block_BF+0x1db>
f01200a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01200a5:	8b 00                	mov    (%eax),%eax
f01200a7:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f01200ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01200af:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01200b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01200b8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01200bf:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f01200c4:	48                   	dec    %eax
f01200c5:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
	        return (void*)best_fit_block;
f01200ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01200cd:	e9 4f 01 00 00       	jmp    f0120221 <alloc_block_BF+0x350>
	    }


	    if (min_diff >= 4 * sizeof(int)) {
f01200d2:	83 7d ec 0f          	cmpl   $0xf,-0x14(%ebp)
f01200d6:	0f 86 a1 00 00 00    	jbe    f012017d <alloc_block_BF+0x2ac>
	        struct BlockElement* remaining_block = (struct BlockElement*)((char*)best_fit_block + compsize);
f01200dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01200df:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01200e2:	01 d0                	add    %edx,%eax
f01200e4:	89 45 c0             	mov    %eax,-0x40(%ebp)
	        set_block_data(best_fit_block, compsize, 1);
f01200e7:	83 ec 04             	sub    $0x4,%esp
f01200ea:	6a 01                	push   $0x1
f01200ec:	ff 75 d4             	pushl  -0x2c(%ebp)
f01200ef:	ff 75 f4             	pushl  -0xc(%ebp)
f01200f2:	e8 d4 f7 ff ff       	call   f011f8cb <set_block_data>
f01200f7:	83 c4 10             	add    $0x10,%esp
	        set_block_data(remaining_block, min_diff, 0);
f01200fa:	83 ec 04             	sub    $0x4,%esp
f01200fd:	6a 00                	push   $0x0
f01200ff:	ff 75 ec             	pushl  -0x14(%ebp)
f0120102:	ff 75 c0             	pushl  -0x40(%ebp)
f0120105:	e8 c1 f7 ff ff       	call   f011f8cb <set_block_data>
f012010a:	83 c4 10             	add    $0x10,%esp
	        LIST_INSERT_AFTER(&freeBlocksList, best_fit_block, remaining_block);
f012010d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120111:	74 06                	je     f0120119 <alloc_block_BF+0x248>
f0120113:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0120117:	75 17                	jne    f0120130 <alloc_block_BF+0x25f>
f0120119:	83 ec 04             	sub    $0x4,%esp
f012011c:	68 34 01 13 f0       	push   $0xf0130134
f0120121:	68 6e 01 00 00       	push   $0x16e
f0120126:	68 fb 00 13 f0       	push   $0xf01300fb
f012012b:	e8 09 02 fe ff       	call   f0100339 <_panic>
f0120130:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120133:	8b 10                	mov    (%eax),%edx
f0120135:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120138:	89 10                	mov    %edx,(%eax)
f012013a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012013d:	8b 00                	mov    (%eax),%eax
f012013f:	85 c0                	test   %eax,%eax
f0120141:	74 0b                	je     f012014e <alloc_block_BF+0x27d>
f0120143:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120146:	8b 00                	mov    (%eax),%eax
f0120148:	8b 55 c0             	mov    -0x40(%ebp),%edx
f012014b:	89 50 04             	mov    %edx,0x4(%eax)
f012014e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120151:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0120154:	89 10                	mov    %edx,(%eax)
f0120156:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120159:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012015c:	89 50 04             	mov    %edx,0x4(%eax)
f012015f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0120162:	8b 00                	mov    (%eax),%eax
f0120164:	85 c0                	test   %eax,%eax
f0120166:	75 08                	jne    f0120170 <alloc_block_BF+0x29f>
f0120168:	8b 45 c0             	mov    -0x40(%ebp),%eax
f012016b:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f0120170:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f0120175:	40                   	inc    %eax
f0120176:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
f012017b:	eb 1f                	jmp    f012019c <alloc_block_BF+0x2cb>
	    } else {

	        set_block_data(best_fit_block, get_block_size(best_fit_block), 1);
f012017d:	83 ec 0c             	sub    $0xc,%esp
f0120180:	ff 75 f4             	pushl  -0xc(%ebp)
f0120183:	e8 c2 f4 ff ff       	call   f011f64a <get_block_size>
f0120188:	83 c4 10             	add    $0x10,%esp
f012018b:	83 ec 04             	sub    $0x4,%esp
f012018e:	6a 01                	push   $0x1
f0120190:	50                   	push   %eax
f0120191:	ff 75 f4             	pushl  -0xc(%ebp)
f0120194:	e8 32 f7 ff ff       	call   f011f8cb <set_block_data>
f0120199:	83 c4 10             	add    $0x10,%esp
	    }


	    LIST_REMOVE(&freeBlocksList, best_fit_block);
f012019c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01201a0:	75 17                	jne    f01201b9 <alloc_block_BF+0x2e8>
f01201a2:	83 ec 04             	sub    $0x4,%esp
f01201a5:	68 13 01 13 f0       	push   $0xf0130113
f01201aa:	68 75 01 00 00       	push   $0x175
f01201af:	68 fb 00 13 f0       	push   $0xf01300fb
f01201b4:	e8 80 01 fe ff       	call   f0100339 <_panic>
f01201b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01201bc:	8b 00                	mov    (%eax),%eax
f01201be:	85 c0                	test   %eax,%eax
f01201c0:	74 10                	je     f01201d2 <alloc_block_BF+0x301>
f01201c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01201c5:	8b 00                	mov    (%eax),%eax
f01201c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01201ca:	8b 52 04             	mov    0x4(%edx),%edx
f01201cd:	89 50 04             	mov    %edx,0x4(%eax)
f01201d0:	eb 0b                	jmp    f01201dd <alloc_block_BF+0x30c>
f01201d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01201d5:	8b 40 04             	mov    0x4(%eax),%eax
f01201d8:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f01201dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01201e0:	8b 40 04             	mov    0x4(%eax),%eax
f01201e3:	85 c0                	test   %eax,%eax
f01201e5:	74 0f                	je     f01201f6 <alloc_block_BF+0x325>
f01201e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01201ea:	8b 40 04             	mov    0x4(%eax),%eax
f01201ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01201f0:	8b 12                	mov    (%edx),%edx
f01201f2:	89 10                	mov    %edx,(%eax)
f01201f4:	eb 0a                	jmp    f0120200 <alloc_block_BF+0x32f>
f01201f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01201f9:	8b 00                	mov    (%eax),%eax
f01201fb:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f0120200:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120203:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120209:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012020c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120213:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f0120218:	48                   	dec    %eax
f0120219:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
	    return (void*)best_fit_block;
f012021e:	8b 45 f4             	mov    -0xc(%ebp),%eax
	}
f0120221:	c9                   	leave  
f0120222:	c3                   	ret    

f0120223 <free_block>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f0120223:	55                   	push   %ebp
f0120224:	89 e5                	mov    %esp,%ebp
f0120226:	53                   	push   %ebx
f0120227:	83 ec 24             	sub    $0x24,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("free_block is not implemented yet");
	//Your Code is Here...
	struct BlockElement* block;
	if (va!=NULL){
f012022a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f012022e:	0f 84 73 05 00 00    	je     f01207a7 <free_block+0x584>
	uint32 size =get_block_size(va);
f0120234:	ff 75 08             	pushl  0x8(%ebp)
f0120237:	e8 0e f4 ff ff       	call   f011f64a <get_block_size>
f012023c:	83 c4 04             	add    $0x4,%esp
f012023f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	set_block_data(va,size,0);//set free block
f0120242:	6a 00                	push   $0x0
f0120244:	ff 75 f0             	pushl  -0x10(%ebp)
f0120247:	ff 75 08             	pushl  0x8(%ebp)
f012024a:	e8 7c f6 ff ff       	call   f011f8cb <set_block_data>
f012024f:	83 c4 0c             	add    $0xc,%esp
	struct BlockElement* va_block=(struct BlockElement*)va;
f0120252:	8b 45 08             	mov    0x8(%ebp),%eax
f0120255:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct BlockElement* prev;
	uint32 newsize;
	//cprintf("here before each\n");
	LIST_FOREACH(block,&freeBlocksList){
f0120258:	a1 90 c5 5e f0       	mov    0xf05ec590,%eax
f012025d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120260:	e9 bb 03 00 00       	jmp    f0120620 <free_block+0x3fd>
		if (va_block<block){
f0120265:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120268:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f012026b:	0f 83 a7 03 00 00    	jae    f0120618 <free_block+0x3f5>
			set_block_data(va_block,size,0);
f0120271:	6a 00                	push   $0x0
f0120273:	ff 75 f0             	pushl  -0x10(%ebp)
f0120276:	ff 75 ec             	pushl  -0x14(%ebp)
f0120279:	e8 4d f6 ff ff       	call   f011f8cb <set_block_data>
f012027e:	83 c4 0c             	add    $0xc,%esp
			LIST_INSERT_BEFORE(&freeBlocksList,block,va_block);
f0120281:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120285:	74 06                	je     f012028d <free_block+0x6a>
f0120287:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f012028b:	75 17                	jne    f01202a4 <free_block+0x81>
f012028d:	83 ec 04             	sub    $0x4,%esp
f0120290:	68 8c 01 13 f0       	push   $0xf013018c
f0120295:	68 92 01 00 00       	push   $0x192
f012029a:	68 fb 00 13 f0       	push   $0xf01300fb
f012029f:	e8 95 00 fe ff       	call   f0100339 <_panic>
f01202a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01202a7:	8b 50 04             	mov    0x4(%eax),%edx
f01202aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01202ad:	89 50 04             	mov    %edx,0x4(%eax)
f01202b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01202b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01202b6:	89 10                	mov    %edx,(%eax)
f01202b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01202bb:	8b 40 04             	mov    0x4(%eax),%eax
f01202be:	85 c0                	test   %eax,%eax
f01202c0:	74 0d                	je     f01202cf <free_block+0xac>
f01202c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01202c5:	8b 40 04             	mov    0x4(%eax),%eax
f01202c8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01202cb:	89 10                	mov    %edx,(%eax)
f01202cd:	eb 08                	jmp    f01202d7 <free_block+0xb4>
f01202cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01202d2:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f01202d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01202da:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01202dd:	89 50 04             	mov    %edx,0x4(%eax)
f01202e0:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f01202e5:	40                   	inc    %eax
f01202e6:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
			long diff_next = (char*)(va_block->prev_next_info.le_next) - (char*)((char*)va_block+size);
f01202eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01202ee:	8b 00                	mov    (%eax),%eax
f01202f0:	89 c1                	mov    %eax,%ecx
f01202f2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01202f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01202f8:	01 d0                	add    %edx,%eax
f01202fa:	29 c1                	sub    %eax,%ecx
f01202fc:	89 c8                	mov    %ecx,%eax
f01202fe:	89 45 dc             	mov    %eax,-0x24(%ebp)
			long diff_prev = (char*)((char*)va_block->prev_next_info.le_prev+get_block_size(va_block->prev_next_info.le_prev)) - (char*)(va_block);
f0120301:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120304:	8b 58 04             	mov    0x4(%eax),%ebx
f0120307:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012030a:	8b 40 04             	mov    0x4(%eax),%eax
f012030d:	83 ec 0c             	sub    $0xc,%esp
f0120310:	50                   	push   %eax
f0120311:	e8 34 f3 ff ff       	call   f011f64a <get_block_size>
f0120316:	83 c4 10             	add    $0x10,%esp
f0120319:	01 d8                	add    %ebx,%eax
f012031b:	89 c2                	mov    %eax,%edx
f012031d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120320:	29 c2                	sub    %eax,%edx
f0120322:	89 d0                	mov    %edx,%eax
f0120324:	89 45 d8             	mov    %eax,-0x28(%ebp)
			//cprintf("here\n");
			if (diff_next<(4*sizeof(int))&&(diff_prev<(4*sizeof(int)))){
f0120327:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012032a:	83 f8 0f             	cmp    $0xf,%eax
f012032d:	0f 87 5b 01 00 00    	ja     f012048e <free_block+0x26b>
f0120333:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0120336:	83 f8 0f             	cmp    $0xf,%eax
f0120339:	0f 87 4f 01 00 00    	ja     f012048e <free_block+0x26b>
				//both merge
				struct BlockElement *mos;



				newsize=get_block_size(va_block->prev_next_info.le_next);
f012033f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120342:	8b 00                	mov    (%eax),%eax
f0120344:	83 ec 0c             	sub    $0xc,%esp
f0120347:	50                   	push   %eax
f0120348:	e8 fd f2 ff ff       	call   f011f64a <get_block_size>
f012034d:	83 c4 10             	add    $0x10,%esp
f0120350:	89 45 e0             	mov    %eax,-0x20(%ebp)
				newsize+=get_block_size(va_block->prev_next_info.le_prev);
f0120353:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120356:	8b 40 04             	mov    0x4(%eax),%eax
f0120359:	83 ec 0c             	sub    $0xc,%esp
f012035c:	50                   	push   %eax
f012035d:	e8 e8 f2 ff ff       	call   f011f64a <get_block_size>
f0120362:	83 c4 10             	add    $0x10,%esp
f0120365:	01 45 e0             	add    %eax,-0x20(%ebp)
				newsize+=size;
f0120368:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012036b:	01 45 e0             	add    %eax,-0x20(%ebp)

				set_block_data(va_block->prev_next_info.le_prev,newsize,0);
f012036e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120371:	8b 40 04             	mov    0x4(%eax),%eax
f0120374:	83 ec 04             	sub    $0x4,%esp
f0120377:	6a 00                	push   $0x0
f0120379:	ff 75 e0             	pushl  -0x20(%ebp)
f012037c:	50                   	push   %eax
f012037d:	e8 49 f5 ff ff       	call   f011f8cb <set_block_data>
f0120382:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&freeBlocksList,block);
f0120385:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120389:	75 17                	jne    f01203a2 <free_block+0x17f>
f012038b:	83 ec 04             	sub    $0x4,%esp
f012038e:	68 13 01 13 f0       	push   $0xf0130113
f0120393:	68 a2 01 00 00       	push   $0x1a2
f0120398:	68 fb 00 13 f0       	push   $0xf01300fb
f012039d:	e8 97 ff fd ff       	call   f0100339 <_panic>
f01203a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203a5:	8b 00                	mov    (%eax),%eax
f01203a7:	85 c0                	test   %eax,%eax
f01203a9:	74 10                	je     f01203bb <free_block+0x198>
f01203ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203ae:	8b 00                	mov    (%eax),%eax
f01203b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01203b3:	8b 52 04             	mov    0x4(%edx),%edx
f01203b6:	89 50 04             	mov    %edx,0x4(%eax)
f01203b9:	eb 0b                	jmp    f01203c6 <free_block+0x1a3>
f01203bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203be:	8b 40 04             	mov    0x4(%eax),%eax
f01203c1:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f01203c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203c9:	8b 40 04             	mov    0x4(%eax),%eax
f01203cc:	85 c0                	test   %eax,%eax
f01203ce:	74 0f                	je     f01203df <free_block+0x1bc>
f01203d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203d3:	8b 40 04             	mov    0x4(%eax),%eax
f01203d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01203d9:	8b 12                	mov    (%edx),%edx
f01203db:	89 10                	mov    %edx,(%eax)
f01203dd:	eb 0a                	jmp    f01203e9 <free_block+0x1c6>
f01203df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203e2:	8b 00                	mov    (%eax),%eax
f01203e4:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f01203e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203ec:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01203f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203f5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01203fc:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f0120401:	48                   	dec    %eax
f0120402:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
				LIST_REMOVE(&freeBlocksList,va_block);
f0120407:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f012040b:	75 17                	jne    f0120424 <free_block+0x201>
f012040d:	83 ec 04             	sub    $0x4,%esp
f0120410:	68 13 01 13 f0       	push   $0xf0130113
f0120415:	68 a3 01 00 00       	push   $0x1a3
f012041a:	68 fb 00 13 f0       	push   $0xf01300fb
f012041f:	e8 15 ff fd ff       	call   f0100339 <_panic>
f0120424:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120427:	8b 00                	mov    (%eax),%eax
f0120429:	85 c0                	test   %eax,%eax
f012042b:	74 10                	je     f012043d <free_block+0x21a>
f012042d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120430:	8b 00                	mov    (%eax),%eax
f0120432:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120435:	8b 52 04             	mov    0x4(%edx),%edx
f0120438:	89 50 04             	mov    %edx,0x4(%eax)
f012043b:	eb 0b                	jmp    f0120448 <free_block+0x225>
f012043d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120440:	8b 40 04             	mov    0x4(%eax),%eax
f0120443:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f0120448:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012044b:	8b 40 04             	mov    0x4(%eax),%eax
f012044e:	85 c0                	test   %eax,%eax
f0120450:	74 0f                	je     f0120461 <free_block+0x23e>
f0120452:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120455:	8b 40 04             	mov    0x4(%eax),%eax
f0120458:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012045b:	8b 12                	mov    (%edx),%edx
f012045d:	89 10                	mov    %edx,(%eax)
f012045f:	eb 0a                	jmp    f012046b <free_block+0x248>
f0120461:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120464:	8b 00                	mov    (%eax),%eax
f0120466:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f012046b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012046e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120474:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120477:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012047e:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f0120483:	48                   	dec    %eax
f0120484:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
				//cprintf("both");


				return;
f0120489:	e9 19 03 00 00       	jmp    f01207a7 <free_block+0x584>

			}
			else if (diff_next<(4*sizeof(int))){
f012048e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120491:	83 f8 0f             	cmp    $0xf,%eax
f0120494:	0f 87 b4 00 00 00    	ja     f012054e <free_block+0x32b>
				//just next merge
				newsize=get_block_size(va_block->prev_next_info.le_next);
f012049a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012049d:	8b 00                	mov    (%eax),%eax
f012049f:	83 ec 0c             	sub    $0xc,%esp
f01204a2:	50                   	push   %eax
f01204a3:	e8 a2 f1 ff ff       	call   f011f64a <get_block_size>
f01204a8:	83 c4 10             	add    $0x10,%esp
f01204ab:	89 45 e0             	mov    %eax,-0x20(%ebp)
				newsize+=size;
f01204ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01204b1:	01 45 e0             	add    %eax,-0x20(%ebp)
				set_block_data(va_block,newsize,0);
f01204b4:	83 ec 04             	sub    $0x4,%esp
f01204b7:	6a 00                	push   $0x0
f01204b9:	ff 75 e0             	pushl  -0x20(%ebp)
f01204bc:	ff 75 ec             	pushl  -0x14(%ebp)
f01204bf:	e8 07 f4 ff ff       	call   f011f8cb <set_block_data>
f01204c4:	83 c4 10             	add    $0x10,%esp
				//LIST_INSERT_BEFORE(&freeBlocksList,va_block->prev_next_info.le_next,va_block);
				LIST_REMOVE(&freeBlocksList,block);
f01204c7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01204cb:	75 17                	jne    f01204e4 <free_block+0x2c1>
f01204cd:	83 ec 04             	sub    $0x4,%esp
f01204d0:	68 13 01 13 f0       	push   $0xf0130113
f01204d5:	68 b0 01 00 00       	push   $0x1b0
f01204da:	68 fb 00 13 f0       	push   $0xf01300fb
f01204df:	e8 55 fe fd ff       	call   f0100339 <_panic>
f01204e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01204e7:	8b 00                	mov    (%eax),%eax
f01204e9:	85 c0                	test   %eax,%eax
f01204eb:	74 10                	je     f01204fd <free_block+0x2da>
f01204ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01204f0:	8b 00                	mov    (%eax),%eax
f01204f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01204f5:	8b 52 04             	mov    0x4(%edx),%edx
f01204f8:	89 50 04             	mov    %edx,0x4(%eax)
f01204fb:	eb 0b                	jmp    f0120508 <free_block+0x2e5>
f01204fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120500:	8b 40 04             	mov    0x4(%eax),%eax
f0120503:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f0120508:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012050b:	8b 40 04             	mov    0x4(%eax),%eax
f012050e:	85 c0                	test   %eax,%eax
f0120510:	74 0f                	je     f0120521 <free_block+0x2fe>
f0120512:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120515:	8b 40 04             	mov    0x4(%eax),%eax
f0120518:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012051b:	8b 12                	mov    (%edx),%edx
f012051d:	89 10                	mov    %edx,(%eax)
f012051f:	eb 0a                	jmp    f012052b <free_block+0x308>
f0120521:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120524:	8b 00                	mov    (%eax),%eax
f0120526:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f012052b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012052e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120534:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120537:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f012053e:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f0120543:	48                   	dec    %eax
f0120544:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
				//cprintf("just next/n");
				return;
f0120549:	e9 59 02 00 00       	jmp    f01207a7 <free_block+0x584>

			}
			else if(diff_prev<(4*sizeof(int))){
f012054e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0120551:	83 f8 0f             	cmp    $0xf,%eax
f0120554:	0f 87 4c 02 00 00    	ja     f01207a6 <free_block+0x583>
				//just prev
				prev=va_block->prev_next_info.le_prev;
f012055a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012055d:	8b 40 04             	mov    0x4(%eax),%eax
f0120560:	89 45 e8             	mov    %eax,-0x18(%ebp)

				newsize=get_block_size(va_block->prev_next_info.le_prev);
f0120563:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120566:	8b 40 04             	mov    0x4(%eax),%eax
f0120569:	83 ec 0c             	sub    $0xc,%esp
f012056c:	50                   	push   %eax
f012056d:	e8 d8 f0 ff ff       	call   f011f64a <get_block_size>
f0120572:	83 c4 10             	add    $0x10,%esp
f0120575:	89 45 e0             	mov    %eax,-0x20(%ebp)
				newsize+=size;
f0120578:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012057b:	01 45 e0             	add    %eax,-0x20(%ebp)
			//	cprintf("the new size %d-----size%d\n",newsize ,size);
				//cprintf("herrrrrrrrrrrrrrrr---------------------->%x\n",alloc_block_FF(get_block_size(prev)));
				//cprintf("the size before edit%d\n",get_block_size(prev));
				set_block_data(prev,newsize,0);
f012057e:	83 ec 04             	sub    $0x4,%esp
f0120581:	6a 00                	push   $0x0
f0120583:	ff 75 e0             	pushl  -0x20(%ebp)
f0120586:	ff 75 e8             	pushl  -0x18(%ebp)
f0120589:	e8 3d f3 ff ff       	call   f011f8cb <set_block_data>
f012058e:	83 c4 10             	add    $0x10,%esp
				//cprintf("the size AFTERedit%d\n",get_block_size(prev));

				LIST_REMOVE(&freeBlocksList,va_block);
f0120591:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0120595:	75 17                	jne    f01205ae <free_block+0x38b>
f0120597:	83 ec 04             	sub    $0x4,%esp
f012059a:	68 13 01 13 f0       	push   $0xf0130113
f012059f:	68 c1 01 00 00       	push   $0x1c1
f01205a4:	68 fb 00 13 f0       	push   $0xf01300fb
f01205a9:	e8 8b fd fd ff       	call   f0100339 <_panic>
f01205ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01205b1:	8b 00                	mov    (%eax),%eax
f01205b3:	85 c0                	test   %eax,%eax
f01205b5:	74 10                	je     f01205c7 <free_block+0x3a4>
f01205b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01205ba:	8b 00                	mov    (%eax),%eax
f01205bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01205bf:	8b 52 04             	mov    0x4(%edx),%edx
f01205c2:	89 50 04             	mov    %edx,0x4(%eax)
f01205c5:	eb 0b                	jmp    f01205d2 <free_block+0x3af>
f01205c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01205ca:	8b 40 04             	mov    0x4(%eax),%eax
f01205cd:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f01205d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01205d5:	8b 40 04             	mov    0x4(%eax),%eax
f01205d8:	85 c0                	test   %eax,%eax
f01205da:	74 0f                	je     f01205eb <free_block+0x3c8>
f01205dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01205df:	8b 40 04             	mov    0x4(%eax),%eax
f01205e2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01205e5:	8b 12                	mov    (%edx),%edx
f01205e7:	89 10                	mov    %edx,(%eax)
f01205e9:	eb 0a                	jmp    f01205f5 <free_block+0x3d2>
f01205eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01205ee:	8b 00                	mov    (%eax),%eax
f01205f0:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f01205f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01205f8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01205fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120601:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120608:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f012060d:	48                   	dec    %eax
f012060e:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
				//cprintf("size AFTER REmove %d",LIST_SIZE(&freeBlocksList));
				//cprintf("justprev\n");

				return;
f0120613:	e9 8f 01 00 00       	jmp    f01207a7 <free_block+0x584>
	set_block_data(va,size,0);//set free block
	struct BlockElement* va_block=(struct BlockElement*)va;
	struct BlockElement* prev;
	uint32 newsize;
	//cprintf("here before each\n");
	LIST_FOREACH(block,&freeBlocksList){
f0120618:	a1 98 c5 5e f0       	mov    0xf05ec598,%eax
f012061d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120620:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120624:	74 07                	je     f012062d <free_block+0x40a>
f0120626:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120629:	8b 00                	mov    (%eax),%eax
f012062b:	eb 05                	jmp    f0120632 <free_block+0x40f>
f012062d:	b8 00 00 00 00       	mov    $0x0,%eax
f0120632:	a3 98 c5 5e f0       	mov    %eax,0xf05ec598
f0120637:	a1 98 c5 5e f0       	mov    0xf05ec598,%eax
f012063c:	85 c0                	test   %eax,%eax
f012063e:	0f 85 21 fc ff ff    	jne    f0120265 <free_block+0x42>
f0120644:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0120648:	0f 85 17 fc ff ff    	jne    f0120265 <free_block+0x42>

			}
		}
	}

	set_block_data(va_block,size,0);
f012064e:	83 ec 04             	sub    $0x4,%esp
f0120651:	6a 00                	push   $0x0
f0120653:	ff 75 f0             	pushl  -0x10(%ebp)
f0120656:	ff 75 ec             	pushl  -0x14(%ebp)
f0120659:	e8 6d f2 ff ff       	call   f011f8cb <set_block_data>
f012065e:	83 c4 10             	add    $0x10,%esp
	//cprintf("size before insert\n %d",LIST_SIZE(&freeBlocksList));
	LIST_INSERT_TAIL(&freeBlocksList,va_block);
f0120661:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0120665:	75 17                	jne    f012067e <free_block+0x45b>
f0120667:	83 ec 04             	sub    $0x4,%esp
f012066a:	68 68 01 13 f0       	push   $0xf0130168
f012066f:	68 d1 01 00 00       	push   $0x1d1
f0120674:	68 fb 00 13 f0       	push   $0xf01300fb
f0120679:	e8 bb fc fd ff       	call   f0100339 <_panic>
f012067e:	8b 15 94 c5 5e f0    	mov    0xf05ec594,%edx
f0120684:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120687:	89 50 04             	mov    %edx,0x4(%eax)
f012068a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012068d:	8b 40 04             	mov    0x4(%eax),%eax
f0120690:	85 c0                	test   %eax,%eax
f0120692:	74 0c                	je     f01206a0 <free_block+0x47d>
f0120694:	a1 94 c5 5e f0       	mov    0xf05ec594,%eax
f0120699:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012069c:	89 10                	mov    %edx,(%eax)
f012069e:	eb 08                	jmp    f01206a8 <free_block+0x485>
f01206a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01206a3:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f01206a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01206ab:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f01206b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01206b3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01206b9:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f01206be:	40                   	inc    %eax
f01206bf:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
	//cprintf((void*)(va_block-va_block->prev_next_info.le_prev));
	prev=va_block->prev_next_info.le_prev;
f01206c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01206c7:	8b 40 04             	mov    0x4(%eax),%eax
f01206ca:	89 45 e8             	mov    %eax,-0x18(%ebp)
	//cprintf("size AFTER insert\n %d",LIST_SIZE(&freeBlocksList));
	//cprintf("Address of va_block: %ld\n", (void*)get_block_size(prev));
//	cprintf("Address of prev: %p\n", (void*)prev);
//	cprintf("Address of prev+size: %p\n", (void*)((char*)prev+get_block_size(prev)));
	long diff = (char*)(va_block) - (char*)((char*)prev+get_block_size(prev));
f01206cd:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f01206d0:	83 ec 0c             	sub    $0xc,%esp
f01206d3:	ff 75 e8             	pushl  -0x18(%ebp)
f01206d6:	e8 6f ef ff ff       	call   f011f64a <get_block_size>
f01206db:	83 c4 10             	add    $0x10,%esp
f01206de:	89 c2                	mov    %eax,%edx
f01206e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01206e3:	01 d0                	add    %edx,%eax
f01206e5:	29 c3                	sub    %eax,%ebx
f01206e7:	89 d8                	mov    %ebx,%eax
f01206e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	//cprintf("sub of va_block: %ld\n", (diff));
	if (diff<4*sizeof(int)){
f01206ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01206ef:	83 f8 0f             	cmp    $0xf,%eax
f01206f2:	0f 87 af 00 00 00    	ja     f01207a7 <free_block+0x584>
		//cprintf("anan heene\n");
		//prev=va_block->prev_next_info.le_prev;
		newsize=get_block_size(prev);
f01206f8:	83 ec 0c             	sub    $0xc,%esp
f01206fb:	ff 75 e8             	pushl  -0x18(%ebp)
f01206fe:	e8 47 ef ff ff       	call   f011f64a <get_block_size>
f0120703:	83 c4 10             	add    $0x10,%esp
f0120706:	89 45 e0             	mov    %eax,-0x20(%ebp)
		newsize+=size;
f0120709:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012070c:	01 45 e0             	add    %eax,-0x20(%ebp)
		LIST_REMOVE(&freeBlocksList,va_block);
f012070f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0120713:	75 17                	jne    f012072c <free_block+0x509>
f0120715:	83 ec 04             	sub    $0x4,%esp
f0120718:	68 13 01 13 f0       	push   $0xf0130113
f012071d:	68 df 01 00 00       	push   $0x1df
f0120722:	68 fb 00 13 f0       	push   $0xf01300fb
f0120727:	e8 0d fc fd ff       	call   f0100339 <_panic>
f012072c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012072f:	8b 00                	mov    (%eax),%eax
f0120731:	85 c0                	test   %eax,%eax
f0120733:	74 10                	je     f0120745 <free_block+0x522>
f0120735:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120738:	8b 00                	mov    (%eax),%eax
f012073a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f012073d:	8b 52 04             	mov    0x4(%edx),%edx
f0120740:	89 50 04             	mov    %edx,0x4(%eax)
f0120743:	eb 0b                	jmp    f0120750 <free_block+0x52d>
f0120745:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120748:	8b 40 04             	mov    0x4(%eax),%eax
f012074b:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f0120750:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120753:	8b 40 04             	mov    0x4(%eax),%eax
f0120756:	85 c0                	test   %eax,%eax
f0120758:	74 0f                	je     f0120769 <free_block+0x546>
f012075a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012075d:	8b 40 04             	mov    0x4(%eax),%eax
f0120760:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120763:	8b 12                	mov    (%edx),%edx
f0120765:	89 10                	mov    %edx,(%eax)
f0120767:	eb 0a                	jmp    f0120773 <free_block+0x550>
f0120769:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012076c:	8b 00                	mov    (%eax),%eax
f012076e:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f0120773:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120776:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f012077c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012077f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120786:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f012078b:	48                   	dec    %eax
f012078c:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
		//cprintf("size AFTER REmove \n%d",LIST_SIZE(&freeBlocksList));
		set_block_data(prev,newsize,0);
f0120791:	83 ec 04             	sub    $0x4,%esp
f0120794:	6a 00                	push   $0x0
f0120796:	ff 75 e0             	pushl  -0x20(%ebp)
f0120799:	ff 75 e8             	pushl  -0x18(%ebp)
f012079c:	e8 2a f1 ff ff       	call   f011f8cb <set_block_data>
f01207a1:	83 c4 10             	add    $0x10,%esp
f01207a4:	eb 01                	jmp    f01207a7 <free_block+0x584>

				return;
			}
			else {

				return;
f01207a6:	90                   	nop
		set_block_data(prev,newsize,0);
		//LIST_INSERT_TAIL(&freeBlocksList,prev);
		//cprintf("size AFTER insert\n %d",LIST_SIZE(&freeBlocksList));

	}
}}
f01207a7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01207aa:	c9                   	leave  
f01207ab:	c3                   	ret    

f01207ac <realloc_block_FF>:
//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void *realloc_block_FF(void* va, uint32 new_size)
{
f01207ac:	55                   	push   %ebp
f01207ad:	89 e5                	mov    %esp,%ebp
f01207af:	83 ec 38             	sub    $0x38,%esp
	//TODO: [PROJECT'24.MS1 - #08] [3] DYNAMIC ALLOCATOR - realloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	//panic("realloc_block_FF is not implemented yet");
	//Your Code is Here...
	// cprintf("(size: %d, isFree: %d)\n", next, va) ;
	    if (va == NULL) {
f01207b2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01207b6:	75 23                	jne    f01207db <realloc_block_FF+0x2f>
	    	//cprintf("(size: %d, NULxxxxxxxLLLL: %d)\n", next, va) ;
	        return (new_size == 0) ? NULL : alloc_block_FF(new_size);
f01207b8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01207bc:	74 13                	je     f01207d1 <realloc_block_FF+0x25>
f01207be:	83 ec 0c             	sub    $0xc,%esp
f01207c1:	ff 75 0c             	pushl  0xc(%ebp)
f01207c4:	e8 4f f1 ff ff       	call   f011f918 <alloc_block_FF>
f01207c9:	83 c4 10             	add    $0x10,%esp
f01207cc:	e9 af 02 00 00       	jmp    f0120a80 <realloc_block_FF+0x2d4>
f01207d1:	b8 00 00 00 00       	mov    $0x0,%eax
f01207d6:	e9 a5 02 00 00       	jmp    f0120a80 <realloc_block_FF+0x2d4>
	        //cprintf("(size: %d, SUIIIIIIIIL: %d)\n", next, va) ;
	        //	return NULL ;
	    }


	    if (new_size == 0) {
f01207db:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01207df:	75 18                	jne    f01207f9 <realloc_block_FF+0x4d>
	        free_block(va);
f01207e1:	83 ec 0c             	sub    $0xc,%esp
f01207e4:	ff 75 08             	pushl  0x8(%ebp)
f01207e7:	e8 37 fa ff ff       	call   f0120223 <free_block>
f01207ec:	83 c4 10             	add    $0x10,%esp
	        return NULL;
f01207ef:	b8 00 00 00 00       	mov    $0x0,%eax
f01207f4:	e9 87 02 00 00       	jmp    f0120a80 <realloc_block_FF+0x2d4>
	    }



	    struct BlockElement* block = (struct BlockElement*)va;
f01207f9:	8b 45 08             	mov    0x8(%ebp),%eax
f01207fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	    uint32 curr = get_block_size(block) - 2 * sizeof(int);
f01207ff:	83 ec 0c             	sub    $0xc,%esp
f0120802:	ff 75 f4             	pushl  -0xc(%ebp)
f0120805:	e8 40 ee ff ff       	call   f011f64a <get_block_size>
f012080a:	83 c4 10             	add    $0x10,%esp
f012080d:	83 e8 08             	sub    $0x8,%eax
f0120810:	89 45 f0             	mov    %eax,-0x10(%ebp)
	    if (new_size==curr)return va;
f0120813:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120816:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0120819:	75 08                	jne    f0120823 <realloc_block_FF+0x77>
f012081b:	8b 45 08             	mov    0x8(%ebp),%eax
f012081e:	e9 5d 02 00 00       	jmp    f0120a80 <realloc_block_FF+0x2d4>
	    struct BlockElement* next = (struct BlockElement*)((void*)block + get_block_size(block));
f0120823:	83 ec 0c             	sub    $0xc,%esp
f0120826:	ff 75 f4             	pushl  -0xc(%ebp)
f0120829:	e8 1c ee ff ff       	call   f011f64a <get_block_size>
f012082e:	83 c4 10             	add    $0x10,%esp
f0120831:	89 c2                	mov    %eax,%edx
f0120833:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120836:	01 d0                	add    %edx,%eax
f0120838:	89 45 ec             	mov    %eax,-0x14(%ebp)
	    //decrase the size-----done
	    if (new_size <= curr) {
f012083b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012083e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0120841:	0f 87 d8 00 00 00    	ja     f012091f <realloc_block_FF+0x173>
	        uint32 remainsize = curr - new_size ;
f0120847:	8b 45 f0             	mov    -0x10(%ebp),%eax
f012084a:	2b 45 0c             	sub    0xc(%ebp),%eax
f012084d:	89 45 e8             	mov    %eax,-0x18(%ebp)


	        if (remainsize >= 4 * sizeof(int)) {
f0120850:	83 7d e8 0f          	cmpl   $0xf,-0x18(%ebp)
f0120854:	76 48                	jbe    f012089e <realloc_block_FF+0xf2>
	            struct BlockElement* new_free_block = (struct BlockElement*)((char*)block+new_size+2*sizeof(int));
f0120856:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120859:	8d 50 08             	lea    0x8(%eax),%edx
f012085c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012085f:	01 d0                	add    %edx,%eax
f0120861:	89 45 e0             	mov    %eax,-0x20(%ebp)
	            set_block_data(new_free_block, remainsize, 0);
f0120864:	83 ec 04             	sub    $0x4,%esp
f0120867:	6a 00                	push   $0x0
f0120869:	ff 75 e8             	pushl  -0x18(%ebp)
f012086c:	ff 75 e0             	pushl  -0x20(%ebp)
f012086f:	e8 57 f0 ff ff       	call   f011f8cb <set_block_data>
f0120874:	83 c4 10             	add    $0x10,%esp
	            set_block_data(block, new_size + 2 * sizeof(int), 1);
f0120877:	8b 45 0c             	mov    0xc(%ebp),%eax
f012087a:	83 c0 08             	add    $0x8,%eax
f012087d:	83 ec 04             	sub    $0x4,%esp
f0120880:	6a 01                	push   $0x1
f0120882:	50                   	push   %eax
f0120883:	ff 75 f4             	pushl  -0xc(%ebp)
f0120886:	e8 40 f0 ff ff       	call   f011f8cb <set_block_data>
f012088b:	83 c4 10             	add    $0x10,%esp

	          //  print_blocks_list(freeBlocksList);
	            free_block(new_free_block);
f012088e:	83 ec 0c             	sub    $0xc,%esp
f0120891:	ff 75 e0             	pushl  -0x20(%ebp)
f0120894:	e8 8a f9 ff ff       	call   f0120223 <free_block>
f0120899:	83 c4 10             	add    $0x10,%esp
f012089c:	eb 79                	jmp    f0120917 <realloc_block_FF+0x16b>



	        }

	       else if (is_free_block(next)){
f012089e:	83 ec 0c             	sub    $0xc,%esp
f01208a1:	ff 75 ec             	pushl  -0x14(%ebp)
f01208a4:	e8 ba ed ff ff       	call   f011f663 <is_free_block>
f01208a9:	83 c4 10             	add    $0x10,%esp
f01208ac:	84 c0                	test   %al,%al
f01208ae:	74 48                	je     f01208f8 <realloc_block_FF+0x14c>
	        	 struct BlockElement* new_free_block = (struct BlockElement*)((char*)block+new_size+2*sizeof(int));
f01208b0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01208b3:	8d 50 08             	lea    0x8(%eax),%edx
f01208b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01208b9:	01 d0                	add    %edx,%eax
f01208bb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	        	set_block_data(new_free_block,remainsize,0);
f01208be:	83 ec 04             	sub    $0x4,%esp
f01208c1:	6a 00                	push   $0x0
f01208c3:	ff 75 e8             	pushl  -0x18(%ebp)
f01208c6:	ff 75 e4             	pushl  -0x1c(%ebp)
f01208c9:	e8 fd ef ff ff       	call   f011f8cb <set_block_data>
f01208ce:	83 c4 10             	add    $0x10,%esp
	        	free_block(new_free_block);
f01208d1:	83 ec 0c             	sub    $0xc,%esp
f01208d4:	ff 75 e4             	pushl  -0x1c(%ebp)
f01208d7:	e8 47 f9 ff ff       	call   f0120223 <free_block>
f01208dc:	83 c4 10             	add    $0x10,%esp
	        	set_block_data(block,new_size+2*sizeof(int),1);
f01208df:	8b 45 0c             	mov    0xc(%ebp),%eax
f01208e2:	83 c0 08             	add    $0x8,%eax
f01208e5:	83 ec 04             	sub    $0x4,%esp
f01208e8:	6a 01                	push   $0x1
f01208ea:	50                   	push   %eax
f01208eb:	ff 75 f4             	pushl  -0xc(%ebp)
f01208ee:	e8 d8 ef ff ff       	call   f011f8cb <set_block_data>
f01208f3:	83 c4 10             	add    $0x10,%esp
f01208f6:	eb 1f                	jmp    f0120917 <realloc_block_FF+0x16b>

	        }

	        else{
	        	 set_block_data(block, curr + 2 * sizeof(int), 1);
f01208f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01208fb:	83 c0 08             	add    $0x8,%eax
f01208fe:	83 ec 04             	sub    $0x4,%esp
f0120901:	6a 01                	push   $0x1
f0120903:	50                   	push   %eax
f0120904:	ff 75 f4             	pushl  -0xc(%ebp)
f0120907:	e8 bf ef ff ff       	call   f011f8cb <set_block_data>
f012090c:	83 c4 10             	add    $0x10,%esp
	        	        return (void*)block;
f012090f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120912:	e9 69 01 00 00       	jmp    f0120a80 <realloc_block_FF+0x2d4>

	        }
	        return (void*)block;
f0120917:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012091a:	e9 61 01 00 00       	jmp    f0120a80 <realloc_block_FF+0x2d4>
	    }

	    else if(new_size > curr)
f012091f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120922:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0120925:	0f 86 28 01 00 00    	jbe    f0120a53 <realloc_block_FF+0x2a7>





	    if (is_free_block(next) && (get_block_size(next) + curr >= new_size)) {
f012092b:	83 ec 0c             	sub    $0xc,%esp
f012092e:	ff 75 ec             	pushl  -0x14(%ebp)
f0120931:	e8 2d ed ff ff       	call   f011f663 <is_free_block>
f0120936:	83 c4 10             	add    $0x10,%esp
f0120939:	84 c0                	test   %al,%al
f012093b:	0f 84 12 01 00 00    	je     f0120a53 <realloc_block_FF+0x2a7>
f0120941:	83 ec 0c             	sub    $0xc,%esp
f0120944:	ff 75 ec             	pushl  -0x14(%ebp)
f0120947:	e8 fe ec ff ff       	call   f011f64a <get_block_size>
f012094c:	83 c4 10             	add    $0x10,%esp
f012094f:	89 c2                	mov    %eax,%edx
f0120951:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120954:	01 d0                	add    %edx,%eax
f0120956:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0120959:	0f 82 f4 00 00 00    	jb     f0120a53 <realloc_block_FF+0x2a7>

	        uint32 newsizeeeee = get_block_size(next) + curr;
f012095f:	83 ec 0c             	sub    $0xc,%esp
f0120962:	ff 75 ec             	pushl  -0x14(%ebp)
f0120965:	e8 e0 ec ff ff       	call   f011f64a <get_block_size>
f012096a:	83 c4 10             	add    $0x10,%esp
f012096d:	89 c2                	mov    %eax,%edx
f012096f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120972:	01 d0                	add    %edx,%eax
f0120974:	89 45 dc             	mov    %eax,-0x24(%ebp)
	        uint32 remaining_size = newsizeeeee - new_size;
f0120977:	8b 45 dc             	mov    -0x24(%ebp),%eax
f012097a:	2b 45 0c             	sub    0xc(%ebp),%eax
f012097d:	89 45 d8             	mov    %eax,-0x28(%ebp)

	        if (remaining_size >= 4 * sizeof(int)) {
f0120980:	83 7d d8 0f          	cmpl   $0xf,-0x28(%ebp)
f0120984:	76 2f                	jbe    f01209b5 <realloc_block_FF+0x209>

	            struct BlockElement* new_free_block = (struct BlockElement*)((void*)block + new_size + 2 * sizeof(int));
f0120986:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120989:	8d 50 08             	lea    0x8(%eax),%edx
f012098c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012098f:	01 d0                	add    %edx,%eax
f0120991:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	            set_block_data(new_free_block, remaining_size, 0);
f0120994:	83 ec 04             	sub    $0x4,%esp
f0120997:	6a 00                	push   $0x0
f0120999:	ff 75 d8             	pushl  -0x28(%ebp)
f012099c:	ff 75 d4             	pushl  -0x2c(%ebp)
f012099f:	e8 27 ef ff ff       	call   f011f8cb <set_block_data>
f01209a4:	83 c4 10             	add    $0x10,%esp
	            free_block(new_free_block);
f01209a7:	83 ec 0c             	sub    $0xc,%esp
f01209aa:	ff 75 d4             	pushl  -0x2c(%ebp)
f01209ad:	e8 71 f8 ff ff       	call   f0120223 <free_block>
f01209b2:	83 c4 10             	add    $0x10,%esp

	        }

	        LIST_REMOVE(&freeBlocksList, next);
f01209b5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01209b9:	75 17                	jne    f01209d2 <realloc_block_FF+0x226>
f01209bb:	83 ec 04             	sub    $0x4,%esp
f01209be:	68 13 01 13 f0       	push   $0xf0130113
f01209c3:	68 3d 02 00 00       	push   $0x23d
f01209c8:	68 fb 00 13 f0       	push   $0xf01300fb
f01209cd:	e8 67 f9 fd ff       	call   f0100339 <_panic>
f01209d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01209d5:	8b 00                	mov    (%eax),%eax
f01209d7:	85 c0                	test   %eax,%eax
f01209d9:	74 10                	je     f01209eb <realloc_block_FF+0x23f>
f01209db:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01209de:	8b 00                	mov    (%eax),%eax
f01209e0:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01209e3:	8b 52 04             	mov    0x4(%edx),%edx
f01209e6:	89 50 04             	mov    %edx,0x4(%eax)
f01209e9:	eb 0b                	jmp    f01209f6 <realloc_block_FF+0x24a>
f01209eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01209ee:	8b 40 04             	mov    0x4(%eax),%eax
f01209f1:	a3 94 c5 5e f0       	mov    %eax,0xf05ec594
f01209f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01209f9:	8b 40 04             	mov    0x4(%eax),%eax
f01209fc:	85 c0                	test   %eax,%eax
f01209fe:	74 0f                	je     f0120a0f <realloc_block_FF+0x263>
f0120a00:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a03:	8b 40 04             	mov    0x4(%eax),%eax
f0120a06:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120a09:	8b 12                	mov    (%edx),%edx
f0120a0b:	89 10                	mov    %edx,(%eax)
f0120a0d:	eb 0a                	jmp    f0120a19 <realloc_block_FF+0x26d>
f0120a0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a12:	8b 00                	mov    (%eax),%eax
f0120a14:	a3 90 c5 5e f0       	mov    %eax,0xf05ec590
f0120a19:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a1c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0120a22:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0120a25:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0120a2c:	a1 9c c5 5e f0       	mov    0xf05ec59c,%eax
f0120a31:	48                   	dec    %eax
f0120a32:	a3 9c c5 5e f0       	mov    %eax,0xf05ec59c
	        set_block_data(block, new_size + 2 * sizeof(int), 1);
f0120a37:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a3a:	83 c0 08             	add    $0x8,%eax
f0120a3d:	83 ec 04             	sub    $0x4,%esp
f0120a40:	6a 01                	push   $0x1
f0120a42:	50                   	push   %eax
f0120a43:	ff 75 f4             	pushl  -0xc(%ebp)
f0120a46:	e8 80 ee ff ff       	call   f011f8cb <set_block_data>
f0120a4b:	83 c4 10             	add    $0x10,%esp
	        return (void*)block;
f0120a4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a51:	eb 2d                	jmp    f0120a80 <realloc_block_FF+0x2d4>
	    }
	    }


	    void* new_block = alloc_block_FF(new_size);
f0120a53:	83 ec 0c             	sub    $0xc,%esp
f0120a56:	ff 75 0c             	pushl  0xc(%ebp)
f0120a59:	e8 ba ee ff ff       	call   f011f918 <alloc_block_FF>
f0120a5e:	83 c4 10             	add    $0x10,%esp
f0120a61:	89 45 d0             	mov    %eax,-0x30(%ebp)
	    if (new_block != NULL) {
f0120a64:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0120a68:	74 13                	je     f0120a7d <realloc_block_FF+0x2d1>

	        free_block(va);
f0120a6a:	83 ec 0c             	sub    $0xc,%esp
f0120a6d:	ff 75 08             	pushl  0x8(%ebp)
f0120a70:	e8 ae f7 ff ff       	call   f0120223 <free_block>
f0120a75:	83 c4 10             	add    $0x10,%esp
	        return new_block;
f0120a78:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0120a7b:	eb 03                	jmp    f0120a80 <realloc_block_FF+0x2d4>
	    }


	    return (void*)block;
f0120a7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0120a80:	c9                   	leave  
f0120a81:	c3                   	ret    

f0120a82 <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f0120a82:	55                   	push   %ebp
f0120a83:	89 e5                	mov    %esp,%ebp
f0120a85:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f0120a88:	83 ec 04             	sub    $0x4,%esp
f0120a8b:	68 c4 01 13 f0       	push   $0xf01301c4
f0120a90:	68 57 02 00 00       	push   $0x257
f0120a95:	68 fb 00 13 f0       	push   $0xf01300fb
f0120a9a:	e8 9a f8 fd ff       	call   f0100339 <_panic>

f0120a9f <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f0120a9f:	55                   	push   %ebp
f0120aa0:	89 e5                	mov    %esp,%ebp
f0120aa2:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f0120aa5:	83 ec 04             	sub    $0x4,%esp
f0120aa8:	68 ec 01 13 f0       	push   $0xf01301ec
f0120aad:	68 60 02 00 00       	push   $0x260
f0120ab2:	68 fb 00 13 f0       	push   $0xf01300fb
f0120ab7:	e8 7d f8 fd ff       	call   f0100339 <_panic>

f0120abc <__moddi3>:
f0120abc:	55                   	push   %ebp
f0120abd:	57                   	push   %edi
f0120abe:	56                   	push   %esi
f0120abf:	53                   	push   %ebx
f0120ac0:	83 ec 2c             	sub    $0x2c,%esp
f0120ac3:	8b 74 24 40          	mov    0x40(%esp),%esi
f0120ac7:	8b 7c 24 44          	mov    0x44(%esp),%edi
f0120acb:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f0120acf:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f0120ad3:	89 d8                	mov    %ebx,%eax
f0120ad5:	85 ff                	test   %edi,%edi
f0120ad7:	0f 88 d3 00 00 00    	js     f0120bb0 <__moddi3+0xf4>
f0120add:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f0120ae4:	00 
f0120ae5:	85 c0                	test   %eax,%eax
f0120ae7:	0f 88 ab 00 00 00    	js     f0120b98 <__moddi3+0xdc>
f0120aed:	89 0c 24             	mov    %ecx,(%esp)
f0120af0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f0120af4:	89 74 24 10          	mov    %esi,0x10(%esp)
f0120af8:	89 fb                	mov    %edi,%ebx
f0120afa:	8b 14 24             	mov    (%esp),%edx
f0120afd:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f0120b01:	89 d0                	mov    %edx,%eax
f0120b03:	89 54 24 18          	mov    %edx,0x18(%esp)
f0120b07:	89 ca                	mov    %ecx,%edx
f0120b09:	8b 0c 24             	mov    (%esp),%ecx
f0120b0c:	89 34 24             	mov    %esi,(%esp)
f0120b0f:	89 7c 24 14          	mov    %edi,0x14(%esp)
f0120b13:	85 d2                	test   %edx,%edx
f0120b15:	75 15                	jne    f0120b2c <__moddi3+0x70>
f0120b17:	89 c7                	mov    %eax,%edi
f0120b19:	39 d8                	cmp    %ebx,%eax
f0120b1b:	76 5b                	jbe    f0120b78 <__moddi3+0xbc>
f0120b1d:	89 f0                	mov    %esi,%eax
f0120b1f:	89 da                	mov    %ebx,%edx
f0120b21:	f7 f7                	div    %edi
f0120b23:	89 d3                	mov    %edx,%ebx
f0120b25:	89 d8                	mov    %ebx,%eax
f0120b27:	31 d2                	xor    %edx,%edx
f0120b29:	eb 09                	jmp    f0120b34 <__moddi3+0x78>
f0120b2b:	90                   	nop
f0120b2c:	39 fa                	cmp    %edi,%edx
f0120b2e:	76 1c                	jbe    f0120b4c <__moddi3+0x90>
f0120b30:	89 f0                	mov    %esi,%eax
f0120b32:	89 fa                	mov    %edi,%edx
f0120b34:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f0120b38:	85 c9                	test   %ecx,%ecx
f0120b3a:	74 07                	je     f0120b43 <__moddi3+0x87>
f0120b3c:	f7 d8                	neg    %eax
f0120b3e:	83 d2 00             	adc    $0x0,%edx
f0120b41:	f7 da                	neg    %edx
f0120b43:	83 c4 2c             	add    $0x2c,%esp
f0120b46:	5b                   	pop    %ebx
f0120b47:	5e                   	pop    %esi
f0120b48:	5f                   	pop    %edi
f0120b49:	5d                   	pop    %ebp
f0120b4a:	c3                   	ret    
f0120b4b:	90                   	nop
f0120b4c:	0f bd c2             	bsr    %edx,%eax
f0120b4f:	83 f0 1f             	xor    $0x1f,%eax
f0120b52:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f0120b56:	75 6c                	jne    f0120bc4 <__moddi3+0x108>
f0120b58:	39 fa                	cmp    %edi,%edx
f0120b5a:	72 05                	jb     f0120b61 <__moddi3+0xa5>
f0120b5c:	3b 0c 24             	cmp    (%esp),%ecx
f0120b5f:	77 0e                	ja     f0120b6f <__moddi3+0xb3>
f0120b61:	8b 34 24             	mov    (%esp),%esi
f0120b64:	29 ce                	sub    %ecx,%esi
f0120b66:	19 d3                	sbb    %edx,%ebx
f0120b68:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f0120b6c:	89 34 24             	mov    %esi,(%esp)
f0120b6f:	8b 04 24             	mov    (%esp),%eax
f0120b72:	8b 54 24 14          	mov    0x14(%esp),%edx
f0120b76:	eb bc                	jmp    f0120b34 <__moddi3+0x78>
f0120b78:	85 c9                	test   %ecx,%ecx
f0120b7a:	75 0b                	jne    f0120b87 <__moddi3+0xcb>
f0120b7c:	b8 01 00 00 00       	mov    $0x1,%eax
f0120b81:	31 d2                	xor    %edx,%edx
f0120b83:	f7 f1                	div    %ecx
f0120b85:	89 c1                	mov    %eax,%ecx
f0120b87:	89 d8                	mov    %ebx,%eax
f0120b89:	31 d2                	xor    %edx,%edx
f0120b8b:	f7 f1                	div    %ecx
f0120b8d:	8b 04 24             	mov    (%esp),%eax
f0120b90:	f7 f1                	div    %ecx
f0120b92:	89 d3                	mov    %edx,%ebx
f0120b94:	eb 8f                	jmp    f0120b25 <__moddi3+0x69>
f0120b96:	66 90                	xchg   %ax,%ax
f0120b98:	89 c8                	mov    %ecx,%eax
f0120b9a:	89 da                	mov    %ebx,%edx
f0120b9c:	f7 d8                	neg    %eax
f0120b9e:	83 d2 00             	adc    $0x0,%edx
f0120ba1:	f7 da                	neg    %edx
f0120ba3:	89 04 24             	mov    %eax,(%esp)
f0120ba6:	89 54 24 04          	mov    %edx,0x4(%esp)
f0120baa:	e9 45 ff ff ff       	jmp    f0120af4 <__moddi3+0x38>
f0120baf:	90                   	nop
f0120bb0:	f7 de                	neg    %esi
f0120bb2:	83 d7 00             	adc    $0x0,%edi
f0120bb5:	f7 df                	neg    %edi
f0120bb7:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f0120bbe:	ff 
f0120bbf:	e9 21 ff ff ff       	jmp    f0120ae5 <__moddi3+0x29>
f0120bc4:	b8 20 00 00 00       	mov    $0x20,%eax
f0120bc9:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0120bcd:	29 f8                	sub    %edi,%eax
f0120bcf:	89 c6                	mov    %eax,%esi
f0120bd1:	89 44 24 14          	mov    %eax,0x14(%esp)
f0120bd5:	89 f9                	mov    %edi,%ecx
f0120bd7:	d3 e2                	shl    %cl,%edx
f0120bd9:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f0120bdd:	89 e8                	mov    %ebp,%eax
f0120bdf:	89 f1                	mov    %esi,%ecx
f0120be1:	d3 e8                	shr    %cl,%eax
f0120be3:	09 d0                	or     %edx,%eax
f0120be5:	89 04 24             	mov    %eax,(%esp)
f0120be8:	89 ea                	mov    %ebp,%edx
f0120bea:	89 f9                	mov    %edi,%ecx
f0120bec:	d3 e2                	shl    %cl,%edx
f0120bee:	89 d7                	mov    %edx,%edi
f0120bf0:	89 da                	mov    %ebx,%edx
f0120bf2:	d3 e2                	shl    %cl,%edx
f0120bf4:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f0120bf8:	d3 e5                	shl    %cl,%ebp
f0120bfa:	8b 44 24 10          	mov    0x10(%esp),%eax
f0120bfe:	89 f1                	mov    %esi,%ecx
f0120c00:	d3 e8                	shr    %cl,%eax
f0120c02:	09 d0                	or     %edx,%eax
f0120c04:	d3 eb                	shr    %cl,%ebx
f0120c06:	89 da                	mov    %ebx,%edx
f0120c08:	f7 34 24             	divl   (%esp)
f0120c0b:	89 d3                	mov    %edx,%ebx
f0120c0d:	f7 e7                	mul    %edi
f0120c0f:	89 c6                	mov    %eax,%esi
f0120c11:	89 d1                	mov    %edx,%ecx
f0120c13:	39 d3                	cmp    %edx,%ebx
f0120c15:	72 29                	jb     f0120c40 <__moddi3+0x184>
f0120c17:	74 33                	je     f0120c4c <__moddi3+0x190>
f0120c19:	89 e8                	mov    %ebp,%eax
f0120c1b:	29 f0                	sub    %esi,%eax
f0120c1d:	19 cb                	sbb    %ecx,%ebx
f0120c1f:	89 de                	mov    %ebx,%esi
f0120c21:	8a 4c 24 14          	mov    0x14(%esp),%cl
f0120c25:	d3 e6                	shl    %cl,%esi
f0120c27:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f0120c2b:	89 f9                	mov    %edi,%ecx
f0120c2d:	d3 e8                	shr    %cl,%eax
f0120c2f:	09 c6                	or     %eax,%esi
f0120c31:	89 f0                	mov    %esi,%eax
f0120c33:	89 f9                	mov    %edi,%ecx
f0120c35:	d3 eb                	shr    %cl,%ebx
f0120c37:	89 da                	mov    %ebx,%edx
f0120c39:	e9 f6 fe ff ff       	jmp    f0120b34 <__moddi3+0x78>
f0120c3e:	66 90                	xchg   %ax,%ax
f0120c40:	29 f8                	sub    %edi,%eax
f0120c42:	1b 14 24             	sbb    (%esp),%edx
f0120c45:	89 d1                	mov    %edx,%ecx
f0120c47:	89 c6                	mov    %eax,%esi
f0120c49:	eb ce                	jmp    f0120c19 <__moddi3+0x15d>
f0120c4b:	90                   	nop
f0120c4c:	39 c5                	cmp    %eax,%ebp
f0120c4e:	72 f0                	jb     f0120c40 <__moddi3+0x184>
f0120c50:	89 d9                	mov    %ebx,%ecx
f0120c52:	eb c5                	jmp    f0120c19 <__moddi3+0x15d>

f0120c54 <__udivdi3>:
f0120c54:	55                   	push   %ebp
f0120c55:	57                   	push   %edi
f0120c56:	56                   	push   %esi
f0120c57:	53                   	push   %ebx
f0120c58:	83 ec 1c             	sub    $0x1c,%esp
f0120c5b:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f0120c5f:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f0120c63:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0120c67:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f0120c6b:	89 ca                	mov    %ecx,%edx
f0120c6d:	89 f8                	mov    %edi,%eax
f0120c6f:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f0120c73:	85 f6                	test   %esi,%esi
f0120c75:	75 2d                	jne    f0120ca4 <__udivdi3+0x50>
f0120c77:	39 cf                	cmp    %ecx,%edi
f0120c79:	77 65                	ja     f0120ce0 <__udivdi3+0x8c>
f0120c7b:	89 fd                	mov    %edi,%ebp
f0120c7d:	85 ff                	test   %edi,%edi
f0120c7f:	75 0b                	jne    f0120c8c <__udivdi3+0x38>
f0120c81:	b8 01 00 00 00       	mov    $0x1,%eax
f0120c86:	31 d2                	xor    %edx,%edx
f0120c88:	f7 f7                	div    %edi
f0120c8a:	89 c5                	mov    %eax,%ebp
f0120c8c:	31 d2                	xor    %edx,%edx
f0120c8e:	89 c8                	mov    %ecx,%eax
f0120c90:	f7 f5                	div    %ebp
f0120c92:	89 c1                	mov    %eax,%ecx
f0120c94:	89 d8                	mov    %ebx,%eax
f0120c96:	f7 f5                	div    %ebp
f0120c98:	89 cf                	mov    %ecx,%edi
f0120c9a:	89 fa                	mov    %edi,%edx
f0120c9c:	83 c4 1c             	add    $0x1c,%esp
f0120c9f:	5b                   	pop    %ebx
f0120ca0:	5e                   	pop    %esi
f0120ca1:	5f                   	pop    %edi
f0120ca2:	5d                   	pop    %ebp
f0120ca3:	c3                   	ret    
f0120ca4:	39 ce                	cmp    %ecx,%esi
f0120ca6:	77 28                	ja     f0120cd0 <__udivdi3+0x7c>
f0120ca8:	0f bd fe             	bsr    %esi,%edi
f0120cab:	83 f7 1f             	xor    $0x1f,%edi
f0120cae:	75 40                	jne    f0120cf0 <__udivdi3+0x9c>
f0120cb0:	39 ce                	cmp    %ecx,%esi
f0120cb2:	72 0a                	jb     f0120cbe <__udivdi3+0x6a>
f0120cb4:	3b 44 24 08          	cmp    0x8(%esp),%eax
f0120cb8:	0f 87 9e 00 00 00    	ja     f0120d5c <__udivdi3+0x108>
f0120cbe:	b8 01 00 00 00       	mov    $0x1,%eax
f0120cc3:	89 fa                	mov    %edi,%edx
f0120cc5:	83 c4 1c             	add    $0x1c,%esp
f0120cc8:	5b                   	pop    %ebx
f0120cc9:	5e                   	pop    %esi
f0120cca:	5f                   	pop    %edi
f0120ccb:	5d                   	pop    %ebp
f0120ccc:	c3                   	ret    
f0120ccd:	8d 76 00             	lea    0x0(%esi),%esi
f0120cd0:	31 ff                	xor    %edi,%edi
f0120cd2:	31 c0                	xor    %eax,%eax
f0120cd4:	89 fa                	mov    %edi,%edx
f0120cd6:	83 c4 1c             	add    $0x1c,%esp
f0120cd9:	5b                   	pop    %ebx
f0120cda:	5e                   	pop    %esi
f0120cdb:	5f                   	pop    %edi
f0120cdc:	5d                   	pop    %ebp
f0120cdd:	c3                   	ret    
f0120cde:	66 90                	xchg   %ax,%ax
f0120ce0:	89 d8                	mov    %ebx,%eax
f0120ce2:	f7 f7                	div    %edi
f0120ce4:	31 ff                	xor    %edi,%edi
f0120ce6:	89 fa                	mov    %edi,%edx
f0120ce8:	83 c4 1c             	add    $0x1c,%esp
f0120ceb:	5b                   	pop    %ebx
f0120cec:	5e                   	pop    %esi
f0120ced:	5f                   	pop    %edi
f0120cee:	5d                   	pop    %ebp
f0120cef:	c3                   	ret    
f0120cf0:	bd 20 00 00 00       	mov    $0x20,%ebp
f0120cf5:	89 eb                	mov    %ebp,%ebx
f0120cf7:	29 fb                	sub    %edi,%ebx
f0120cf9:	89 f9                	mov    %edi,%ecx
f0120cfb:	d3 e6                	shl    %cl,%esi
f0120cfd:	89 c5                	mov    %eax,%ebp
f0120cff:	88 d9                	mov    %bl,%cl
f0120d01:	d3 ed                	shr    %cl,%ebp
f0120d03:	89 e9                	mov    %ebp,%ecx
f0120d05:	09 f1                	or     %esi,%ecx
f0120d07:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f0120d0b:	89 f9                	mov    %edi,%ecx
f0120d0d:	d3 e0                	shl    %cl,%eax
f0120d0f:	89 c5                	mov    %eax,%ebp
f0120d11:	89 d6                	mov    %edx,%esi
f0120d13:	88 d9                	mov    %bl,%cl
f0120d15:	d3 ee                	shr    %cl,%esi
f0120d17:	89 f9                	mov    %edi,%ecx
f0120d19:	d3 e2                	shl    %cl,%edx
f0120d1b:	8b 44 24 08          	mov    0x8(%esp),%eax
f0120d1f:	88 d9                	mov    %bl,%cl
f0120d21:	d3 e8                	shr    %cl,%eax
f0120d23:	09 c2                	or     %eax,%edx
f0120d25:	89 d0                	mov    %edx,%eax
f0120d27:	89 f2                	mov    %esi,%edx
f0120d29:	f7 74 24 0c          	divl   0xc(%esp)
f0120d2d:	89 d6                	mov    %edx,%esi
f0120d2f:	89 c3                	mov    %eax,%ebx
f0120d31:	f7 e5                	mul    %ebp
f0120d33:	39 d6                	cmp    %edx,%esi
f0120d35:	72 19                	jb     f0120d50 <__udivdi3+0xfc>
f0120d37:	74 0b                	je     f0120d44 <__udivdi3+0xf0>
f0120d39:	89 d8                	mov    %ebx,%eax
f0120d3b:	31 ff                	xor    %edi,%edi
f0120d3d:	e9 58 ff ff ff       	jmp    f0120c9a <__udivdi3+0x46>
f0120d42:	66 90                	xchg   %ax,%ax
f0120d44:	8b 54 24 08          	mov    0x8(%esp),%edx
f0120d48:	89 f9                	mov    %edi,%ecx
f0120d4a:	d3 e2                	shl    %cl,%edx
f0120d4c:	39 c2                	cmp    %eax,%edx
f0120d4e:	73 e9                	jae    f0120d39 <__udivdi3+0xe5>
f0120d50:	8d 43 ff             	lea    -0x1(%ebx),%eax
f0120d53:	31 ff                	xor    %edi,%edi
f0120d55:	e9 40 ff ff ff       	jmp    f0120c9a <__udivdi3+0x46>
f0120d5a:	66 90                	xchg   %ax,%ax
f0120d5c:	31 c0                	xor    %eax,%eax
f0120d5e:	e9 37 ff ff ff       	jmp    f0120c9a <__udivdi3+0x46>
f0120d63:	90                   	nop

f0120d64 <__umoddi3>:
f0120d64:	55                   	push   %ebp
f0120d65:	57                   	push   %edi
f0120d66:	56                   	push   %esi
f0120d67:	53                   	push   %ebx
f0120d68:	83 ec 1c             	sub    $0x1c,%esp
f0120d6b:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f0120d6f:	8b 74 24 34          	mov    0x34(%esp),%esi
f0120d73:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0120d77:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f0120d7b:	89 44 24 0c          	mov    %eax,0xc(%esp)
f0120d7f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f0120d83:	89 f3                	mov    %esi,%ebx
f0120d85:	89 fa                	mov    %edi,%edx
f0120d87:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0120d8b:	89 34 24             	mov    %esi,(%esp)
f0120d8e:	85 c0                	test   %eax,%eax
f0120d90:	75 1a                	jne    f0120dac <__umoddi3+0x48>
f0120d92:	39 f7                	cmp    %esi,%edi
f0120d94:	0f 86 a2 00 00 00    	jbe    f0120e3c <__umoddi3+0xd8>
f0120d9a:	89 c8                	mov    %ecx,%eax
f0120d9c:	89 f2                	mov    %esi,%edx
f0120d9e:	f7 f7                	div    %edi
f0120da0:	89 d0                	mov    %edx,%eax
f0120da2:	31 d2                	xor    %edx,%edx
f0120da4:	83 c4 1c             	add    $0x1c,%esp
f0120da7:	5b                   	pop    %ebx
f0120da8:	5e                   	pop    %esi
f0120da9:	5f                   	pop    %edi
f0120daa:	5d                   	pop    %ebp
f0120dab:	c3                   	ret    
f0120dac:	39 f0                	cmp    %esi,%eax
f0120dae:	0f 87 ac 00 00 00    	ja     f0120e60 <__umoddi3+0xfc>
f0120db4:	0f bd e8             	bsr    %eax,%ebp
f0120db7:	83 f5 1f             	xor    $0x1f,%ebp
f0120dba:	0f 84 ac 00 00 00    	je     f0120e6c <__umoddi3+0x108>
f0120dc0:	bf 20 00 00 00       	mov    $0x20,%edi
f0120dc5:	29 ef                	sub    %ebp,%edi
f0120dc7:	89 fe                	mov    %edi,%esi
f0120dc9:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f0120dcd:	89 e9                	mov    %ebp,%ecx
f0120dcf:	d3 e0                	shl    %cl,%eax
f0120dd1:	89 d7                	mov    %edx,%edi
f0120dd3:	89 f1                	mov    %esi,%ecx
f0120dd5:	d3 ef                	shr    %cl,%edi
f0120dd7:	09 c7                	or     %eax,%edi
f0120dd9:	89 e9                	mov    %ebp,%ecx
f0120ddb:	d3 e2                	shl    %cl,%edx
f0120ddd:	89 14 24             	mov    %edx,(%esp)
f0120de0:	89 d8                	mov    %ebx,%eax
f0120de2:	d3 e0                	shl    %cl,%eax
f0120de4:	89 c2                	mov    %eax,%edx
f0120de6:	8b 44 24 08          	mov    0x8(%esp),%eax
f0120dea:	d3 e0                	shl    %cl,%eax
f0120dec:	89 44 24 04          	mov    %eax,0x4(%esp)
f0120df0:	8b 44 24 08          	mov    0x8(%esp),%eax
f0120df4:	89 f1                	mov    %esi,%ecx
f0120df6:	d3 e8                	shr    %cl,%eax
f0120df8:	09 d0                	or     %edx,%eax
f0120dfa:	d3 eb                	shr    %cl,%ebx
f0120dfc:	89 da                	mov    %ebx,%edx
f0120dfe:	f7 f7                	div    %edi
f0120e00:	89 d3                	mov    %edx,%ebx
f0120e02:	f7 24 24             	mull   (%esp)
f0120e05:	89 c6                	mov    %eax,%esi
f0120e07:	89 d1                	mov    %edx,%ecx
f0120e09:	39 d3                	cmp    %edx,%ebx
f0120e0b:	0f 82 87 00 00 00    	jb     f0120e98 <__umoddi3+0x134>
f0120e11:	0f 84 91 00 00 00    	je     f0120ea8 <__umoddi3+0x144>
f0120e17:	8b 54 24 04          	mov    0x4(%esp),%edx
f0120e1b:	29 f2                	sub    %esi,%edx
f0120e1d:	19 cb                	sbb    %ecx,%ebx
f0120e1f:	89 d8                	mov    %ebx,%eax
f0120e21:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f0120e25:	d3 e0                	shl    %cl,%eax
f0120e27:	89 e9                	mov    %ebp,%ecx
f0120e29:	d3 ea                	shr    %cl,%edx
f0120e2b:	09 d0                	or     %edx,%eax
f0120e2d:	89 e9                	mov    %ebp,%ecx
f0120e2f:	d3 eb                	shr    %cl,%ebx
f0120e31:	89 da                	mov    %ebx,%edx
f0120e33:	83 c4 1c             	add    $0x1c,%esp
f0120e36:	5b                   	pop    %ebx
f0120e37:	5e                   	pop    %esi
f0120e38:	5f                   	pop    %edi
f0120e39:	5d                   	pop    %ebp
f0120e3a:	c3                   	ret    
f0120e3b:	90                   	nop
f0120e3c:	89 fd                	mov    %edi,%ebp
f0120e3e:	85 ff                	test   %edi,%edi
f0120e40:	75 0b                	jne    f0120e4d <__umoddi3+0xe9>
f0120e42:	b8 01 00 00 00       	mov    $0x1,%eax
f0120e47:	31 d2                	xor    %edx,%edx
f0120e49:	f7 f7                	div    %edi
f0120e4b:	89 c5                	mov    %eax,%ebp
f0120e4d:	89 f0                	mov    %esi,%eax
f0120e4f:	31 d2                	xor    %edx,%edx
f0120e51:	f7 f5                	div    %ebp
f0120e53:	89 c8                	mov    %ecx,%eax
f0120e55:	f7 f5                	div    %ebp
f0120e57:	89 d0                	mov    %edx,%eax
f0120e59:	e9 44 ff ff ff       	jmp    f0120da2 <__umoddi3+0x3e>
f0120e5e:	66 90                	xchg   %ax,%ax
f0120e60:	89 c8                	mov    %ecx,%eax
f0120e62:	89 f2                	mov    %esi,%edx
f0120e64:	83 c4 1c             	add    $0x1c,%esp
f0120e67:	5b                   	pop    %ebx
f0120e68:	5e                   	pop    %esi
f0120e69:	5f                   	pop    %edi
f0120e6a:	5d                   	pop    %ebp
f0120e6b:	c3                   	ret    
f0120e6c:	3b 04 24             	cmp    (%esp),%eax
f0120e6f:	72 06                	jb     f0120e77 <__umoddi3+0x113>
f0120e71:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0120e75:	77 0f                	ja     f0120e86 <__umoddi3+0x122>
f0120e77:	89 f2                	mov    %esi,%edx
f0120e79:	29 f9                	sub    %edi,%ecx
f0120e7b:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f0120e7f:	89 14 24             	mov    %edx,(%esp)
f0120e82:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0120e86:	8b 44 24 04          	mov    0x4(%esp),%eax
f0120e8a:	8b 14 24             	mov    (%esp),%edx
f0120e8d:	83 c4 1c             	add    $0x1c,%esp
f0120e90:	5b                   	pop    %ebx
f0120e91:	5e                   	pop    %esi
f0120e92:	5f                   	pop    %edi
f0120e93:	5d                   	pop    %ebp
f0120e94:	c3                   	ret    
f0120e95:	8d 76 00             	lea    0x0(%esi),%esi
f0120e98:	2b 04 24             	sub    (%esp),%eax
f0120e9b:	19 fa                	sbb    %edi,%edx
f0120e9d:	89 d1                	mov    %edx,%ecx
f0120e9f:	89 c6                	mov    %eax,%esi
f0120ea1:	e9 71 ff ff ff       	jmp    f0120e17 <__umoddi3+0xb3>
f0120ea6:	66 90                	xchg   %ax,%ax
f0120ea8:	39 44 24 04          	cmp    %eax,0x4(%esp)
f0120eac:	72 ea                	jb     f0120e98 <__umoddi3+0x134>
f0120eae:	89 d9                	mov    %ebx,%ecx
f0120eb0:	e9 62 ff ff ff       	jmp    f0120e17 <__umoddi3+0xb3>
